
buildAA/ch.elf:     file format elf32-littlearm


Disassembly of section .text:

080000c0 <Reset_Handler>:
 80000c0:	b672      	cpsid	i
 80000c2:	4822      	ldr	r0, [pc, #136]	; (800014c <endfiniloop+0x4>)
 80000c4:	f380 8809 	msr	PSP, r0
 80000c8:	2002      	movs	r0, #2
 80000ca:	f380 8814 	msr	CONTROL, r0
 80000ce:	f3bf 8f6f 	isb	sy
 80000d2:	f003 fb95 	bl	8003800 <__core_init>
 80000d6:	f006 ff33 	bl	8006f40 <__early_init>
 80000da:	481d      	ldr	r0, [pc, #116]	; (8000150 <endfiniloop+0x8>)
 80000dc:	491d      	ldr	r1, [pc, #116]	; (8000154 <endfiniloop+0xc>)
 80000de:	4a1e      	ldr	r2, [pc, #120]	; (8000158 <endfiniloop+0x10>)

080000e0 <msloop>:
 80000e0:	4291      	cmp	r1, r2
 80000e2:	da02      	bge.n	80000ea <endmsloop>
 80000e4:	6008      	str	r0, [r1, #0]
 80000e6:	3104      	adds	r1, #4
 80000e8:	e7fa      	b.n	80000e0 <msloop>

080000ea <endmsloop>:
 80000ea:	491c      	ldr	r1, [pc, #112]	; (800015c <endfiniloop+0x14>)
 80000ec:	4a17      	ldr	r2, [pc, #92]	; (800014c <endfiniloop+0x4>)

080000ee <psloop>:
 80000ee:	4291      	cmp	r1, r2
 80000f0:	da02      	bge.n	80000f8 <endpsloop>
 80000f2:	6008      	str	r0, [r1, #0]
 80000f4:	3104      	adds	r1, #4
 80000f6:	e7fa      	b.n	80000ee <psloop>

080000f8 <endpsloop>:
 80000f8:	4919      	ldr	r1, [pc, #100]	; (8000160 <endfiniloop+0x18>)
 80000fa:	4a1a      	ldr	r2, [pc, #104]	; (8000164 <endfiniloop+0x1c>)
 80000fc:	4b1a      	ldr	r3, [pc, #104]	; (8000168 <endfiniloop+0x20>)

080000fe <dloop>:
 80000fe:	429a      	cmp	r2, r3
 8000100:	da04      	bge.n	800010c <enddloop>
 8000102:	6808      	ldr	r0, [r1, #0]
 8000104:	6010      	str	r0, [r2, #0]
 8000106:	3104      	adds	r1, #4
 8000108:	3204      	adds	r2, #4
 800010a:	e7f8      	b.n	80000fe <dloop>

0800010c <enddloop>:
 800010c:	2000      	movs	r0, #0
 800010e:	4917      	ldr	r1, [pc, #92]	; (800016c <endfiniloop+0x24>)
 8000110:	4a17      	ldr	r2, [pc, #92]	; (8000170 <endfiniloop+0x28>)

08000112 <bloop>:
 8000112:	4291      	cmp	r1, r2
 8000114:	da02      	bge.n	800011c <endbloop>
 8000116:	6008      	str	r0, [r1, #0]
 8000118:	3104      	adds	r1, #4
 800011a:	e7fa      	b.n	8000112 <bloop>

0800011c <endbloop>:
 800011c:	f003 fb88 	bl	8003830 <__init_ram_areas>
 8000120:	f003 fb76 	bl	8003810 <__late_init>
 8000124:	4c13      	ldr	r4, [pc, #76]	; (8000174 <endfiniloop+0x2c>)
 8000126:	4d14      	ldr	r5, [pc, #80]	; (8000178 <endfiniloop+0x30>)

08000128 <initloop>:
 8000128:	42ac      	cmp	r4, r5
 800012a:	da03      	bge.n	8000134 <endinitloop>
 800012c:	6821      	ldr	r1, [r4, #0]
 800012e:	4788      	blx	r1
 8000130:	3404      	adds	r4, #4
 8000132:	e7f9      	b.n	8000128 <initloop>

08000134 <endinitloop>:
 8000134:	f00a fd54 	bl	800abe0 <main>
 8000138:	4c10      	ldr	r4, [pc, #64]	; (800017c <endfiniloop+0x34>)
 800013a:	4d11      	ldr	r5, [pc, #68]	; (8000180 <endfiniloop+0x38>)

0800013c <finiloop>:
 800013c:	42ac      	cmp	r4, r5
 800013e:	da03      	bge.n	8000148 <endfiniloop>
 8000140:	6821      	ldr	r1, [r4, #0]
 8000142:	4788      	blx	r1
 8000144:	3404      	adds	r4, #4
 8000146:	e7f9      	b.n	800013c <finiloop>

08000148 <endfiniloop>:
 8000148:	490e      	ldr	r1, [pc, #56]	; (8000184 <endfiniloop+0x3c>)
 800014a:	4708      	bx	r1
 800014c:	20000400 	.word	0x20000400
 8000150:	55555555 	.word	0x55555555
 8000154:	20000000 	.word	0x20000000
 8000158:	20000200 	.word	0x20000200
 800015c:	20000200 	.word	0x20000200
 8000160:	08016d5c 	.word	0x08016d5c
 8000164:	20000400 	.word	0x20000400
 8000168:	200016c8 	.word	0x200016c8
 800016c:	200016c8 	.word	0x200016c8
 8000170:	200038b4 	.word	0x200038b4
 8000174:	080000c0 	.word	0x080000c0
 8000178:	080000c0 	.word	0x080000c0
 800017c:	080000c0 	.word	0x080000c0
 8000180:	080000c0 	.word	0x080000c0
 8000184:	08003821 	.word	0x08003821
	...

08000190 <_port_switch>:
 8000190:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000192:	4644      	mov	r4, r8
 8000194:	464d      	mov	r5, r9
 8000196:	4656      	mov	r6, sl
 8000198:	465f      	mov	r7, fp
 800019a:	b4f0      	push	{r4, r5, r6, r7}
 800019c:	466b      	mov	r3, sp
 800019e:	60cb      	str	r3, [r1, #12]
 80001a0:	68c3      	ldr	r3, [r0, #12]
 80001a2:	469d      	mov	sp, r3
 80001a4:	bcf0      	pop	{r4, r5, r6, r7}
 80001a6:	46a0      	mov	r8, r4
 80001a8:	46a9      	mov	r9, r5
 80001aa:	46b2      	mov	sl, r6
 80001ac:	46bb      	mov	fp, r7
 80001ae:	bdf0      	pop	{r4, r5, r6, r7, pc}

080001b0 <_port_thread_start>:
 80001b0:	b662      	cpsie	i
 80001b2:	1c28      	adds	r0, r5, #0
 80001b4:	47a0      	blx	r4
 80001b6:	2000      	movs	r0, #0
 80001b8:	f003 fe72 	bl	8003ea0 <chThdExit>

080001bc <_port_switch_from_isr>:
 80001bc:	f003 fd98 	bl	8003cf0 <chSchDoReschedule>

080001c0 <_port_exit_from_isr>:
 80001c0:	4a01      	ldr	r2, [pc, #4]	; (80001c8 <_port_exit_from_isr+0x8>)
 80001c2:	4b02      	ldr	r3, [pc, #8]	; (80001cc <_port_exit_from_isr+0xc>)
 80001c4:	6013      	str	r3, [r2, #0]
 80001c6:	e7fe      	b.n	80001c6 <_port_exit_from_isr+0x6>
 80001c8:	e000ed04 	.word	0xe000ed04
 80001cc:	80000000 	.word	0x80000000

080001d0 <__udivsi3>:
 80001d0:	2200      	movs	r2, #0
 80001d2:	0843      	lsrs	r3, r0, #1
 80001d4:	428b      	cmp	r3, r1
 80001d6:	d374      	bcc.n	80002c2 <__udivsi3+0xf2>
 80001d8:	0903      	lsrs	r3, r0, #4
 80001da:	428b      	cmp	r3, r1
 80001dc:	d35f      	bcc.n	800029e <__udivsi3+0xce>
 80001de:	0a03      	lsrs	r3, r0, #8
 80001e0:	428b      	cmp	r3, r1
 80001e2:	d344      	bcc.n	800026e <__udivsi3+0x9e>
 80001e4:	0b03      	lsrs	r3, r0, #12
 80001e6:	428b      	cmp	r3, r1
 80001e8:	d328      	bcc.n	800023c <__udivsi3+0x6c>
 80001ea:	0c03      	lsrs	r3, r0, #16
 80001ec:	428b      	cmp	r3, r1
 80001ee:	d30d      	bcc.n	800020c <__udivsi3+0x3c>
 80001f0:	22ff      	movs	r2, #255	; 0xff
 80001f2:	0209      	lsls	r1, r1, #8
 80001f4:	ba12      	rev	r2, r2
 80001f6:	0c03      	lsrs	r3, r0, #16
 80001f8:	428b      	cmp	r3, r1
 80001fa:	d302      	bcc.n	8000202 <__udivsi3+0x32>
 80001fc:	1212      	asrs	r2, r2, #8
 80001fe:	0209      	lsls	r1, r1, #8
 8000200:	d065      	beq.n	80002ce <__udivsi3+0xfe>
 8000202:	0b03      	lsrs	r3, r0, #12
 8000204:	428b      	cmp	r3, r1
 8000206:	d319      	bcc.n	800023c <__udivsi3+0x6c>
 8000208:	e000      	b.n	800020c <__udivsi3+0x3c>
 800020a:	0a09      	lsrs	r1, r1, #8
 800020c:	0bc3      	lsrs	r3, r0, #15
 800020e:	428b      	cmp	r3, r1
 8000210:	d301      	bcc.n	8000216 <__udivsi3+0x46>
 8000212:	03cb      	lsls	r3, r1, #15
 8000214:	1ac0      	subs	r0, r0, r3
 8000216:	4152      	adcs	r2, r2
 8000218:	0b83      	lsrs	r3, r0, #14
 800021a:	428b      	cmp	r3, r1
 800021c:	d301      	bcc.n	8000222 <__udivsi3+0x52>
 800021e:	038b      	lsls	r3, r1, #14
 8000220:	1ac0      	subs	r0, r0, r3
 8000222:	4152      	adcs	r2, r2
 8000224:	0b43      	lsrs	r3, r0, #13
 8000226:	428b      	cmp	r3, r1
 8000228:	d301      	bcc.n	800022e <__udivsi3+0x5e>
 800022a:	034b      	lsls	r3, r1, #13
 800022c:	1ac0      	subs	r0, r0, r3
 800022e:	4152      	adcs	r2, r2
 8000230:	0b03      	lsrs	r3, r0, #12
 8000232:	428b      	cmp	r3, r1
 8000234:	d301      	bcc.n	800023a <__udivsi3+0x6a>
 8000236:	030b      	lsls	r3, r1, #12
 8000238:	1ac0      	subs	r0, r0, r3
 800023a:	4152      	adcs	r2, r2
 800023c:	0ac3      	lsrs	r3, r0, #11
 800023e:	428b      	cmp	r3, r1
 8000240:	d301      	bcc.n	8000246 <__udivsi3+0x76>
 8000242:	02cb      	lsls	r3, r1, #11
 8000244:	1ac0      	subs	r0, r0, r3
 8000246:	4152      	adcs	r2, r2
 8000248:	0a83      	lsrs	r3, r0, #10
 800024a:	428b      	cmp	r3, r1
 800024c:	d301      	bcc.n	8000252 <__udivsi3+0x82>
 800024e:	028b      	lsls	r3, r1, #10
 8000250:	1ac0      	subs	r0, r0, r3
 8000252:	4152      	adcs	r2, r2
 8000254:	0a43      	lsrs	r3, r0, #9
 8000256:	428b      	cmp	r3, r1
 8000258:	d301      	bcc.n	800025e <__udivsi3+0x8e>
 800025a:	024b      	lsls	r3, r1, #9
 800025c:	1ac0      	subs	r0, r0, r3
 800025e:	4152      	adcs	r2, r2
 8000260:	0a03      	lsrs	r3, r0, #8
 8000262:	428b      	cmp	r3, r1
 8000264:	d301      	bcc.n	800026a <__udivsi3+0x9a>
 8000266:	020b      	lsls	r3, r1, #8
 8000268:	1ac0      	subs	r0, r0, r3
 800026a:	4152      	adcs	r2, r2
 800026c:	d2cd      	bcs.n	800020a <__udivsi3+0x3a>
 800026e:	09c3      	lsrs	r3, r0, #7
 8000270:	428b      	cmp	r3, r1
 8000272:	d301      	bcc.n	8000278 <__udivsi3+0xa8>
 8000274:	01cb      	lsls	r3, r1, #7
 8000276:	1ac0      	subs	r0, r0, r3
 8000278:	4152      	adcs	r2, r2
 800027a:	0983      	lsrs	r3, r0, #6
 800027c:	428b      	cmp	r3, r1
 800027e:	d301      	bcc.n	8000284 <__udivsi3+0xb4>
 8000280:	018b      	lsls	r3, r1, #6
 8000282:	1ac0      	subs	r0, r0, r3
 8000284:	4152      	adcs	r2, r2
 8000286:	0943      	lsrs	r3, r0, #5
 8000288:	428b      	cmp	r3, r1
 800028a:	d301      	bcc.n	8000290 <__udivsi3+0xc0>
 800028c:	014b      	lsls	r3, r1, #5
 800028e:	1ac0      	subs	r0, r0, r3
 8000290:	4152      	adcs	r2, r2
 8000292:	0903      	lsrs	r3, r0, #4
 8000294:	428b      	cmp	r3, r1
 8000296:	d301      	bcc.n	800029c <__udivsi3+0xcc>
 8000298:	010b      	lsls	r3, r1, #4
 800029a:	1ac0      	subs	r0, r0, r3
 800029c:	4152      	adcs	r2, r2
 800029e:	08c3      	lsrs	r3, r0, #3
 80002a0:	428b      	cmp	r3, r1
 80002a2:	d301      	bcc.n	80002a8 <__udivsi3+0xd8>
 80002a4:	00cb      	lsls	r3, r1, #3
 80002a6:	1ac0      	subs	r0, r0, r3
 80002a8:	4152      	adcs	r2, r2
 80002aa:	0883      	lsrs	r3, r0, #2
 80002ac:	428b      	cmp	r3, r1
 80002ae:	d301      	bcc.n	80002b4 <__udivsi3+0xe4>
 80002b0:	008b      	lsls	r3, r1, #2
 80002b2:	1ac0      	subs	r0, r0, r3
 80002b4:	4152      	adcs	r2, r2
 80002b6:	0843      	lsrs	r3, r0, #1
 80002b8:	428b      	cmp	r3, r1
 80002ba:	d301      	bcc.n	80002c0 <__udivsi3+0xf0>
 80002bc:	004b      	lsls	r3, r1, #1
 80002be:	1ac0      	subs	r0, r0, r3
 80002c0:	4152      	adcs	r2, r2
 80002c2:	1a41      	subs	r1, r0, r1
 80002c4:	d200      	bcs.n	80002c8 <__udivsi3+0xf8>
 80002c6:	4601      	mov	r1, r0
 80002c8:	4152      	adcs	r2, r2
 80002ca:	4610      	mov	r0, r2
 80002cc:	4770      	bx	lr
 80002ce:	e7ff      	b.n	80002d0 <__udivsi3+0x100>
 80002d0:	b501      	push	{r0, lr}
 80002d2:	2000      	movs	r0, #0
 80002d4:	f000 f8fc 	bl	80004d0 <__aeabi_idiv0>
 80002d8:	bd02      	pop	{r1, pc}
 80002da:	46c0      	nop			; (mov r8, r8)

080002dc <__aeabi_uidivmod>:
 80002dc:	2900      	cmp	r1, #0
 80002de:	d0f7      	beq.n	80002d0 <__udivsi3+0x100>
 80002e0:	e776      	b.n	80001d0 <__udivsi3>
 80002e2:	4770      	bx	lr
	...

080002f0 <__divsi3>:
 80002f0:	4603      	mov	r3, r0
 80002f2:	430b      	orrs	r3, r1
 80002f4:	d47f      	bmi.n	80003f6 <__divsi3+0x106>
 80002f6:	2200      	movs	r2, #0
 80002f8:	0843      	lsrs	r3, r0, #1
 80002fa:	428b      	cmp	r3, r1
 80002fc:	d374      	bcc.n	80003e8 <__divsi3+0xf8>
 80002fe:	0903      	lsrs	r3, r0, #4
 8000300:	428b      	cmp	r3, r1
 8000302:	d35f      	bcc.n	80003c4 <__divsi3+0xd4>
 8000304:	0a03      	lsrs	r3, r0, #8
 8000306:	428b      	cmp	r3, r1
 8000308:	d344      	bcc.n	8000394 <__divsi3+0xa4>
 800030a:	0b03      	lsrs	r3, r0, #12
 800030c:	428b      	cmp	r3, r1
 800030e:	d328      	bcc.n	8000362 <__divsi3+0x72>
 8000310:	0c03      	lsrs	r3, r0, #16
 8000312:	428b      	cmp	r3, r1
 8000314:	d30d      	bcc.n	8000332 <__divsi3+0x42>
 8000316:	22ff      	movs	r2, #255	; 0xff
 8000318:	0209      	lsls	r1, r1, #8
 800031a:	ba12      	rev	r2, r2
 800031c:	0c03      	lsrs	r3, r0, #16
 800031e:	428b      	cmp	r3, r1
 8000320:	d302      	bcc.n	8000328 <__divsi3+0x38>
 8000322:	1212      	asrs	r2, r2, #8
 8000324:	0209      	lsls	r1, r1, #8
 8000326:	d065      	beq.n	80003f4 <__divsi3+0x104>
 8000328:	0b03      	lsrs	r3, r0, #12
 800032a:	428b      	cmp	r3, r1
 800032c:	d319      	bcc.n	8000362 <__divsi3+0x72>
 800032e:	e000      	b.n	8000332 <__divsi3+0x42>
 8000330:	0a09      	lsrs	r1, r1, #8
 8000332:	0bc3      	lsrs	r3, r0, #15
 8000334:	428b      	cmp	r3, r1
 8000336:	d301      	bcc.n	800033c <__divsi3+0x4c>
 8000338:	03cb      	lsls	r3, r1, #15
 800033a:	1ac0      	subs	r0, r0, r3
 800033c:	4152      	adcs	r2, r2
 800033e:	0b83      	lsrs	r3, r0, #14
 8000340:	428b      	cmp	r3, r1
 8000342:	d301      	bcc.n	8000348 <__divsi3+0x58>
 8000344:	038b      	lsls	r3, r1, #14
 8000346:	1ac0      	subs	r0, r0, r3
 8000348:	4152      	adcs	r2, r2
 800034a:	0b43      	lsrs	r3, r0, #13
 800034c:	428b      	cmp	r3, r1
 800034e:	d301      	bcc.n	8000354 <__divsi3+0x64>
 8000350:	034b      	lsls	r3, r1, #13
 8000352:	1ac0      	subs	r0, r0, r3
 8000354:	4152      	adcs	r2, r2
 8000356:	0b03      	lsrs	r3, r0, #12
 8000358:	428b      	cmp	r3, r1
 800035a:	d301      	bcc.n	8000360 <__divsi3+0x70>
 800035c:	030b      	lsls	r3, r1, #12
 800035e:	1ac0      	subs	r0, r0, r3
 8000360:	4152      	adcs	r2, r2
 8000362:	0ac3      	lsrs	r3, r0, #11
 8000364:	428b      	cmp	r3, r1
 8000366:	d301      	bcc.n	800036c <__divsi3+0x7c>
 8000368:	02cb      	lsls	r3, r1, #11
 800036a:	1ac0      	subs	r0, r0, r3
 800036c:	4152      	adcs	r2, r2
 800036e:	0a83      	lsrs	r3, r0, #10
 8000370:	428b      	cmp	r3, r1
 8000372:	d301      	bcc.n	8000378 <__divsi3+0x88>
 8000374:	028b      	lsls	r3, r1, #10
 8000376:	1ac0      	subs	r0, r0, r3
 8000378:	4152      	adcs	r2, r2
 800037a:	0a43      	lsrs	r3, r0, #9
 800037c:	428b      	cmp	r3, r1
 800037e:	d301      	bcc.n	8000384 <__divsi3+0x94>
 8000380:	024b      	lsls	r3, r1, #9
 8000382:	1ac0      	subs	r0, r0, r3
 8000384:	4152      	adcs	r2, r2
 8000386:	0a03      	lsrs	r3, r0, #8
 8000388:	428b      	cmp	r3, r1
 800038a:	d301      	bcc.n	8000390 <__divsi3+0xa0>
 800038c:	020b      	lsls	r3, r1, #8
 800038e:	1ac0      	subs	r0, r0, r3
 8000390:	4152      	adcs	r2, r2
 8000392:	d2cd      	bcs.n	8000330 <__divsi3+0x40>
 8000394:	09c3      	lsrs	r3, r0, #7
 8000396:	428b      	cmp	r3, r1
 8000398:	d301      	bcc.n	800039e <__divsi3+0xae>
 800039a:	01cb      	lsls	r3, r1, #7
 800039c:	1ac0      	subs	r0, r0, r3
 800039e:	4152      	adcs	r2, r2
 80003a0:	0983      	lsrs	r3, r0, #6
 80003a2:	428b      	cmp	r3, r1
 80003a4:	d301      	bcc.n	80003aa <__divsi3+0xba>
 80003a6:	018b      	lsls	r3, r1, #6
 80003a8:	1ac0      	subs	r0, r0, r3
 80003aa:	4152      	adcs	r2, r2
 80003ac:	0943      	lsrs	r3, r0, #5
 80003ae:	428b      	cmp	r3, r1
 80003b0:	d301      	bcc.n	80003b6 <__divsi3+0xc6>
 80003b2:	014b      	lsls	r3, r1, #5
 80003b4:	1ac0      	subs	r0, r0, r3
 80003b6:	4152      	adcs	r2, r2
 80003b8:	0903      	lsrs	r3, r0, #4
 80003ba:	428b      	cmp	r3, r1
 80003bc:	d301      	bcc.n	80003c2 <__divsi3+0xd2>
 80003be:	010b      	lsls	r3, r1, #4
 80003c0:	1ac0      	subs	r0, r0, r3
 80003c2:	4152      	adcs	r2, r2
 80003c4:	08c3      	lsrs	r3, r0, #3
 80003c6:	428b      	cmp	r3, r1
 80003c8:	d301      	bcc.n	80003ce <__divsi3+0xde>
 80003ca:	00cb      	lsls	r3, r1, #3
 80003cc:	1ac0      	subs	r0, r0, r3
 80003ce:	4152      	adcs	r2, r2
 80003d0:	0883      	lsrs	r3, r0, #2
 80003d2:	428b      	cmp	r3, r1
 80003d4:	d301      	bcc.n	80003da <__divsi3+0xea>
 80003d6:	008b      	lsls	r3, r1, #2
 80003d8:	1ac0      	subs	r0, r0, r3
 80003da:	4152      	adcs	r2, r2
 80003dc:	0843      	lsrs	r3, r0, #1
 80003de:	428b      	cmp	r3, r1
 80003e0:	d301      	bcc.n	80003e6 <__divsi3+0xf6>
 80003e2:	004b      	lsls	r3, r1, #1
 80003e4:	1ac0      	subs	r0, r0, r3
 80003e6:	4152      	adcs	r2, r2
 80003e8:	1a41      	subs	r1, r0, r1
 80003ea:	d200      	bcs.n	80003ee <__divsi3+0xfe>
 80003ec:	4601      	mov	r1, r0
 80003ee:	4152      	adcs	r2, r2
 80003f0:	4610      	mov	r0, r2
 80003f2:	4770      	bx	lr
 80003f4:	e05d      	b.n	80004b2 <__divsi3+0x1c2>
 80003f6:	0fca      	lsrs	r2, r1, #31
 80003f8:	d000      	beq.n	80003fc <__divsi3+0x10c>
 80003fa:	4249      	negs	r1, r1
 80003fc:	1003      	asrs	r3, r0, #32
 80003fe:	d300      	bcc.n	8000402 <__divsi3+0x112>
 8000400:	4240      	negs	r0, r0
 8000402:	4053      	eors	r3, r2
 8000404:	2200      	movs	r2, #0
 8000406:	469c      	mov	ip, r3
 8000408:	0903      	lsrs	r3, r0, #4
 800040a:	428b      	cmp	r3, r1
 800040c:	d32d      	bcc.n	800046a <__divsi3+0x17a>
 800040e:	0a03      	lsrs	r3, r0, #8
 8000410:	428b      	cmp	r3, r1
 8000412:	d312      	bcc.n	800043a <__divsi3+0x14a>
 8000414:	22fc      	movs	r2, #252	; 0xfc
 8000416:	0189      	lsls	r1, r1, #6
 8000418:	ba12      	rev	r2, r2
 800041a:	0a03      	lsrs	r3, r0, #8
 800041c:	428b      	cmp	r3, r1
 800041e:	d30c      	bcc.n	800043a <__divsi3+0x14a>
 8000420:	0189      	lsls	r1, r1, #6
 8000422:	1192      	asrs	r2, r2, #6
 8000424:	428b      	cmp	r3, r1
 8000426:	d308      	bcc.n	800043a <__divsi3+0x14a>
 8000428:	0189      	lsls	r1, r1, #6
 800042a:	1192      	asrs	r2, r2, #6
 800042c:	428b      	cmp	r3, r1
 800042e:	d304      	bcc.n	800043a <__divsi3+0x14a>
 8000430:	0189      	lsls	r1, r1, #6
 8000432:	d03a      	beq.n	80004aa <__divsi3+0x1ba>
 8000434:	1192      	asrs	r2, r2, #6
 8000436:	e000      	b.n	800043a <__divsi3+0x14a>
 8000438:	0989      	lsrs	r1, r1, #6
 800043a:	09c3      	lsrs	r3, r0, #7
 800043c:	428b      	cmp	r3, r1
 800043e:	d301      	bcc.n	8000444 <__divsi3+0x154>
 8000440:	01cb      	lsls	r3, r1, #7
 8000442:	1ac0      	subs	r0, r0, r3
 8000444:	4152      	adcs	r2, r2
 8000446:	0983      	lsrs	r3, r0, #6
 8000448:	428b      	cmp	r3, r1
 800044a:	d301      	bcc.n	8000450 <__divsi3+0x160>
 800044c:	018b      	lsls	r3, r1, #6
 800044e:	1ac0      	subs	r0, r0, r3
 8000450:	4152      	adcs	r2, r2
 8000452:	0943      	lsrs	r3, r0, #5
 8000454:	428b      	cmp	r3, r1
 8000456:	d301      	bcc.n	800045c <__divsi3+0x16c>
 8000458:	014b      	lsls	r3, r1, #5
 800045a:	1ac0      	subs	r0, r0, r3
 800045c:	4152      	adcs	r2, r2
 800045e:	0903      	lsrs	r3, r0, #4
 8000460:	428b      	cmp	r3, r1
 8000462:	d301      	bcc.n	8000468 <__divsi3+0x178>
 8000464:	010b      	lsls	r3, r1, #4
 8000466:	1ac0      	subs	r0, r0, r3
 8000468:	4152      	adcs	r2, r2
 800046a:	08c3      	lsrs	r3, r0, #3
 800046c:	428b      	cmp	r3, r1
 800046e:	d301      	bcc.n	8000474 <__divsi3+0x184>
 8000470:	00cb      	lsls	r3, r1, #3
 8000472:	1ac0      	subs	r0, r0, r3
 8000474:	4152      	adcs	r2, r2
 8000476:	0883      	lsrs	r3, r0, #2
 8000478:	428b      	cmp	r3, r1
 800047a:	d301      	bcc.n	8000480 <__divsi3+0x190>
 800047c:	008b      	lsls	r3, r1, #2
 800047e:	1ac0      	subs	r0, r0, r3
 8000480:	4152      	adcs	r2, r2
 8000482:	d2d9      	bcs.n	8000438 <__divsi3+0x148>
 8000484:	0843      	lsrs	r3, r0, #1
 8000486:	428b      	cmp	r3, r1
 8000488:	d301      	bcc.n	800048e <__divsi3+0x19e>
 800048a:	004b      	lsls	r3, r1, #1
 800048c:	1ac0      	subs	r0, r0, r3
 800048e:	4152      	adcs	r2, r2
 8000490:	1a41      	subs	r1, r0, r1
 8000492:	d200      	bcs.n	8000496 <__divsi3+0x1a6>
 8000494:	4601      	mov	r1, r0
 8000496:	4663      	mov	r3, ip
 8000498:	4152      	adcs	r2, r2
 800049a:	105b      	asrs	r3, r3, #1
 800049c:	4610      	mov	r0, r2
 800049e:	d301      	bcc.n	80004a4 <__divsi3+0x1b4>
 80004a0:	4240      	negs	r0, r0
 80004a2:	2b00      	cmp	r3, #0
 80004a4:	d500      	bpl.n	80004a8 <__divsi3+0x1b8>
 80004a6:	4249      	negs	r1, r1
 80004a8:	4770      	bx	lr
 80004aa:	4663      	mov	r3, ip
 80004ac:	105b      	asrs	r3, r3, #1
 80004ae:	d300      	bcc.n	80004b2 <__divsi3+0x1c2>
 80004b0:	4240      	negs	r0, r0
 80004b2:	b501      	push	{r0, lr}
 80004b4:	2000      	movs	r0, #0
 80004b6:	f000 f80b 	bl	80004d0 <__aeabi_idiv0>
 80004ba:	bd02      	pop	{r1, pc}

080004bc <__aeabi_idivmod>:
 80004bc:	2900      	cmp	r1, #0
 80004be:	d0f8      	beq.n	80004b2 <__divsi3+0x1c2>
 80004c0:	e716      	b.n	80002f0 <__divsi3>
 80004c2:	4770      	bx	lr
	...

080004d0 <__aeabi_idiv0>:
 80004d0:	4770      	bx	lr
 80004d2:	46c0      	nop			; (mov r8, r8)
	...

080004e0 <__aeabi_cdrcmple>:
 80004e0:	4684      	mov	ip, r0
 80004e2:	1c10      	adds	r0, r2, #0
 80004e4:	4662      	mov	r2, ip
 80004e6:	468c      	mov	ip, r1
 80004e8:	1c19      	adds	r1, r3, #0
 80004ea:	4663      	mov	r3, ip
 80004ec:	e000      	b.n	80004f0 <__aeabi_cdcmpeq>
 80004ee:	46c0      	nop			; (mov r8, r8)

080004f0 <__aeabi_cdcmpeq>:
 80004f0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 80004f2:	f002 f81d 	bl	8002530 <__ledf2>
 80004f6:	2800      	cmp	r0, #0
 80004f8:	d401      	bmi.n	80004fe <__aeabi_cdcmpeq+0xe>
 80004fa:	2100      	movs	r1, #0
 80004fc:	42c8      	cmn	r0, r1
 80004fe:	bd1f      	pop	{r0, r1, r2, r3, r4, pc}

08000500 <__aeabi_dcmpeq>:
 8000500:	b510      	push	{r4, lr}
 8000502:	f001 ff6d 	bl	80023e0 <__eqdf2>
 8000506:	4240      	negs	r0, r0
 8000508:	3001      	adds	r0, #1
 800050a:	bd10      	pop	{r4, pc}

0800050c <__aeabi_dcmplt>:
 800050c:	b510      	push	{r4, lr}
 800050e:	f002 f80f 	bl	8002530 <__ledf2>
 8000512:	2800      	cmp	r0, #0
 8000514:	db01      	blt.n	800051a <__aeabi_dcmplt+0xe>
 8000516:	2000      	movs	r0, #0
 8000518:	bd10      	pop	{r4, pc}
 800051a:	2001      	movs	r0, #1
 800051c:	bd10      	pop	{r4, pc}
 800051e:	46c0      	nop			; (mov r8, r8)

08000520 <__aeabi_dcmple>:
 8000520:	b510      	push	{r4, lr}
 8000522:	f002 f805 	bl	8002530 <__ledf2>
 8000526:	2800      	cmp	r0, #0
 8000528:	dd01      	ble.n	800052e <__aeabi_dcmple+0xe>
 800052a:	2000      	movs	r0, #0
 800052c:	bd10      	pop	{r4, pc}
 800052e:	2001      	movs	r0, #1
 8000530:	bd10      	pop	{r4, pc}
 8000532:	46c0      	nop			; (mov r8, r8)

08000534 <__aeabi_dcmpgt>:
 8000534:	b510      	push	{r4, lr}
 8000536:	f001 ff93 	bl	8002460 <__gedf2>
 800053a:	2800      	cmp	r0, #0
 800053c:	dc01      	bgt.n	8000542 <__aeabi_dcmpgt+0xe>
 800053e:	2000      	movs	r0, #0
 8000540:	bd10      	pop	{r4, pc}
 8000542:	2001      	movs	r0, #1
 8000544:	bd10      	pop	{r4, pc}
 8000546:	46c0      	nop			; (mov r8, r8)

08000548 <__aeabi_dcmpge>:
 8000548:	b510      	push	{r4, lr}
 800054a:	f001 ff89 	bl	8002460 <__gedf2>
 800054e:	2800      	cmp	r0, #0
 8000550:	da01      	bge.n	8000556 <__aeabi_dcmpge+0xe>
 8000552:	2000      	movs	r0, #0
 8000554:	bd10      	pop	{r4, pc}
 8000556:	2001      	movs	r0, #1
 8000558:	bd10      	pop	{r4, pc}
 800055a:	46c0      	nop			; (mov r8, r8)
 800055c:	0000      	movs	r0, r0
	...

08000560 <__aeabi_cfrcmple>:
 8000560:	4684      	mov	ip, r0
 8000562:	1c08      	adds	r0, r1, #0
 8000564:	4661      	mov	r1, ip
 8000566:	e7ff      	b.n	8000568 <__aeabi_cfcmpeq>

08000568 <__aeabi_cfcmpeq>:
 8000568:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 800056a:	f000 fcf1 	bl	8000f50 <__lesf2>
 800056e:	2800      	cmp	r0, #0
 8000570:	d401      	bmi.n	8000576 <__aeabi_cfcmpeq+0xe>
 8000572:	2100      	movs	r1, #0
 8000574:	42c8      	cmn	r0, r1
 8000576:	bd1f      	pop	{r0, r1, r2, r3, r4, pc}

08000578 <__aeabi_fcmpeq>:
 8000578:	b510      	push	{r4, lr}
 800057a:	f000 fc71 	bl	8000e60 <__eqsf2>
 800057e:	4240      	negs	r0, r0
 8000580:	3001      	adds	r0, #1
 8000582:	bd10      	pop	{r4, pc}

08000584 <__aeabi_fcmplt>:
 8000584:	b510      	push	{r4, lr}
 8000586:	f000 fce3 	bl	8000f50 <__lesf2>
 800058a:	2800      	cmp	r0, #0
 800058c:	db01      	blt.n	8000592 <__aeabi_fcmplt+0xe>
 800058e:	2000      	movs	r0, #0
 8000590:	bd10      	pop	{r4, pc}
 8000592:	2001      	movs	r0, #1
 8000594:	bd10      	pop	{r4, pc}
 8000596:	46c0      	nop			; (mov r8, r8)

08000598 <__aeabi_fcmple>:
 8000598:	b510      	push	{r4, lr}
 800059a:	f000 fcd9 	bl	8000f50 <__lesf2>
 800059e:	2800      	cmp	r0, #0
 80005a0:	dd01      	ble.n	80005a6 <__aeabi_fcmple+0xe>
 80005a2:	2000      	movs	r0, #0
 80005a4:	bd10      	pop	{r4, pc}
 80005a6:	2001      	movs	r0, #1
 80005a8:	bd10      	pop	{r4, pc}
 80005aa:	46c0      	nop			; (mov r8, r8)

080005ac <__aeabi_fcmpgt>:
 80005ac:	b510      	push	{r4, lr}
 80005ae:	f000 fc7f 	bl	8000eb0 <__gesf2>
 80005b2:	2800      	cmp	r0, #0
 80005b4:	dc01      	bgt.n	80005ba <__aeabi_fcmpgt+0xe>
 80005b6:	2000      	movs	r0, #0
 80005b8:	bd10      	pop	{r4, pc}
 80005ba:	2001      	movs	r0, #1
 80005bc:	bd10      	pop	{r4, pc}
 80005be:	46c0      	nop			; (mov r8, r8)

080005c0 <__aeabi_fcmpge>:
 80005c0:	b510      	push	{r4, lr}
 80005c2:	f000 fc75 	bl	8000eb0 <__gesf2>
 80005c6:	2800      	cmp	r0, #0
 80005c8:	da01      	bge.n	80005ce <__aeabi_fcmpge+0xe>
 80005ca:	2000      	movs	r0, #0
 80005cc:	bd10      	pop	{r4, pc}
 80005ce:	2001      	movs	r0, #1
 80005d0:	bd10      	pop	{r4, pc}
 80005d2:	46c0      	nop			; (mov r8, r8)
	...

080005e0 <__aeabi_ldivmod>:
 80005e0:	2b00      	cmp	r3, #0
 80005e2:	d115      	bne.n	8000610 <__aeabi_ldivmod+0x30>
 80005e4:	2a00      	cmp	r2, #0
 80005e6:	d113      	bne.n	8000610 <__aeabi_ldivmod+0x30>
 80005e8:	2900      	cmp	r1, #0
 80005ea:	db06      	blt.n	80005fa <__aeabi_ldivmod+0x1a>
 80005ec:	dc01      	bgt.n	80005f2 <__aeabi_ldivmod+0x12>
 80005ee:	2800      	cmp	r0, #0
 80005f0:	d006      	beq.n	8000600 <__aeabi_ldivmod+0x20>
 80005f2:	2000      	movs	r0, #0
 80005f4:	43c0      	mvns	r0, r0
 80005f6:	0841      	lsrs	r1, r0, #1
 80005f8:	e002      	b.n	8000600 <__aeabi_ldivmod+0x20>
 80005fa:	2180      	movs	r1, #128	; 0x80
 80005fc:	0609      	lsls	r1, r1, #24
 80005fe:	2000      	movs	r0, #0
 8000600:	b407      	push	{r0, r1, r2}
 8000602:	4802      	ldr	r0, [pc, #8]	; (800060c <__aeabi_ldivmod+0x2c>)
 8000604:	a101      	add	r1, pc, #4	; (adr r1, 800060c <__aeabi_ldivmod+0x2c>)
 8000606:	1840      	adds	r0, r0, r1
 8000608:	9002      	str	r0, [sp, #8]
 800060a:	bd03      	pop	{r0, r1, pc}
 800060c:	fffffec5 	.word	0xfffffec5
 8000610:	b403      	push	{r0, r1}
 8000612:	4668      	mov	r0, sp
 8000614:	b501      	push	{r0, lr}
 8000616:	9802      	ldr	r0, [sp, #8]
 8000618:	f000 f96a 	bl	80008f0 <__gnu_ldivmod_helper>
 800061c:	9b01      	ldr	r3, [sp, #4]
 800061e:	469e      	mov	lr, r3
 8000620:	b002      	add	sp, #8
 8000622:	bc0c      	pop	{r2, r3}
 8000624:	4770      	bx	lr
 8000626:	46c0      	nop			; (mov r8, r8)
	...

08000630 <__aeabi_uldivmod>:
 8000630:	2b00      	cmp	r3, #0
 8000632:	d111      	bne.n	8000658 <__aeabi_uldivmod+0x28>
 8000634:	2a00      	cmp	r2, #0
 8000636:	d10f      	bne.n	8000658 <__aeabi_uldivmod+0x28>
 8000638:	2900      	cmp	r1, #0
 800063a:	d100      	bne.n	800063e <__aeabi_uldivmod+0xe>
 800063c:	2800      	cmp	r0, #0
 800063e:	d002      	beq.n	8000646 <__aeabi_uldivmod+0x16>
 8000640:	2100      	movs	r1, #0
 8000642:	43c9      	mvns	r1, r1
 8000644:	1c08      	adds	r0, r1, #0
 8000646:	b407      	push	{r0, r1, r2}
 8000648:	4802      	ldr	r0, [pc, #8]	; (8000654 <__aeabi_uldivmod+0x24>)
 800064a:	a102      	add	r1, pc, #8	; (adr r1, 8000654 <__aeabi_uldivmod+0x24>)
 800064c:	1840      	adds	r0, r0, r1
 800064e:	9002      	str	r0, [sp, #8]
 8000650:	bd03      	pop	{r0, r1, pc}
 8000652:	46c0      	nop			; (mov r8, r8)
 8000654:	fffffe7d 	.word	0xfffffe7d
 8000658:	b403      	push	{r0, r1}
 800065a:	4668      	mov	r0, sp
 800065c:	b501      	push	{r0, lr}
 800065e:	9802      	ldr	r0, [sp, #8]
 8000660:	f000 f86e 	bl	8000740 <__udivmoddi4>
 8000664:	9b01      	ldr	r3, [sp, #4]
 8000666:	469e      	mov	lr, r3
 8000668:	b002      	add	sp, #8
 800066a:	bc0c      	pop	{r2, r3}
 800066c:	4770      	bx	lr
 800066e:	46c0      	nop			; (mov r8, r8)

08000670 <__aeabi_lmul>:
 8000670:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000672:	46ce      	mov	lr, r9
 8000674:	4647      	mov	r7, r8
 8000676:	0415      	lsls	r5, r2, #16
 8000678:	0c2d      	lsrs	r5, r5, #16
 800067a:	002e      	movs	r6, r5
 800067c:	b580      	push	{r7, lr}
 800067e:	0407      	lsls	r7, r0, #16
 8000680:	0c14      	lsrs	r4, r2, #16
 8000682:	0c3f      	lsrs	r7, r7, #16
 8000684:	4699      	mov	r9, r3
 8000686:	0c03      	lsrs	r3, r0, #16
 8000688:	437e      	muls	r6, r7
 800068a:	435d      	muls	r5, r3
 800068c:	4367      	muls	r7, r4
 800068e:	4363      	muls	r3, r4
 8000690:	197f      	adds	r7, r7, r5
 8000692:	0c34      	lsrs	r4, r6, #16
 8000694:	19e4      	adds	r4, r4, r7
 8000696:	469c      	mov	ip, r3
 8000698:	42a5      	cmp	r5, r4
 800069a:	d903      	bls.n	80006a4 <__aeabi_lmul+0x34>
 800069c:	2380      	movs	r3, #128	; 0x80
 800069e:	025b      	lsls	r3, r3, #9
 80006a0:	4698      	mov	r8, r3
 80006a2:	44c4      	add	ip, r8
 80006a4:	464b      	mov	r3, r9
 80006a6:	4343      	muls	r3, r0
 80006a8:	4351      	muls	r1, r2
 80006aa:	0c25      	lsrs	r5, r4, #16
 80006ac:	0436      	lsls	r6, r6, #16
 80006ae:	4465      	add	r5, ip
 80006b0:	0c36      	lsrs	r6, r6, #16
 80006b2:	0424      	lsls	r4, r4, #16
 80006b4:	19a4      	adds	r4, r4, r6
 80006b6:	195b      	adds	r3, r3, r5
 80006b8:	1859      	adds	r1, r3, r1
 80006ba:	0020      	movs	r0, r4
 80006bc:	bc0c      	pop	{r2, r3}
 80006be:	4690      	mov	r8, r2
 80006c0:	4699      	mov	r9, r3
 80006c2:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

080006d0 <__aeabi_f2uiz>:
 80006d0:	219e      	movs	r1, #158	; 0x9e
 80006d2:	b510      	push	{r4, lr}
 80006d4:	05c9      	lsls	r1, r1, #23
 80006d6:	1c04      	adds	r4, r0, #0
 80006d8:	f7ff ff72 	bl	80005c0 <__aeabi_fcmpge>
 80006dc:	2800      	cmp	r0, #0
 80006de:	d103      	bne.n	80006e8 <__aeabi_f2uiz+0x18>
 80006e0:	1c20      	adds	r0, r4, #0
 80006e2:	f000 ff5d 	bl	80015a0 <__aeabi_f2iz>
 80006e6:	bd10      	pop	{r4, pc}
 80006e8:	219e      	movs	r1, #158	; 0x9e
 80006ea:	1c20      	adds	r0, r4, #0
 80006ec:	05c9      	lsls	r1, r1, #23
 80006ee:	f000 fd97 	bl	8001220 <__aeabi_fsub>
 80006f2:	f000 ff55 	bl	80015a0 <__aeabi_f2iz>
 80006f6:	2380      	movs	r3, #128	; 0x80
 80006f8:	061b      	lsls	r3, r3, #24
 80006fa:	469c      	mov	ip, r3
 80006fc:	4460      	add	r0, ip
 80006fe:	e7f2      	b.n	80006e6 <__aeabi_f2uiz+0x16>

08000700 <__aeabi_d2uiz>:
 8000700:	b570      	push	{r4, r5, r6, lr}
 8000702:	2200      	movs	r2, #0
 8000704:	4b0c      	ldr	r3, [pc, #48]	; (8000738 <__aeabi_d2uiz+0x38>)
 8000706:	0004      	movs	r4, r0
 8000708:	000d      	movs	r5, r1
 800070a:	f7ff ff1d 	bl	8000548 <__aeabi_dcmpge>
 800070e:	2800      	cmp	r0, #0
 8000710:	d104      	bne.n	800071c <__aeabi_d2uiz+0x1c>
 8000712:	0020      	movs	r0, r4
 8000714:	0029      	movs	r1, r5
 8000716:	f002 fdb3 	bl	8003280 <__aeabi_d2iz>
 800071a:	bd70      	pop	{r4, r5, r6, pc}
 800071c:	4b06      	ldr	r3, [pc, #24]	; (8000738 <__aeabi_d2uiz+0x38>)
 800071e:	2200      	movs	r2, #0
 8000720:	0020      	movs	r0, r4
 8000722:	0029      	movs	r1, r5
 8000724:	f002 f9f4 	bl	8002b10 <__aeabi_dsub>
 8000728:	f002 fdaa 	bl	8003280 <__aeabi_d2iz>
 800072c:	2380      	movs	r3, #128	; 0x80
 800072e:	061b      	lsls	r3, r3, #24
 8000730:	469c      	mov	ip, r3
 8000732:	4460      	add	r0, ip
 8000734:	e7f1      	b.n	800071a <__aeabi_d2uiz+0x1a>
 8000736:	46c0      	nop			; (mov r8, r8)
 8000738:	41e00000 	.word	0x41e00000
 800073c:	00000000 	.word	0x00000000

08000740 <__udivmoddi4>:
 8000740:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000742:	4657      	mov	r7, sl
 8000744:	464e      	mov	r6, r9
 8000746:	4645      	mov	r5, r8
 8000748:	46de      	mov	lr, fp
 800074a:	b5e0      	push	{r5, r6, r7, lr}
 800074c:	0004      	movs	r4, r0
 800074e:	b083      	sub	sp, #12
 8000750:	000d      	movs	r5, r1
 8000752:	4692      	mov	sl, r2
 8000754:	4699      	mov	r9, r3
 8000756:	428b      	cmp	r3, r1
 8000758:	d830      	bhi.n	80007bc <__udivmoddi4+0x7c>
 800075a:	d02d      	beq.n	80007b8 <__udivmoddi4+0x78>
 800075c:	4649      	mov	r1, r9
 800075e:	4650      	mov	r0, sl
 8000760:	f002 ff3e 	bl	80035e0 <__clzdi2>
 8000764:	0029      	movs	r1, r5
 8000766:	0006      	movs	r6, r0
 8000768:	0020      	movs	r0, r4
 800076a:	f002 ff39 	bl	80035e0 <__clzdi2>
 800076e:	1a33      	subs	r3, r6, r0
 8000770:	4698      	mov	r8, r3
 8000772:	3b20      	subs	r3, #32
 8000774:	469b      	mov	fp, r3
 8000776:	d433      	bmi.n	80007e0 <__udivmoddi4+0xa0>
 8000778:	465a      	mov	r2, fp
 800077a:	4653      	mov	r3, sl
 800077c:	4093      	lsls	r3, r2
 800077e:	4642      	mov	r2, r8
 8000780:	001f      	movs	r7, r3
 8000782:	4653      	mov	r3, sl
 8000784:	4093      	lsls	r3, r2
 8000786:	001e      	movs	r6, r3
 8000788:	42af      	cmp	r7, r5
 800078a:	d83a      	bhi.n	8000802 <__udivmoddi4+0xc2>
 800078c:	42af      	cmp	r7, r5
 800078e:	d100      	bne.n	8000792 <__udivmoddi4+0x52>
 8000790:	e07b      	b.n	800088a <__udivmoddi4+0x14a>
 8000792:	465b      	mov	r3, fp
 8000794:	1ba4      	subs	r4, r4, r6
 8000796:	41bd      	sbcs	r5, r7
 8000798:	2b00      	cmp	r3, #0
 800079a:	da00      	bge.n	800079e <__udivmoddi4+0x5e>
 800079c:	e078      	b.n	8000890 <__udivmoddi4+0x150>
 800079e:	2200      	movs	r2, #0
 80007a0:	2300      	movs	r3, #0
 80007a2:	9200      	str	r2, [sp, #0]
 80007a4:	9301      	str	r3, [sp, #4]
 80007a6:	2301      	movs	r3, #1
 80007a8:	465a      	mov	r2, fp
 80007aa:	4093      	lsls	r3, r2
 80007ac:	9301      	str	r3, [sp, #4]
 80007ae:	2301      	movs	r3, #1
 80007b0:	4642      	mov	r2, r8
 80007b2:	4093      	lsls	r3, r2
 80007b4:	9300      	str	r3, [sp, #0]
 80007b6:	e028      	b.n	800080a <__udivmoddi4+0xca>
 80007b8:	4282      	cmp	r2, r0
 80007ba:	d9cf      	bls.n	800075c <__udivmoddi4+0x1c>
 80007bc:	2200      	movs	r2, #0
 80007be:	2300      	movs	r3, #0
 80007c0:	9200      	str	r2, [sp, #0]
 80007c2:	9301      	str	r3, [sp, #4]
 80007c4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80007c6:	2b00      	cmp	r3, #0
 80007c8:	d001      	beq.n	80007ce <__udivmoddi4+0x8e>
 80007ca:	601c      	str	r4, [r3, #0]
 80007cc:	605d      	str	r5, [r3, #4]
 80007ce:	9800      	ldr	r0, [sp, #0]
 80007d0:	9901      	ldr	r1, [sp, #4]
 80007d2:	b003      	add	sp, #12
 80007d4:	bc3c      	pop	{r2, r3, r4, r5}
 80007d6:	4690      	mov	r8, r2
 80007d8:	4699      	mov	r9, r3
 80007da:	46a2      	mov	sl, r4
 80007dc:	46ab      	mov	fp, r5
 80007de:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80007e0:	4642      	mov	r2, r8
 80007e2:	2320      	movs	r3, #32
 80007e4:	1a9b      	subs	r3, r3, r2
 80007e6:	4652      	mov	r2, sl
 80007e8:	40da      	lsrs	r2, r3
 80007ea:	4641      	mov	r1, r8
 80007ec:	0013      	movs	r3, r2
 80007ee:	464a      	mov	r2, r9
 80007f0:	408a      	lsls	r2, r1
 80007f2:	0017      	movs	r7, r2
 80007f4:	4642      	mov	r2, r8
 80007f6:	431f      	orrs	r7, r3
 80007f8:	4653      	mov	r3, sl
 80007fa:	4093      	lsls	r3, r2
 80007fc:	001e      	movs	r6, r3
 80007fe:	42af      	cmp	r7, r5
 8000800:	d9c4      	bls.n	800078c <__udivmoddi4+0x4c>
 8000802:	2200      	movs	r2, #0
 8000804:	2300      	movs	r3, #0
 8000806:	9200      	str	r2, [sp, #0]
 8000808:	9301      	str	r3, [sp, #4]
 800080a:	4643      	mov	r3, r8
 800080c:	2b00      	cmp	r3, #0
 800080e:	d0d9      	beq.n	80007c4 <__udivmoddi4+0x84>
 8000810:	07fb      	lsls	r3, r7, #31
 8000812:	469c      	mov	ip, r3
 8000814:	4661      	mov	r1, ip
 8000816:	0872      	lsrs	r2, r6, #1
 8000818:	430a      	orrs	r2, r1
 800081a:	087b      	lsrs	r3, r7, #1
 800081c:	4646      	mov	r6, r8
 800081e:	e00e      	b.n	800083e <__udivmoddi4+0xfe>
 8000820:	42ab      	cmp	r3, r5
 8000822:	d101      	bne.n	8000828 <__udivmoddi4+0xe8>
 8000824:	42a2      	cmp	r2, r4
 8000826:	d80c      	bhi.n	8000842 <__udivmoddi4+0x102>
 8000828:	1aa4      	subs	r4, r4, r2
 800082a:	419d      	sbcs	r5, r3
 800082c:	2001      	movs	r0, #1
 800082e:	1924      	adds	r4, r4, r4
 8000830:	416d      	adcs	r5, r5
 8000832:	2100      	movs	r1, #0
 8000834:	3e01      	subs	r6, #1
 8000836:	1824      	adds	r4, r4, r0
 8000838:	414d      	adcs	r5, r1
 800083a:	2e00      	cmp	r6, #0
 800083c:	d006      	beq.n	800084c <__udivmoddi4+0x10c>
 800083e:	42ab      	cmp	r3, r5
 8000840:	d9ee      	bls.n	8000820 <__udivmoddi4+0xe0>
 8000842:	3e01      	subs	r6, #1
 8000844:	1924      	adds	r4, r4, r4
 8000846:	416d      	adcs	r5, r5
 8000848:	2e00      	cmp	r6, #0
 800084a:	d1f8      	bne.n	800083e <__udivmoddi4+0xfe>
 800084c:	9800      	ldr	r0, [sp, #0]
 800084e:	9901      	ldr	r1, [sp, #4]
 8000850:	465b      	mov	r3, fp
 8000852:	1900      	adds	r0, r0, r4
 8000854:	4169      	adcs	r1, r5
 8000856:	2b00      	cmp	r3, #0
 8000858:	db25      	blt.n	80008a6 <__udivmoddi4+0x166>
 800085a:	002b      	movs	r3, r5
 800085c:	465a      	mov	r2, fp
 800085e:	4644      	mov	r4, r8
 8000860:	40d3      	lsrs	r3, r2
 8000862:	002a      	movs	r2, r5
 8000864:	40e2      	lsrs	r2, r4
 8000866:	001c      	movs	r4, r3
 8000868:	465b      	mov	r3, fp
 800086a:	0015      	movs	r5, r2
 800086c:	2b00      	cmp	r3, #0
 800086e:	db2b      	blt.n	80008c8 <__udivmoddi4+0x188>
 8000870:	0026      	movs	r6, r4
 8000872:	465f      	mov	r7, fp
 8000874:	40be      	lsls	r6, r7
 8000876:	0033      	movs	r3, r6
 8000878:	0026      	movs	r6, r4
 800087a:	4647      	mov	r7, r8
 800087c:	40be      	lsls	r6, r7
 800087e:	0032      	movs	r2, r6
 8000880:	1a80      	subs	r0, r0, r2
 8000882:	4199      	sbcs	r1, r3
 8000884:	9000      	str	r0, [sp, #0]
 8000886:	9101      	str	r1, [sp, #4]
 8000888:	e79c      	b.n	80007c4 <__udivmoddi4+0x84>
 800088a:	42a3      	cmp	r3, r4
 800088c:	d8b9      	bhi.n	8000802 <__udivmoddi4+0xc2>
 800088e:	e780      	b.n	8000792 <__udivmoddi4+0x52>
 8000890:	4642      	mov	r2, r8
 8000892:	2320      	movs	r3, #32
 8000894:	2100      	movs	r1, #0
 8000896:	1a9b      	subs	r3, r3, r2
 8000898:	2200      	movs	r2, #0
 800089a:	9100      	str	r1, [sp, #0]
 800089c:	9201      	str	r2, [sp, #4]
 800089e:	2201      	movs	r2, #1
 80008a0:	40da      	lsrs	r2, r3
 80008a2:	9201      	str	r2, [sp, #4]
 80008a4:	e783      	b.n	80007ae <__udivmoddi4+0x6e>
 80008a6:	4642      	mov	r2, r8
 80008a8:	2320      	movs	r3, #32
 80008aa:	1a9b      	subs	r3, r3, r2
 80008ac:	002a      	movs	r2, r5
 80008ae:	4646      	mov	r6, r8
 80008b0:	409a      	lsls	r2, r3
 80008b2:	0023      	movs	r3, r4
 80008b4:	40f3      	lsrs	r3, r6
 80008b6:	4644      	mov	r4, r8
 80008b8:	4313      	orrs	r3, r2
 80008ba:	002a      	movs	r2, r5
 80008bc:	40e2      	lsrs	r2, r4
 80008be:	001c      	movs	r4, r3
 80008c0:	465b      	mov	r3, fp
 80008c2:	0015      	movs	r5, r2
 80008c4:	2b00      	cmp	r3, #0
 80008c6:	dad3      	bge.n	8000870 <__udivmoddi4+0x130>
 80008c8:	2320      	movs	r3, #32
 80008ca:	4642      	mov	r2, r8
 80008cc:	0026      	movs	r6, r4
 80008ce:	1a9b      	subs	r3, r3, r2
 80008d0:	40de      	lsrs	r6, r3
 80008d2:	002f      	movs	r7, r5
 80008d4:	46b4      	mov	ip, r6
 80008d6:	4646      	mov	r6, r8
 80008d8:	40b7      	lsls	r7, r6
 80008da:	4666      	mov	r6, ip
 80008dc:	003b      	movs	r3, r7
 80008de:	4333      	orrs	r3, r6
 80008e0:	e7ca      	b.n	8000878 <__udivmoddi4+0x138>
 80008e2:	46c0      	nop			; (mov r8, r8)
	...

080008f0 <__gnu_ldivmod_helper>:
 80008f0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80008f2:	b083      	sub	sp, #12
 80008f4:	0016      	movs	r6, r2
 80008f6:	001f      	movs	r7, r3
 80008f8:	9000      	str	r0, [sp, #0]
 80008fa:	9101      	str	r1, [sp, #4]
 80008fc:	f002 fe80 	bl	8003600 <__divdi3>
 8000900:	0004      	movs	r4, r0
 8000902:	000d      	movs	r5, r1
 8000904:	0002      	movs	r2, r0
 8000906:	000b      	movs	r3, r1
 8000908:	0030      	movs	r0, r6
 800090a:	0039      	movs	r1, r7
 800090c:	f7ff feb0 	bl	8000670 <__aeabi_lmul>
 8000910:	9a00      	ldr	r2, [sp, #0]
 8000912:	9b01      	ldr	r3, [sp, #4]
 8000914:	1a12      	subs	r2, r2, r0
 8000916:	418b      	sbcs	r3, r1
 8000918:	9908      	ldr	r1, [sp, #32]
 800091a:	0020      	movs	r0, r4
 800091c:	600a      	str	r2, [r1, #0]
 800091e:	604b      	str	r3, [r1, #4]
 8000920:	0029      	movs	r1, r5
 8000922:	b003      	add	sp, #12
 8000924:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000926:	46c0      	nop			; (mov r8, r8)
	...

08000930 <__aeabi_fadd>:
 8000930:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000932:	024c      	lsls	r4, r1, #9
 8000934:	0a64      	lsrs	r4, r4, #9
 8000936:	4647      	mov	r7, r8
 8000938:	46a0      	mov	r8, r4
 800093a:	004c      	lsls	r4, r1, #1
 800093c:	0fc9      	lsrs	r1, r1, #31
 800093e:	46ce      	mov	lr, r9
 8000940:	4689      	mov	r9, r1
 8000942:	4641      	mov	r1, r8
 8000944:	0243      	lsls	r3, r0, #9
 8000946:	0046      	lsls	r6, r0, #1
 8000948:	0a5b      	lsrs	r3, r3, #9
 800094a:	0e36      	lsrs	r6, r6, #24
 800094c:	0e24      	lsrs	r4, r4, #24
 800094e:	b580      	push	{r7, lr}
 8000950:	0fc5      	lsrs	r5, r0, #31
 8000952:	469c      	mov	ip, r3
 8000954:	0032      	movs	r2, r6
 8000956:	00d8      	lsls	r0, r3, #3
 8000958:	00c9      	lsls	r1, r1, #3
 800095a:	1b37      	subs	r7, r6, r4
 800095c:	454d      	cmp	r5, r9
 800095e:	d060      	beq.n	8000a22 <__aeabi_fadd+0xf2>
 8000960:	2f00      	cmp	r7, #0
 8000962:	dd48      	ble.n	80009f6 <__aeabi_fadd+0xc6>
 8000964:	2c00      	cmp	r4, #0
 8000966:	d100      	bne.n	800096a <__aeabi_fadd+0x3a>
 8000968:	e07c      	b.n	8000a64 <__aeabi_fadd+0x134>
 800096a:	2eff      	cmp	r6, #255	; 0xff
 800096c:	d100      	bne.n	8000970 <__aeabi_fadd+0x40>
 800096e:	e083      	b.n	8000a78 <__aeabi_fadd+0x148>
 8000970:	2380      	movs	r3, #128	; 0x80
 8000972:	04db      	lsls	r3, r3, #19
 8000974:	4319      	orrs	r1, r3
 8000976:	2301      	movs	r3, #1
 8000978:	2f1b      	cmp	r7, #27
 800097a:	dc07      	bgt.n	800098c <__aeabi_fadd+0x5c>
 800097c:	000b      	movs	r3, r1
 800097e:	2220      	movs	r2, #32
 8000980:	40fb      	lsrs	r3, r7
 8000982:	1bd7      	subs	r7, r2, r7
 8000984:	40b9      	lsls	r1, r7
 8000986:	1e4a      	subs	r2, r1, #1
 8000988:	4191      	sbcs	r1, r2
 800098a:	430b      	orrs	r3, r1
 800098c:	1ac3      	subs	r3, r0, r3
 800098e:	015a      	lsls	r2, r3, #5
 8000990:	d400      	bmi.n	8000994 <__aeabi_fadd+0x64>
 8000992:	e0a8      	b.n	8000ae6 <__aeabi_fadd+0x1b6>
 8000994:	019b      	lsls	r3, r3, #6
 8000996:	099c      	lsrs	r4, r3, #6
 8000998:	0020      	movs	r0, r4
 800099a:	f002 fe01 	bl	80035a0 <__clzsi2>
 800099e:	3805      	subs	r0, #5
 80009a0:	4084      	lsls	r4, r0
 80009a2:	4286      	cmp	r6, r0
 80009a4:	dd00      	ble.n	80009a8 <__aeabi_fadd+0x78>
 80009a6:	e0ad      	b.n	8000b04 <__aeabi_fadd+0x1d4>
 80009a8:	1b86      	subs	r6, r0, r6
 80009aa:	0022      	movs	r2, r4
 80009ac:	2020      	movs	r0, #32
 80009ae:	3601      	adds	r6, #1
 80009b0:	40f2      	lsrs	r2, r6
 80009b2:	1b86      	subs	r6, r0, r6
 80009b4:	40b4      	lsls	r4, r6
 80009b6:	0023      	movs	r3, r4
 80009b8:	1e5c      	subs	r4, r3, #1
 80009ba:	41a3      	sbcs	r3, r4
 80009bc:	2600      	movs	r6, #0
 80009be:	4313      	orrs	r3, r2
 80009c0:	075a      	lsls	r2, r3, #29
 80009c2:	d004      	beq.n	80009ce <__aeabi_fadd+0x9e>
 80009c4:	220f      	movs	r2, #15
 80009c6:	401a      	ands	r2, r3
 80009c8:	2a04      	cmp	r2, #4
 80009ca:	d000      	beq.n	80009ce <__aeabi_fadd+0x9e>
 80009cc:	3304      	adds	r3, #4
 80009ce:	015a      	lsls	r2, r3, #5
 80009d0:	d400      	bmi.n	80009d4 <__aeabi_fadd+0xa4>
 80009d2:	e08b      	b.n	8000aec <__aeabi_fadd+0x1bc>
 80009d4:	3601      	adds	r6, #1
 80009d6:	b2f2      	uxtb	r2, r6
 80009d8:	2eff      	cmp	r6, #255	; 0xff
 80009da:	d100      	bne.n	80009de <__aeabi_fadd+0xae>
 80009dc:	e08f      	b.n	8000afe <__aeabi_fadd+0x1ce>
 80009de:	019b      	lsls	r3, r3, #6
 80009e0:	0a5b      	lsrs	r3, r3, #9
 80009e2:	025b      	lsls	r3, r3, #9
 80009e4:	05d2      	lsls	r2, r2, #23
 80009e6:	0a58      	lsrs	r0, r3, #9
 80009e8:	07ed      	lsls	r5, r5, #31
 80009ea:	4310      	orrs	r0, r2
 80009ec:	4328      	orrs	r0, r5
 80009ee:	bc0c      	pop	{r2, r3}
 80009f0:	4690      	mov	r8, r2
 80009f2:	4699      	mov	r9, r3
 80009f4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80009f6:	2f00      	cmp	r7, #0
 80009f8:	d149      	bne.n	8000a8e <__aeabi_fadd+0x15e>
 80009fa:	24fe      	movs	r4, #254	; 0xfe
 80009fc:	1c77      	adds	r7, r6, #1
 80009fe:	423c      	tst	r4, r7
 8000a00:	d000      	beq.n	8000a04 <__aeabi_fadd+0xd4>
 8000a02:	e086      	b.n	8000b12 <__aeabi_fadd+0x1e2>
 8000a04:	2e00      	cmp	r6, #0
 8000a06:	d000      	beq.n	8000a0a <__aeabi_fadd+0xda>
 8000a08:	e0de      	b.n	8000bc8 <__aeabi_fadd+0x298>
 8000a0a:	2800      	cmp	r0, #0
 8000a0c:	d100      	bne.n	8000a10 <__aeabi_fadd+0xe0>
 8000a0e:	e0d1      	b.n	8000bb4 <__aeabi_fadd+0x284>
 8000a10:	2900      	cmp	r1, #0
 8000a12:	d0e6      	beq.n	80009e2 <__aeabi_fadd+0xb2>
 8000a14:	1a43      	subs	r3, r0, r1
 8000a16:	015c      	lsls	r4, r3, #5
 8000a18:	d400      	bmi.n	8000a1c <__aeabi_fadd+0xec>
 8000a1a:	e0f1      	b.n	8000c00 <__aeabi_fadd+0x2d0>
 8000a1c:	1a0b      	subs	r3, r1, r0
 8000a1e:	464d      	mov	r5, r9
 8000a20:	e7ce      	b.n	80009c0 <__aeabi_fadd+0x90>
 8000a22:	2f00      	cmp	r7, #0
 8000a24:	dd4a      	ble.n	8000abc <__aeabi_fadd+0x18c>
 8000a26:	2c00      	cmp	r4, #0
 8000a28:	d03f      	beq.n	8000aaa <__aeabi_fadd+0x17a>
 8000a2a:	2eff      	cmp	r6, #255	; 0xff
 8000a2c:	d024      	beq.n	8000a78 <__aeabi_fadd+0x148>
 8000a2e:	2380      	movs	r3, #128	; 0x80
 8000a30:	04db      	lsls	r3, r3, #19
 8000a32:	4319      	orrs	r1, r3
 8000a34:	2301      	movs	r3, #1
 8000a36:	2f1b      	cmp	r7, #27
 8000a38:	dc07      	bgt.n	8000a4a <__aeabi_fadd+0x11a>
 8000a3a:	000b      	movs	r3, r1
 8000a3c:	2220      	movs	r2, #32
 8000a3e:	40fb      	lsrs	r3, r7
 8000a40:	1bd7      	subs	r7, r2, r7
 8000a42:	40b9      	lsls	r1, r7
 8000a44:	1e4a      	subs	r2, r1, #1
 8000a46:	4191      	sbcs	r1, r2
 8000a48:	430b      	orrs	r3, r1
 8000a4a:	181b      	adds	r3, r3, r0
 8000a4c:	015a      	lsls	r2, r3, #5
 8000a4e:	d54a      	bpl.n	8000ae6 <__aeabi_fadd+0x1b6>
 8000a50:	3601      	adds	r6, #1
 8000a52:	2eff      	cmp	r6, #255	; 0xff
 8000a54:	d053      	beq.n	8000afe <__aeabi_fadd+0x1ce>
 8000a56:	2201      	movs	r2, #1
 8000a58:	4971      	ldr	r1, [pc, #452]	; (8000c20 <__aeabi_fadd+0x2f0>)
 8000a5a:	401a      	ands	r2, r3
 8000a5c:	085b      	lsrs	r3, r3, #1
 8000a5e:	400b      	ands	r3, r1
 8000a60:	4313      	orrs	r3, r2
 8000a62:	e7ad      	b.n	80009c0 <__aeabi_fadd+0x90>
 8000a64:	2900      	cmp	r1, #0
 8000a66:	d043      	beq.n	8000af0 <__aeabi_fadd+0x1c0>
 8000a68:	3f01      	subs	r7, #1
 8000a6a:	1a43      	subs	r3, r0, r1
 8000a6c:	2f00      	cmp	r7, #0
 8000a6e:	d100      	bne.n	8000a72 <__aeabi_fadd+0x142>
 8000a70:	e78d      	b.n	800098e <__aeabi_fadd+0x5e>
 8000a72:	2eff      	cmp	r6, #255	; 0xff
 8000a74:	d000      	beq.n	8000a78 <__aeabi_fadd+0x148>
 8000a76:	e77e      	b.n	8000976 <__aeabi_fadd+0x46>
 8000a78:	4663      	mov	r3, ip
 8000a7a:	2b00      	cmp	r3, #0
 8000a7c:	d03f      	beq.n	8000afe <__aeabi_fadd+0x1ce>
 8000a7e:	2380      	movs	r3, #128	; 0x80
 8000a80:	4662      	mov	r2, ip
 8000a82:	03db      	lsls	r3, r3, #15
 8000a84:	4313      	orrs	r3, r2
 8000a86:	025b      	lsls	r3, r3, #9
 8000a88:	0a5b      	lsrs	r3, r3, #9
 8000a8a:	22ff      	movs	r2, #255	; 0xff
 8000a8c:	e7a9      	b.n	80009e2 <__aeabi_fadd+0xb2>
 8000a8e:	1ba2      	subs	r2, r4, r6
 8000a90:	2e00      	cmp	r6, #0
 8000a92:	d160      	bne.n	8000b56 <__aeabi_fadd+0x226>
 8000a94:	2800      	cmp	r0, #0
 8000a96:	d078      	beq.n	8000b8a <__aeabi_fadd+0x25a>
 8000a98:	3a01      	subs	r2, #1
 8000a9a:	2a00      	cmp	r2, #0
 8000a9c:	d100      	bne.n	8000aa0 <__aeabi_fadd+0x170>
 8000a9e:	e0b5      	b.n	8000c0c <__aeabi_fadd+0x2dc>
 8000aa0:	2cff      	cmp	r4, #255	; 0xff
 8000aa2:	d15d      	bne.n	8000b60 <__aeabi_fadd+0x230>
 8000aa4:	464d      	mov	r5, r9
 8000aa6:	46c4      	mov	ip, r8
 8000aa8:	e7e6      	b.n	8000a78 <__aeabi_fadd+0x148>
 8000aaa:	2900      	cmp	r1, #0
 8000aac:	d020      	beq.n	8000af0 <__aeabi_fadd+0x1c0>
 8000aae:	3f01      	subs	r7, #1
 8000ab0:	1843      	adds	r3, r0, r1
 8000ab2:	2f00      	cmp	r7, #0
 8000ab4:	d0ca      	beq.n	8000a4c <__aeabi_fadd+0x11c>
 8000ab6:	2eff      	cmp	r6, #255	; 0xff
 8000ab8:	d1bc      	bne.n	8000a34 <__aeabi_fadd+0x104>
 8000aba:	e7dd      	b.n	8000a78 <__aeabi_fadd+0x148>
 8000abc:	2f00      	cmp	r7, #0
 8000abe:	d132      	bne.n	8000b26 <__aeabi_fadd+0x1f6>
 8000ac0:	24fe      	movs	r4, #254	; 0xfe
 8000ac2:	3601      	adds	r6, #1
 8000ac4:	4234      	tst	r4, r6
 8000ac6:	d17a      	bne.n	8000bbe <__aeabi_fadd+0x28e>
 8000ac8:	2a00      	cmp	r2, #0
 8000aca:	d162      	bne.n	8000b92 <__aeabi_fadd+0x262>
 8000acc:	2800      	cmp	r0, #0
 8000ace:	d100      	bne.n	8000ad2 <__aeabi_fadd+0x1a2>
 8000ad0:	e0a0      	b.n	8000c14 <__aeabi_fadd+0x2e4>
 8000ad2:	2900      	cmp	r1, #0
 8000ad4:	d100      	bne.n	8000ad8 <__aeabi_fadd+0x1a8>
 8000ad6:	e784      	b.n	80009e2 <__aeabi_fadd+0xb2>
 8000ad8:	1843      	adds	r3, r0, r1
 8000ada:	2600      	movs	r6, #0
 8000adc:	015a      	lsls	r2, r3, #5
 8000ade:	d502      	bpl.n	8000ae6 <__aeabi_fadd+0x1b6>
 8000ae0:	4a50      	ldr	r2, [pc, #320]	; (8000c24 <__aeabi_fadd+0x2f4>)
 8000ae2:	3601      	adds	r6, #1
 8000ae4:	4013      	ands	r3, r2
 8000ae6:	075a      	lsls	r2, r3, #29
 8000ae8:	d000      	beq.n	8000aec <__aeabi_fadd+0x1bc>
 8000aea:	e76b      	b.n	80009c4 <__aeabi_fadd+0x94>
 8000aec:	08db      	lsrs	r3, r3, #3
 8000aee:	469c      	mov	ip, r3
 8000af0:	2eff      	cmp	r6, #255	; 0xff
 8000af2:	d0c1      	beq.n	8000a78 <__aeabi_fadd+0x148>
 8000af4:	4663      	mov	r3, ip
 8000af6:	025b      	lsls	r3, r3, #9
 8000af8:	0a5b      	lsrs	r3, r3, #9
 8000afa:	b2f2      	uxtb	r2, r6
 8000afc:	e771      	b.n	80009e2 <__aeabi_fadd+0xb2>
 8000afe:	22ff      	movs	r2, #255	; 0xff
 8000b00:	2300      	movs	r3, #0
 8000b02:	e76e      	b.n	80009e2 <__aeabi_fadd+0xb2>
 8000b04:	4b47      	ldr	r3, [pc, #284]	; (8000c24 <__aeabi_fadd+0x2f4>)
 8000b06:	1a36      	subs	r6, r6, r0
 8000b08:	4023      	ands	r3, r4
 8000b0a:	075a      	lsls	r2, r3, #29
 8000b0c:	d000      	beq.n	8000b10 <__aeabi_fadd+0x1e0>
 8000b0e:	e759      	b.n	80009c4 <__aeabi_fadd+0x94>
 8000b10:	e7ec      	b.n	8000aec <__aeabi_fadd+0x1bc>
 8000b12:	1a44      	subs	r4, r0, r1
 8000b14:	0163      	lsls	r3, r4, #5
 8000b16:	d461      	bmi.n	8000bdc <__aeabi_fadd+0x2ac>
 8000b18:	2c00      	cmp	r4, #0
 8000b1a:	d000      	beq.n	8000b1e <__aeabi_fadd+0x1ee>
 8000b1c:	e73c      	b.n	8000998 <__aeabi_fadd+0x68>
 8000b1e:	2500      	movs	r5, #0
 8000b20:	2200      	movs	r2, #0
 8000b22:	2300      	movs	r3, #0
 8000b24:	e75d      	b.n	80009e2 <__aeabi_fadd+0xb2>
 8000b26:	1ba2      	subs	r2, r4, r6
 8000b28:	2e00      	cmp	r6, #0
 8000b2a:	d128      	bne.n	8000b7e <__aeabi_fadd+0x24e>
 8000b2c:	2800      	cmp	r0, #0
 8000b2e:	d02d      	beq.n	8000b8c <__aeabi_fadd+0x25c>
 8000b30:	3a01      	subs	r2, #1
 8000b32:	2a00      	cmp	r2, #0
 8000b34:	d070      	beq.n	8000c18 <__aeabi_fadd+0x2e8>
 8000b36:	2cff      	cmp	r4, #255	; 0xff
 8000b38:	d0b5      	beq.n	8000aa6 <__aeabi_fadd+0x176>
 8000b3a:	2301      	movs	r3, #1
 8000b3c:	2a1b      	cmp	r2, #27
 8000b3e:	dc07      	bgt.n	8000b50 <__aeabi_fadd+0x220>
 8000b40:	0003      	movs	r3, r0
 8000b42:	2620      	movs	r6, #32
 8000b44:	40d3      	lsrs	r3, r2
 8000b46:	1ab2      	subs	r2, r6, r2
 8000b48:	4090      	lsls	r0, r2
 8000b4a:	1e42      	subs	r2, r0, #1
 8000b4c:	4190      	sbcs	r0, r2
 8000b4e:	4303      	orrs	r3, r0
 8000b50:	185b      	adds	r3, r3, r1
 8000b52:	0026      	movs	r6, r4
 8000b54:	e77a      	b.n	8000a4c <__aeabi_fadd+0x11c>
 8000b56:	2cff      	cmp	r4, #255	; 0xff
 8000b58:	d0a4      	beq.n	8000aa4 <__aeabi_fadd+0x174>
 8000b5a:	2380      	movs	r3, #128	; 0x80
 8000b5c:	04db      	lsls	r3, r3, #19
 8000b5e:	4318      	orrs	r0, r3
 8000b60:	2301      	movs	r3, #1
 8000b62:	2a1b      	cmp	r2, #27
 8000b64:	dc07      	bgt.n	8000b76 <__aeabi_fadd+0x246>
 8000b66:	0003      	movs	r3, r0
 8000b68:	2520      	movs	r5, #32
 8000b6a:	40d3      	lsrs	r3, r2
 8000b6c:	1aaa      	subs	r2, r5, r2
 8000b6e:	4090      	lsls	r0, r2
 8000b70:	1e42      	subs	r2, r0, #1
 8000b72:	4190      	sbcs	r0, r2
 8000b74:	4303      	orrs	r3, r0
 8000b76:	1acb      	subs	r3, r1, r3
 8000b78:	464d      	mov	r5, r9
 8000b7a:	0026      	movs	r6, r4
 8000b7c:	e707      	b.n	800098e <__aeabi_fadd+0x5e>
 8000b7e:	2cff      	cmp	r4, #255	; 0xff
 8000b80:	d091      	beq.n	8000aa6 <__aeabi_fadd+0x176>
 8000b82:	2380      	movs	r3, #128	; 0x80
 8000b84:	04db      	lsls	r3, r3, #19
 8000b86:	4318      	orrs	r0, r3
 8000b88:	e7d7      	b.n	8000b3a <__aeabi_fadd+0x20a>
 8000b8a:	464d      	mov	r5, r9
 8000b8c:	46c4      	mov	ip, r8
 8000b8e:	0026      	movs	r6, r4
 8000b90:	e7ae      	b.n	8000af0 <__aeabi_fadd+0x1c0>
 8000b92:	2800      	cmp	r0, #0
 8000b94:	d087      	beq.n	8000aa6 <__aeabi_fadd+0x176>
 8000b96:	2900      	cmp	r1, #0
 8000b98:	d100      	bne.n	8000b9c <__aeabi_fadd+0x26c>
 8000b9a:	e76d      	b.n	8000a78 <__aeabi_fadd+0x148>
 8000b9c:	2380      	movs	r3, #128	; 0x80
 8000b9e:	4662      	mov	r2, ip
 8000ba0:	03db      	lsls	r3, r3, #15
 8000ba2:	421a      	tst	r2, r3
 8000ba4:	d100      	bne.n	8000ba8 <__aeabi_fadd+0x278>
 8000ba6:	e767      	b.n	8000a78 <__aeabi_fadd+0x148>
 8000ba8:	4642      	mov	r2, r8
 8000baa:	421a      	tst	r2, r3
 8000bac:	d000      	beq.n	8000bb0 <__aeabi_fadd+0x280>
 8000bae:	e763      	b.n	8000a78 <__aeabi_fadd+0x148>
 8000bb0:	46c4      	mov	ip, r8
 8000bb2:	e761      	b.n	8000a78 <__aeabi_fadd+0x148>
 8000bb4:	2900      	cmp	r1, #0
 8000bb6:	d026      	beq.n	8000c06 <__aeabi_fadd+0x2d6>
 8000bb8:	464d      	mov	r5, r9
 8000bba:	4643      	mov	r3, r8
 8000bbc:	e711      	b.n	80009e2 <__aeabi_fadd+0xb2>
 8000bbe:	2eff      	cmp	r6, #255	; 0xff
 8000bc0:	d09d      	beq.n	8000afe <__aeabi_fadd+0x1ce>
 8000bc2:	1843      	adds	r3, r0, r1
 8000bc4:	085b      	lsrs	r3, r3, #1
 8000bc6:	e78e      	b.n	8000ae6 <__aeabi_fadd+0x1b6>
 8000bc8:	2800      	cmp	r0, #0
 8000bca:	d10a      	bne.n	8000be2 <__aeabi_fadd+0x2b2>
 8000bcc:	2900      	cmp	r1, #0
 8000bce:	d000      	beq.n	8000bd2 <__aeabi_fadd+0x2a2>
 8000bd0:	e768      	b.n	8000aa4 <__aeabi_fadd+0x174>
 8000bd2:	2380      	movs	r3, #128	; 0x80
 8000bd4:	2500      	movs	r5, #0
 8000bd6:	03db      	lsls	r3, r3, #15
 8000bd8:	22ff      	movs	r2, #255	; 0xff
 8000bda:	e702      	b.n	80009e2 <__aeabi_fadd+0xb2>
 8000bdc:	1a0c      	subs	r4, r1, r0
 8000bde:	464d      	mov	r5, r9
 8000be0:	e6da      	b.n	8000998 <__aeabi_fadd+0x68>
 8000be2:	2900      	cmp	r1, #0
 8000be4:	d100      	bne.n	8000be8 <__aeabi_fadd+0x2b8>
 8000be6:	e747      	b.n	8000a78 <__aeabi_fadd+0x148>
 8000be8:	2380      	movs	r3, #128	; 0x80
 8000bea:	4662      	mov	r2, ip
 8000bec:	03db      	lsls	r3, r3, #15
 8000bee:	421a      	tst	r2, r3
 8000bf0:	d100      	bne.n	8000bf4 <__aeabi_fadd+0x2c4>
 8000bf2:	e741      	b.n	8000a78 <__aeabi_fadd+0x148>
 8000bf4:	4642      	mov	r2, r8
 8000bf6:	421a      	tst	r2, r3
 8000bf8:	d000      	beq.n	8000bfc <__aeabi_fadd+0x2cc>
 8000bfa:	e73d      	b.n	8000a78 <__aeabi_fadd+0x148>
 8000bfc:	464d      	mov	r5, r9
 8000bfe:	e752      	b.n	8000aa6 <__aeabi_fadd+0x176>
 8000c00:	2b00      	cmp	r3, #0
 8000c02:	d000      	beq.n	8000c06 <__aeabi_fadd+0x2d6>
 8000c04:	e76f      	b.n	8000ae6 <__aeabi_fadd+0x1b6>
 8000c06:	2500      	movs	r5, #0
 8000c08:	2300      	movs	r3, #0
 8000c0a:	e6ea      	b.n	80009e2 <__aeabi_fadd+0xb2>
 8000c0c:	1a0b      	subs	r3, r1, r0
 8000c0e:	464d      	mov	r5, r9
 8000c10:	0026      	movs	r6, r4
 8000c12:	e6bc      	b.n	800098e <__aeabi_fadd+0x5e>
 8000c14:	4643      	mov	r3, r8
 8000c16:	e6e4      	b.n	80009e2 <__aeabi_fadd+0xb2>
 8000c18:	1843      	adds	r3, r0, r1
 8000c1a:	0026      	movs	r6, r4
 8000c1c:	e716      	b.n	8000a4c <__aeabi_fadd+0x11c>
 8000c1e:	46c0      	nop			; (mov r8, r8)
 8000c20:	7dffffff 	.word	0x7dffffff
 8000c24:	fbffffff 	.word	0xfbffffff
	...

08000c30 <__aeabi_fdiv>:
 8000c30:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000c32:	464f      	mov	r7, r9
 8000c34:	4646      	mov	r6, r8
 8000c36:	46d6      	mov	lr, sl
 8000c38:	0244      	lsls	r4, r0, #9
 8000c3a:	0045      	lsls	r5, r0, #1
 8000c3c:	b5c0      	push	{r6, r7, lr}
 8000c3e:	0a64      	lsrs	r4, r4, #9
 8000c40:	1c0f      	adds	r7, r1, #0
 8000c42:	0e2d      	lsrs	r5, r5, #24
 8000c44:	0fc6      	lsrs	r6, r0, #31
 8000c46:	2d00      	cmp	r5, #0
 8000c48:	d04f      	beq.n	8000cea <__aeabi_fdiv+0xba>
 8000c4a:	2dff      	cmp	r5, #255	; 0xff
 8000c4c:	d055      	beq.n	8000cfa <__aeabi_fdiv+0xca>
 8000c4e:	2380      	movs	r3, #128	; 0x80
 8000c50:	00e4      	lsls	r4, r4, #3
 8000c52:	04db      	lsls	r3, r3, #19
 8000c54:	431c      	orrs	r4, r3
 8000c56:	2300      	movs	r3, #0
 8000c58:	4699      	mov	r9, r3
 8000c5a:	469a      	mov	sl, r3
 8000c5c:	3d7f      	subs	r5, #127	; 0x7f
 8000c5e:	027b      	lsls	r3, r7, #9
 8000c60:	0078      	lsls	r0, r7, #1
 8000c62:	0a5b      	lsrs	r3, r3, #9
 8000c64:	4698      	mov	r8, r3
 8000c66:	0e00      	lsrs	r0, r0, #24
 8000c68:	0fff      	lsrs	r7, r7, #31
 8000c6a:	2800      	cmp	r0, #0
 8000c6c:	d031      	beq.n	8000cd2 <__aeabi_fdiv+0xa2>
 8000c6e:	28ff      	cmp	r0, #255	; 0xff
 8000c70:	d010      	beq.n	8000c94 <__aeabi_fdiv+0x64>
 8000c72:	2280      	movs	r2, #128	; 0x80
 8000c74:	00db      	lsls	r3, r3, #3
 8000c76:	04d2      	lsls	r2, r2, #19
 8000c78:	431a      	orrs	r2, r3
 8000c7a:	4690      	mov	r8, r2
 8000c7c:	2100      	movs	r1, #0
 8000c7e:	387f      	subs	r0, #127	; 0x7f
 8000c80:	1a2d      	subs	r5, r5, r0
 8000c82:	464b      	mov	r3, r9
 8000c84:	0032      	movs	r2, r6
 8000c86:	430b      	orrs	r3, r1
 8000c88:	4871      	ldr	r0, [pc, #452]	; (8000e50 <__aeabi_fdiv+0x220>)
 8000c8a:	009b      	lsls	r3, r3, #2
 8000c8c:	58c3      	ldr	r3, [r0, r3]
 8000c8e:	407a      	eors	r2, r7
 8000c90:	b2d2      	uxtb	r2, r2
 8000c92:	469f      	mov	pc, r3
 8000c94:	3dff      	subs	r5, #255	; 0xff
 8000c96:	2b00      	cmp	r3, #0
 8000c98:	d154      	bne.n	8000d44 <__aeabi_fdiv+0x114>
 8000c9a:	2302      	movs	r3, #2
 8000c9c:	4649      	mov	r1, r9
 8000c9e:	4319      	orrs	r1, r3
 8000ca0:	0032      	movs	r2, r6
 8000ca2:	000b      	movs	r3, r1
 8000ca4:	407a      	eors	r2, r7
 8000ca6:	3b03      	subs	r3, #3
 8000ca8:	b2d2      	uxtb	r2, r2
 8000caa:	2b0c      	cmp	r3, #12
 8000cac:	d804      	bhi.n	8000cb8 <__aeabi_fdiv+0x88>
 8000cae:	4969      	ldr	r1, [pc, #420]	; (8000e54 <__aeabi_fdiv+0x224>)
 8000cb0:	009b      	lsls	r3, r3, #2
 8000cb2:	58cb      	ldr	r3, [r1, r3]
 8000cb4:	469f      	mov	pc, r3
 8000cb6:	003a      	movs	r2, r7
 8000cb8:	2000      	movs	r0, #0
 8000cba:	2400      	movs	r4, #0
 8000cbc:	0264      	lsls	r4, r4, #9
 8000cbe:	05c3      	lsls	r3, r0, #23
 8000cc0:	0a60      	lsrs	r0, r4, #9
 8000cc2:	07d2      	lsls	r2, r2, #31
 8000cc4:	4318      	orrs	r0, r3
 8000cc6:	4310      	orrs	r0, r2
 8000cc8:	bc1c      	pop	{r2, r3, r4}
 8000cca:	4690      	mov	r8, r2
 8000ccc:	4699      	mov	r9, r3
 8000cce:	46a2      	mov	sl, r4
 8000cd0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000cd2:	2b00      	cmp	r3, #0
 8000cd4:	d12b      	bne.n	8000d2e <__aeabi_fdiv+0xfe>
 8000cd6:	2301      	movs	r3, #1
 8000cd8:	4649      	mov	r1, r9
 8000cda:	0032      	movs	r2, r6
 8000cdc:	4319      	orrs	r1, r3
 8000cde:	008b      	lsls	r3, r1, #2
 8000ce0:	495d      	ldr	r1, [pc, #372]	; (8000e58 <__aeabi_fdiv+0x228>)
 8000ce2:	407a      	eors	r2, r7
 8000ce4:	58cb      	ldr	r3, [r1, r3]
 8000ce6:	b2d2      	uxtb	r2, r2
 8000ce8:	469f      	mov	pc, r3
 8000cea:	2c00      	cmp	r4, #0
 8000cec:	d113      	bne.n	8000d16 <__aeabi_fdiv+0xe6>
 8000cee:	2304      	movs	r3, #4
 8000cf0:	4699      	mov	r9, r3
 8000cf2:	3b03      	subs	r3, #3
 8000cf4:	2500      	movs	r5, #0
 8000cf6:	469a      	mov	sl, r3
 8000cf8:	e7b1      	b.n	8000c5e <__aeabi_fdiv+0x2e>
 8000cfa:	2c00      	cmp	r4, #0
 8000cfc:	d105      	bne.n	8000d0a <__aeabi_fdiv+0xda>
 8000cfe:	2308      	movs	r3, #8
 8000d00:	4699      	mov	r9, r3
 8000d02:	3b06      	subs	r3, #6
 8000d04:	25ff      	movs	r5, #255	; 0xff
 8000d06:	469a      	mov	sl, r3
 8000d08:	e7a9      	b.n	8000c5e <__aeabi_fdiv+0x2e>
 8000d0a:	230c      	movs	r3, #12
 8000d0c:	4699      	mov	r9, r3
 8000d0e:	3b09      	subs	r3, #9
 8000d10:	25ff      	movs	r5, #255	; 0xff
 8000d12:	469a      	mov	sl, r3
 8000d14:	e7a3      	b.n	8000c5e <__aeabi_fdiv+0x2e>
 8000d16:	0020      	movs	r0, r4
 8000d18:	f002 fc42 	bl	80035a0 <__clzsi2>
 8000d1c:	2576      	movs	r5, #118	; 0x76
 8000d1e:	1f43      	subs	r3, r0, #5
 8000d20:	409c      	lsls	r4, r3
 8000d22:	2300      	movs	r3, #0
 8000d24:	426d      	negs	r5, r5
 8000d26:	1a2d      	subs	r5, r5, r0
 8000d28:	4699      	mov	r9, r3
 8000d2a:	469a      	mov	sl, r3
 8000d2c:	e797      	b.n	8000c5e <__aeabi_fdiv+0x2e>
 8000d2e:	0018      	movs	r0, r3
 8000d30:	f002 fc36 	bl	80035a0 <__clzsi2>
 8000d34:	4642      	mov	r2, r8
 8000d36:	1f43      	subs	r3, r0, #5
 8000d38:	409a      	lsls	r2, r3
 8000d3a:	182d      	adds	r5, r5, r0
 8000d3c:	4690      	mov	r8, r2
 8000d3e:	3576      	adds	r5, #118	; 0x76
 8000d40:	2100      	movs	r1, #0
 8000d42:	e79e      	b.n	8000c82 <__aeabi_fdiv+0x52>
 8000d44:	2103      	movs	r1, #3
 8000d46:	e79c      	b.n	8000c82 <__aeabi_fdiv+0x52>
 8000d48:	0017      	movs	r7, r2
 8000d4a:	003a      	movs	r2, r7
 8000d4c:	20ff      	movs	r0, #255	; 0xff
 8000d4e:	2400      	movs	r4, #0
 8000d50:	e7b4      	b.n	8000cbc <__aeabi_fdiv+0x8c>
 8000d52:	2480      	movs	r4, #128	; 0x80
 8000d54:	2200      	movs	r2, #0
 8000d56:	03e4      	lsls	r4, r4, #15
 8000d58:	20ff      	movs	r0, #255	; 0xff
 8000d5a:	e7af      	b.n	8000cbc <__aeabi_fdiv+0x8c>
 8000d5c:	0032      	movs	r2, r6
 8000d5e:	4653      	mov	r3, sl
 8000d60:	2b02      	cmp	r3, #2
 8000d62:	d0f1      	beq.n	8000d48 <__aeabi_fdiv+0x118>
 8000d64:	2b03      	cmp	r3, #3
 8000d66:	d06c      	beq.n	8000e42 <__aeabi_fdiv+0x212>
 8000d68:	2b01      	cmp	r3, #1
 8000d6a:	d0a5      	beq.n	8000cb8 <__aeabi_fdiv+0x88>
 8000d6c:	0028      	movs	r0, r5
 8000d6e:	307f      	adds	r0, #127	; 0x7f
 8000d70:	2800      	cmp	r0, #0
 8000d72:	dd46      	ble.n	8000e02 <__aeabi_fdiv+0x1d2>
 8000d74:	0763      	lsls	r3, r4, #29
 8000d76:	d004      	beq.n	8000d82 <__aeabi_fdiv+0x152>
 8000d78:	230f      	movs	r3, #15
 8000d7a:	4023      	ands	r3, r4
 8000d7c:	2b04      	cmp	r3, #4
 8000d7e:	d000      	beq.n	8000d82 <__aeabi_fdiv+0x152>
 8000d80:	3404      	adds	r4, #4
 8000d82:	0123      	lsls	r3, r4, #4
 8000d84:	d503      	bpl.n	8000d8e <__aeabi_fdiv+0x15e>
 8000d86:	0028      	movs	r0, r5
 8000d88:	4b34      	ldr	r3, [pc, #208]	; (8000e5c <__aeabi_fdiv+0x22c>)
 8000d8a:	3080      	adds	r0, #128	; 0x80
 8000d8c:	401c      	ands	r4, r3
 8000d8e:	28fe      	cmp	r0, #254	; 0xfe
 8000d90:	dcdc      	bgt.n	8000d4c <__aeabi_fdiv+0x11c>
 8000d92:	01a4      	lsls	r4, r4, #6
 8000d94:	0a64      	lsrs	r4, r4, #9
 8000d96:	b2c0      	uxtb	r0, r0
 8000d98:	e790      	b.n	8000cbc <__aeabi_fdiv+0x8c>
 8000d9a:	2380      	movs	r3, #128	; 0x80
 8000d9c:	03db      	lsls	r3, r3, #15
 8000d9e:	421c      	tst	r4, r3
 8000da0:	d027      	beq.n	8000df2 <__aeabi_fdiv+0x1c2>
 8000da2:	4642      	mov	r2, r8
 8000da4:	421a      	tst	r2, r3
 8000da6:	d124      	bne.n	8000df2 <__aeabi_fdiv+0x1c2>
 8000da8:	4644      	mov	r4, r8
 8000daa:	431c      	orrs	r4, r3
 8000dac:	0264      	lsls	r4, r4, #9
 8000dae:	0a64      	lsrs	r4, r4, #9
 8000db0:	003a      	movs	r2, r7
 8000db2:	20ff      	movs	r0, #255	; 0xff
 8000db4:	e782      	b.n	8000cbc <__aeabi_fdiv+0x8c>
 8000db6:	003a      	movs	r2, r7
 8000db8:	4644      	mov	r4, r8
 8000dba:	468a      	mov	sl, r1
 8000dbc:	e7cf      	b.n	8000d5e <__aeabi_fdiv+0x12e>
 8000dbe:	4641      	mov	r1, r8
 8000dc0:	0163      	lsls	r3, r4, #5
 8000dc2:	014c      	lsls	r4, r1, #5
 8000dc4:	42a3      	cmp	r3, r4
 8000dc6:	d235      	bcs.n	8000e34 <__aeabi_fdiv+0x204>
 8000dc8:	201b      	movs	r0, #27
 8000dca:	2100      	movs	r1, #0
 8000dcc:	3d01      	subs	r5, #1
 8000dce:	2701      	movs	r7, #1
 8000dd0:	001e      	movs	r6, r3
 8000dd2:	0049      	lsls	r1, r1, #1
 8000dd4:	005b      	lsls	r3, r3, #1
 8000dd6:	2e00      	cmp	r6, #0
 8000dd8:	db01      	blt.n	8000dde <__aeabi_fdiv+0x1ae>
 8000dda:	429c      	cmp	r4, r3
 8000ddc:	d801      	bhi.n	8000de2 <__aeabi_fdiv+0x1b2>
 8000dde:	1b1b      	subs	r3, r3, r4
 8000de0:	4339      	orrs	r1, r7
 8000de2:	3801      	subs	r0, #1
 8000de4:	2800      	cmp	r0, #0
 8000de6:	d1f3      	bne.n	8000dd0 <__aeabi_fdiv+0x1a0>
 8000de8:	001c      	movs	r4, r3
 8000dea:	1e63      	subs	r3, r4, #1
 8000dec:	419c      	sbcs	r4, r3
 8000dee:	430c      	orrs	r4, r1
 8000df0:	e7bc      	b.n	8000d6c <__aeabi_fdiv+0x13c>
 8000df2:	2380      	movs	r3, #128	; 0x80
 8000df4:	03db      	lsls	r3, r3, #15
 8000df6:	431c      	orrs	r4, r3
 8000df8:	0264      	lsls	r4, r4, #9
 8000dfa:	0a64      	lsrs	r4, r4, #9
 8000dfc:	0032      	movs	r2, r6
 8000dfe:	20ff      	movs	r0, #255	; 0xff
 8000e00:	e75c      	b.n	8000cbc <__aeabi_fdiv+0x8c>
 8000e02:	2301      	movs	r3, #1
 8000e04:	1a18      	subs	r0, r3, r0
 8000e06:	281b      	cmp	r0, #27
 8000e08:	dd00      	ble.n	8000e0c <__aeabi_fdiv+0x1dc>
 8000e0a:	e755      	b.n	8000cb8 <__aeabi_fdiv+0x88>
 8000e0c:	359e      	adds	r5, #158	; 0x9e
 8000e0e:	0023      	movs	r3, r4
 8000e10:	40ac      	lsls	r4, r5
 8000e12:	40c3      	lsrs	r3, r0
 8000e14:	1e61      	subs	r1, r4, #1
 8000e16:	418c      	sbcs	r4, r1
 8000e18:	431c      	orrs	r4, r3
 8000e1a:	0763      	lsls	r3, r4, #29
 8000e1c:	d004      	beq.n	8000e28 <__aeabi_fdiv+0x1f8>
 8000e1e:	230f      	movs	r3, #15
 8000e20:	4023      	ands	r3, r4
 8000e22:	2b04      	cmp	r3, #4
 8000e24:	d000      	beq.n	8000e28 <__aeabi_fdiv+0x1f8>
 8000e26:	3404      	adds	r4, #4
 8000e28:	0163      	lsls	r3, r4, #5
 8000e2a:	d407      	bmi.n	8000e3c <__aeabi_fdiv+0x20c>
 8000e2c:	01a4      	lsls	r4, r4, #6
 8000e2e:	0a64      	lsrs	r4, r4, #9
 8000e30:	2000      	movs	r0, #0
 8000e32:	e743      	b.n	8000cbc <__aeabi_fdiv+0x8c>
 8000e34:	1b1b      	subs	r3, r3, r4
 8000e36:	201a      	movs	r0, #26
 8000e38:	2101      	movs	r1, #1
 8000e3a:	e7c8      	b.n	8000dce <__aeabi_fdiv+0x19e>
 8000e3c:	2001      	movs	r0, #1
 8000e3e:	2400      	movs	r4, #0
 8000e40:	e73c      	b.n	8000cbc <__aeabi_fdiv+0x8c>
 8000e42:	2380      	movs	r3, #128	; 0x80
 8000e44:	03db      	lsls	r3, r3, #15
 8000e46:	431c      	orrs	r4, r3
 8000e48:	0264      	lsls	r4, r4, #9
 8000e4a:	0a64      	lsrs	r4, r4, #9
 8000e4c:	20ff      	movs	r0, #255	; 0xff
 8000e4e:	e735      	b.n	8000cbc <__aeabi_fdiv+0x8c>
 8000e50:	080133c0 	.word	0x080133c0
 8000e54:	08013400 	.word	0x08013400
 8000e58:	08013434 	.word	0x08013434
 8000e5c:	f7ffffff 	.word	0xf7ffffff

08000e60 <__eqsf2>:
 8000e60:	b570      	push	{r4, r5, r6, lr}
 8000e62:	0042      	lsls	r2, r0, #1
 8000e64:	024e      	lsls	r6, r1, #9
 8000e66:	004c      	lsls	r4, r1, #1
 8000e68:	0245      	lsls	r5, r0, #9
 8000e6a:	0a6d      	lsrs	r5, r5, #9
 8000e6c:	0e12      	lsrs	r2, r2, #24
 8000e6e:	0fc3      	lsrs	r3, r0, #31
 8000e70:	0a76      	lsrs	r6, r6, #9
 8000e72:	0e24      	lsrs	r4, r4, #24
 8000e74:	0fc9      	lsrs	r1, r1, #31
 8000e76:	2aff      	cmp	r2, #255	; 0xff
 8000e78:	d00f      	beq.n	8000e9a <__eqsf2+0x3a>
 8000e7a:	2cff      	cmp	r4, #255	; 0xff
 8000e7c:	d011      	beq.n	8000ea2 <__eqsf2+0x42>
 8000e7e:	2001      	movs	r0, #1
 8000e80:	42a2      	cmp	r2, r4
 8000e82:	d000      	beq.n	8000e86 <__eqsf2+0x26>
 8000e84:	bd70      	pop	{r4, r5, r6, pc}
 8000e86:	42b5      	cmp	r5, r6
 8000e88:	d1fc      	bne.n	8000e84 <__eqsf2+0x24>
 8000e8a:	428b      	cmp	r3, r1
 8000e8c:	d00d      	beq.n	8000eaa <__eqsf2+0x4a>
 8000e8e:	2a00      	cmp	r2, #0
 8000e90:	d1f8      	bne.n	8000e84 <__eqsf2+0x24>
 8000e92:	0028      	movs	r0, r5
 8000e94:	1e45      	subs	r5, r0, #1
 8000e96:	41a8      	sbcs	r0, r5
 8000e98:	e7f4      	b.n	8000e84 <__eqsf2+0x24>
 8000e9a:	2001      	movs	r0, #1
 8000e9c:	2d00      	cmp	r5, #0
 8000e9e:	d1f1      	bne.n	8000e84 <__eqsf2+0x24>
 8000ea0:	e7eb      	b.n	8000e7a <__eqsf2+0x1a>
 8000ea2:	2001      	movs	r0, #1
 8000ea4:	2e00      	cmp	r6, #0
 8000ea6:	d1ed      	bne.n	8000e84 <__eqsf2+0x24>
 8000ea8:	e7e9      	b.n	8000e7e <__eqsf2+0x1e>
 8000eaa:	2000      	movs	r0, #0
 8000eac:	e7ea      	b.n	8000e84 <__eqsf2+0x24>
 8000eae:	46c0      	nop			; (mov r8, r8)

08000eb0 <__gesf2>:
 8000eb0:	b570      	push	{r4, r5, r6, lr}
 8000eb2:	004a      	lsls	r2, r1, #1
 8000eb4:	024e      	lsls	r6, r1, #9
 8000eb6:	0245      	lsls	r5, r0, #9
 8000eb8:	0044      	lsls	r4, r0, #1
 8000eba:	0a6d      	lsrs	r5, r5, #9
 8000ebc:	0e24      	lsrs	r4, r4, #24
 8000ebe:	0fc3      	lsrs	r3, r0, #31
 8000ec0:	0a76      	lsrs	r6, r6, #9
 8000ec2:	0e12      	lsrs	r2, r2, #24
 8000ec4:	0fc9      	lsrs	r1, r1, #31
 8000ec6:	2cff      	cmp	r4, #255	; 0xff
 8000ec8:	d015      	beq.n	8000ef6 <__gesf2+0x46>
 8000eca:	2aff      	cmp	r2, #255	; 0xff
 8000ecc:	d00e      	beq.n	8000eec <__gesf2+0x3c>
 8000ece:	2c00      	cmp	r4, #0
 8000ed0:	d115      	bne.n	8000efe <__gesf2+0x4e>
 8000ed2:	2a00      	cmp	r2, #0
 8000ed4:	d101      	bne.n	8000eda <__gesf2+0x2a>
 8000ed6:	2e00      	cmp	r6, #0
 8000ed8:	d01c      	beq.n	8000f14 <__gesf2+0x64>
 8000eda:	2d00      	cmp	r5, #0
 8000edc:	d014      	beq.n	8000f08 <__gesf2+0x58>
 8000ede:	428b      	cmp	r3, r1
 8000ee0:	d027      	beq.n	8000f32 <__gesf2+0x82>
 8000ee2:	2002      	movs	r0, #2
 8000ee4:	3b01      	subs	r3, #1
 8000ee6:	4018      	ands	r0, r3
 8000ee8:	3801      	subs	r0, #1
 8000eea:	bd70      	pop	{r4, r5, r6, pc}
 8000eec:	2e00      	cmp	r6, #0
 8000eee:	d0ee      	beq.n	8000ece <__gesf2+0x1e>
 8000ef0:	2002      	movs	r0, #2
 8000ef2:	4240      	negs	r0, r0
 8000ef4:	e7f9      	b.n	8000eea <__gesf2+0x3a>
 8000ef6:	2d00      	cmp	r5, #0
 8000ef8:	d1fa      	bne.n	8000ef0 <__gesf2+0x40>
 8000efa:	2aff      	cmp	r2, #255	; 0xff
 8000efc:	d00e      	beq.n	8000f1c <__gesf2+0x6c>
 8000efe:	2a00      	cmp	r2, #0
 8000f00:	d10e      	bne.n	8000f20 <__gesf2+0x70>
 8000f02:	2e00      	cmp	r6, #0
 8000f04:	d0ed      	beq.n	8000ee2 <__gesf2+0x32>
 8000f06:	e00b      	b.n	8000f20 <__gesf2+0x70>
 8000f08:	2301      	movs	r3, #1
 8000f0a:	3901      	subs	r1, #1
 8000f0c:	4399      	bics	r1, r3
 8000f0e:	0008      	movs	r0, r1
 8000f10:	3001      	adds	r0, #1
 8000f12:	e7ea      	b.n	8000eea <__gesf2+0x3a>
 8000f14:	2000      	movs	r0, #0
 8000f16:	2d00      	cmp	r5, #0
 8000f18:	d0e7      	beq.n	8000eea <__gesf2+0x3a>
 8000f1a:	e7e2      	b.n	8000ee2 <__gesf2+0x32>
 8000f1c:	2e00      	cmp	r6, #0
 8000f1e:	d1e7      	bne.n	8000ef0 <__gesf2+0x40>
 8000f20:	428b      	cmp	r3, r1
 8000f22:	d1de      	bne.n	8000ee2 <__gesf2+0x32>
 8000f24:	4294      	cmp	r4, r2
 8000f26:	dd05      	ble.n	8000f34 <__gesf2+0x84>
 8000f28:	2102      	movs	r1, #2
 8000f2a:	1e58      	subs	r0, r3, #1
 8000f2c:	4008      	ands	r0, r1
 8000f2e:	3801      	subs	r0, #1
 8000f30:	e7db      	b.n	8000eea <__gesf2+0x3a>
 8000f32:	2400      	movs	r4, #0
 8000f34:	42a2      	cmp	r2, r4
 8000f36:	dc04      	bgt.n	8000f42 <__gesf2+0x92>
 8000f38:	42b5      	cmp	r5, r6
 8000f3a:	d8d2      	bhi.n	8000ee2 <__gesf2+0x32>
 8000f3c:	2000      	movs	r0, #0
 8000f3e:	42b5      	cmp	r5, r6
 8000f40:	d2d3      	bcs.n	8000eea <__gesf2+0x3a>
 8000f42:	1e58      	subs	r0, r3, #1
 8000f44:	2301      	movs	r3, #1
 8000f46:	4398      	bics	r0, r3
 8000f48:	3001      	adds	r0, #1
 8000f4a:	e7ce      	b.n	8000eea <__gesf2+0x3a>
 8000f4c:	0000      	movs	r0, r0
	...

08000f50 <__lesf2>:
 8000f50:	b530      	push	{r4, r5, lr}
 8000f52:	0042      	lsls	r2, r0, #1
 8000f54:	0244      	lsls	r4, r0, #9
 8000f56:	024d      	lsls	r5, r1, #9
 8000f58:	0fc3      	lsrs	r3, r0, #31
 8000f5a:	0048      	lsls	r0, r1, #1
 8000f5c:	0a64      	lsrs	r4, r4, #9
 8000f5e:	0e12      	lsrs	r2, r2, #24
 8000f60:	0a6d      	lsrs	r5, r5, #9
 8000f62:	0e00      	lsrs	r0, r0, #24
 8000f64:	0fc9      	lsrs	r1, r1, #31
 8000f66:	2aff      	cmp	r2, #255	; 0xff
 8000f68:	d017      	beq.n	8000f9a <__lesf2+0x4a>
 8000f6a:	28ff      	cmp	r0, #255	; 0xff
 8000f6c:	d008      	beq.n	8000f80 <__lesf2+0x30>
 8000f6e:	2a00      	cmp	r2, #0
 8000f70:	d117      	bne.n	8000fa2 <__lesf2+0x52>
 8000f72:	2800      	cmp	r0, #0
 8000f74:	d108      	bne.n	8000f88 <__lesf2+0x38>
 8000f76:	2d00      	cmp	r5, #0
 8000f78:	d106      	bne.n	8000f88 <__lesf2+0x38>
 8000f7a:	2c00      	cmp	r4, #0
 8000f7c:	d023      	beq.n	8000fc6 <__lesf2+0x76>
 8000f7e:	e007      	b.n	8000f90 <__lesf2+0x40>
 8000f80:	2d00      	cmp	r5, #0
 8000f82:	d0f4      	beq.n	8000f6e <__lesf2+0x1e>
 8000f84:	2002      	movs	r0, #2
 8000f86:	e01e      	b.n	8000fc6 <__lesf2+0x76>
 8000f88:	2c00      	cmp	r4, #0
 8000f8a:	d017      	beq.n	8000fbc <__lesf2+0x6c>
 8000f8c:	428b      	cmp	r3, r1
 8000f8e:	d01f      	beq.n	8000fd0 <__lesf2+0x80>
 8000f90:	2002      	movs	r0, #2
 8000f92:	3b01      	subs	r3, #1
 8000f94:	4018      	ands	r0, r3
 8000f96:	3801      	subs	r0, #1
 8000f98:	e015      	b.n	8000fc6 <__lesf2+0x76>
 8000f9a:	2c00      	cmp	r4, #0
 8000f9c:	d1f2      	bne.n	8000f84 <__lesf2+0x34>
 8000f9e:	28ff      	cmp	r0, #255	; 0xff
 8000fa0:	d012      	beq.n	8000fc8 <__lesf2+0x78>
 8000fa2:	2800      	cmp	r0, #0
 8000fa4:	d101      	bne.n	8000faa <__lesf2+0x5a>
 8000fa6:	2d00      	cmp	r5, #0
 8000fa8:	d0f2      	beq.n	8000f90 <__lesf2+0x40>
 8000faa:	428b      	cmp	r3, r1
 8000fac:	d1f0      	bne.n	8000f90 <__lesf2+0x40>
 8000fae:	4282      	cmp	r2, r0
 8000fb0:	dd0f      	ble.n	8000fd2 <__lesf2+0x82>
 8000fb2:	2102      	movs	r1, #2
 8000fb4:	1e58      	subs	r0, r3, #1
 8000fb6:	4008      	ands	r0, r1
 8000fb8:	3801      	subs	r0, #1
 8000fba:	e004      	b.n	8000fc6 <__lesf2+0x76>
 8000fbc:	2301      	movs	r3, #1
 8000fbe:	3901      	subs	r1, #1
 8000fc0:	4399      	bics	r1, r3
 8000fc2:	0008      	movs	r0, r1
 8000fc4:	3001      	adds	r0, #1
 8000fc6:	bd30      	pop	{r4, r5, pc}
 8000fc8:	2d00      	cmp	r5, #0
 8000fca:	d0ee      	beq.n	8000faa <__lesf2+0x5a>
 8000fcc:	2002      	movs	r0, #2
 8000fce:	e7fa      	b.n	8000fc6 <__lesf2+0x76>
 8000fd0:	2200      	movs	r2, #0
 8000fd2:	4290      	cmp	r0, r2
 8000fd4:	dc04      	bgt.n	8000fe0 <__lesf2+0x90>
 8000fd6:	42ac      	cmp	r4, r5
 8000fd8:	d8da      	bhi.n	8000f90 <__lesf2+0x40>
 8000fda:	2000      	movs	r0, #0
 8000fdc:	42ac      	cmp	r4, r5
 8000fde:	d2f2      	bcs.n	8000fc6 <__lesf2+0x76>
 8000fe0:	1e58      	subs	r0, r3, #1
 8000fe2:	2301      	movs	r3, #1
 8000fe4:	4398      	bics	r0, r3
 8000fe6:	3001      	adds	r0, #1
 8000fe8:	e7ed      	b.n	8000fc6 <__lesf2+0x76>
 8000fea:	46c0      	nop			; (mov r8, r8)
 8000fec:	0000      	movs	r0, r0
	...

08000ff0 <__aeabi_fmul>:
 8000ff0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000ff2:	464f      	mov	r7, r9
 8000ff4:	4646      	mov	r6, r8
 8000ff6:	46d6      	mov	lr, sl
 8000ff8:	0244      	lsls	r4, r0, #9
 8000ffa:	0045      	lsls	r5, r0, #1
 8000ffc:	b5c0      	push	{r6, r7, lr}
 8000ffe:	4688      	mov	r8, r1
 8001000:	0a64      	lsrs	r4, r4, #9
 8001002:	0e2d      	lsrs	r5, r5, #24
 8001004:	0fc7      	lsrs	r7, r0, #31
 8001006:	2d00      	cmp	r5, #0
 8001008:	d049      	beq.n	800109e <__aeabi_fmul+0xae>
 800100a:	2dff      	cmp	r5, #255	; 0xff
 800100c:	d04f      	beq.n	80010ae <__aeabi_fmul+0xbe>
 800100e:	2380      	movs	r3, #128	; 0x80
 8001010:	00e4      	lsls	r4, r4, #3
 8001012:	04db      	lsls	r3, r3, #19
 8001014:	431c      	orrs	r4, r3
 8001016:	2300      	movs	r3, #0
 8001018:	4699      	mov	r9, r3
 800101a:	469a      	mov	sl, r3
 800101c:	3d7f      	subs	r5, #127	; 0x7f
 800101e:	4643      	mov	r3, r8
 8001020:	4642      	mov	r2, r8
 8001022:	025e      	lsls	r6, r3, #9
 8001024:	0fd2      	lsrs	r2, r2, #31
 8001026:	005b      	lsls	r3, r3, #1
 8001028:	0a76      	lsrs	r6, r6, #9
 800102a:	0e1b      	lsrs	r3, r3, #24
 800102c:	4690      	mov	r8, r2
 800102e:	d046      	beq.n	80010be <__aeabi_fmul+0xce>
 8001030:	2bff      	cmp	r3, #255	; 0xff
 8001032:	d012      	beq.n	800105a <__aeabi_fmul+0x6a>
 8001034:	2280      	movs	r2, #128	; 0x80
 8001036:	2000      	movs	r0, #0
 8001038:	00f6      	lsls	r6, r6, #3
 800103a:	04d2      	lsls	r2, r2, #19
 800103c:	3b7f      	subs	r3, #127	; 0x7f
 800103e:	4316      	orrs	r6, r2
 8001040:	18ed      	adds	r5, r5, r3
 8001042:	1c6a      	adds	r2, r5, #1
 8001044:	4643      	mov	r3, r8
 8001046:	4694      	mov	ip, r2
 8001048:	464a      	mov	r2, r9
 800104a:	407b      	eors	r3, r7
 800104c:	2a0f      	cmp	r2, #15
 800104e:	d900      	bls.n	8001052 <__aeabi_fmul+0x62>
 8001050:	e074      	b.n	800113c <__aeabi_fmul+0x14c>
 8001052:	4970      	ldr	r1, [pc, #448]	; (8001214 <__aeabi_fmul+0x224>)
 8001054:	0092      	lsls	r2, r2, #2
 8001056:	588a      	ldr	r2, [r1, r2]
 8001058:	4697      	mov	pc, r2
 800105a:	35ff      	adds	r5, #255	; 0xff
 800105c:	2e00      	cmp	r6, #0
 800105e:	d154      	bne.n	800110a <__aeabi_fmul+0x11a>
 8001060:	464a      	mov	r2, r9
 8001062:	2302      	movs	r3, #2
 8001064:	431a      	orrs	r2, r3
 8001066:	4691      	mov	r9, r2
 8001068:	2002      	movs	r0, #2
 800106a:	e7ea      	b.n	8001042 <__aeabi_fmul+0x52>
 800106c:	4643      	mov	r3, r8
 800106e:	0034      	movs	r4, r6
 8001070:	4682      	mov	sl, r0
 8001072:	4652      	mov	r2, sl
 8001074:	2a02      	cmp	r2, #2
 8001076:	d02a      	beq.n	80010ce <__aeabi_fmul+0xde>
 8001078:	2a03      	cmp	r2, #3
 800107a:	d100      	bne.n	800107e <__aeabi_fmul+0x8e>
 800107c:	e0c3      	b.n	8001206 <__aeabi_fmul+0x216>
 800107e:	2a01      	cmp	r2, #1
 8001080:	d000      	beq.n	8001084 <__aeabi_fmul+0x94>
 8001082:	e082      	b.n	800118a <__aeabi_fmul+0x19a>
 8001084:	2200      	movs	r2, #0
 8001086:	2400      	movs	r4, #0
 8001088:	0264      	lsls	r4, r4, #9
 800108a:	05d2      	lsls	r2, r2, #23
 800108c:	0a60      	lsrs	r0, r4, #9
 800108e:	07db      	lsls	r3, r3, #31
 8001090:	4310      	orrs	r0, r2
 8001092:	4318      	orrs	r0, r3
 8001094:	bc1c      	pop	{r2, r3, r4}
 8001096:	4690      	mov	r8, r2
 8001098:	4699      	mov	r9, r3
 800109a:	46a2      	mov	sl, r4
 800109c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800109e:	2c00      	cmp	r4, #0
 80010a0:	d127      	bne.n	80010f2 <__aeabi_fmul+0x102>
 80010a2:	2304      	movs	r3, #4
 80010a4:	4699      	mov	r9, r3
 80010a6:	3b03      	subs	r3, #3
 80010a8:	2500      	movs	r5, #0
 80010aa:	469a      	mov	sl, r3
 80010ac:	e7b7      	b.n	800101e <__aeabi_fmul+0x2e>
 80010ae:	2c00      	cmp	r4, #0
 80010b0:	d119      	bne.n	80010e6 <__aeabi_fmul+0xf6>
 80010b2:	2308      	movs	r3, #8
 80010b4:	4699      	mov	r9, r3
 80010b6:	3b06      	subs	r3, #6
 80010b8:	25ff      	movs	r5, #255	; 0xff
 80010ba:	469a      	mov	sl, r3
 80010bc:	e7af      	b.n	800101e <__aeabi_fmul+0x2e>
 80010be:	2e00      	cmp	r6, #0
 80010c0:	d108      	bne.n	80010d4 <__aeabi_fmul+0xe4>
 80010c2:	464a      	mov	r2, r9
 80010c4:	2301      	movs	r3, #1
 80010c6:	431a      	orrs	r2, r3
 80010c8:	4691      	mov	r9, r2
 80010ca:	2001      	movs	r0, #1
 80010cc:	e7b9      	b.n	8001042 <__aeabi_fmul+0x52>
 80010ce:	22ff      	movs	r2, #255	; 0xff
 80010d0:	2400      	movs	r4, #0
 80010d2:	e7d9      	b.n	8001088 <__aeabi_fmul+0x98>
 80010d4:	0030      	movs	r0, r6
 80010d6:	f002 fa63 	bl	80035a0 <__clzsi2>
 80010da:	1f43      	subs	r3, r0, #5
 80010dc:	1a2d      	subs	r5, r5, r0
 80010de:	409e      	lsls	r6, r3
 80010e0:	3d76      	subs	r5, #118	; 0x76
 80010e2:	2000      	movs	r0, #0
 80010e4:	e7ad      	b.n	8001042 <__aeabi_fmul+0x52>
 80010e6:	230c      	movs	r3, #12
 80010e8:	4699      	mov	r9, r3
 80010ea:	3b09      	subs	r3, #9
 80010ec:	25ff      	movs	r5, #255	; 0xff
 80010ee:	469a      	mov	sl, r3
 80010f0:	e795      	b.n	800101e <__aeabi_fmul+0x2e>
 80010f2:	0020      	movs	r0, r4
 80010f4:	f002 fa54 	bl	80035a0 <__clzsi2>
 80010f8:	2576      	movs	r5, #118	; 0x76
 80010fa:	1f43      	subs	r3, r0, #5
 80010fc:	409c      	lsls	r4, r3
 80010fe:	2300      	movs	r3, #0
 8001100:	426d      	negs	r5, r5
 8001102:	1a2d      	subs	r5, r5, r0
 8001104:	4699      	mov	r9, r3
 8001106:	469a      	mov	sl, r3
 8001108:	e789      	b.n	800101e <__aeabi_fmul+0x2e>
 800110a:	464a      	mov	r2, r9
 800110c:	2303      	movs	r3, #3
 800110e:	431a      	orrs	r2, r3
 8001110:	4691      	mov	r9, r2
 8001112:	2003      	movs	r0, #3
 8001114:	e795      	b.n	8001042 <__aeabi_fmul+0x52>
 8001116:	003b      	movs	r3, r7
 8001118:	e7ab      	b.n	8001072 <__aeabi_fmul+0x82>
 800111a:	2480      	movs	r4, #128	; 0x80
 800111c:	2300      	movs	r3, #0
 800111e:	03e4      	lsls	r4, r4, #15
 8001120:	22ff      	movs	r2, #255	; 0xff
 8001122:	e7b1      	b.n	8001088 <__aeabi_fmul+0x98>
 8001124:	2380      	movs	r3, #128	; 0x80
 8001126:	03db      	lsls	r3, r3, #15
 8001128:	421c      	tst	r4, r3
 800112a:	d045      	beq.n	80011b8 <__aeabi_fmul+0x1c8>
 800112c:	421e      	tst	r6, r3
 800112e:	d143      	bne.n	80011b8 <__aeabi_fmul+0x1c8>
 8001130:	4333      	orrs	r3, r6
 8001132:	025c      	lsls	r4, r3, #9
 8001134:	0a64      	lsrs	r4, r4, #9
 8001136:	4643      	mov	r3, r8
 8001138:	22ff      	movs	r2, #255	; 0xff
 800113a:	e7a5      	b.n	8001088 <__aeabi_fmul+0x98>
 800113c:	0c20      	lsrs	r0, r4, #16
 800113e:	0424      	lsls	r4, r4, #16
 8001140:	0c21      	lsrs	r1, r4, #16
 8001142:	000f      	movs	r7, r1
 8001144:	0c32      	lsrs	r2, r6, #16
 8001146:	0436      	lsls	r6, r6, #16
 8001148:	0c36      	lsrs	r6, r6, #16
 800114a:	4377      	muls	r7, r6
 800114c:	4351      	muls	r1, r2
 800114e:	4346      	muls	r6, r0
 8001150:	4350      	muls	r0, r2
 8001152:	1989      	adds	r1, r1, r6
 8001154:	0c3a      	lsrs	r2, r7, #16
 8001156:	1852      	adds	r2, r2, r1
 8001158:	4296      	cmp	r6, r2
 800115a:	d903      	bls.n	8001164 <__aeabi_fmul+0x174>
 800115c:	2180      	movs	r1, #128	; 0x80
 800115e:	0249      	lsls	r1, r1, #9
 8001160:	4688      	mov	r8, r1
 8001162:	4440      	add	r0, r8
 8001164:	043f      	lsls	r7, r7, #16
 8001166:	0411      	lsls	r1, r2, #16
 8001168:	0c3f      	lsrs	r7, r7, #16
 800116a:	19c9      	adds	r1, r1, r7
 800116c:	018c      	lsls	r4, r1, #6
 800116e:	1e66      	subs	r6, r4, #1
 8001170:	41b4      	sbcs	r4, r6
 8001172:	0e89      	lsrs	r1, r1, #26
 8001174:	4321      	orrs	r1, r4
 8001176:	0c14      	lsrs	r4, r2, #16
 8001178:	1824      	adds	r4, r4, r0
 800117a:	01a4      	lsls	r4, r4, #6
 800117c:	430c      	orrs	r4, r1
 800117e:	0122      	lsls	r2, r4, #4
 8001180:	d53c      	bpl.n	80011fc <__aeabi_fmul+0x20c>
 8001182:	2201      	movs	r2, #1
 8001184:	0861      	lsrs	r1, r4, #1
 8001186:	4014      	ands	r4, r2
 8001188:	430c      	orrs	r4, r1
 800118a:	4660      	mov	r0, ip
 800118c:	307f      	adds	r0, #127	; 0x7f
 800118e:	2800      	cmp	r0, #0
 8001190:	dd1a      	ble.n	80011c8 <__aeabi_fmul+0x1d8>
 8001192:	0762      	lsls	r2, r4, #29
 8001194:	d004      	beq.n	80011a0 <__aeabi_fmul+0x1b0>
 8001196:	220f      	movs	r2, #15
 8001198:	4022      	ands	r2, r4
 800119a:	2a04      	cmp	r2, #4
 800119c:	d000      	beq.n	80011a0 <__aeabi_fmul+0x1b0>
 800119e:	3404      	adds	r4, #4
 80011a0:	0122      	lsls	r2, r4, #4
 80011a2:	d503      	bpl.n	80011ac <__aeabi_fmul+0x1bc>
 80011a4:	4660      	mov	r0, ip
 80011a6:	4a1c      	ldr	r2, [pc, #112]	; (8001218 <__aeabi_fmul+0x228>)
 80011a8:	3080      	adds	r0, #128	; 0x80
 80011aa:	4014      	ands	r4, r2
 80011ac:	28fe      	cmp	r0, #254	; 0xfe
 80011ae:	dc8e      	bgt.n	80010ce <__aeabi_fmul+0xde>
 80011b0:	01a4      	lsls	r4, r4, #6
 80011b2:	0a64      	lsrs	r4, r4, #9
 80011b4:	b2c2      	uxtb	r2, r0
 80011b6:	e767      	b.n	8001088 <__aeabi_fmul+0x98>
 80011b8:	2080      	movs	r0, #128	; 0x80
 80011ba:	03c0      	lsls	r0, r0, #15
 80011bc:	4304      	orrs	r4, r0
 80011be:	0264      	lsls	r4, r4, #9
 80011c0:	0a64      	lsrs	r4, r4, #9
 80011c2:	003b      	movs	r3, r7
 80011c4:	22ff      	movs	r2, #255	; 0xff
 80011c6:	e75f      	b.n	8001088 <__aeabi_fmul+0x98>
 80011c8:	2201      	movs	r2, #1
 80011ca:	1a10      	subs	r0, r2, r0
 80011cc:	281b      	cmp	r0, #27
 80011ce:	dd00      	ble.n	80011d2 <__aeabi_fmul+0x1e2>
 80011d0:	e758      	b.n	8001084 <__aeabi_fmul+0x94>
 80011d2:	4662      	mov	r2, ip
 80011d4:	329e      	adds	r2, #158	; 0x9e
 80011d6:	0021      	movs	r1, r4
 80011d8:	4094      	lsls	r4, r2
 80011da:	40c1      	lsrs	r1, r0
 80011dc:	1e62      	subs	r2, r4, #1
 80011de:	4194      	sbcs	r4, r2
 80011e0:	430c      	orrs	r4, r1
 80011e2:	0762      	lsls	r2, r4, #29
 80011e4:	d004      	beq.n	80011f0 <__aeabi_fmul+0x200>
 80011e6:	220f      	movs	r2, #15
 80011e8:	4022      	ands	r2, r4
 80011ea:	2a04      	cmp	r2, #4
 80011ec:	d000      	beq.n	80011f0 <__aeabi_fmul+0x200>
 80011ee:	3404      	adds	r4, #4
 80011f0:	0162      	lsls	r2, r4, #5
 80011f2:	d405      	bmi.n	8001200 <__aeabi_fmul+0x210>
 80011f4:	01a4      	lsls	r4, r4, #6
 80011f6:	0a64      	lsrs	r4, r4, #9
 80011f8:	2200      	movs	r2, #0
 80011fa:	e745      	b.n	8001088 <__aeabi_fmul+0x98>
 80011fc:	46ac      	mov	ip, r5
 80011fe:	e7c4      	b.n	800118a <__aeabi_fmul+0x19a>
 8001200:	2201      	movs	r2, #1
 8001202:	2400      	movs	r4, #0
 8001204:	e740      	b.n	8001088 <__aeabi_fmul+0x98>
 8001206:	2280      	movs	r2, #128	; 0x80
 8001208:	03d2      	lsls	r2, r2, #15
 800120a:	4314      	orrs	r4, r2
 800120c:	0264      	lsls	r4, r4, #9
 800120e:	0a64      	lsrs	r4, r4, #9
 8001210:	22ff      	movs	r2, #255	; 0xff
 8001212:	e739      	b.n	8001088 <__aeabi_fmul+0x98>
 8001214:	0801346c 	.word	0x0801346c
 8001218:	f7ffffff 	.word	0xf7ffffff
 800121c:	00000000 	.word	0x00000000

08001220 <__aeabi_fsub>:
 8001220:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001222:	0243      	lsls	r3, r0, #9
 8001224:	0a5b      	lsrs	r3, r3, #9
 8001226:	00da      	lsls	r2, r3, #3
 8001228:	46de      	mov	lr, fp
 800122a:	4693      	mov	fp, r2
 800122c:	024a      	lsls	r2, r1, #9
 800122e:	0a52      	lsrs	r2, r2, #9
 8001230:	4645      	mov	r5, r8
 8001232:	4690      	mov	r8, r2
 8001234:	464e      	mov	r6, r9
 8001236:	4657      	mov	r7, sl
 8001238:	4644      	mov	r4, r8
 800123a:	b5e0      	push	{r5, r6, r7, lr}
 800123c:	004a      	lsls	r2, r1, #1
 800123e:	0047      	lsls	r7, r0, #1
 8001240:	0e3f      	lsrs	r7, r7, #24
 8001242:	00e4      	lsls	r4, r4, #3
 8001244:	0e12      	lsrs	r2, r2, #24
 8001246:	46a1      	mov	r9, r4
 8001248:	469c      	mov	ip, r3
 800124a:	003e      	movs	r6, r7
 800124c:	0fc5      	lsrs	r5, r0, #31
 800124e:	0fc9      	lsrs	r1, r1, #31
 8001250:	1abc      	subs	r4, r7, r2
 8001252:	2aff      	cmp	r2, #255	; 0xff
 8001254:	d100      	bne.n	8001258 <__aeabi_fsub+0x38>
 8001256:	e077      	b.n	8001348 <__aeabi_fsub+0x128>
 8001258:	2001      	movs	r0, #1
 800125a:	4682      	mov	sl, r0
 800125c:	4650      	mov	r0, sl
 800125e:	4041      	eors	r1, r0
 8001260:	428d      	cmp	r5, r1
 8001262:	d100      	bne.n	8001266 <__aeabi_fsub+0x46>
 8001264:	e080      	b.n	8001368 <__aeabi_fsub+0x148>
 8001266:	2c00      	cmp	r4, #0
 8001268:	dd51      	ble.n	800130e <__aeabi_fsub+0xee>
 800126a:	2a00      	cmp	r2, #0
 800126c:	d000      	beq.n	8001270 <__aeabi_fsub+0x50>
 800126e:	e073      	b.n	8001358 <__aeabi_fsub+0x138>
 8001270:	464b      	mov	r3, r9
 8001272:	2b00      	cmp	r3, #0
 8001274:	d100      	bne.n	8001278 <__aeabi_fsub+0x58>
 8001276:	e0dd      	b.n	8001434 <__aeabi_fsub+0x214>
 8001278:	3c01      	subs	r4, #1
 800127a:	2c00      	cmp	r4, #0
 800127c:	d00f      	beq.n	800129e <__aeabi_fsub+0x7e>
 800127e:	2fff      	cmp	r7, #255	; 0xff
 8001280:	d100      	bne.n	8001284 <__aeabi_fsub+0x64>
 8001282:	e0a5      	b.n	80013d0 <__aeabi_fsub+0x1b0>
 8001284:	2301      	movs	r3, #1
 8001286:	2c1b      	cmp	r4, #27
 8001288:	dc09      	bgt.n	800129e <__aeabi_fsub+0x7e>
 800128a:	2220      	movs	r2, #32
 800128c:	4649      	mov	r1, r9
 800128e:	1b12      	subs	r2, r2, r4
 8001290:	4091      	lsls	r1, r2
 8001292:	464b      	mov	r3, r9
 8001294:	000a      	movs	r2, r1
 8001296:	40e3      	lsrs	r3, r4
 8001298:	1e51      	subs	r1, r2, #1
 800129a:	418a      	sbcs	r2, r1
 800129c:	4313      	orrs	r3, r2
 800129e:	465a      	mov	r2, fp
 80012a0:	1ad3      	subs	r3, r2, r3
 80012a2:	015a      	lsls	r2, r3, #5
 80012a4:	d400      	bmi.n	80012a8 <__aeabi_fsub+0x88>
 80012a6:	e0c0      	b.n	800142a <__aeabi_fsub+0x20a>
 80012a8:	019b      	lsls	r3, r3, #6
 80012aa:	099c      	lsrs	r4, r3, #6
 80012ac:	0020      	movs	r0, r4
 80012ae:	f002 f977 	bl	80035a0 <__clzsi2>
 80012b2:	0023      	movs	r3, r4
 80012b4:	3805      	subs	r0, #5
 80012b6:	4083      	lsls	r3, r0
 80012b8:	4286      	cmp	r6, r0
 80012ba:	dd00      	ble.n	80012be <__aeabi_fsub+0x9e>
 80012bc:	e0c4      	b.n	8001448 <__aeabi_fsub+0x228>
 80012be:	1b86      	subs	r6, r0, r6
 80012c0:	001a      	movs	r2, r3
 80012c2:	2020      	movs	r0, #32
 80012c4:	3601      	adds	r6, #1
 80012c6:	40f2      	lsrs	r2, r6
 80012c8:	1b86      	subs	r6, r0, r6
 80012ca:	40b3      	lsls	r3, r6
 80012cc:	1e5c      	subs	r4, r3, #1
 80012ce:	41a3      	sbcs	r3, r4
 80012d0:	2600      	movs	r6, #0
 80012d2:	4313      	orrs	r3, r2
 80012d4:	075a      	lsls	r2, r3, #29
 80012d6:	d004      	beq.n	80012e2 <__aeabi_fsub+0xc2>
 80012d8:	220f      	movs	r2, #15
 80012da:	401a      	ands	r2, r3
 80012dc:	2a04      	cmp	r2, #4
 80012de:	d000      	beq.n	80012e2 <__aeabi_fsub+0xc2>
 80012e0:	3304      	adds	r3, #4
 80012e2:	015a      	lsls	r2, r3, #5
 80012e4:	d400      	bmi.n	80012e8 <__aeabi_fsub+0xc8>
 80012e6:	e0a3      	b.n	8001430 <__aeabi_fsub+0x210>
 80012e8:	3601      	adds	r6, #1
 80012ea:	b2f7      	uxtb	r7, r6
 80012ec:	2eff      	cmp	r6, #255	; 0xff
 80012ee:	d100      	bne.n	80012f2 <__aeabi_fsub+0xd2>
 80012f0:	e0a7      	b.n	8001442 <__aeabi_fsub+0x222>
 80012f2:	019b      	lsls	r3, r3, #6
 80012f4:	0a5b      	lsrs	r3, r3, #9
 80012f6:	0258      	lsls	r0, r3, #9
 80012f8:	05ff      	lsls	r7, r7, #23
 80012fa:	0a40      	lsrs	r0, r0, #9
 80012fc:	07ed      	lsls	r5, r5, #31
 80012fe:	4338      	orrs	r0, r7
 8001300:	4328      	orrs	r0, r5
 8001302:	bc3c      	pop	{r2, r3, r4, r5}
 8001304:	4690      	mov	r8, r2
 8001306:	4699      	mov	r9, r3
 8001308:	46a2      	mov	sl, r4
 800130a:	46ab      	mov	fp, r5
 800130c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800130e:	2c00      	cmp	r4, #0
 8001310:	d14f      	bne.n	80013b2 <__aeabi_fsub+0x192>
 8001312:	24fe      	movs	r4, #254	; 0xfe
 8001314:	1c7a      	adds	r2, r7, #1
 8001316:	4214      	tst	r4, r2
 8001318:	d000      	beq.n	800131c <__aeabi_fsub+0xfc>
 800131a:	e09c      	b.n	8001456 <__aeabi_fsub+0x236>
 800131c:	465a      	mov	r2, fp
 800131e:	2f00      	cmp	r7, #0
 8001320:	d000      	beq.n	8001324 <__aeabi_fsub+0x104>
 8001322:	e103      	b.n	800152c <__aeabi_fsub+0x30c>
 8001324:	2a00      	cmp	r2, #0
 8001326:	d100      	bne.n	800132a <__aeabi_fsub+0x10a>
 8001328:	e0f4      	b.n	8001514 <__aeabi_fsub+0x2f4>
 800132a:	464a      	mov	r2, r9
 800132c:	2a00      	cmp	r2, #0
 800132e:	d0e2      	beq.n	80012f6 <__aeabi_fsub+0xd6>
 8001330:	464b      	mov	r3, r9
 8001332:	465a      	mov	r2, fp
 8001334:	1ad3      	subs	r3, r2, r3
 8001336:	015a      	lsls	r2, r3, #5
 8001338:	d400      	bmi.n	800133c <__aeabi_fsub+0x11c>
 800133a:	e105      	b.n	8001548 <__aeabi_fsub+0x328>
 800133c:	464b      	mov	r3, r9
 800133e:	465a      	mov	r2, fp
 8001340:	000d      	movs	r5, r1
 8001342:	1a9b      	subs	r3, r3, r2
 8001344:	2600      	movs	r6, #0
 8001346:	e7c5      	b.n	80012d4 <__aeabi_fsub+0xb4>
 8001348:	4648      	mov	r0, r9
 800134a:	2800      	cmp	r0, #0
 800134c:	d100      	bne.n	8001350 <__aeabi_fsub+0x130>
 800134e:	e783      	b.n	8001258 <__aeabi_fsub+0x38>
 8001350:	428d      	cmp	r5, r1
 8001352:	d051      	beq.n	80013f8 <__aeabi_fsub+0x1d8>
 8001354:	2c00      	cmp	r4, #0
 8001356:	ddda      	ble.n	800130e <__aeabi_fsub+0xee>
 8001358:	2fff      	cmp	r7, #255	; 0xff
 800135a:	d039      	beq.n	80013d0 <__aeabi_fsub+0x1b0>
 800135c:	2380      	movs	r3, #128	; 0x80
 800135e:	464a      	mov	r2, r9
 8001360:	04db      	lsls	r3, r3, #19
 8001362:	431a      	orrs	r2, r3
 8001364:	4691      	mov	r9, r2
 8001366:	e78d      	b.n	8001284 <__aeabi_fsub+0x64>
 8001368:	2c00      	cmp	r4, #0
 800136a:	dd45      	ble.n	80013f8 <__aeabi_fsub+0x1d8>
 800136c:	2a00      	cmp	r2, #0
 800136e:	d03a      	beq.n	80013e6 <__aeabi_fsub+0x1c6>
 8001370:	2fff      	cmp	r7, #255	; 0xff
 8001372:	d02d      	beq.n	80013d0 <__aeabi_fsub+0x1b0>
 8001374:	2380      	movs	r3, #128	; 0x80
 8001376:	464a      	mov	r2, r9
 8001378:	04db      	lsls	r3, r3, #19
 800137a:	431a      	orrs	r2, r3
 800137c:	4691      	mov	r9, r2
 800137e:	2301      	movs	r3, #1
 8001380:	2c1b      	cmp	r4, #27
 8001382:	dc09      	bgt.n	8001398 <__aeabi_fsub+0x178>
 8001384:	2220      	movs	r2, #32
 8001386:	4649      	mov	r1, r9
 8001388:	1b12      	subs	r2, r2, r4
 800138a:	4091      	lsls	r1, r2
 800138c:	464b      	mov	r3, r9
 800138e:	000a      	movs	r2, r1
 8001390:	40e3      	lsrs	r3, r4
 8001392:	1e51      	subs	r1, r2, #1
 8001394:	418a      	sbcs	r2, r1
 8001396:	4313      	orrs	r3, r2
 8001398:	445b      	add	r3, fp
 800139a:	015a      	lsls	r2, r3, #5
 800139c:	d545      	bpl.n	800142a <__aeabi_fsub+0x20a>
 800139e:	3601      	adds	r6, #1
 80013a0:	2eff      	cmp	r6, #255	; 0xff
 80013a2:	d04e      	beq.n	8001442 <__aeabi_fsub+0x222>
 80013a4:	2201      	movs	r2, #1
 80013a6:	496f      	ldr	r1, [pc, #444]	; (8001564 <__aeabi_fsub+0x344>)
 80013a8:	401a      	ands	r2, r3
 80013aa:	085b      	lsrs	r3, r3, #1
 80013ac:	400b      	ands	r3, r1
 80013ae:	4313      	orrs	r3, r2
 80013b0:	e790      	b.n	80012d4 <__aeabi_fsub+0xb4>
 80013b2:	1bd4      	subs	r4, r2, r7
 80013b4:	000d      	movs	r5, r1
 80013b6:	2f00      	cmp	r7, #0
 80013b8:	d172      	bne.n	80014a0 <__aeabi_fsub+0x280>
 80013ba:	465b      	mov	r3, fp
 80013bc:	2b00      	cmp	r3, #0
 80013be:	d100      	bne.n	80013c2 <__aeabi_fsub+0x1a2>
 80013c0:	e092      	b.n	80014e8 <__aeabi_fsub+0x2c8>
 80013c2:	3c01      	subs	r4, #1
 80013c4:	2c00      	cmp	r4, #0
 80013c6:	d100      	bne.n	80013ca <__aeabi_fsub+0x1aa>
 80013c8:	e0c5      	b.n	8001556 <__aeabi_fsub+0x336>
 80013ca:	2aff      	cmp	r2, #255	; 0xff
 80013cc:	d16f      	bne.n	80014ae <__aeabi_fsub+0x28e>
 80013ce:	46c4      	mov	ip, r8
 80013d0:	4663      	mov	r3, ip
 80013d2:	2b00      	cmp	r3, #0
 80013d4:	d035      	beq.n	8001442 <__aeabi_fsub+0x222>
 80013d6:	2380      	movs	r3, #128	; 0x80
 80013d8:	4662      	mov	r2, ip
 80013da:	03db      	lsls	r3, r3, #15
 80013dc:	4313      	orrs	r3, r2
 80013de:	025b      	lsls	r3, r3, #9
 80013e0:	0a5b      	lsrs	r3, r3, #9
 80013e2:	27ff      	movs	r7, #255	; 0xff
 80013e4:	e787      	b.n	80012f6 <__aeabi_fsub+0xd6>
 80013e6:	464b      	mov	r3, r9
 80013e8:	2b00      	cmp	r3, #0
 80013ea:	d023      	beq.n	8001434 <__aeabi_fsub+0x214>
 80013ec:	3c01      	subs	r4, #1
 80013ee:	2c00      	cmp	r4, #0
 80013f0:	d077      	beq.n	80014e2 <__aeabi_fsub+0x2c2>
 80013f2:	2fff      	cmp	r7, #255	; 0xff
 80013f4:	d1c3      	bne.n	800137e <__aeabi_fsub+0x15e>
 80013f6:	e7eb      	b.n	80013d0 <__aeabi_fsub+0x1b0>
 80013f8:	2c00      	cmp	r4, #0
 80013fa:	d138      	bne.n	800146e <__aeabi_fsub+0x24e>
 80013fc:	22fe      	movs	r2, #254	; 0xfe
 80013fe:	1c7e      	adds	r6, r7, #1
 8001400:	4232      	tst	r2, r6
 8001402:	d000      	beq.n	8001406 <__aeabi_fsub+0x1e6>
 8001404:	e08c      	b.n	8001520 <__aeabi_fsub+0x300>
 8001406:	465a      	mov	r2, fp
 8001408:	2f00      	cmp	r7, #0
 800140a:	d170      	bne.n	80014ee <__aeabi_fsub+0x2ce>
 800140c:	2a00      	cmp	r2, #0
 800140e:	d100      	bne.n	8001412 <__aeabi_fsub+0x1f2>
 8001410:	e0a6      	b.n	8001560 <__aeabi_fsub+0x340>
 8001412:	464a      	mov	r2, r9
 8001414:	2a00      	cmp	r2, #0
 8001416:	d100      	bne.n	800141a <__aeabi_fsub+0x1fa>
 8001418:	e76d      	b.n	80012f6 <__aeabi_fsub+0xd6>
 800141a:	465b      	mov	r3, fp
 800141c:	444b      	add	r3, r9
 800141e:	2600      	movs	r6, #0
 8001420:	015a      	lsls	r2, r3, #5
 8001422:	d502      	bpl.n	800142a <__aeabi_fsub+0x20a>
 8001424:	4a50      	ldr	r2, [pc, #320]	; (8001568 <__aeabi_fsub+0x348>)
 8001426:	3601      	adds	r6, #1
 8001428:	4013      	ands	r3, r2
 800142a:	075a      	lsls	r2, r3, #29
 800142c:	d000      	beq.n	8001430 <__aeabi_fsub+0x210>
 800142e:	e753      	b.n	80012d8 <__aeabi_fsub+0xb8>
 8001430:	08db      	lsrs	r3, r3, #3
 8001432:	469c      	mov	ip, r3
 8001434:	2eff      	cmp	r6, #255	; 0xff
 8001436:	d0cb      	beq.n	80013d0 <__aeabi_fsub+0x1b0>
 8001438:	4663      	mov	r3, ip
 800143a:	025b      	lsls	r3, r3, #9
 800143c:	0a5b      	lsrs	r3, r3, #9
 800143e:	b2f7      	uxtb	r7, r6
 8001440:	e759      	b.n	80012f6 <__aeabi_fsub+0xd6>
 8001442:	27ff      	movs	r7, #255	; 0xff
 8001444:	2300      	movs	r3, #0
 8001446:	e756      	b.n	80012f6 <__aeabi_fsub+0xd6>
 8001448:	4a47      	ldr	r2, [pc, #284]	; (8001568 <__aeabi_fsub+0x348>)
 800144a:	1a36      	subs	r6, r6, r0
 800144c:	4013      	ands	r3, r2
 800144e:	075a      	lsls	r2, r3, #29
 8001450:	d000      	beq.n	8001454 <__aeabi_fsub+0x234>
 8001452:	e741      	b.n	80012d8 <__aeabi_fsub+0xb8>
 8001454:	e7ec      	b.n	8001430 <__aeabi_fsub+0x210>
 8001456:	464b      	mov	r3, r9
 8001458:	465a      	mov	r2, fp
 800145a:	1ad4      	subs	r4, r2, r3
 800145c:	0163      	lsls	r3, r4, #5
 800145e:	d46f      	bmi.n	8001540 <__aeabi_fsub+0x320>
 8001460:	2c00      	cmp	r4, #0
 8001462:	d000      	beq.n	8001466 <__aeabi_fsub+0x246>
 8001464:	e722      	b.n	80012ac <__aeabi_fsub+0x8c>
 8001466:	2500      	movs	r5, #0
 8001468:	2700      	movs	r7, #0
 800146a:	2300      	movs	r3, #0
 800146c:	e743      	b.n	80012f6 <__aeabi_fsub+0xd6>
 800146e:	1bd1      	subs	r1, r2, r7
 8001470:	2f00      	cmp	r7, #0
 8001472:	d02c      	beq.n	80014ce <__aeabi_fsub+0x2ae>
 8001474:	2aff      	cmp	r2, #255	; 0xff
 8001476:	d0aa      	beq.n	80013ce <__aeabi_fsub+0x1ae>
 8001478:	2380      	movs	r3, #128	; 0x80
 800147a:	4658      	mov	r0, fp
 800147c:	04db      	lsls	r3, r3, #19
 800147e:	4318      	orrs	r0, r3
 8001480:	4683      	mov	fp, r0
 8001482:	2301      	movs	r3, #1
 8001484:	291b      	cmp	r1, #27
 8001486:	dc08      	bgt.n	800149a <__aeabi_fsub+0x27a>
 8001488:	465b      	mov	r3, fp
 800148a:	2420      	movs	r4, #32
 800148c:	4658      	mov	r0, fp
 800148e:	40cb      	lsrs	r3, r1
 8001490:	1a61      	subs	r1, r4, r1
 8001492:	4088      	lsls	r0, r1
 8001494:	1e41      	subs	r1, r0, #1
 8001496:	4188      	sbcs	r0, r1
 8001498:	4303      	orrs	r3, r0
 800149a:	444b      	add	r3, r9
 800149c:	0016      	movs	r6, r2
 800149e:	e77c      	b.n	800139a <__aeabi_fsub+0x17a>
 80014a0:	2aff      	cmp	r2, #255	; 0xff
 80014a2:	d094      	beq.n	80013ce <__aeabi_fsub+0x1ae>
 80014a4:	2380      	movs	r3, #128	; 0x80
 80014a6:	4659      	mov	r1, fp
 80014a8:	04db      	lsls	r3, r3, #19
 80014aa:	4319      	orrs	r1, r3
 80014ac:	468b      	mov	fp, r1
 80014ae:	2301      	movs	r3, #1
 80014b0:	2c1b      	cmp	r4, #27
 80014b2:	dc08      	bgt.n	80014c6 <__aeabi_fsub+0x2a6>
 80014b4:	2120      	movs	r1, #32
 80014b6:	465b      	mov	r3, fp
 80014b8:	4658      	mov	r0, fp
 80014ba:	40e3      	lsrs	r3, r4
 80014bc:	1b0c      	subs	r4, r1, r4
 80014be:	40a0      	lsls	r0, r4
 80014c0:	1e41      	subs	r1, r0, #1
 80014c2:	4188      	sbcs	r0, r1
 80014c4:	4303      	orrs	r3, r0
 80014c6:	4649      	mov	r1, r9
 80014c8:	0016      	movs	r6, r2
 80014ca:	1acb      	subs	r3, r1, r3
 80014cc:	e6e9      	b.n	80012a2 <__aeabi_fsub+0x82>
 80014ce:	465b      	mov	r3, fp
 80014d0:	2b00      	cmp	r3, #0
 80014d2:	d009      	beq.n	80014e8 <__aeabi_fsub+0x2c8>
 80014d4:	3901      	subs	r1, #1
 80014d6:	2900      	cmp	r1, #0
 80014d8:	d0df      	beq.n	800149a <__aeabi_fsub+0x27a>
 80014da:	2aff      	cmp	r2, #255	; 0xff
 80014dc:	d1d1      	bne.n	8001482 <__aeabi_fsub+0x262>
 80014de:	46c4      	mov	ip, r8
 80014e0:	e776      	b.n	80013d0 <__aeabi_fsub+0x1b0>
 80014e2:	465b      	mov	r3, fp
 80014e4:	444b      	add	r3, r9
 80014e6:	e758      	b.n	800139a <__aeabi_fsub+0x17a>
 80014e8:	46c4      	mov	ip, r8
 80014ea:	0016      	movs	r6, r2
 80014ec:	e7a2      	b.n	8001434 <__aeabi_fsub+0x214>
 80014ee:	2a00      	cmp	r2, #0
 80014f0:	d100      	bne.n	80014f4 <__aeabi_fsub+0x2d4>
 80014f2:	e76c      	b.n	80013ce <__aeabi_fsub+0x1ae>
 80014f4:	464a      	mov	r2, r9
 80014f6:	2a00      	cmp	r2, #0
 80014f8:	d100      	bne.n	80014fc <__aeabi_fsub+0x2dc>
 80014fa:	e769      	b.n	80013d0 <__aeabi_fsub+0x1b0>
 80014fc:	2280      	movs	r2, #128	; 0x80
 80014fe:	03d2      	lsls	r2, r2, #15
 8001500:	4213      	tst	r3, r2
 8001502:	d100      	bne.n	8001506 <__aeabi_fsub+0x2e6>
 8001504:	e764      	b.n	80013d0 <__aeabi_fsub+0x1b0>
 8001506:	4643      	mov	r3, r8
 8001508:	4213      	tst	r3, r2
 800150a:	d000      	beq.n	800150e <__aeabi_fsub+0x2ee>
 800150c:	e760      	b.n	80013d0 <__aeabi_fsub+0x1b0>
 800150e:	000d      	movs	r5, r1
 8001510:	46c4      	mov	ip, r8
 8001512:	e75d      	b.n	80013d0 <__aeabi_fsub+0x1b0>
 8001514:	464b      	mov	r3, r9
 8001516:	2b00      	cmp	r3, #0
 8001518:	d01a      	beq.n	8001550 <__aeabi_fsub+0x330>
 800151a:	000d      	movs	r5, r1
 800151c:	4643      	mov	r3, r8
 800151e:	e6ea      	b.n	80012f6 <__aeabi_fsub+0xd6>
 8001520:	2eff      	cmp	r6, #255	; 0xff
 8001522:	d08e      	beq.n	8001442 <__aeabi_fsub+0x222>
 8001524:	465b      	mov	r3, fp
 8001526:	444b      	add	r3, r9
 8001528:	085b      	lsrs	r3, r3, #1
 800152a:	e77e      	b.n	800142a <__aeabi_fsub+0x20a>
 800152c:	2a00      	cmp	r2, #0
 800152e:	d1e1      	bne.n	80014f4 <__aeabi_fsub+0x2d4>
 8001530:	464b      	mov	r3, r9
 8001532:	2b00      	cmp	r3, #0
 8001534:	d1eb      	bne.n	800150e <__aeabi_fsub+0x2ee>
 8001536:	2380      	movs	r3, #128	; 0x80
 8001538:	2500      	movs	r5, #0
 800153a:	03db      	lsls	r3, r3, #15
 800153c:	27ff      	movs	r7, #255	; 0xff
 800153e:	e6da      	b.n	80012f6 <__aeabi_fsub+0xd6>
 8001540:	464b      	mov	r3, r9
 8001542:	000d      	movs	r5, r1
 8001544:	1a9c      	subs	r4, r3, r2
 8001546:	e6b1      	b.n	80012ac <__aeabi_fsub+0x8c>
 8001548:	2600      	movs	r6, #0
 800154a:	2b00      	cmp	r3, #0
 800154c:	d000      	beq.n	8001550 <__aeabi_fsub+0x330>
 800154e:	e76c      	b.n	800142a <__aeabi_fsub+0x20a>
 8001550:	2500      	movs	r5, #0
 8001552:	2300      	movs	r3, #0
 8001554:	e6cf      	b.n	80012f6 <__aeabi_fsub+0xd6>
 8001556:	464b      	mov	r3, r9
 8001558:	4659      	mov	r1, fp
 800155a:	0016      	movs	r6, r2
 800155c:	1a5b      	subs	r3, r3, r1
 800155e:	e6a0      	b.n	80012a2 <__aeabi_fsub+0x82>
 8001560:	4643      	mov	r3, r8
 8001562:	e6c8      	b.n	80012f6 <__aeabi_fsub+0xd6>
 8001564:	7dffffff 	.word	0x7dffffff
 8001568:	fbffffff 	.word	0xfbffffff
 800156c:	00000000 	.word	0x00000000

08001570 <__aeabi_fcmpun>:
 8001570:	0242      	lsls	r2, r0, #9
 8001572:	024b      	lsls	r3, r1, #9
 8001574:	0040      	lsls	r0, r0, #1
 8001576:	0049      	lsls	r1, r1, #1
 8001578:	0a52      	lsrs	r2, r2, #9
 800157a:	0a5b      	lsrs	r3, r3, #9
 800157c:	0e09      	lsrs	r1, r1, #24
 800157e:	0e00      	lsrs	r0, r0, #24
 8001580:	28ff      	cmp	r0, #255	; 0xff
 8001582:	d006      	beq.n	8001592 <__aeabi_fcmpun+0x22>
 8001584:	2000      	movs	r0, #0
 8001586:	29ff      	cmp	r1, #255	; 0xff
 8001588:	d102      	bne.n	8001590 <__aeabi_fcmpun+0x20>
 800158a:	0018      	movs	r0, r3
 800158c:	1e43      	subs	r3, r0, #1
 800158e:	4198      	sbcs	r0, r3
 8001590:	4770      	bx	lr
 8001592:	38fe      	subs	r0, #254	; 0xfe
 8001594:	2a00      	cmp	r2, #0
 8001596:	d1fb      	bne.n	8001590 <__aeabi_fcmpun+0x20>
 8001598:	e7f4      	b.n	8001584 <__aeabi_fcmpun+0x14>
 800159a:	46c0      	nop			; (mov r8, r8)
 800159c:	0000      	movs	r0, r0
	...

080015a0 <__aeabi_f2iz>:
 80015a0:	0241      	lsls	r1, r0, #9
 80015a2:	0042      	lsls	r2, r0, #1
 80015a4:	0fc3      	lsrs	r3, r0, #31
 80015a6:	0a49      	lsrs	r1, r1, #9
 80015a8:	0e12      	lsrs	r2, r2, #24
 80015aa:	2000      	movs	r0, #0
 80015ac:	2a7e      	cmp	r2, #126	; 0x7e
 80015ae:	d903      	bls.n	80015b8 <__aeabi_f2iz+0x18>
 80015b0:	2a9d      	cmp	r2, #157	; 0x9d
 80015b2:	d902      	bls.n	80015ba <__aeabi_f2iz+0x1a>
 80015b4:	4a09      	ldr	r2, [pc, #36]	; (80015dc <__aeabi_f2iz+0x3c>)
 80015b6:	1898      	adds	r0, r3, r2
 80015b8:	4770      	bx	lr
 80015ba:	2080      	movs	r0, #128	; 0x80
 80015bc:	0400      	lsls	r0, r0, #16
 80015be:	4301      	orrs	r1, r0
 80015c0:	2a95      	cmp	r2, #149	; 0x95
 80015c2:	dc07      	bgt.n	80015d4 <__aeabi_f2iz+0x34>
 80015c4:	2096      	movs	r0, #150	; 0x96
 80015c6:	1a82      	subs	r2, r0, r2
 80015c8:	40d1      	lsrs	r1, r2
 80015ca:	4248      	negs	r0, r1
 80015cc:	2b00      	cmp	r3, #0
 80015ce:	d1f3      	bne.n	80015b8 <__aeabi_f2iz+0x18>
 80015d0:	0008      	movs	r0, r1
 80015d2:	e7f1      	b.n	80015b8 <__aeabi_f2iz+0x18>
 80015d4:	3a96      	subs	r2, #150	; 0x96
 80015d6:	4091      	lsls	r1, r2
 80015d8:	e7f7      	b.n	80015ca <__aeabi_f2iz+0x2a>
 80015da:	46c0      	nop			; (mov r8, r8)
 80015dc:	7fffffff 	.word	0x7fffffff

080015e0 <__aeabi_i2f>:
 80015e0:	b570      	push	{r4, r5, r6, lr}
 80015e2:	2800      	cmp	r0, #0
 80015e4:	d012      	beq.n	800160c <__aeabi_i2f+0x2c>
 80015e6:	17c3      	asrs	r3, r0, #31
 80015e8:	18c5      	adds	r5, r0, r3
 80015ea:	405d      	eors	r5, r3
 80015ec:	0fc4      	lsrs	r4, r0, #31
 80015ee:	0028      	movs	r0, r5
 80015f0:	f001 ffd6 	bl	80035a0 <__clzsi2>
 80015f4:	229e      	movs	r2, #158	; 0x9e
 80015f6:	1a12      	subs	r2, r2, r0
 80015f8:	2a96      	cmp	r2, #150	; 0x96
 80015fa:	dc11      	bgt.n	8001620 <__aeabi_i2f+0x40>
 80015fc:	b2d2      	uxtb	r2, r2
 80015fe:	2808      	cmp	r0, #8
 8001600:	dd33      	ble.n	800166a <__aeabi_i2f+0x8a>
 8001602:	3808      	subs	r0, #8
 8001604:	4085      	lsls	r5, r0
 8001606:	0268      	lsls	r0, r5, #9
 8001608:	0a40      	lsrs	r0, r0, #9
 800160a:	e002      	b.n	8001612 <__aeabi_i2f+0x32>
 800160c:	2400      	movs	r4, #0
 800160e:	2200      	movs	r2, #0
 8001610:	2000      	movs	r0, #0
 8001612:	0240      	lsls	r0, r0, #9
 8001614:	05d2      	lsls	r2, r2, #23
 8001616:	0a40      	lsrs	r0, r0, #9
 8001618:	07e4      	lsls	r4, r4, #31
 800161a:	4310      	orrs	r0, r2
 800161c:	4320      	orrs	r0, r4
 800161e:	bd70      	pop	{r4, r5, r6, pc}
 8001620:	2a99      	cmp	r2, #153	; 0x99
 8001622:	dd0b      	ble.n	800163c <__aeabi_i2f+0x5c>
 8001624:	2305      	movs	r3, #5
 8001626:	0029      	movs	r1, r5
 8001628:	1a1b      	subs	r3, r3, r0
 800162a:	40d9      	lsrs	r1, r3
 800162c:	0003      	movs	r3, r0
 800162e:	331b      	adds	r3, #27
 8001630:	409d      	lsls	r5, r3
 8001632:	002b      	movs	r3, r5
 8001634:	1e5d      	subs	r5, r3, #1
 8001636:	41ab      	sbcs	r3, r5
 8001638:	4319      	orrs	r1, r3
 800163a:	000d      	movs	r5, r1
 800163c:	2805      	cmp	r0, #5
 800163e:	dd01      	ble.n	8001644 <__aeabi_i2f+0x64>
 8001640:	1f43      	subs	r3, r0, #5
 8001642:	409d      	lsls	r5, r3
 8001644:	002b      	movs	r3, r5
 8001646:	490a      	ldr	r1, [pc, #40]	; (8001670 <__aeabi_i2f+0x90>)
 8001648:	400b      	ands	r3, r1
 800164a:	076e      	lsls	r6, r5, #29
 800164c:	d009      	beq.n	8001662 <__aeabi_i2f+0x82>
 800164e:	260f      	movs	r6, #15
 8001650:	4035      	ands	r5, r6
 8001652:	2d04      	cmp	r5, #4
 8001654:	d005      	beq.n	8001662 <__aeabi_i2f+0x82>
 8001656:	3304      	adds	r3, #4
 8001658:	015d      	lsls	r5, r3, #5
 800165a:	d502      	bpl.n	8001662 <__aeabi_i2f+0x82>
 800165c:	229f      	movs	r2, #159	; 0x9f
 800165e:	400b      	ands	r3, r1
 8001660:	1a12      	subs	r2, r2, r0
 8001662:	019b      	lsls	r3, r3, #6
 8001664:	0a58      	lsrs	r0, r3, #9
 8001666:	b2d2      	uxtb	r2, r2
 8001668:	e7d3      	b.n	8001612 <__aeabi_i2f+0x32>
 800166a:	0268      	lsls	r0, r5, #9
 800166c:	0a40      	lsrs	r0, r0, #9
 800166e:	e7d0      	b.n	8001612 <__aeabi_i2f+0x32>
 8001670:	fbffffff 	.word	0xfbffffff
	...

08001680 <__aeabi_ui2f>:
 8001680:	b570      	push	{r4, r5, r6, lr}
 8001682:	1e04      	subs	r4, r0, #0
 8001684:	d00d      	beq.n	80016a2 <__aeabi_ui2f+0x22>
 8001686:	f001 ff8b 	bl	80035a0 <__clzsi2>
 800168a:	229e      	movs	r2, #158	; 0x9e
 800168c:	1a12      	subs	r2, r2, r0
 800168e:	2a96      	cmp	r2, #150	; 0x96
 8001690:	dc0e      	bgt.n	80016b0 <__aeabi_ui2f+0x30>
 8001692:	b2d2      	uxtb	r2, r2
 8001694:	2808      	cmp	r0, #8
 8001696:	dd2e      	ble.n	80016f6 <__aeabi_ui2f+0x76>
 8001698:	3808      	subs	r0, #8
 800169a:	4084      	lsls	r4, r0
 800169c:	0260      	lsls	r0, r4, #9
 800169e:	0a40      	lsrs	r0, r0, #9
 80016a0:	e001      	b.n	80016a6 <__aeabi_ui2f+0x26>
 80016a2:	2200      	movs	r2, #0
 80016a4:	2000      	movs	r0, #0
 80016a6:	0240      	lsls	r0, r0, #9
 80016a8:	05d2      	lsls	r2, r2, #23
 80016aa:	0a40      	lsrs	r0, r0, #9
 80016ac:	4310      	orrs	r0, r2
 80016ae:	bd70      	pop	{r4, r5, r6, pc}
 80016b0:	2a99      	cmp	r2, #153	; 0x99
 80016b2:	dd09      	ble.n	80016c8 <__aeabi_ui2f+0x48>
 80016b4:	0003      	movs	r3, r0
 80016b6:	0021      	movs	r1, r4
 80016b8:	331b      	adds	r3, #27
 80016ba:	4099      	lsls	r1, r3
 80016bc:	1e4b      	subs	r3, r1, #1
 80016be:	4199      	sbcs	r1, r3
 80016c0:	2305      	movs	r3, #5
 80016c2:	1a1b      	subs	r3, r3, r0
 80016c4:	40dc      	lsrs	r4, r3
 80016c6:	430c      	orrs	r4, r1
 80016c8:	2805      	cmp	r0, #5
 80016ca:	dd01      	ble.n	80016d0 <__aeabi_ui2f+0x50>
 80016cc:	1f43      	subs	r3, r0, #5
 80016ce:	409c      	lsls	r4, r3
 80016d0:	0023      	movs	r3, r4
 80016d2:	490a      	ldr	r1, [pc, #40]	; (80016fc <__aeabi_ui2f+0x7c>)
 80016d4:	400b      	ands	r3, r1
 80016d6:	0765      	lsls	r5, r4, #29
 80016d8:	d009      	beq.n	80016ee <__aeabi_ui2f+0x6e>
 80016da:	250f      	movs	r5, #15
 80016dc:	402c      	ands	r4, r5
 80016de:	2c04      	cmp	r4, #4
 80016e0:	d005      	beq.n	80016ee <__aeabi_ui2f+0x6e>
 80016e2:	3304      	adds	r3, #4
 80016e4:	015c      	lsls	r4, r3, #5
 80016e6:	d502      	bpl.n	80016ee <__aeabi_ui2f+0x6e>
 80016e8:	229f      	movs	r2, #159	; 0x9f
 80016ea:	400b      	ands	r3, r1
 80016ec:	1a12      	subs	r2, r2, r0
 80016ee:	019b      	lsls	r3, r3, #6
 80016f0:	0a58      	lsrs	r0, r3, #9
 80016f2:	b2d2      	uxtb	r2, r2
 80016f4:	e7d7      	b.n	80016a6 <__aeabi_ui2f+0x26>
 80016f6:	0260      	lsls	r0, r4, #9
 80016f8:	0a40      	lsrs	r0, r0, #9
 80016fa:	e7d4      	b.n	80016a6 <__aeabi_ui2f+0x26>
 80016fc:	fbffffff 	.word	0xfbffffff

08001700 <__aeabi_dadd>:
 8001700:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001702:	4647      	mov	r7, r8
 8001704:	46ce      	mov	lr, r9
 8001706:	030e      	lsls	r6, r1, #12
 8001708:	004d      	lsls	r5, r1, #1
 800170a:	0a76      	lsrs	r6, r6, #9
 800170c:	0fcc      	lsrs	r4, r1, #31
 800170e:	0f41      	lsrs	r1, r0, #29
 8001710:	4331      	orrs	r1, r6
 8001712:	4689      	mov	r9, r1
 8001714:	0319      	lsls	r1, r3, #12
 8001716:	b580      	push	{r7, lr}
 8001718:	0a49      	lsrs	r1, r1, #9
 800171a:	0f57      	lsrs	r7, r2, #29
 800171c:	005e      	lsls	r6, r3, #1
 800171e:	430f      	orrs	r7, r1
 8001720:	0d6d      	lsrs	r5, r5, #21
 8001722:	00c0      	lsls	r0, r0, #3
 8001724:	0d76      	lsrs	r6, r6, #21
 8001726:	0fdb      	lsrs	r3, r3, #31
 8001728:	46b8      	mov	r8, r7
 800172a:	00d2      	lsls	r2, r2, #3
 800172c:	429c      	cmp	r4, r3
 800172e:	d100      	bne.n	8001732 <__aeabi_dadd+0x32>
 8001730:	e0a3      	b.n	800187a <__aeabi_dadd+0x17a>
 8001732:	1baf      	subs	r7, r5, r6
 8001734:	2f00      	cmp	r7, #0
 8001736:	dc00      	bgt.n	800173a <__aeabi_dadd+0x3a>
 8001738:	e083      	b.n	8001842 <__aeabi_dadd+0x142>
 800173a:	2e00      	cmp	r6, #0
 800173c:	d100      	bne.n	8001740 <__aeabi_dadd+0x40>
 800173e:	e0c0      	b.n	80018c2 <__aeabi_dadd+0x1c2>
 8001740:	4bb9      	ldr	r3, [pc, #740]	; (8001a28 <__aeabi_dadd+0x328>)
 8001742:	429d      	cmp	r5, r3
 8001744:	d100      	bne.n	8001748 <__aeabi_dadd+0x48>
 8001746:	e14f      	b.n	80019e8 <__aeabi_dadd+0x2e8>
 8001748:	2380      	movs	r3, #128	; 0x80
 800174a:	4641      	mov	r1, r8
 800174c:	041b      	lsls	r3, r3, #16
 800174e:	4319      	orrs	r1, r3
 8001750:	4688      	mov	r8, r1
 8001752:	2f38      	cmp	r7, #56	; 0x38
 8001754:	dd00      	ble.n	8001758 <__aeabi_dadd+0x58>
 8001756:	e12d      	b.n	80019b4 <__aeabi_dadd+0x2b4>
 8001758:	2f1f      	cmp	r7, #31
 800175a:	dd00      	ble.n	800175e <__aeabi_dadd+0x5e>
 800175c:	e1e7      	b.n	8001b2e <__aeabi_dadd+0x42e>
 800175e:	2320      	movs	r3, #32
 8001760:	0011      	movs	r1, r2
 8001762:	4646      	mov	r6, r8
 8001764:	1bdb      	subs	r3, r3, r7
 8001766:	409e      	lsls	r6, r3
 8001768:	40f9      	lsrs	r1, r7
 800176a:	409a      	lsls	r2, r3
 800176c:	430e      	orrs	r6, r1
 800176e:	4641      	mov	r1, r8
 8001770:	1e53      	subs	r3, r2, #1
 8001772:	419a      	sbcs	r2, r3
 8001774:	40f9      	lsrs	r1, r7
 8001776:	464b      	mov	r3, r9
 8001778:	1a5b      	subs	r3, r3, r1
 800177a:	4699      	mov	r9, r3
 800177c:	4332      	orrs	r2, r6
 800177e:	1a87      	subs	r7, r0, r2
 8001780:	42b8      	cmp	r0, r7
 8001782:	4180      	sbcs	r0, r0
 8001784:	464b      	mov	r3, r9
 8001786:	4241      	negs	r1, r0
 8001788:	1a59      	subs	r1, r3, r1
 800178a:	020b      	lsls	r3, r1, #8
 800178c:	d400      	bmi.n	8001790 <__aeabi_dadd+0x90>
 800178e:	e0d6      	b.n	800193e <__aeabi_dadd+0x23e>
 8001790:	0249      	lsls	r1, r1, #9
 8001792:	0a4e      	lsrs	r6, r1, #9
 8001794:	2e00      	cmp	r6, #0
 8001796:	d100      	bne.n	800179a <__aeabi_dadd+0x9a>
 8001798:	e0ff      	b.n	800199a <__aeabi_dadd+0x29a>
 800179a:	0030      	movs	r0, r6
 800179c:	f001 ff00 	bl	80035a0 <__clzsi2>
 80017a0:	0003      	movs	r3, r0
 80017a2:	3b08      	subs	r3, #8
 80017a4:	2220      	movs	r2, #32
 80017a6:	0039      	movs	r1, r7
 80017a8:	1ad2      	subs	r2, r2, r3
 80017aa:	409e      	lsls	r6, r3
 80017ac:	40d1      	lsrs	r1, r2
 80017ae:	409f      	lsls	r7, r3
 80017b0:	430e      	orrs	r6, r1
 80017b2:	429d      	cmp	r5, r3
 80017b4:	dd00      	ble.n	80017b8 <__aeabi_dadd+0xb8>
 80017b6:	e0e9      	b.n	800198c <__aeabi_dadd+0x28c>
 80017b8:	1b5d      	subs	r5, r3, r5
 80017ba:	1c6b      	adds	r3, r5, #1
 80017bc:	2b1f      	cmp	r3, #31
 80017be:	dd00      	ble.n	80017c2 <__aeabi_dadd+0xc2>
 80017c0:	e1a6      	b.n	8001b10 <__aeabi_dadd+0x410>
 80017c2:	2120      	movs	r1, #32
 80017c4:	1ac9      	subs	r1, r1, r3
 80017c6:	003d      	movs	r5, r7
 80017c8:	0030      	movs	r0, r6
 80017ca:	408f      	lsls	r7, r1
 80017cc:	4088      	lsls	r0, r1
 80017ce:	40dd      	lsrs	r5, r3
 80017d0:	1e79      	subs	r1, r7, #1
 80017d2:	418f      	sbcs	r7, r1
 80017d4:	0031      	movs	r1, r6
 80017d6:	4328      	orrs	r0, r5
 80017d8:	40d9      	lsrs	r1, r3
 80017da:	2500      	movs	r5, #0
 80017dc:	4307      	orrs	r7, r0
 80017de:	077b      	lsls	r3, r7, #29
 80017e0:	d009      	beq.n	80017f6 <__aeabi_dadd+0xf6>
 80017e2:	230f      	movs	r3, #15
 80017e4:	403b      	ands	r3, r7
 80017e6:	2b04      	cmp	r3, #4
 80017e8:	d005      	beq.n	80017f6 <__aeabi_dadd+0xf6>
 80017ea:	1d3b      	adds	r3, r7, #4
 80017ec:	42bb      	cmp	r3, r7
 80017ee:	41bf      	sbcs	r7, r7
 80017f0:	427f      	negs	r7, r7
 80017f2:	19c9      	adds	r1, r1, r7
 80017f4:	001f      	movs	r7, r3
 80017f6:	020b      	lsls	r3, r1, #8
 80017f8:	d400      	bmi.n	80017fc <__aeabi_dadd+0xfc>
 80017fa:	e277      	b.n	8001cec <__aeabi_dadd+0x5ec>
 80017fc:	1c6a      	adds	r2, r5, #1
 80017fe:	4b8a      	ldr	r3, [pc, #552]	; (8001a28 <__aeabi_dadd+0x328>)
 8001800:	0555      	lsls	r5, r2, #21
 8001802:	0d6d      	lsrs	r5, r5, #21
 8001804:	429a      	cmp	r2, r3
 8001806:	d100      	bne.n	800180a <__aeabi_dadd+0x10a>
 8001808:	e0a2      	b.n	8001950 <__aeabi_dadd+0x250>
 800180a:	4a88      	ldr	r2, [pc, #544]	; (8001a2c <__aeabi_dadd+0x32c>)
 800180c:	08ff      	lsrs	r7, r7, #3
 800180e:	400a      	ands	r2, r1
 8001810:	0750      	lsls	r0, r2, #29
 8001812:	4338      	orrs	r0, r7
 8001814:	4684      	mov	ip, r0
 8001816:	0252      	lsls	r2, r2, #9
 8001818:	0b12      	lsrs	r2, r2, #12
 800181a:	2100      	movs	r1, #0
 800181c:	0312      	lsls	r2, r2, #12
 800181e:	0b13      	lsrs	r3, r2, #12
 8001820:	0d0a      	lsrs	r2, r1, #20
 8001822:	0512      	lsls	r2, r2, #20
 8001824:	431a      	orrs	r2, r3
 8001826:	4b82      	ldr	r3, [pc, #520]	; (8001a30 <__aeabi_dadd+0x330>)
 8001828:	052d      	lsls	r5, r5, #20
 800182a:	4013      	ands	r3, r2
 800182c:	432b      	orrs	r3, r5
 800182e:	005b      	lsls	r3, r3, #1
 8001830:	07e4      	lsls	r4, r4, #31
 8001832:	085b      	lsrs	r3, r3, #1
 8001834:	4323      	orrs	r3, r4
 8001836:	4660      	mov	r0, ip
 8001838:	0019      	movs	r1, r3
 800183a:	bc0c      	pop	{r2, r3}
 800183c:	4690      	mov	r8, r2
 800183e:	4699      	mov	r9, r3
 8001840:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8001842:	2f00      	cmp	r7, #0
 8001844:	d14b      	bne.n	80018de <__aeabi_dadd+0x1de>
 8001846:	4e7b      	ldr	r6, [pc, #492]	; (8001a34 <__aeabi_dadd+0x334>)
 8001848:	1c69      	adds	r1, r5, #1
 800184a:	4231      	tst	r1, r6
 800184c:	d000      	beq.n	8001850 <__aeabi_dadd+0x150>
 800184e:	e0b7      	b.n	80019c0 <__aeabi_dadd+0x2c0>
 8001850:	4646      	mov	r6, r8
 8001852:	4649      	mov	r1, r9
 8001854:	4316      	orrs	r6, r2
 8001856:	4301      	orrs	r1, r0
 8001858:	46b4      	mov	ip, r6
 800185a:	2d00      	cmp	r5, #0
 800185c:	d000      	beq.n	8001860 <__aeabi_dadd+0x160>
 800185e:	e1ee      	b.n	8001c3e <__aeabi_dadd+0x53e>
 8001860:	2900      	cmp	r1, #0
 8001862:	d100      	bne.n	8001866 <__aeabi_dadd+0x166>
 8001864:	e1af      	b.n	8001bc6 <__aeabi_dadd+0x4c6>
 8001866:	2e00      	cmp	r6, #0
 8001868:	d000      	beq.n	800186c <__aeabi_dadd+0x16c>
 800186a:	e1f0      	b.n	8001c4e <__aeabi_dadd+0x54e>
 800186c:	464b      	mov	r3, r9
 800186e:	08c0      	lsrs	r0, r0, #3
 8001870:	075f      	lsls	r7, r3, #29
 8001872:	4307      	orrs	r7, r0
 8001874:	46bc      	mov	ip, r7
 8001876:	08d9      	lsrs	r1, r3, #3
 8001878:	e0d1      	b.n	8001a1e <__aeabi_dadd+0x31e>
 800187a:	1bab      	subs	r3, r5, r6
 800187c:	2b00      	cmp	r3, #0
 800187e:	dd6c      	ble.n	800195a <__aeabi_dadd+0x25a>
 8001880:	2e00      	cmp	r6, #0
 8001882:	d03e      	beq.n	8001902 <__aeabi_dadd+0x202>
 8001884:	4968      	ldr	r1, [pc, #416]	; (8001a28 <__aeabi_dadd+0x328>)
 8001886:	428d      	cmp	r5, r1
 8001888:	d100      	bne.n	800188c <__aeabi_dadd+0x18c>
 800188a:	e1b9      	b.n	8001c00 <__aeabi_dadd+0x500>
 800188c:	2180      	movs	r1, #128	; 0x80
 800188e:	003e      	movs	r6, r7
 8001890:	0409      	lsls	r1, r1, #16
 8001892:	430e      	orrs	r6, r1
 8001894:	46b0      	mov	r8, r6
 8001896:	2b38      	cmp	r3, #56	; 0x38
 8001898:	dd00      	ble.n	800189c <__aeabi_dadd+0x19c>
 800189a:	e11d      	b.n	8001ad8 <__aeabi_dadd+0x3d8>
 800189c:	2b1f      	cmp	r3, #31
 800189e:	dc00      	bgt.n	80018a2 <__aeabi_dadd+0x1a2>
 80018a0:	e162      	b.n	8001b68 <__aeabi_dadd+0x468>
 80018a2:	0019      	movs	r1, r3
 80018a4:	4646      	mov	r6, r8
 80018a6:	3920      	subs	r1, #32
 80018a8:	40ce      	lsrs	r6, r1
 80018aa:	2b20      	cmp	r3, #32
 80018ac:	d004      	beq.n	80018b8 <__aeabi_dadd+0x1b8>
 80018ae:	2140      	movs	r1, #64	; 0x40
 80018b0:	1acb      	subs	r3, r1, r3
 80018b2:	4641      	mov	r1, r8
 80018b4:	4099      	lsls	r1, r3
 80018b6:	430a      	orrs	r2, r1
 80018b8:	0017      	movs	r7, r2
 80018ba:	1e7a      	subs	r2, r7, #1
 80018bc:	4197      	sbcs	r7, r2
 80018be:	4337      	orrs	r7, r6
 80018c0:	e10f      	b.n	8001ae2 <__aeabi_dadd+0x3e2>
 80018c2:	4643      	mov	r3, r8
 80018c4:	4313      	orrs	r3, r2
 80018c6:	d100      	bne.n	80018ca <__aeabi_dadd+0x1ca>
 80018c8:	e09f      	b.n	8001a0a <__aeabi_dadd+0x30a>
 80018ca:	1e7b      	subs	r3, r7, #1
 80018cc:	2b00      	cmp	r3, #0
 80018ce:	d100      	bne.n	80018d2 <__aeabi_dadd+0x1d2>
 80018d0:	e18c      	b.n	8001bec <__aeabi_dadd+0x4ec>
 80018d2:	4955      	ldr	r1, [pc, #340]	; (8001a28 <__aeabi_dadd+0x328>)
 80018d4:	428f      	cmp	r7, r1
 80018d6:	d100      	bne.n	80018da <__aeabi_dadd+0x1da>
 80018d8:	e086      	b.n	80019e8 <__aeabi_dadd+0x2e8>
 80018da:	001f      	movs	r7, r3
 80018dc:	e739      	b.n	8001752 <__aeabi_dadd+0x52>
 80018de:	1b77      	subs	r7, r6, r5
 80018e0:	2d00      	cmp	r5, #0
 80018e2:	d000      	beq.n	80018e6 <__aeabi_dadd+0x1e6>
 80018e4:	e0d0      	b.n	8001a88 <__aeabi_dadd+0x388>
 80018e6:	4649      	mov	r1, r9
 80018e8:	4301      	orrs	r1, r0
 80018ea:	d100      	bne.n	80018ee <__aeabi_dadd+0x1ee>
 80018ec:	e158      	b.n	8001ba0 <__aeabi_dadd+0x4a0>
 80018ee:	1e79      	subs	r1, r7, #1
 80018f0:	2900      	cmp	r1, #0
 80018f2:	d100      	bne.n	80018f6 <__aeabi_dadd+0x1f6>
 80018f4:	e200      	b.n	8001cf8 <__aeabi_dadd+0x5f8>
 80018f6:	4c4c      	ldr	r4, [pc, #304]	; (8001a28 <__aeabi_dadd+0x328>)
 80018f8:	42a7      	cmp	r7, r4
 80018fa:	d100      	bne.n	80018fe <__aeabi_dadd+0x1fe>
 80018fc:	e249      	b.n	8001d92 <__aeabi_dadd+0x692>
 80018fe:	000f      	movs	r7, r1
 8001900:	e0cb      	b.n	8001a9a <__aeabi_dadd+0x39a>
 8001902:	0039      	movs	r1, r7
 8001904:	4311      	orrs	r1, r2
 8001906:	d100      	bne.n	800190a <__aeabi_dadd+0x20a>
 8001908:	e181      	b.n	8001c0e <__aeabi_dadd+0x50e>
 800190a:	1e59      	subs	r1, r3, #1
 800190c:	2900      	cmp	r1, #0
 800190e:	d100      	bne.n	8001912 <__aeabi_dadd+0x212>
 8001910:	e139      	b.n	8001b86 <__aeabi_dadd+0x486>
 8001912:	4e45      	ldr	r6, [pc, #276]	; (8001a28 <__aeabi_dadd+0x328>)
 8001914:	42b3      	cmp	r3, r6
 8001916:	d100      	bne.n	800191a <__aeabi_dadd+0x21a>
 8001918:	e172      	b.n	8001c00 <__aeabi_dadd+0x500>
 800191a:	000b      	movs	r3, r1
 800191c:	e7bb      	b.n	8001896 <__aeabi_dadd+0x196>
 800191e:	4b42      	ldr	r3, [pc, #264]	; (8001a28 <__aeabi_dadd+0x328>)
 8001920:	429e      	cmp	r6, r3
 8001922:	d100      	bne.n	8001926 <__aeabi_dadd+0x226>
 8001924:	e219      	b.n	8001d5a <__aeabi_dadd+0x65a>
 8001926:	1882      	adds	r2, r0, r2
 8001928:	4282      	cmp	r2, r0
 800192a:	4180      	sbcs	r0, r0
 800192c:	4649      	mov	r1, r9
 800192e:	0035      	movs	r5, r6
 8001930:	4441      	add	r1, r8
 8001932:	4240      	negs	r0, r0
 8001934:	1809      	adds	r1, r1, r0
 8001936:	07cf      	lsls	r7, r1, #31
 8001938:	0852      	lsrs	r2, r2, #1
 800193a:	4317      	orrs	r7, r2
 800193c:	0849      	lsrs	r1, r1, #1
 800193e:	077b      	lsls	r3, r7, #29
 8001940:	d000      	beq.n	8001944 <__aeabi_dadd+0x244>
 8001942:	e74e      	b.n	80017e2 <__aeabi_dadd+0xe2>
 8001944:	0748      	lsls	r0, r1, #29
 8001946:	08ff      	lsrs	r7, r7, #3
 8001948:	4307      	orrs	r7, r0
 800194a:	46bc      	mov	ip, r7
 800194c:	08c9      	lsrs	r1, r1, #3
 800194e:	e063      	b.n	8001a18 <__aeabi_dadd+0x318>
 8001950:	0015      	movs	r5, r2
 8001952:	2300      	movs	r3, #0
 8001954:	2200      	movs	r2, #0
 8001956:	469c      	mov	ip, r3
 8001958:	e75f      	b.n	800181a <__aeabi_dadd+0x11a>
 800195a:	2b00      	cmp	r3, #0
 800195c:	d16c      	bne.n	8001a38 <__aeabi_dadd+0x338>
 800195e:	4b35      	ldr	r3, [pc, #212]	; (8001a34 <__aeabi_dadd+0x334>)
 8001960:	1c6e      	adds	r6, r5, #1
 8001962:	421e      	tst	r6, r3
 8001964:	d1db      	bne.n	800191e <__aeabi_dadd+0x21e>
 8001966:	464b      	mov	r3, r9
 8001968:	4303      	orrs	r3, r0
 800196a:	2d00      	cmp	r5, #0
 800196c:	d000      	beq.n	8001970 <__aeabi_dadd+0x270>
 800196e:	e120      	b.n	8001bb2 <__aeabi_dadd+0x4b2>
 8001970:	2b00      	cmp	r3, #0
 8001972:	d100      	bne.n	8001976 <__aeabi_dadd+0x276>
 8001974:	e1cb      	b.n	8001d0e <__aeabi_dadd+0x60e>
 8001976:	003b      	movs	r3, r7
 8001978:	4313      	orrs	r3, r2
 800197a:	d000      	beq.n	800197e <__aeabi_dadd+0x27e>
 800197c:	e1ce      	b.n	8001d1c <__aeabi_dadd+0x61c>
 800197e:	464b      	mov	r3, r9
 8001980:	08c0      	lsrs	r0, r0, #3
 8001982:	075f      	lsls	r7, r3, #29
 8001984:	4338      	orrs	r0, r7
 8001986:	4684      	mov	ip, r0
 8001988:	08d9      	lsrs	r1, r3, #3
 800198a:	e048      	b.n	8001a1e <__aeabi_dadd+0x31e>
 800198c:	4927      	ldr	r1, [pc, #156]	; (8001a2c <__aeabi_dadd+0x32c>)
 800198e:	1aed      	subs	r5, r5, r3
 8001990:	4031      	ands	r1, r6
 8001992:	077b      	lsls	r3, r7, #29
 8001994:	d000      	beq.n	8001998 <__aeabi_dadd+0x298>
 8001996:	e724      	b.n	80017e2 <__aeabi_dadd+0xe2>
 8001998:	e7d4      	b.n	8001944 <__aeabi_dadd+0x244>
 800199a:	0038      	movs	r0, r7
 800199c:	f001 fe00 	bl	80035a0 <__clzsi2>
 80019a0:	0003      	movs	r3, r0
 80019a2:	3318      	adds	r3, #24
 80019a4:	2b1f      	cmp	r3, #31
 80019a6:	dc00      	bgt.n	80019aa <__aeabi_dadd+0x2aa>
 80019a8:	e6fc      	b.n	80017a4 <__aeabi_dadd+0xa4>
 80019aa:	003e      	movs	r6, r7
 80019ac:	3808      	subs	r0, #8
 80019ae:	4086      	lsls	r6, r0
 80019b0:	2700      	movs	r7, #0
 80019b2:	e6fe      	b.n	80017b2 <__aeabi_dadd+0xb2>
 80019b4:	4643      	mov	r3, r8
 80019b6:	4313      	orrs	r3, r2
 80019b8:	001a      	movs	r2, r3
 80019ba:	1e57      	subs	r7, r2, #1
 80019bc:	41ba      	sbcs	r2, r7
 80019be:	e6de      	b.n	800177e <__aeabi_dadd+0x7e>
 80019c0:	4649      	mov	r1, r9
 80019c2:	4646      	mov	r6, r8
 80019c4:	1a87      	subs	r7, r0, r2
 80019c6:	1b8e      	subs	r6, r1, r6
 80019c8:	42b8      	cmp	r0, r7
 80019ca:	4189      	sbcs	r1, r1
 80019cc:	4249      	negs	r1, r1
 80019ce:	1a76      	subs	r6, r6, r1
 80019d0:	0231      	lsls	r1, r6, #8
 80019d2:	d500      	bpl.n	80019d6 <__aeabi_dadd+0x2d6>
 80019d4:	e129      	b.n	8001c2a <__aeabi_dadd+0x52a>
 80019d6:	003b      	movs	r3, r7
 80019d8:	4333      	orrs	r3, r6
 80019da:	469c      	mov	ip, r3
 80019dc:	d000      	beq.n	80019e0 <__aeabi_dadd+0x2e0>
 80019de:	e6d9      	b.n	8001794 <__aeabi_dadd+0x94>
 80019e0:	2100      	movs	r1, #0
 80019e2:	2400      	movs	r4, #0
 80019e4:	2500      	movs	r5, #0
 80019e6:	e01a      	b.n	8001a1e <__aeabi_dadd+0x31e>
 80019e8:	464b      	mov	r3, r9
 80019ea:	08c0      	lsrs	r0, r0, #3
 80019ec:	075f      	lsls	r7, r3, #29
 80019ee:	4307      	orrs	r7, r0
 80019f0:	46bc      	mov	ip, r7
 80019f2:	08d9      	lsrs	r1, r3, #3
 80019f4:	4663      	mov	r3, ip
 80019f6:	430b      	orrs	r3, r1
 80019f8:	d100      	bne.n	80019fc <__aeabi_dadd+0x2fc>
 80019fa:	e1ef      	b.n	8001ddc <__aeabi_dadd+0x6dc>
 80019fc:	2280      	movs	r2, #128	; 0x80
 80019fe:	0312      	lsls	r2, r2, #12
 8001a00:	430a      	orrs	r2, r1
 8001a02:	0312      	lsls	r2, r2, #12
 8001a04:	0b12      	lsrs	r2, r2, #12
 8001a06:	4d08      	ldr	r5, [pc, #32]	; (8001a28 <__aeabi_dadd+0x328>)
 8001a08:	e707      	b.n	800181a <__aeabi_dadd+0x11a>
 8001a0a:	464b      	mov	r3, r9
 8001a0c:	08c0      	lsrs	r0, r0, #3
 8001a0e:	075a      	lsls	r2, r3, #29
 8001a10:	4302      	orrs	r2, r0
 8001a12:	4694      	mov	ip, r2
 8001a14:	003d      	movs	r5, r7
 8001a16:	08d9      	lsrs	r1, r3, #3
 8001a18:	4b03      	ldr	r3, [pc, #12]	; (8001a28 <__aeabi_dadd+0x328>)
 8001a1a:	429d      	cmp	r5, r3
 8001a1c:	d0ea      	beq.n	80019f4 <__aeabi_dadd+0x2f4>
 8001a1e:	030a      	lsls	r2, r1, #12
 8001a20:	056d      	lsls	r5, r5, #21
 8001a22:	0b12      	lsrs	r2, r2, #12
 8001a24:	0d6d      	lsrs	r5, r5, #21
 8001a26:	e6f8      	b.n	800181a <__aeabi_dadd+0x11a>
 8001a28:	000007ff 	.word	0x000007ff
 8001a2c:	ff7fffff 	.word	0xff7fffff
 8001a30:	800fffff 	.word	0x800fffff
 8001a34:	000007fe 	.word	0x000007fe
 8001a38:	1b73      	subs	r3, r6, r5
 8001a3a:	2d00      	cmp	r5, #0
 8001a3c:	d100      	bne.n	8001a40 <__aeabi_dadd+0x340>
 8001a3e:	e085      	b.n	8001b4c <__aeabi_dadd+0x44c>
 8001a40:	49d8      	ldr	r1, [pc, #864]	; (8001da4 <__aeabi_dadd+0x6a4>)
 8001a42:	428e      	cmp	r6, r1
 8001a44:	d100      	bne.n	8001a48 <__aeabi_dadd+0x348>
 8001a46:	e179      	b.n	8001d3c <__aeabi_dadd+0x63c>
 8001a48:	2180      	movs	r1, #128	; 0x80
 8001a4a:	464d      	mov	r5, r9
 8001a4c:	0409      	lsls	r1, r1, #16
 8001a4e:	430d      	orrs	r5, r1
 8001a50:	46a9      	mov	r9, r5
 8001a52:	2b38      	cmp	r3, #56	; 0x38
 8001a54:	dd00      	ble.n	8001a58 <__aeabi_dadd+0x358>
 8001a56:	e10e      	b.n	8001c76 <__aeabi_dadd+0x576>
 8001a58:	2b1f      	cmp	r3, #31
 8001a5a:	dd00      	ble.n	8001a5e <__aeabi_dadd+0x35e>
 8001a5c:	e1a6      	b.n	8001dac <__aeabi_dadd+0x6ac>
 8001a5e:	2120      	movs	r1, #32
 8001a60:	1ac9      	subs	r1, r1, r3
 8001a62:	0005      	movs	r5, r0
 8001a64:	464f      	mov	r7, r9
 8001a66:	4088      	lsls	r0, r1
 8001a68:	408f      	lsls	r7, r1
 8001a6a:	1e41      	subs	r1, r0, #1
 8001a6c:	4188      	sbcs	r0, r1
 8001a6e:	4649      	mov	r1, r9
 8001a70:	40dd      	lsrs	r5, r3
 8001a72:	40d9      	lsrs	r1, r3
 8001a74:	432f      	orrs	r7, r5
 8001a76:	4307      	orrs	r7, r0
 8001a78:	4488      	add	r8, r1
 8001a7a:	18bf      	adds	r7, r7, r2
 8001a7c:	4297      	cmp	r7, r2
 8001a7e:	4192      	sbcs	r2, r2
 8001a80:	4251      	negs	r1, r2
 8001a82:	4441      	add	r1, r8
 8001a84:	0035      	movs	r5, r6
 8001a86:	e031      	b.n	8001aec <__aeabi_dadd+0x3ec>
 8001a88:	49c6      	ldr	r1, [pc, #792]	; (8001da4 <__aeabi_dadd+0x6a4>)
 8001a8a:	428e      	cmp	r6, r1
 8001a8c:	d100      	bne.n	8001a90 <__aeabi_dadd+0x390>
 8001a8e:	e0a5      	b.n	8001bdc <__aeabi_dadd+0x4dc>
 8001a90:	2180      	movs	r1, #128	; 0x80
 8001a92:	464c      	mov	r4, r9
 8001a94:	0409      	lsls	r1, r1, #16
 8001a96:	430c      	orrs	r4, r1
 8001a98:	46a1      	mov	r9, r4
 8001a9a:	2f38      	cmp	r7, #56	; 0x38
 8001a9c:	dd00      	ble.n	8001aa0 <__aeabi_dadd+0x3a0>
 8001a9e:	e0be      	b.n	8001c1e <__aeabi_dadd+0x51e>
 8001aa0:	2f1f      	cmp	r7, #31
 8001aa2:	dd00      	ble.n	8001aa6 <__aeabi_dadd+0x3a6>
 8001aa4:	e0ed      	b.n	8001c82 <__aeabi_dadd+0x582>
 8001aa6:	2120      	movs	r1, #32
 8001aa8:	0005      	movs	r5, r0
 8001aaa:	1bc9      	subs	r1, r1, r7
 8001aac:	464c      	mov	r4, r9
 8001aae:	4088      	lsls	r0, r1
 8001ab0:	408c      	lsls	r4, r1
 8001ab2:	40fd      	lsrs	r5, r7
 8001ab4:	1e41      	subs	r1, r0, #1
 8001ab6:	4188      	sbcs	r0, r1
 8001ab8:	4649      	mov	r1, r9
 8001aba:	432c      	orrs	r4, r5
 8001abc:	4320      	orrs	r0, r4
 8001abe:	40f9      	lsrs	r1, r7
 8001ac0:	4644      	mov	r4, r8
 8001ac2:	1a61      	subs	r1, r4, r1
 8001ac4:	4688      	mov	r8, r1
 8001ac6:	1a17      	subs	r7, r2, r0
 8001ac8:	42ba      	cmp	r2, r7
 8001aca:	4192      	sbcs	r2, r2
 8001acc:	4641      	mov	r1, r8
 8001ace:	4252      	negs	r2, r2
 8001ad0:	1a89      	subs	r1, r1, r2
 8001ad2:	001c      	movs	r4, r3
 8001ad4:	0035      	movs	r5, r6
 8001ad6:	e658      	b.n	800178a <__aeabi_dadd+0x8a>
 8001ad8:	4643      	mov	r3, r8
 8001ada:	4313      	orrs	r3, r2
 8001adc:	001f      	movs	r7, r3
 8001ade:	1e7a      	subs	r2, r7, #1
 8001ae0:	4197      	sbcs	r7, r2
 8001ae2:	183f      	adds	r7, r7, r0
 8001ae4:	4287      	cmp	r7, r0
 8001ae6:	4180      	sbcs	r0, r0
 8001ae8:	4241      	negs	r1, r0
 8001aea:	4449      	add	r1, r9
 8001aec:	020b      	lsls	r3, r1, #8
 8001aee:	d400      	bmi.n	8001af2 <__aeabi_dadd+0x3f2>
 8001af0:	e725      	b.n	800193e <__aeabi_dadd+0x23e>
 8001af2:	4bac      	ldr	r3, [pc, #688]	; (8001da4 <__aeabi_dadd+0x6a4>)
 8001af4:	3501      	adds	r5, #1
 8001af6:	429d      	cmp	r5, r3
 8001af8:	d100      	bne.n	8001afc <__aeabi_dadd+0x3fc>
 8001afa:	e72a      	b.n	8001952 <__aeabi_dadd+0x252>
 8001afc:	4aaa      	ldr	r2, [pc, #680]	; (8001da8 <__aeabi_dadd+0x6a8>)
 8001afe:	087b      	lsrs	r3, r7, #1
 8001b00:	400a      	ands	r2, r1
 8001b02:	2101      	movs	r1, #1
 8001b04:	400f      	ands	r7, r1
 8001b06:	431f      	orrs	r7, r3
 8001b08:	07d3      	lsls	r3, r2, #31
 8001b0a:	431f      	orrs	r7, r3
 8001b0c:	0851      	lsrs	r1, r2, #1
 8001b0e:	e666      	b.n	80017de <__aeabi_dadd+0xde>
 8001b10:	0030      	movs	r0, r6
 8001b12:	3d1f      	subs	r5, #31
 8001b14:	40e8      	lsrs	r0, r5
 8001b16:	2b20      	cmp	r3, #32
 8001b18:	d003      	beq.n	8001b22 <__aeabi_dadd+0x422>
 8001b1a:	2140      	movs	r1, #64	; 0x40
 8001b1c:	1acb      	subs	r3, r1, r3
 8001b1e:	409e      	lsls	r6, r3
 8001b20:	4337      	orrs	r7, r6
 8001b22:	1e7b      	subs	r3, r7, #1
 8001b24:	419f      	sbcs	r7, r3
 8001b26:	2100      	movs	r1, #0
 8001b28:	4307      	orrs	r7, r0
 8001b2a:	2500      	movs	r5, #0
 8001b2c:	e707      	b.n	800193e <__aeabi_dadd+0x23e>
 8001b2e:	003b      	movs	r3, r7
 8001b30:	4646      	mov	r6, r8
 8001b32:	3b20      	subs	r3, #32
 8001b34:	40de      	lsrs	r6, r3
 8001b36:	2f20      	cmp	r7, #32
 8001b38:	d004      	beq.n	8001b44 <__aeabi_dadd+0x444>
 8001b3a:	2340      	movs	r3, #64	; 0x40
 8001b3c:	4641      	mov	r1, r8
 8001b3e:	1bdb      	subs	r3, r3, r7
 8001b40:	4099      	lsls	r1, r3
 8001b42:	430a      	orrs	r2, r1
 8001b44:	1e57      	subs	r7, r2, #1
 8001b46:	41ba      	sbcs	r2, r7
 8001b48:	4332      	orrs	r2, r6
 8001b4a:	e618      	b.n	800177e <__aeabi_dadd+0x7e>
 8001b4c:	4649      	mov	r1, r9
 8001b4e:	4301      	orrs	r1, r0
 8001b50:	d100      	bne.n	8001b54 <__aeabi_dadd+0x454>
 8001b52:	e0fa      	b.n	8001d4a <__aeabi_dadd+0x64a>
 8001b54:	1e59      	subs	r1, r3, #1
 8001b56:	2900      	cmp	r1, #0
 8001b58:	d100      	bne.n	8001b5c <__aeabi_dadd+0x45c>
 8001b5a:	e137      	b.n	8001dcc <__aeabi_dadd+0x6cc>
 8001b5c:	4d91      	ldr	r5, [pc, #580]	; (8001da4 <__aeabi_dadd+0x6a4>)
 8001b5e:	42ab      	cmp	r3, r5
 8001b60:	d100      	bne.n	8001b64 <__aeabi_dadd+0x464>
 8001b62:	e0eb      	b.n	8001d3c <__aeabi_dadd+0x63c>
 8001b64:	000b      	movs	r3, r1
 8001b66:	e774      	b.n	8001a52 <__aeabi_dadd+0x352>
 8001b68:	2120      	movs	r1, #32
 8001b6a:	1ac9      	subs	r1, r1, r3
 8001b6c:	0016      	movs	r6, r2
 8001b6e:	4647      	mov	r7, r8
 8001b70:	408a      	lsls	r2, r1
 8001b72:	408f      	lsls	r7, r1
 8001b74:	1e51      	subs	r1, r2, #1
 8001b76:	418a      	sbcs	r2, r1
 8001b78:	4641      	mov	r1, r8
 8001b7a:	40de      	lsrs	r6, r3
 8001b7c:	40d9      	lsrs	r1, r3
 8001b7e:	4337      	orrs	r7, r6
 8001b80:	4317      	orrs	r7, r2
 8001b82:	4489      	add	r9, r1
 8001b84:	e7ad      	b.n	8001ae2 <__aeabi_dadd+0x3e2>
 8001b86:	1887      	adds	r7, r0, r2
 8001b88:	4649      	mov	r1, r9
 8001b8a:	4287      	cmp	r7, r0
 8001b8c:	419b      	sbcs	r3, r3
 8001b8e:	4441      	add	r1, r8
 8001b90:	425b      	negs	r3, r3
 8001b92:	18c9      	adds	r1, r1, r3
 8001b94:	2501      	movs	r5, #1
 8001b96:	020b      	lsls	r3, r1, #8
 8001b98:	d400      	bmi.n	8001b9c <__aeabi_dadd+0x49c>
 8001b9a:	e6d0      	b.n	800193e <__aeabi_dadd+0x23e>
 8001b9c:	2502      	movs	r5, #2
 8001b9e:	e7ad      	b.n	8001afc <__aeabi_dadd+0x3fc>
 8001ba0:	4641      	mov	r1, r8
 8001ba2:	08d2      	lsrs	r2, r2, #3
 8001ba4:	0748      	lsls	r0, r1, #29
 8001ba6:	4310      	orrs	r0, r2
 8001ba8:	4684      	mov	ip, r0
 8001baa:	08c9      	lsrs	r1, r1, #3
 8001bac:	001c      	movs	r4, r3
 8001bae:	003d      	movs	r5, r7
 8001bb0:	e732      	b.n	8001a18 <__aeabi_dadd+0x318>
 8001bb2:	2b00      	cmp	r3, #0
 8001bb4:	d000      	beq.n	8001bb8 <__aeabi_dadd+0x4b8>
 8001bb6:	e0d5      	b.n	8001d64 <__aeabi_dadd+0x664>
 8001bb8:	003b      	movs	r3, r7
 8001bba:	08d2      	lsrs	r2, r2, #3
 8001bbc:	077f      	lsls	r7, r7, #29
 8001bbe:	4317      	orrs	r7, r2
 8001bc0:	46bc      	mov	ip, r7
 8001bc2:	08d9      	lsrs	r1, r3, #3
 8001bc4:	e716      	b.n	80019f4 <__aeabi_dadd+0x2f4>
 8001bc6:	2e00      	cmp	r6, #0
 8001bc8:	d100      	bne.n	8001bcc <__aeabi_dadd+0x4cc>
 8001bca:	e08c      	b.n	8001ce6 <__aeabi_dadd+0x5e6>
 8001bcc:	4641      	mov	r1, r8
 8001bce:	08d2      	lsrs	r2, r2, #3
 8001bd0:	074f      	lsls	r7, r1, #29
 8001bd2:	433a      	orrs	r2, r7
 8001bd4:	4694      	mov	ip, r2
 8001bd6:	08c9      	lsrs	r1, r1, #3
 8001bd8:	001c      	movs	r4, r3
 8001bda:	e720      	b.n	8001a1e <__aeabi_dadd+0x31e>
 8001bdc:	4641      	mov	r1, r8
 8001bde:	08d2      	lsrs	r2, r2, #3
 8001be0:	074f      	lsls	r7, r1, #29
 8001be2:	4317      	orrs	r7, r2
 8001be4:	46bc      	mov	ip, r7
 8001be6:	08c9      	lsrs	r1, r1, #3
 8001be8:	001c      	movs	r4, r3
 8001bea:	e703      	b.n	80019f4 <__aeabi_dadd+0x2f4>
 8001bec:	1a87      	subs	r7, r0, r2
 8001bee:	464b      	mov	r3, r9
 8001bf0:	4642      	mov	r2, r8
 8001bf2:	42b8      	cmp	r0, r7
 8001bf4:	4180      	sbcs	r0, r0
 8001bf6:	1a99      	subs	r1, r3, r2
 8001bf8:	4240      	negs	r0, r0
 8001bfa:	1a09      	subs	r1, r1, r0
 8001bfc:	2501      	movs	r5, #1
 8001bfe:	e5c4      	b.n	800178a <__aeabi_dadd+0x8a>
 8001c00:	464b      	mov	r3, r9
 8001c02:	08c0      	lsrs	r0, r0, #3
 8001c04:	075f      	lsls	r7, r3, #29
 8001c06:	4338      	orrs	r0, r7
 8001c08:	4684      	mov	ip, r0
 8001c0a:	08d9      	lsrs	r1, r3, #3
 8001c0c:	e6f2      	b.n	80019f4 <__aeabi_dadd+0x2f4>
 8001c0e:	464a      	mov	r2, r9
 8001c10:	08c0      	lsrs	r0, r0, #3
 8001c12:	0757      	lsls	r7, r2, #29
 8001c14:	4338      	orrs	r0, r7
 8001c16:	4684      	mov	ip, r0
 8001c18:	08d1      	lsrs	r1, r2, #3
 8001c1a:	001d      	movs	r5, r3
 8001c1c:	e6fc      	b.n	8001a18 <__aeabi_dadd+0x318>
 8001c1e:	4649      	mov	r1, r9
 8001c20:	4301      	orrs	r1, r0
 8001c22:	0008      	movs	r0, r1
 8001c24:	1e47      	subs	r7, r0, #1
 8001c26:	41b8      	sbcs	r0, r7
 8001c28:	e74d      	b.n	8001ac6 <__aeabi_dadd+0x3c6>
 8001c2a:	1a17      	subs	r7, r2, r0
 8001c2c:	4641      	mov	r1, r8
 8001c2e:	4648      	mov	r0, r9
 8001c30:	42ba      	cmp	r2, r7
 8001c32:	41b6      	sbcs	r6, r6
 8001c34:	1a09      	subs	r1, r1, r0
 8001c36:	4276      	negs	r6, r6
 8001c38:	1b8e      	subs	r6, r1, r6
 8001c3a:	001c      	movs	r4, r3
 8001c3c:	e5aa      	b.n	8001794 <__aeabi_dadd+0x94>
 8001c3e:	2900      	cmp	r1, #0
 8001c40:	d12e      	bne.n	8001ca0 <__aeabi_dadd+0x5a0>
 8001c42:	2e00      	cmp	r6, #0
 8001c44:	d1ca      	bne.n	8001bdc <__aeabi_dadd+0x4dc>
 8001c46:	2180      	movs	r1, #128	; 0x80
 8001c48:	2400      	movs	r4, #0
 8001c4a:	0309      	lsls	r1, r1, #12
 8001c4c:	e6d6      	b.n	80019fc <__aeabi_dadd+0x2fc>
 8001c4e:	4649      	mov	r1, r9
 8001c50:	4646      	mov	r6, r8
 8001c52:	1a87      	subs	r7, r0, r2
 8001c54:	1b8e      	subs	r6, r1, r6
 8001c56:	42b8      	cmp	r0, r7
 8001c58:	4189      	sbcs	r1, r1
 8001c5a:	4249      	negs	r1, r1
 8001c5c:	1a71      	subs	r1, r6, r1
 8001c5e:	020e      	lsls	r6, r1, #8
 8001c60:	d53c      	bpl.n	8001cdc <__aeabi_dadd+0x5dc>
 8001c62:	1a17      	subs	r7, r2, r0
 8001c64:	4641      	mov	r1, r8
 8001c66:	4648      	mov	r0, r9
 8001c68:	42ba      	cmp	r2, r7
 8001c6a:	4192      	sbcs	r2, r2
 8001c6c:	1a09      	subs	r1, r1, r0
 8001c6e:	4252      	negs	r2, r2
 8001c70:	1a89      	subs	r1, r1, r2
 8001c72:	001c      	movs	r4, r3
 8001c74:	e5b3      	b.n	80017de <__aeabi_dadd+0xde>
 8001c76:	464b      	mov	r3, r9
 8001c78:	4303      	orrs	r3, r0
 8001c7a:	001f      	movs	r7, r3
 8001c7c:	1e78      	subs	r0, r7, #1
 8001c7e:	4187      	sbcs	r7, r0
 8001c80:	e6fb      	b.n	8001a7a <__aeabi_dadd+0x37a>
 8001c82:	0039      	movs	r1, r7
 8001c84:	464c      	mov	r4, r9
 8001c86:	3920      	subs	r1, #32
 8001c88:	40cc      	lsrs	r4, r1
 8001c8a:	2f20      	cmp	r7, #32
 8001c8c:	d004      	beq.n	8001c98 <__aeabi_dadd+0x598>
 8001c8e:	2140      	movs	r1, #64	; 0x40
 8001c90:	464d      	mov	r5, r9
 8001c92:	1bc9      	subs	r1, r1, r7
 8001c94:	408d      	lsls	r5, r1
 8001c96:	4328      	orrs	r0, r5
 8001c98:	1e41      	subs	r1, r0, #1
 8001c9a:	4188      	sbcs	r0, r1
 8001c9c:	4320      	orrs	r0, r4
 8001c9e:	e712      	b.n	8001ac6 <__aeabi_dadd+0x3c6>
 8001ca0:	4649      	mov	r1, r9
 8001ca2:	08c0      	lsrs	r0, r0, #3
 8001ca4:	074d      	lsls	r5, r1, #29
 8001ca6:	4328      	orrs	r0, r5
 8001ca8:	08c9      	lsrs	r1, r1, #3
 8001caa:	2e00      	cmp	r6, #0
 8001cac:	d044      	beq.n	8001d38 <__aeabi_dadd+0x638>
 8001cae:	2580      	movs	r5, #128	; 0x80
 8001cb0:	032d      	lsls	r5, r5, #12
 8001cb2:	4229      	tst	r1, r5
 8001cb4:	d008      	beq.n	8001cc8 <__aeabi_dadd+0x5c8>
 8001cb6:	4646      	mov	r6, r8
 8001cb8:	08f7      	lsrs	r7, r6, #3
 8001cba:	422f      	tst	r7, r5
 8001cbc:	d104      	bne.n	8001cc8 <__aeabi_dadd+0x5c8>
 8001cbe:	001c      	movs	r4, r3
 8001cc0:	0039      	movs	r1, r7
 8001cc2:	08d2      	lsrs	r2, r2, #3
 8001cc4:	0770      	lsls	r0, r6, #29
 8001cc6:	4310      	orrs	r0, r2
 8001cc8:	00ca      	lsls	r2, r1, #3
 8001cca:	0f43      	lsrs	r3, r0, #29
 8001ccc:	431a      	orrs	r2, r3
 8001cce:	00c0      	lsls	r0, r0, #3
 8001cd0:	0757      	lsls	r7, r2, #29
 8001cd2:	08c0      	lsrs	r0, r0, #3
 8001cd4:	4307      	orrs	r7, r0
 8001cd6:	46bc      	mov	ip, r7
 8001cd8:	08d1      	lsrs	r1, r2, #3
 8001cda:	e68b      	b.n	80019f4 <__aeabi_dadd+0x2f4>
 8001cdc:	003b      	movs	r3, r7
 8001cde:	430b      	orrs	r3, r1
 8001ce0:	469c      	mov	ip, r3
 8001ce2:	d000      	beq.n	8001ce6 <__aeabi_dadd+0x5e6>
 8001ce4:	e62b      	b.n	800193e <__aeabi_dadd+0x23e>
 8001ce6:	2100      	movs	r1, #0
 8001ce8:	2400      	movs	r4, #0
 8001cea:	e698      	b.n	8001a1e <__aeabi_dadd+0x31e>
 8001cec:	074b      	lsls	r3, r1, #29
 8001cee:	08ff      	lsrs	r7, r7, #3
 8001cf0:	431f      	orrs	r7, r3
 8001cf2:	46bc      	mov	ip, r7
 8001cf4:	08c9      	lsrs	r1, r1, #3
 8001cf6:	e68f      	b.n	8001a18 <__aeabi_dadd+0x318>
 8001cf8:	1a17      	subs	r7, r2, r0
 8001cfa:	4641      	mov	r1, r8
 8001cfc:	4648      	mov	r0, r9
 8001cfe:	42ba      	cmp	r2, r7
 8001d00:	4192      	sbcs	r2, r2
 8001d02:	1a09      	subs	r1, r1, r0
 8001d04:	4252      	negs	r2, r2
 8001d06:	1a89      	subs	r1, r1, r2
 8001d08:	001c      	movs	r4, r3
 8001d0a:	2501      	movs	r5, #1
 8001d0c:	e53d      	b.n	800178a <__aeabi_dadd+0x8a>
 8001d0e:	003b      	movs	r3, r7
 8001d10:	08d2      	lsrs	r2, r2, #3
 8001d12:	077f      	lsls	r7, r7, #29
 8001d14:	4317      	orrs	r7, r2
 8001d16:	46bc      	mov	ip, r7
 8001d18:	08d9      	lsrs	r1, r3, #3
 8001d1a:	e680      	b.n	8001a1e <__aeabi_dadd+0x31e>
 8001d1c:	1887      	adds	r7, r0, r2
 8001d1e:	4649      	mov	r1, r9
 8001d20:	4287      	cmp	r7, r0
 8001d22:	419b      	sbcs	r3, r3
 8001d24:	4441      	add	r1, r8
 8001d26:	425b      	negs	r3, r3
 8001d28:	18c9      	adds	r1, r1, r3
 8001d2a:	020b      	lsls	r3, r1, #8
 8001d2c:	d400      	bmi.n	8001d30 <__aeabi_dadd+0x630>
 8001d2e:	e606      	b.n	800193e <__aeabi_dadd+0x23e>
 8001d30:	4b1d      	ldr	r3, [pc, #116]	; (8001da8 <__aeabi_dadd+0x6a8>)
 8001d32:	2501      	movs	r5, #1
 8001d34:	4019      	ands	r1, r3
 8001d36:	e602      	b.n	800193e <__aeabi_dadd+0x23e>
 8001d38:	4684      	mov	ip, r0
 8001d3a:	e65b      	b.n	80019f4 <__aeabi_dadd+0x2f4>
 8001d3c:	4643      	mov	r3, r8
 8001d3e:	08d2      	lsrs	r2, r2, #3
 8001d40:	075f      	lsls	r7, r3, #29
 8001d42:	433a      	orrs	r2, r7
 8001d44:	4694      	mov	ip, r2
 8001d46:	08d9      	lsrs	r1, r3, #3
 8001d48:	e654      	b.n	80019f4 <__aeabi_dadd+0x2f4>
 8001d4a:	0039      	movs	r1, r7
 8001d4c:	08d2      	lsrs	r2, r2, #3
 8001d4e:	077f      	lsls	r7, r7, #29
 8001d50:	4317      	orrs	r7, r2
 8001d52:	46bc      	mov	ip, r7
 8001d54:	08c9      	lsrs	r1, r1, #3
 8001d56:	001d      	movs	r5, r3
 8001d58:	e65e      	b.n	8001a18 <__aeabi_dadd+0x318>
 8001d5a:	2300      	movs	r3, #0
 8001d5c:	0035      	movs	r5, r6
 8001d5e:	2200      	movs	r2, #0
 8001d60:	469c      	mov	ip, r3
 8001d62:	e55a      	b.n	800181a <__aeabi_dadd+0x11a>
 8001d64:	464b      	mov	r3, r9
 8001d66:	075f      	lsls	r7, r3, #29
 8001d68:	08d9      	lsrs	r1, r3, #3
 8001d6a:	4643      	mov	r3, r8
 8001d6c:	08c0      	lsrs	r0, r0, #3
 8001d6e:	4313      	orrs	r3, r2
 8001d70:	4338      	orrs	r0, r7
 8001d72:	2b00      	cmp	r3, #0
 8001d74:	d0e0      	beq.n	8001d38 <__aeabi_dadd+0x638>
 8001d76:	2380      	movs	r3, #128	; 0x80
 8001d78:	031b      	lsls	r3, r3, #12
 8001d7a:	4219      	tst	r1, r3
 8001d7c:	d0a4      	beq.n	8001cc8 <__aeabi_dadd+0x5c8>
 8001d7e:	4645      	mov	r5, r8
 8001d80:	08ed      	lsrs	r5, r5, #3
 8001d82:	421d      	tst	r5, r3
 8001d84:	d1a0      	bne.n	8001cc8 <__aeabi_dadd+0x5c8>
 8001d86:	4643      	mov	r3, r8
 8001d88:	08d2      	lsrs	r2, r2, #3
 8001d8a:	0758      	lsls	r0, r3, #29
 8001d8c:	4310      	orrs	r0, r2
 8001d8e:	0029      	movs	r1, r5
 8001d90:	e79a      	b.n	8001cc8 <__aeabi_dadd+0x5c8>
 8001d92:	4641      	mov	r1, r8
 8001d94:	08d2      	lsrs	r2, r2, #3
 8001d96:	074f      	lsls	r7, r1, #29
 8001d98:	433a      	orrs	r2, r7
 8001d9a:	4694      	mov	ip, r2
 8001d9c:	08c9      	lsrs	r1, r1, #3
 8001d9e:	001c      	movs	r4, r3
 8001da0:	e628      	b.n	80019f4 <__aeabi_dadd+0x2f4>
 8001da2:	46c0      	nop			; (mov r8, r8)
 8001da4:	000007ff 	.word	0x000007ff
 8001da8:	ff7fffff 	.word	0xff7fffff
 8001dac:	0019      	movs	r1, r3
 8001dae:	464d      	mov	r5, r9
 8001db0:	3920      	subs	r1, #32
 8001db2:	40cd      	lsrs	r5, r1
 8001db4:	2b20      	cmp	r3, #32
 8001db6:	d004      	beq.n	8001dc2 <__aeabi_dadd+0x6c2>
 8001db8:	2140      	movs	r1, #64	; 0x40
 8001dba:	1acb      	subs	r3, r1, r3
 8001dbc:	4649      	mov	r1, r9
 8001dbe:	4099      	lsls	r1, r3
 8001dc0:	4308      	orrs	r0, r1
 8001dc2:	0007      	movs	r7, r0
 8001dc4:	1e78      	subs	r0, r7, #1
 8001dc6:	4187      	sbcs	r7, r0
 8001dc8:	432f      	orrs	r7, r5
 8001dca:	e656      	b.n	8001a7a <__aeabi_dadd+0x37a>
 8001dcc:	1887      	adds	r7, r0, r2
 8001dce:	4649      	mov	r1, r9
 8001dd0:	4297      	cmp	r7, r2
 8001dd2:	419b      	sbcs	r3, r3
 8001dd4:	4441      	add	r1, r8
 8001dd6:	425b      	negs	r3, r3
 8001dd8:	18c9      	adds	r1, r1, r3
 8001dda:	e6db      	b.n	8001b94 <__aeabi_dadd+0x494>
 8001ddc:	2300      	movs	r3, #0
 8001dde:	4d02      	ldr	r5, [pc, #8]	; (8001de8 <__aeabi_dadd+0x6e8>)
 8001de0:	469c      	mov	ip, r3
 8001de2:	001a      	movs	r2, r3
 8001de4:	e519      	b.n	800181a <__aeabi_dadd+0x11a>
 8001de6:	46c0      	nop			; (mov r8, r8)
 8001de8:	000007ff 	.word	0x000007ff
 8001dec:	00000000 	.word	0x00000000

08001df0 <__aeabi_ddiv>:
 8001df0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001df2:	4657      	mov	r7, sl
 8001df4:	464e      	mov	r6, r9
 8001df6:	4645      	mov	r5, r8
 8001df8:	46de      	mov	lr, fp
 8001dfa:	b5e0      	push	{r5, r6, r7, lr}
 8001dfc:	030f      	lsls	r7, r1, #12
 8001dfe:	4681      	mov	r9, r0
 8001e00:	001e      	movs	r6, r3
 8001e02:	0004      	movs	r4, r0
 8001e04:	0b3b      	lsrs	r3, r7, #12
 8001e06:	0048      	lsls	r0, r1, #1
 8001e08:	b085      	sub	sp, #20
 8001e0a:	4692      	mov	sl, r2
 8001e0c:	4698      	mov	r8, r3
 8001e0e:	0d40      	lsrs	r0, r0, #21
 8001e10:	0fcd      	lsrs	r5, r1, #31
 8001e12:	2800      	cmp	r0, #0
 8001e14:	d100      	bne.n	8001e18 <__aeabi_ddiv+0x28>
 8001e16:	e0b6      	b.n	8001f86 <__aeabi_ddiv+0x196>
 8001e18:	4b8b      	ldr	r3, [pc, #556]	; (8002048 <__aeabi_ddiv+0x258>)
 8001e1a:	4298      	cmp	r0, r3
 8001e1c:	d100      	bne.n	8001e20 <__aeabi_ddiv+0x30>
 8001e1e:	e0d2      	b.n	8001fc6 <__aeabi_ddiv+0x1d6>
 8001e20:	4643      	mov	r3, r8
 8001e22:	0f67      	lsrs	r7, r4, #29
 8001e24:	00db      	lsls	r3, r3, #3
 8001e26:	431f      	orrs	r7, r3
 8001e28:	2380      	movs	r3, #128	; 0x80
 8001e2a:	041b      	lsls	r3, r3, #16
 8001e2c:	431f      	orrs	r7, r3
 8001e2e:	4b87      	ldr	r3, [pc, #540]	; (800204c <__aeabi_ddiv+0x25c>)
 8001e30:	9700      	str	r7, [sp, #0]
 8001e32:	469b      	mov	fp, r3
 8001e34:	2300      	movs	r3, #0
 8001e36:	4698      	mov	r8, r3
 8001e38:	00e4      	lsls	r4, r4, #3
 8001e3a:	4483      	add	fp, r0
 8001e3c:	9301      	str	r3, [sp, #4]
 8001e3e:	0333      	lsls	r3, r6, #12
 8001e40:	0b1b      	lsrs	r3, r3, #12
 8001e42:	4699      	mov	r9, r3
 8001e44:	0073      	lsls	r3, r6, #1
 8001e46:	4652      	mov	r2, sl
 8001e48:	0d5b      	lsrs	r3, r3, #21
 8001e4a:	0ff6      	lsrs	r6, r6, #31
 8001e4c:	2b00      	cmp	r3, #0
 8001e4e:	d100      	bne.n	8001e52 <__aeabi_ddiv+0x62>
 8001e50:	e078      	b.n	8001f44 <__aeabi_ddiv+0x154>
 8001e52:	497d      	ldr	r1, [pc, #500]	; (8002048 <__aeabi_ddiv+0x258>)
 8001e54:	428b      	cmp	r3, r1
 8001e56:	d01a      	beq.n	8001e8e <__aeabi_ddiv+0x9e>
 8001e58:	0f51      	lsrs	r1, r2, #29
 8001e5a:	464a      	mov	r2, r9
 8001e5c:	487b      	ldr	r0, [pc, #492]	; (800204c <__aeabi_ddiv+0x25c>)
 8001e5e:	00d2      	lsls	r2, r2, #3
 8001e60:	4311      	orrs	r1, r2
 8001e62:	4684      	mov	ip, r0
 8001e64:	2280      	movs	r2, #128	; 0x80
 8001e66:	4658      	mov	r0, fp
 8001e68:	0412      	lsls	r2, r2, #16
 8001e6a:	4463      	add	r3, ip
 8001e6c:	1ac3      	subs	r3, r0, r3
 8001e6e:	4311      	orrs	r1, r2
 8001e70:	4652      	mov	r2, sl
 8001e72:	469b      	mov	fp, r3
 8001e74:	2000      	movs	r0, #0
 8001e76:	00d2      	lsls	r2, r2, #3
 8001e78:	002b      	movs	r3, r5
 8001e7a:	4073      	eors	r3, r6
 8001e7c:	469a      	mov	sl, r3
 8001e7e:	4643      	mov	r3, r8
 8001e80:	2b0f      	cmp	r3, #15
 8001e82:	d900      	bls.n	8001e86 <__aeabi_ddiv+0x96>
 8001e84:	e0f4      	b.n	8002070 <__aeabi_ddiv+0x280>
 8001e86:	4f72      	ldr	r7, [pc, #456]	; (8002050 <__aeabi_ddiv+0x260>)
 8001e88:	009b      	lsls	r3, r3, #2
 8001e8a:	58fb      	ldr	r3, [r7, r3]
 8001e8c:	469f      	mov	pc, r3
 8001e8e:	464b      	mov	r3, r9
 8001e90:	4651      	mov	r1, sl
 8001e92:	4319      	orrs	r1, r3
 8001e94:	4b6f      	ldr	r3, [pc, #444]	; (8002054 <__aeabi_ddiv+0x264>)
 8001e96:	469c      	mov	ip, r3
 8001e98:	44e3      	add	fp, ip
 8001e9a:	2900      	cmp	r1, #0
 8001e9c:	d000      	beq.n	8001ea0 <__aeabi_ddiv+0xb0>
 8001e9e:	e0b5      	b.n	800200c <__aeabi_ddiv+0x21c>
 8001ea0:	4642      	mov	r2, r8
 8001ea2:	2302      	movs	r3, #2
 8001ea4:	431a      	orrs	r2, r3
 8001ea6:	4690      	mov	r8, r2
 8001ea8:	2002      	movs	r0, #2
 8001eaa:	2200      	movs	r2, #0
 8001eac:	e7e4      	b.n	8001e78 <__aeabi_ddiv+0x88>
 8001eae:	0035      	movs	r5, r6
 8001eb0:	0014      	movs	r4, r2
 8001eb2:	9100      	str	r1, [sp, #0]
 8001eb4:	9001      	str	r0, [sp, #4]
 8001eb6:	9b01      	ldr	r3, [sp, #4]
 8001eb8:	2b02      	cmp	r3, #2
 8001eba:	d100      	bne.n	8001ebe <__aeabi_ddiv+0xce>
 8001ebc:	e212      	b.n	80022e4 <__aeabi_ddiv+0x4f4>
 8001ebe:	2b03      	cmp	r3, #3
 8001ec0:	d100      	bne.n	8001ec4 <__aeabi_ddiv+0xd4>
 8001ec2:	e275      	b.n	80023b0 <__aeabi_ddiv+0x5c0>
 8001ec4:	2b01      	cmp	r3, #1
 8001ec6:	d01d      	beq.n	8001f04 <__aeabi_ddiv+0x114>
 8001ec8:	46aa      	mov	sl, r5
 8001eca:	4e63      	ldr	r6, [pc, #396]	; (8002058 <__aeabi_ddiv+0x268>)
 8001ecc:	445e      	add	r6, fp
 8001ece:	2e00      	cmp	r6, #0
 8001ed0:	dc00      	bgt.n	8001ed4 <__aeabi_ddiv+0xe4>
 8001ed2:	e1e0      	b.n	8002296 <__aeabi_ddiv+0x4a6>
 8001ed4:	0763      	lsls	r3, r4, #29
 8001ed6:	d000      	beq.n	8001eda <__aeabi_ddiv+0xea>
 8001ed8:	e215      	b.n	8002306 <__aeabi_ddiv+0x516>
 8001eda:	08e4      	lsrs	r4, r4, #3
 8001edc:	9a00      	ldr	r2, [sp, #0]
 8001ede:	01d3      	lsls	r3, r2, #7
 8001ee0:	d505      	bpl.n	8001eee <__aeabi_ddiv+0xfe>
 8001ee2:	2680      	movs	r6, #128	; 0x80
 8001ee4:	4b5d      	ldr	r3, [pc, #372]	; (800205c <__aeabi_ddiv+0x26c>)
 8001ee6:	00f6      	lsls	r6, r6, #3
 8001ee8:	401a      	ands	r2, r3
 8001eea:	9200      	str	r2, [sp, #0]
 8001eec:	445e      	add	r6, fp
 8001eee:	4b5c      	ldr	r3, [pc, #368]	; (8002060 <__aeabi_ddiv+0x270>)
 8001ef0:	429e      	cmp	r6, r3
 8001ef2:	dc23      	bgt.n	8001f3c <__aeabi_ddiv+0x14c>
 8001ef4:	9a00      	ldr	r2, [sp, #0]
 8001ef6:	0576      	lsls	r6, r6, #21
 8001ef8:	0753      	lsls	r3, r2, #29
 8001efa:	0257      	lsls	r7, r2, #9
 8001efc:	431c      	orrs	r4, r3
 8001efe:	0b3f      	lsrs	r7, r7, #12
 8001f00:	0d73      	lsrs	r3, r6, #21
 8001f02:	e003      	b.n	8001f0c <__aeabi_ddiv+0x11c>
 8001f04:	46aa      	mov	sl, r5
 8001f06:	2300      	movs	r3, #0
 8001f08:	2700      	movs	r7, #0
 8001f0a:	2400      	movs	r4, #0
 8001f0c:	2100      	movs	r1, #0
 8001f0e:	033f      	lsls	r7, r7, #12
 8001f10:	0b3e      	lsrs	r6, r7, #12
 8001f12:	0d0f      	lsrs	r7, r1, #20
 8001f14:	053f      	lsls	r7, r7, #20
 8001f16:	4337      	orrs	r7, r6
 8001f18:	051e      	lsls	r6, r3, #20
 8001f1a:	4b52      	ldr	r3, [pc, #328]	; (8002064 <__aeabi_ddiv+0x274>)
 8001f1c:	0020      	movs	r0, r4
 8001f1e:	401f      	ands	r7, r3
 8001f20:	4653      	mov	r3, sl
 8001f22:	433e      	orrs	r6, r7
 8001f24:	0076      	lsls	r6, r6, #1
 8001f26:	07db      	lsls	r3, r3, #31
 8001f28:	0876      	lsrs	r6, r6, #1
 8001f2a:	431e      	orrs	r6, r3
 8001f2c:	0031      	movs	r1, r6
 8001f2e:	b005      	add	sp, #20
 8001f30:	bc3c      	pop	{r2, r3, r4, r5}
 8001f32:	4690      	mov	r8, r2
 8001f34:	4699      	mov	r9, r3
 8001f36:	46a2      	mov	sl, r4
 8001f38:	46ab      	mov	fp, r5
 8001f3a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001f3c:	4b42      	ldr	r3, [pc, #264]	; (8002048 <__aeabi_ddiv+0x258>)
 8001f3e:	2700      	movs	r7, #0
 8001f40:	2400      	movs	r4, #0
 8001f42:	e7e3      	b.n	8001f0c <__aeabi_ddiv+0x11c>
 8001f44:	4649      	mov	r1, r9
 8001f46:	4311      	orrs	r1, r2
 8001f48:	d059      	beq.n	8001ffe <__aeabi_ddiv+0x20e>
 8001f4a:	464b      	mov	r3, r9
 8001f4c:	2b00      	cmp	r3, #0
 8001f4e:	d100      	bne.n	8001f52 <__aeabi_ddiv+0x162>
 8001f50:	e190      	b.n	8002274 <__aeabi_ddiv+0x484>
 8001f52:	4648      	mov	r0, r9
 8001f54:	f001 fb24 	bl	80035a0 <__clzsi2>
 8001f58:	0002      	movs	r2, r0
 8001f5a:	3a0b      	subs	r2, #11
 8001f5c:	2308      	movs	r3, #8
 8001f5e:	425b      	negs	r3, r3
 8001f60:	469c      	mov	ip, r3
 8001f62:	4484      	add	ip, r0
 8001f64:	4663      	mov	r3, ip
 8001f66:	4649      	mov	r1, r9
 8001f68:	4099      	lsls	r1, r3
 8001f6a:	231d      	movs	r3, #29
 8001f6c:	1a9b      	subs	r3, r3, r2
 8001f6e:	4652      	mov	r2, sl
 8001f70:	40da      	lsrs	r2, r3
 8001f72:	4663      	mov	r3, ip
 8001f74:	4311      	orrs	r1, r2
 8001f76:	4652      	mov	r2, sl
 8001f78:	409a      	lsls	r2, r3
 8001f7a:	4b3b      	ldr	r3, [pc, #236]	; (8002068 <__aeabi_ddiv+0x278>)
 8001f7c:	4458      	add	r0, fp
 8001f7e:	469b      	mov	fp, r3
 8001f80:	4483      	add	fp, r0
 8001f82:	2000      	movs	r0, #0
 8001f84:	e778      	b.n	8001e78 <__aeabi_ddiv+0x88>
 8001f86:	001f      	movs	r7, r3
 8001f88:	4327      	orrs	r7, r4
 8001f8a:	9700      	str	r7, [sp, #0]
 8001f8c:	d02f      	beq.n	8001fee <__aeabi_ddiv+0x1fe>
 8001f8e:	4643      	mov	r3, r8
 8001f90:	2b00      	cmp	r3, #0
 8001f92:	d100      	bne.n	8001f96 <__aeabi_ddiv+0x1a6>
 8001f94:	e15e      	b.n	8002254 <__aeabi_ddiv+0x464>
 8001f96:	4640      	mov	r0, r8
 8001f98:	f001 fb02 	bl	80035a0 <__clzsi2>
 8001f9c:	0002      	movs	r2, r0
 8001f9e:	3a0b      	subs	r2, #11
 8001fa0:	231d      	movs	r3, #29
 8001fa2:	0001      	movs	r1, r0
 8001fa4:	1a9b      	subs	r3, r3, r2
 8001fa6:	4647      	mov	r7, r8
 8001fa8:	464a      	mov	r2, r9
 8001faa:	464c      	mov	r4, r9
 8001fac:	3908      	subs	r1, #8
 8001fae:	408f      	lsls	r7, r1
 8001fb0:	40da      	lsrs	r2, r3
 8001fb2:	408c      	lsls	r4, r1
 8001fb4:	4317      	orrs	r7, r2
 8001fb6:	9700      	str	r7, [sp, #0]
 8001fb8:	4b2c      	ldr	r3, [pc, #176]	; (800206c <__aeabi_ddiv+0x27c>)
 8001fba:	1a1b      	subs	r3, r3, r0
 8001fbc:	469b      	mov	fp, r3
 8001fbe:	2300      	movs	r3, #0
 8001fc0:	4698      	mov	r8, r3
 8001fc2:	9301      	str	r3, [sp, #4]
 8001fc4:	e73b      	b.n	8001e3e <__aeabi_ddiv+0x4e>
 8001fc6:	464f      	mov	r7, r9
 8001fc8:	4643      	mov	r3, r8
 8001fca:	431f      	orrs	r7, r3
 8001fcc:	9700      	str	r7, [sp, #0]
 8001fce:	d106      	bne.n	8001fde <__aeabi_ddiv+0x1ee>
 8001fd0:	2308      	movs	r3, #8
 8001fd2:	4698      	mov	r8, r3
 8001fd4:	3b06      	subs	r3, #6
 8001fd6:	2400      	movs	r4, #0
 8001fd8:	4683      	mov	fp, r0
 8001fda:	9301      	str	r3, [sp, #4]
 8001fdc:	e72f      	b.n	8001e3e <__aeabi_ddiv+0x4e>
 8001fde:	4643      	mov	r3, r8
 8001fe0:	9300      	str	r3, [sp, #0]
 8001fe2:	230c      	movs	r3, #12
 8001fe4:	4698      	mov	r8, r3
 8001fe6:	3b09      	subs	r3, #9
 8001fe8:	4683      	mov	fp, r0
 8001fea:	9301      	str	r3, [sp, #4]
 8001fec:	e727      	b.n	8001e3e <__aeabi_ddiv+0x4e>
 8001fee:	2304      	movs	r3, #4
 8001ff0:	4698      	mov	r8, r3
 8001ff2:	2300      	movs	r3, #0
 8001ff4:	469b      	mov	fp, r3
 8001ff6:	3301      	adds	r3, #1
 8001ff8:	2400      	movs	r4, #0
 8001ffa:	9301      	str	r3, [sp, #4]
 8001ffc:	e71f      	b.n	8001e3e <__aeabi_ddiv+0x4e>
 8001ffe:	4642      	mov	r2, r8
 8002000:	2301      	movs	r3, #1
 8002002:	431a      	orrs	r2, r3
 8002004:	4690      	mov	r8, r2
 8002006:	2001      	movs	r0, #1
 8002008:	2200      	movs	r2, #0
 800200a:	e735      	b.n	8001e78 <__aeabi_ddiv+0x88>
 800200c:	4641      	mov	r1, r8
 800200e:	2303      	movs	r3, #3
 8002010:	4319      	orrs	r1, r3
 8002012:	4688      	mov	r8, r1
 8002014:	2003      	movs	r0, #3
 8002016:	4649      	mov	r1, r9
 8002018:	e72e      	b.n	8001e78 <__aeabi_ddiv+0x88>
 800201a:	2300      	movs	r3, #0
 800201c:	2780      	movs	r7, #128	; 0x80
 800201e:	469a      	mov	sl, r3
 8002020:	033f      	lsls	r7, r7, #12
 8002022:	2400      	movs	r4, #0
 8002024:	4b08      	ldr	r3, [pc, #32]	; (8002048 <__aeabi_ddiv+0x258>)
 8002026:	e771      	b.n	8001f0c <__aeabi_ddiv+0x11c>
 8002028:	2380      	movs	r3, #128	; 0x80
 800202a:	9800      	ldr	r0, [sp, #0]
 800202c:	031b      	lsls	r3, r3, #12
 800202e:	4218      	tst	r0, r3
 8002030:	d100      	bne.n	8002034 <__aeabi_ddiv+0x244>
 8002032:	e0ea      	b.n	800220a <__aeabi_ddiv+0x41a>
 8002034:	4219      	tst	r1, r3
 8002036:	d000      	beq.n	800203a <__aeabi_ddiv+0x24a>
 8002038:	e0e7      	b.n	800220a <__aeabi_ddiv+0x41a>
 800203a:	430b      	orrs	r3, r1
 800203c:	031f      	lsls	r7, r3, #12
 800203e:	0b3f      	lsrs	r7, r7, #12
 8002040:	46b2      	mov	sl, r6
 8002042:	0014      	movs	r4, r2
 8002044:	4b00      	ldr	r3, [pc, #0]	; (8002048 <__aeabi_ddiv+0x258>)
 8002046:	e761      	b.n	8001f0c <__aeabi_ddiv+0x11c>
 8002048:	000007ff 	.word	0x000007ff
 800204c:	fffffc01 	.word	0xfffffc01
 8002050:	080134ac 	.word	0x080134ac
 8002054:	fffff801 	.word	0xfffff801
 8002058:	000003ff 	.word	0x000003ff
 800205c:	feffffff 	.word	0xfeffffff
 8002060:	000007fe 	.word	0x000007fe
 8002064:	800fffff 	.word	0x800fffff
 8002068:	000003f3 	.word	0x000003f3
 800206c:	fffffc0d 	.word	0xfffffc0d
 8002070:	9b00      	ldr	r3, [sp, #0]
 8002072:	4299      	cmp	r1, r3
 8002074:	d200      	bcs.n	8002078 <__aeabi_ddiv+0x288>
 8002076:	e0e6      	b.n	8002246 <__aeabi_ddiv+0x456>
 8002078:	d100      	bne.n	800207c <__aeabi_ddiv+0x28c>
 800207a:	e0e1      	b.n	8002240 <__aeabi_ddiv+0x450>
 800207c:	2301      	movs	r3, #1
 800207e:	425b      	negs	r3, r3
 8002080:	469c      	mov	ip, r3
 8002082:	0025      	movs	r5, r4
 8002084:	2600      	movs	r6, #0
 8002086:	9800      	ldr	r0, [sp, #0]
 8002088:	44e3      	add	fp, ip
 800208a:	0e13      	lsrs	r3, r2, #24
 800208c:	0209      	lsls	r1, r1, #8
 800208e:	430b      	orrs	r3, r1
 8002090:	4699      	mov	r9, r3
 8002092:	0213      	lsls	r3, r2, #8
 8002094:	4698      	mov	r8, r3
 8002096:	464b      	mov	r3, r9
 8002098:	0c1c      	lsrs	r4, r3, #16
 800209a:	041b      	lsls	r3, r3, #16
 800209c:	0c1b      	lsrs	r3, r3, #16
 800209e:	0021      	movs	r1, r4
 80020a0:	9301      	str	r3, [sp, #4]
 80020a2:	f7fe f91b 	bl	80002dc <__aeabi_uidivmod>
 80020a6:	9a01      	ldr	r2, [sp, #4]
 80020a8:	040b      	lsls	r3, r1, #16
 80020aa:	4342      	muls	r2, r0
 80020ac:	0c29      	lsrs	r1, r5, #16
 80020ae:	0007      	movs	r7, r0
 80020b0:	4319      	orrs	r1, r3
 80020b2:	428a      	cmp	r2, r1
 80020b4:	d907      	bls.n	80020c6 <__aeabi_ddiv+0x2d6>
 80020b6:	4449      	add	r1, r9
 80020b8:	3f01      	subs	r7, #1
 80020ba:	4589      	cmp	r9, r1
 80020bc:	d803      	bhi.n	80020c6 <__aeabi_ddiv+0x2d6>
 80020be:	428a      	cmp	r2, r1
 80020c0:	d901      	bls.n	80020c6 <__aeabi_ddiv+0x2d6>
 80020c2:	1e87      	subs	r7, r0, #2
 80020c4:	4449      	add	r1, r9
 80020c6:	1a88      	subs	r0, r1, r2
 80020c8:	0021      	movs	r1, r4
 80020ca:	f7fe f907 	bl	80002dc <__aeabi_uidivmod>
 80020ce:	0409      	lsls	r1, r1, #16
 80020d0:	468c      	mov	ip, r1
 80020d2:	0429      	lsls	r1, r5, #16
 80020d4:	4665      	mov	r5, ip
 80020d6:	9a01      	ldr	r2, [sp, #4]
 80020d8:	0c09      	lsrs	r1, r1, #16
 80020da:	4342      	muls	r2, r0
 80020dc:	0003      	movs	r3, r0
 80020de:	4329      	orrs	r1, r5
 80020e0:	428a      	cmp	r2, r1
 80020e2:	d904      	bls.n	80020ee <__aeabi_ddiv+0x2fe>
 80020e4:	4449      	add	r1, r9
 80020e6:	3b01      	subs	r3, #1
 80020e8:	4589      	cmp	r9, r1
 80020ea:	d800      	bhi.n	80020ee <__aeabi_ddiv+0x2fe>
 80020ec:	e105      	b.n	80022fa <__aeabi_ddiv+0x50a>
 80020ee:	043f      	lsls	r7, r7, #16
 80020f0:	431f      	orrs	r7, r3
 80020f2:	1a89      	subs	r1, r1, r2
 80020f4:	4643      	mov	r3, r8
 80020f6:	003a      	movs	r2, r7
 80020f8:	0c38      	lsrs	r0, r7, #16
 80020fa:	9700      	str	r7, [sp, #0]
 80020fc:	0c1f      	lsrs	r7, r3, #16
 80020fe:	0413      	lsls	r3, r2, #16
 8002100:	4642      	mov	r2, r8
 8002102:	0412      	lsls	r2, r2, #16
 8002104:	0c15      	lsrs	r5, r2, #16
 8002106:	002a      	movs	r2, r5
 8002108:	0c1b      	lsrs	r3, r3, #16
 800210a:	435a      	muls	r2, r3
 800210c:	9702      	str	r7, [sp, #8]
 800210e:	437b      	muls	r3, r7
 8002110:	9503      	str	r5, [sp, #12]
 8002112:	4345      	muls	r5, r0
 8002114:	4378      	muls	r0, r7
 8002116:	0c17      	lsrs	r7, r2, #16
 8002118:	46bc      	mov	ip, r7
 800211a:	195b      	adds	r3, r3, r5
 800211c:	4463      	add	r3, ip
 800211e:	429d      	cmp	r5, r3
 8002120:	d903      	bls.n	800212a <__aeabi_ddiv+0x33a>
 8002122:	2580      	movs	r5, #128	; 0x80
 8002124:	026d      	lsls	r5, r5, #9
 8002126:	46ac      	mov	ip, r5
 8002128:	4460      	add	r0, ip
 800212a:	0c1d      	lsrs	r5, r3, #16
 800212c:	1828      	adds	r0, r5, r0
 800212e:	0415      	lsls	r5, r2, #16
 8002130:	041b      	lsls	r3, r3, #16
 8002132:	0c2d      	lsrs	r5, r5, #16
 8002134:	195d      	adds	r5, r3, r5
 8002136:	4281      	cmp	r1, r0
 8002138:	d372      	bcc.n	8002220 <__aeabi_ddiv+0x430>
 800213a:	d06f      	beq.n	800221c <__aeabi_ddiv+0x42c>
 800213c:	1b75      	subs	r5, r6, r5
 800213e:	1a09      	subs	r1, r1, r0
 8002140:	42ae      	cmp	r6, r5
 8002142:	4180      	sbcs	r0, r0
 8002144:	4ea1      	ldr	r6, [pc, #644]	; (80023cc <__aeabi_ddiv+0x5dc>)
 8002146:	4240      	negs	r0, r0
 8002148:	1a08      	subs	r0, r1, r0
 800214a:	445e      	add	r6, fp
 800214c:	4581      	cmp	r9, r0
 800214e:	d100      	bne.n	8002152 <__aeabi_ddiv+0x362>
 8002150:	e100      	b.n	8002354 <__aeabi_ddiv+0x564>
 8002152:	0021      	movs	r1, r4
 8002154:	f7fe f8c2 	bl	80002dc <__aeabi_uidivmod>
 8002158:	0002      	movs	r2, r0
 800215a:	9b01      	ldr	r3, [sp, #4]
 800215c:	0007      	movs	r7, r0
 800215e:	435a      	muls	r2, r3
 8002160:	040b      	lsls	r3, r1, #16
 8002162:	0c29      	lsrs	r1, r5, #16
 8002164:	4319      	orrs	r1, r3
 8002166:	428a      	cmp	r2, r1
 8002168:	d908      	bls.n	800217c <__aeabi_ddiv+0x38c>
 800216a:	4449      	add	r1, r9
 800216c:	3f01      	subs	r7, #1
 800216e:	4589      	cmp	r9, r1
 8002170:	d804      	bhi.n	800217c <__aeabi_ddiv+0x38c>
 8002172:	428a      	cmp	r2, r1
 8002174:	d902      	bls.n	800217c <__aeabi_ddiv+0x38c>
 8002176:	1e83      	subs	r3, r0, #2
 8002178:	001f      	movs	r7, r3
 800217a:	4449      	add	r1, r9
 800217c:	1a88      	subs	r0, r1, r2
 800217e:	0021      	movs	r1, r4
 8002180:	f7fe f8ac 	bl	80002dc <__aeabi_uidivmod>
 8002184:	9a01      	ldr	r2, [sp, #4]
 8002186:	040c      	lsls	r4, r1, #16
 8002188:	4342      	muls	r2, r0
 800218a:	0429      	lsls	r1, r5, #16
 800218c:	0c09      	lsrs	r1, r1, #16
 800218e:	0003      	movs	r3, r0
 8002190:	4321      	orrs	r1, r4
 8002192:	428a      	cmp	r2, r1
 8002194:	d907      	bls.n	80021a6 <__aeabi_ddiv+0x3b6>
 8002196:	4449      	add	r1, r9
 8002198:	3b01      	subs	r3, #1
 800219a:	4589      	cmp	r9, r1
 800219c:	d803      	bhi.n	80021a6 <__aeabi_ddiv+0x3b6>
 800219e:	428a      	cmp	r2, r1
 80021a0:	d901      	bls.n	80021a6 <__aeabi_ddiv+0x3b6>
 80021a2:	1e83      	subs	r3, r0, #2
 80021a4:	4449      	add	r1, r9
 80021a6:	9d03      	ldr	r5, [sp, #12]
 80021a8:	043c      	lsls	r4, r7, #16
 80021aa:	431c      	orrs	r4, r3
 80021ac:	002b      	movs	r3, r5
 80021ae:	1a89      	subs	r1, r1, r2
 80021b0:	0422      	lsls	r2, r4, #16
 80021b2:	0c12      	lsrs	r2, r2, #16
 80021b4:	4353      	muls	r3, r2
 80021b6:	9f02      	ldr	r7, [sp, #8]
 80021b8:	0c20      	lsrs	r0, r4, #16
 80021ba:	4345      	muls	r5, r0
 80021bc:	437a      	muls	r2, r7
 80021be:	4378      	muls	r0, r7
 80021c0:	0c1f      	lsrs	r7, r3, #16
 80021c2:	46bc      	mov	ip, r7
 80021c4:	1952      	adds	r2, r2, r5
 80021c6:	4462      	add	r2, ip
 80021c8:	4295      	cmp	r5, r2
 80021ca:	d903      	bls.n	80021d4 <__aeabi_ddiv+0x3e4>
 80021cc:	2580      	movs	r5, #128	; 0x80
 80021ce:	026d      	lsls	r5, r5, #9
 80021d0:	46ac      	mov	ip, r5
 80021d2:	4460      	add	r0, ip
 80021d4:	0c15      	lsrs	r5, r2, #16
 80021d6:	041b      	lsls	r3, r3, #16
 80021d8:	0412      	lsls	r2, r2, #16
 80021da:	0c1b      	lsrs	r3, r3, #16
 80021dc:	1828      	adds	r0, r5, r0
 80021de:	18d2      	adds	r2, r2, r3
 80021e0:	4281      	cmp	r1, r0
 80021e2:	d306      	bcc.n	80021f2 <__aeabi_ddiv+0x402>
 80021e4:	d002      	beq.n	80021ec <__aeabi_ddiv+0x3fc>
 80021e6:	2301      	movs	r3, #1
 80021e8:	431c      	orrs	r4, r3
 80021ea:	e670      	b.n	8001ece <__aeabi_ddiv+0xde>
 80021ec:	2a00      	cmp	r2, #0
 80021ee:	d100      	bne.n	80021f2 <__aeabi_ddiv+0x402>
 80021f0:	e66d      	b.n	8001ece <__aeabi_ddiv+0xde>
 80021f2:	4449      	add	r1, r9
 80021f4:	1e63      	subs	r3, r4, #1
 80021f6:	4549      	cmp	r1, r9
 80021f8:	d200      	bcs.n	80021fc <__aeabi_ddiv+0x40c>
 80021fa:	e096      	b.n	800232a <__aeabi_ddiv+0x53a>
 80021fc:	4281      	cmp	r1, r0
 80021fe:	d200      	bcs.n	8002202 <__aeabi_ddiv+0x412>
 8002200:	e0ad      	b.n	800235e <__aeabi_ddiv+0x56e>
 8002202:	d100      	bne.n	8002206 <__aeabi_ddiv+0x416>
 8002204:	e0dd      	b.n	80023c2 <__aeabi_ddiv+0x5d2>
 8002206:	001c      	movs	r4, r3
 8002208:	e7ed      	b.n	80021e6 <__aeabi_ddiv+0x3f6>
 800220a:	2680      	movs	r6, #128	; 0x80
 800220c:	9f00      	ldr	r7, [sp, #0]
 800220e:	0336      	lsls	r6, r6, #12
 8002210:	4337      	orrs	r7, r6
 8002212:	033f      	lsls	r7, r7, #12
 8002214:	0b3f      	lsrs	r7, r7, #12
 8002216:	46aa      	mov	sl, r5
 8002218:	4b6d      	ldr	r3, [pc, #436]	; (80023d0 <__aeabi_ddiv+0x5e0>)
 800221a:	e677      	b.n	8001f0c <__aeabi_ddiv+0x11c>
 800221c:	42ae      	cmp	r6, r5
 800221e:	d28d      	bcs.n	800213c <__aeabi_ddiv+0x34c>
 8002220:	9b00      	ldr	r3, [sp, #0]
 8002222:	4446      	add	r6, r8
 8002224:	1e5a      	subs	r2, r3, #1
 8002226:	4546      	cmp	r6, r8
 8002228:	419b      	sbcs	r3, r3
 800222a:	425b      	negs	r3, r3
 800222c:	444b      	add	r3, r9
 800222e:	18c9      	adds	r1, r1, r3
 8002230:	4589      	cmp	r9, r1
 8002232:	d25c      	bcs.n	80022ee <__aeabi_ddiv+0x4fe>
 8002234:	4288      	cmp	r0, r1
 8002236:	d900      	bls.n	800223a <__aeabi_ddiv+0x44a>
 8002238:	e082      	b.n	8002340 <__aeabi_ddiv+0x550>
 800223a:	d07e      	beq.n	800233a <__aeabi_ddiv+0x54a>
 800223c:	9200      	str	r2, [sp, #0]
 800223e:	e77d      	b.n	800213c <__aeabi_ddiv+0x34c>
 8002240:	42a2      	cmp	r2, r4
 8002242:	d900      	bls.n	8002246 <__aeabi_ddiv+0x456>
 8002244:	e71a      	b.n	800207c <__aeabi_ddiv+0x28c>
 8002246:	9b00      	ldr	r3, [sp, #0]
 8002248:	0865      	lsrs	r5, r4, #1
 800224a:	07df      	lsls	r7, r3, #31
 800224c:	0858      	lsrs	r0, r3, #1
 800224e:	433d      	orrs	r5, r7
 8002250:	07e6      	lsls	r6, r4, #31
 8002252:	e71a      	b.n	800208a <__aeabi_ddiv+0x29a>
 8002254:	4648      	mov	r0, r9
 8002256:	f001 f9a3 	bl	80035a0 <__clzsi2>
 800225a:	0003      	movs	r3, r0
 800225c:	001a      	movs	r2, r3
 800225e:	3215      	adds	r2, #21
 8002260:	3020      	adds	r0, #32
 8002262:	2a1c      	cmp	r2, #28
 8002264:	dc00      	bgt.n	8002268 <__aeabi_ddiv+0x478>
 8002266:	e69b      	b.n	8001fa0 <__aeabi_ddiv+0x1b0>
 8002268:	464f      	mov	r7, r9
 800226a:	3b08      	subs	r3, #8
 800226c:	409f      	lsls	r7, r3
 800226e:	2400      	movs	r4, #0
 8002270:	9700      	str	r7, [sp, #0]
 8002272:	e6a1      	b.n	8001fb8 <__aeabi_ddiv+0x1c8>
 8002274:	4650      	mov	r0, sl
 8002276:	f001 f993 	bl	80035a0 <__clzsi2>
 800227a:	0003      	movs	r3, r0
 800227c:	001a      	movs	r2, r3
 800227e:	3215      	adds	r2, #21
 8002280:	3020      	adds	r0, #32
 8002282:	2a1c      	cmp	r2, #28
 8002284:	dc00      	bgt.n	8002288 <__aeabi_ddiv+0x498>
 8002286:	e669      	b.n	8001f5c <__aeabi_ddiv+0x16c>
 8002288:	4651      	mov	r1, sl
 800228a:	3b08      	subs	r3, #8
 800228c:	4099      	lsls	r1, r3
 800228e:	2200      	movs	r2, #0
 8002290:	e673      	b.n	8001f7a <__aeabi_ddiv+0x18a>
 8002292:	2401      	movs	r4, #1
 8002294:	4264      	negs	r4, r4
 8002296:	2101      	movs	r1, #1
 8002298:	1b89      	subs	r1, r1, r6
 800229a:	2938      	cmp	r1, #56	; 0x38
 800229c:	dd00      	ble.n	80022a0 <__aeabi_ddiv+0x4b0>
 800229e:	e632      	b.n	8001f06 <__aeabi_ddiv+0x116>
 80022a0:	291f      	cmp	r1, #31
 80022a2:	dc66      	bgt.n	8002372 <__aeabi_ddiv+0x582>
 80022a4:	9d00      	ldr	r5, [sp, #0]
 80022a6:	0022      	movs	r2, r4
 80022a8:	002b      	movs	r3, r5
 80022aa:	484a      	ldr	r0, [pc, #296]	; (80023d4 <__aeabi_ddiv+0x5e4>)
 80022ac:	40ca      	lsrs	r2, r1
 80022ae:	4458      	add	r0, fp
 80022b0:	4083      	lsls	r3, r0
 80022b2:	4084      	lsls	r4, r0
 80022b4:	4313      	orrs	r3, r2
 80022b6:	1e62      	subs	r2, r4, #1
 80022b8:	4194      	sbcs	r4, r2
 80022ba:	40cd      	lsrs	r5, r1
 80022bc:	4323      	orrs	r3, r4
 80022be:	002f      	movs	r7, r5
 80022c0:	075a      	lsls	r2, r3, #29
 80022c2:	d009      	beq.n	80022d8 <__aeabi_ddiv+0x4e8>
 80022c4:	220f      	movs	r2, #15
 80022c6:	401a      	ands	r2, r3
 80022c8:	2a04      	cmp	r2, #4
 80022ca:	d005      	beq.n	80022d8 <__aeabi_ddiv+0x4e8>
 80022cc:	1d1a      	adds	r2, r3, #4
 80022ce:	429a      	cmp	r2, r3
 80022d0:	419b      	sbcs	r3, r3
 80022d2:	425b      	negs	r3, r3
 80022d4:	18ff      	adds	r7, r7, r3
 80022d6:	0013      	movs	r3, r2
 80022d8:	023a      	lsls	r2, r7, #8
 80022da:	d562      	bpl.n	80023a2 <__aeabi_ddiv+0x5b2>
 80022dc:	2301      	movs	r3, #1
 80022de:	2700      	movs	r7, #0
 80022e0:	2400      	movs	r4, #0
 80022e2:	e613      	b.n	8001f0c <__aeabi_ddiv+0x11c>
 80022e4:	46aa      	mov	sl, r5
 80022e6:	4b3a      	ldr	r3, [pc, #232]	; (80023d0 <__aeabi_ddiv+0x5e0>)
 80022e8:	2700      	movs	r7, #0
 80022ea:	2400      	movs	r4, #0
 80022ec:	e60e      	b.n	8001f0c <__aeabi_ddiv+0x11c>
 80022ee:	4589      	cmp	r9, r1
 80022f0:	d1a4      	bne.n	800223c <__aeabi_ddiv+0x44c>
 80022f2:	45b0      	cmp	r8, r6
 80022f4:	d99e      	bls.n	8002234 <__aeabi_ddiv+0x444>
 80022f6:	9200      	str	r2, [sp, #0]
 80022f8:	e720      	b.n	800213c <__aeabi_ddiv+0x34c>
 80022fa:	428a      	cmp	r2, r1
 80022fc:	d800      	bhi.n	8002300 <__aeabi_ddiv+0x510>
 80022fe:	e6f6      	b.n	80020ee <__aeabi_ddiv+0x2fe>
 8002300:	1e83      	subs	r3, r0, #2
 8002302:	4449      	add	r1, r9
 8002304:	e6f3      	b.n	80020ee <__aeabi_ddiv+0x2fe>
 8002306:	230f      	movs	r3, #15
 8002308:	4023      	ands	r3, r4
 800230a:	2b04      	cmp	r3, #4
 800230c:	d100      	bne.n	8002310 <__aeabi_ddiv+0x520>
 800230e:	e5e4      	b.n	8001eda <__aeabi_ddiv+0xea>
 8002310:	2305      	movs	r3, #5
 8002312:	425b      	negs	r3, r3
 8002314:	42a3      	cmp	r3, r4
 8002316:	419b      	sbcs	r3, r3
 8002318:	3404      	adds	r4, #4
 800231a:	425b      	negs	r3, r3
 800231c:	08e4      	lsrs	r4, r4, #3
 800231e:	9a00      	ldr	r2, [sp, #0]
 8002320:	4694      	mov	ip, r2
 8002322:	449c      	add	ip, r3
 8002324:	4663      	mov	r3, ip
 8002326:	9300      	str	r3, [sp, #0]
 8002328:	e5d8      	b.n	8001edc <__aeabi_ddiv+0xec>
 800232a:	001c      	movs	r4, r3
 800232c:	4281      	cmp	r1, r0
 800232e:	d000      	beq.n	8002332 <__aeabi_ddiv+0x542>
 8002330:	e759      	b.n	80021e6 <__aeabi_ddiv+0x3f6>
 8002332:	4542      	cmp	r2, r8
 8002334:	d000      	beq.n	8002338 <__aeabi_ddiv+0x548>
 8002336:	e756      	b.n	80021e6 <__aeabi_ddiv+0x3f6>
 8002338:	e5c9      	b.n	8001ece <__aeabi_ddiv+0xde>
 800233a:	42b5      	cmp	r5, r6
 800233c:	d800      	bhi.n	8002340 <__aeabi_ddiv+0x550>
 800233e:	e77d      	b.n	800223c <__aeabi_ddiv+0x44c>
 8002340:	9b00      	ldr	r3, [sp, #0]
 8002342:	4446      	add	r6, r8
 8002344:	3b02      	subs	r3, #2
 8002346:	9300      	str	r3, [sp, #0]
 8002348:	4546      	cmp	r6, r8
 800234a:	419b      	sbcs	r3, r3
 800234c:	425b      	negs	r3, r3
 800234e:	444b      	add	r3, r9
 8002350:	18c9      	adds	r1, r1, r3
 8002352:	e6f3      	b.n	800213c <__aeabi_ddiv+0x34c>
 8002354:	2e00      	cmp	r6, #0
 8002356:	dd9c      	ble.n	8002292 <__aeabi_ddiv+0x4a2>
 8002358:	2400      	movs	r4, #0
 800235a:	2301      	movs	r3, #1
 800235c:	e7df      	b.n	800231e <__aeabi_ddiv+0x52e>
 800235e:	4643      	mov	r3, r8
 8002360:	005d      	lsls	r5, r3, #1
 8002362:	4545      	cmp	r5, r8
 8002364:	419b      	sbcs	r3, r3
 8002366:	425b      	negs	r3, r3
 8002368:	444b      	add	r3, r9
 800236a:	3c02      	subs	r4, #2
 800236c:	18c9      	adds	r1, r1, r3
 800236e:	46a8      	mov	r8, r5
 8002370:	e7dc      	b.n	800232c <__aeabi_ddiv+0x53c>
 8002372:	221f      	movs	r2, #31
 8002374:	4252      	negs	r2, r2
 8002376:	1b96      	subs	r6, r2, r6
 8002378:	9a00      	ldr	r2, [sp, #0]
 800237a:	0013      	movs	r3, r2
 800237c:	40f3      	lsrs	r3, r6
 800237e:	2920      	cmp	r1, #32
 8002380:	d003      	beq.n	800238a <__aeabi_ddiv+0x59a>
 8002382:	4815      	ldr	r0, [pc, #84]	; (80023d8 <__aeabi_ddiv+0x5e8>)
 8002384:	4458      	add	r0, fp
 8002386:	4082      	lsls	r2, r0
 8002388:	4314      	orrs	r4, r2
 800238a:	1e62      	subs	r2, r4, #1
 800238c:	4194      	sbcs	r4, r2
 800238e:	4323      	orrs	r3, r4
 8002390:	2407      	movs	r4, #7
 8002392:	2700      	movs	r7, #0
 8002394:	401c      	ands	r4, r3
 8002396:	d007      	beq.n	80023a8 <__aeabi_ddiv+0x5b8>
 8002398:	220f      	movs	r2, #15
 800239a:	2700      	movs	r7, #0
 800239c:	401a      	ands	r2, r3
 800239e:	2a04      	cmp	r2, #4
 80023a0:	d194      	bne.n	80022cc <__aeabi_ddiv+0x4dc>
 80023a2:	077c      	lsls	r4, r7, #29
 80023a4:	027f      	lsls	r7, r7, #9
 80023a6:	0b3f      	lsrs	r7, r7, #12
 80023a8:	08db      	lsrs	r3, r3, #3
 80023aa:	431c      	orrs	r4, r3
 80023ac:	2300      	movs	r3, #0
 80023ae:	e5ad      	b.n	8001f0c <__aeabi_ddiv+0x11c>
 80023b0:	2380      	movs	r3, #128	; 0x80
 80023b2:	9f00      	ldr	r7, [sp, #0]
 80023b4:	031b      	lsls	r3, r3, #12
 80023b6:	431f      	orrs	r7, r3
 80023b8:	033f      	lsls	r7, r7, #12
 80023ba:	0b3f      	lsrs	r7, r7, #12
 80023bc:	46aa      	mov	sl, r5
 80023be:	4b04      	ldr	r3, [pc, #16]	; (80023d0 <__aeabi_ddiv+0x5e0>)
 80023c0:	e5a4      	b.n	8001f0c <__aeabi_ddiv+0x11c>
 80023c2:	4590      	cmp	r8, r2
 80023c4:	d3cb      	bcc.n	800235e <__aeabi_ddiv+0x56e>
 80023c6:	001c      	movs	r4, r3
 80023c8:	e7b3      	b.n	8002332 <__aeabi_ddiv+0x542>
 80023ca:	46c0      	nop			; (mov r8, r8)
 80023cc:	000003ff 	.word	0x000003ff
 80023d0:	000007ff 	.word	0x000007ff
 80023d4:	0000041e 	.word	0x0000041e
 80023d8:	0000043e 	.word	0x0000043e
 80023dc:	00000000 	.word	0x00000000

080023e0 <__eqdf2>:
 80023e0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80023e2:	464e      	mov	r6, r9
 80023e4:	4645      	mov	r5, r8
 80023e6:	46de      	mov	lr, fp
 80023e8:	4657      	mov	r7, sl
 80023ea:	031c      	lsls	r4, r3, #12
 80023ec:	b5e0      	push	{r5, r6, r7, lr}
 80023ee:	0b24      	lsrs	r4, r4, #12
 80023f0:	4e1a      	ldr	r6, [pc, #104]	; (800245c <__eqdf2+0x7c>)
 80023f2:	030f      	lsls	r7, r1, #12
 80023f4:	004d      	lsls	r5, r1, #1
 80023f6:	46a1      	mov	r9, r4
 80023f8:	005c      	lsls	r4, r3, #1
 80023fa:	0fdb      	lsrs	r3, r3, #31
 80023fc:	4684      	mov	ip, r0
 80023fe:	0b3f      	lsrs	r7, r7, #12
 8002400:	0d6d      	lsrs	r5, r5, #21
 8002402:	0fc9      	lsrs	r1, r1, #31
 8002404:	4690      	mov	r8, r2
 8002406:	0d64      	lsrs	r4, r4, #21
 8002408:	469b      	mov	fp, r3
 800240a:	42b5      	cmp	r5, r6
 800240c:	d01a      	beq.n	8002444 <__eqdf2+0x64>
 800240e:	42b4      	cmp	r4, r6
 8002410:	d010      	beq.n	8002434 <__eqdf2+0x54>
 8002412:	2601      	movs	r6, #1
 8002414:	42a5      	cmp	r5, r4
 8002416:	d10e      	bne.n	8002436 <__eqdf2+0x56>
 8002418:	454f      	cmp	r7, r9
 800241a:	d10c      	bne.n	8002436 <__eqdf2+0x56>
 800241c:	2601      	movs	r6, #1
 800241e:	45c4      	cmp	ip, r8
 8002420:	d109      	bne.n	8002436 <__eqdf2+0x56>
 8002422:	4559      	cmp	r1, fp
 8002424:	d018      	beq.n	8002458 <__eqdf2+0x78>
 8002426:	2d00      	cmp	r5, #0
 8002428:	d105      	bne.n	8002436 <__eqdf2+0x56>
 800242a:	4338      	orrs	r0, r7
 800242c:	0006      	movs	r6, r0
 800242e:	1e70      	subs	r0, r6, #1
 8002430:	4186      	sbcs	r6, r0
 8002432:	e000      	b.n	8002436 <__eqdf2+0x56>
 8002434:	2601      	movs	r6, #1
 8002436:	0030      	movs	r0, r6
 8002438:	bc3c      	pop	{r2, r3, r4, r5}
 800243a:	4690      	mov	r8, r2
 800243c:	4699      	mov	r9, r3
 800243e:	46a2      	mov	sl, r4
 8002440:	46ab      	mov	fp, r5
 8002442:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8002444:	003b      	movs	r3, r7
 8002446:	2601      	movs	r6, #1
 8002448:	4303      	orrs	r3, r0
 800244a:	d1f4      	bne.n	8002436 <__eqdf2+0x56>
 800244c:	42ac      	cmp	r4, r5
 800244e:	d1f2      	bne.n	8002436 <__eqdf2+0x56>
 8002450:	464b      	mov	r3, r9
 8002452:	4313      	orrs	r3, r2
 8002454:	d1ef      	bne.n	8002436 <__eqdf2+0x56>
 8002456:	e7e1      	b.n	800241c <__eqdf2+0x3c>
 8002458:	2600      	movs	r6, #0
 800245a:	e7ec      	b.n	8002436 <__eqdf2+0x56>
 800245c:	000007ff 	.word	0x000007ff

08002460 <__gedf2>:
 8002460:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002462:	464f      	mov	r7, r9
 8002464:	4646      	mov	r6, r8
 8002466:	46d6      	mov	lr, sl
 8002468:	004d      	lsls	r5, r1, #1
 800246a:	b5c0      	push	{r6, r7, lr}
 800246c:	030e      	lsls	r6, r1, #12
 800246e:	0fc9      	lsrs	r1, r1, #31
 8002470:	468a      	mov	sl, r1
 8002472:	492c      	ldr	r1, [pc, #176]	; (8002524 <__gedf2+0xc4>)
 8002474:	031f      	lsls	r7, r3, #12
 8002476:	005c      	lsls	r4, r3, #1
 8002478:	4680      	mov	r8, r0
 800247a:	0b36      	lsrs	r6, r6, #12
 800247c:	0d6d      	lsrs	r5, r5, #21
 800247e:	4691      	mov	r9, r2
 8002480:	0b3f      	lsrs	r7, r7, #12
 8002482:	0d64      	lsrs	r4, r4, #21
 8002484:	0fdb      	lsrs	r3, r3, #31
 8002486:	428d      	cmp	r5, r1
 8002488:	d01e      	beq.n	80024c8 <__gedf2+0x68>
 800248a:	428c      	cmp	r4, r1
 800248c:	d016      	beq.n	80024bc <__gedf2+0x5c>
 800248e:	2d00      	cmp	r5, #0
 8002490:	d11e      	bne.n	80024d0 <__gedf2+0x70>
 8002492:	4330      	orrs	r0, r6
 8002494:	4684      	mov	ip, r0
 8002496:	2c00      	cmp	r4, #0
 8002498:	d101      	bne.n	800249e <__gedf2+0x3e>
 800249a:	433a      	orrs	r2, r7
 800249c:	d023      	beq.n	80024e6 <__gedf2+0x86>
 800249e:	4662      	mov	r2, ip
 80024a0:	2a00      	cmp	r2, #0
 80024a2:	d01a      	beq.n	80024da <__gedf2+0x7a>
 80024a4:	459a      	cmp	sl, r3
 80024a6:	d029      	beq.n	80024fc <__gedf2+0x9c>
 80024a8:	4651      	mov	r1, sl
 80024aa:	2002      	movs	r0, #2
 80024ac:	3901      	subs	r1, #1
 80024ae:	4008      	ands	r0, r1
 80024b0:	3801      	subs	r0, #1
 80024b2:	bc1c      	pop	{r2, r3, r4}
 80024b4:	4690      	mov	r8, r2
 80024b6:	4699      	mov	r9, r3
 80024b8:	46a2      	mov	sl, r4
 80024ba:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80024bc:	0039      	movs	r1, r7
 80024be:	4311      	orrs	r1, r2
 80024c0:	d0e5      	beq.n	800248e <__gedf2+0x2e>
 80024c2:	2002      	movs	r0, #2
 80024c4:	4240      	negs	r0, r0
 80024c6:	e7f4      	b.n	80024b2 <__gedf2+0x52>
 80024c8:	4330      	orrs	r0, r6
 80024ca:	d1fa      	bne.n	80024c2 <__gedf2+0x62>
 80024cc:	42ac      	cmp	r4, r5
 80024ce:	d00f      	beq.n	80024f0 <__gedf2+0x90>
 80024d0:	2c00      	cmp	r4, #0
 80024d2:	d10f      	bne.n	80024f4 <__gedf2+0x94>
 80024d4:	433a      	orrs	r2, r7
 80024d6:	d0e7      	beq.n	80024a8 <__gedf2+0x48>
 80024d8:	e00c      	b.n	80024f4 <__gedf2+0x94>
 80024da:	2201      	movs	r2, #1
 80024dc:	3b01      	subs	r3, #1
 80024de:	4393      	bics	r3, r2
 80024e0:	0018      	movs	r0, r3
 80024e2:	3001      	adds	r0, #1
 80024e4:	e7e5      	b.n	80024b2 <__gedf2+0x52>
 80024e6:	4663      	mov	r3, ip
 80024e8:	2000      	movs	r0, #0
 80024ea:	2b00      	cmp	r3, #0
 80024ec:	d0e1      	beq.n	80024b2 <__gedf2+0x52>
 80024ee:	e7db      	b.n	80024a8 <__gedf2+0x48>
 80024f0:	433a      	orrs	r2, r7
 80024f2:	d1e6      	bne.n	80024c2 <__gedf2+0x62>
 80024f4:	459a      	cmp	sl, r3
 80024f6:	d1d7      	bne.n	80024a8 <__gedf2+0x48>
 80024f8:	42a5      	cmp	r5, r4
 80024fa:	dcd5      	bgt.n	80024a8 <__gedf2+0x48>
 80024fc:	42a5      	cmp	r5, r4
 80024fe:	db05      	blt.n	800250c <__gedf2+0xac>
 8002500:	42be      	cmp	r6, r7
 8002502:	d8d1      	bhi.n	80024a8 <__gedf2+0x48>
 8002504:	d008      	beq.n	8002518 <__gedf2+0xb8>
 8002506:	2000      	movs	r0, #0
 8002508:	42be      	cmp	r6, r7
 800250a:	d2d2      	bcs.n	80024b2 <__gedf2+0x52>
 800250c:	4650      	mov	r0, sl
 800250e:	2301      	movs	r3, #1
 8002510:	3801      	subs	r0, #1
 8002512:	4398      	bics	r0, r3
 8002514:	3001      	adds	r0, #1
 8002516:	e7cc      	b.n	80024b2 <__gedf2+0x52>
 8002518:	45c8      	cmp	r8, r9
 800251a:	d8c5      	bhi.n	80024a8 <__gedf2+0x48>
 800251c:	2000      	movs	r0, #0
 800251e:	45c8      	cmp	r8, r9
 8002520:	d2c7      	bcs.n	80024b2 <__gedf2+0x52>
 8002522:	e7f3      	b.n	800250c <__gedf2+0xac>
 8002524:	000007ff 	.word	0x000007ff
	...

08002530 <__ledf2>:
 8002530:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002532:	464f      	mov	r7, r9
 8002534:	4646      	mov	r6, r8
 8002536:	46d6      	mov	lr, sl
 8002538:	004d      	lsls	r5, r1, #1
 800253a:	b5c0      	push	{r6, r7, lr}
 800253c:	030e      	lsls	r6, r1, #12
 800253e:	0fc9      	lsrs	r1, r1, #31
 8002540:	468a      	mov	sl, r1
 8002542:	492c      	ldr	r1, [pc, #176]	; (80025f4 <__ledf2+0xc4>)
 8002544:	031f      	lsls	r7, r3, #12
 8002546:	005c      	lsls	r4, r3, #1
 8002548:	4680      	mov	r8, r0
 800254a:	0b36      	lsrs	r6, r6, #12
 800254c:	0d6d      	lsrs	r5, r5, #21
 800254e:	4691      	mov	r9, r2
 8002550:	0b3f      	lsrs	r7, r7, #12
 8002552:	0d64      	lsrs	r4, r4, #21
 8002554:	0fdb      	lsrs	r3, r3, #31
 8002556:	428d      	cmp	r5, r1
 8002558:	d01e      	beq.n	8002598 <__ledf2+0x68>
 800255a:	428c      	cmp	r4, r1
 800255c:	d00c      	beq.n	8002578 <__ledf2+0x48>
 800255e:	2d00      	cmp	r5, #0
 8002560:	d11e      	bne.n	80025a0 <__ledf2+0x70>
 8002562:	4330      	orrs	r0, r6
 8002564:	4684      	mov	ip, r0
 8002566:	2c00      	cmp	r4, #0
 8002568:	d10b      	bne.n	8002582 <__ledf2+0x52>
 800256a:	433a      	orrs	r2, r7
 800256c:	d109      	bne.n	8002582 <__ledf2+0x52>
 800256e:	4663      	mov	r3, ip
 8002570:	2000      	movs	r0, #0
 8002572:	2b00      	cmp	r3, #0
 8002574:	d02f      	beq.n	80025d6 <__ledf2+0xa6>
 8002576:	e009      	b.n	800258c <__ledf2+0x5c>
 8002578:	0039      	movs	r1, r7
 800257a:	4311      	orrs	r1, r2
 800257c:	d0ef      	beq.n	800255e <__ledf2+0x2e>
 800257e:	2002      	movs	r0, #2
 8002580:	e029      	b.n	80025d6 <__ledf2+0xa6>
 8002582:	4662      	mov	r2, ip
 8002584:	2a00      	cmp	r2, #0
 8002586:	d021      	beq.n	80025cc <__ledf2+0x9c>
 8002588:	459a      	cmp	sl, r3
 800258a:	d011      	beq.n	80025b0 <__ledf2+0x80>
 800258c:	4651      	mov	r1, sl
 800258e:	2002      	movs	r0, #2
 8002590:	3901      	subs	r1, #1
 8002592:	4008      	ands	r0, r1
 8002594:	3801      	subs	r0, #1
 8002596:	e01e      	b.n	80025d6 <__ledf2+0xa6>
 8002598:	4330      	orrs	r0, r6
 800259a:	d1f0      	bne.n	800257e <__ledf2+0x4e>
 800259c:	42ac      	cmp	r4, r5
 800259e:	d01f      	beq.n	80025e0 <__ledf2+0xb0>
 80025a0:	2c00      	cmp	r4, #0
 80025a2:	d101      	bne.n	80025a8 <__ledf2+0x78>
 80025a4:	433a      	orrs	r2, r7
 80025a6:	d0f1      	beq.n	800258c <__ledf2+0x5c>
 80025a8:	459a      	cmp	sl, r3
 80025aa:	d1ef      	bne.n	800258c <__ledf2+0x5c>
 80025ac:	42a5      	cmp	r5, r4
 80025ae:	dced      	bgt.n	800258c <__ledf2+0x5c>
 80025b0:	42a5      	cmp	r5, r4
 80025b2:	db05      	blt.n	80025c0 <__ledf2+0x90>
 80025b4:	42be      	cmp	r6, r7
 80025b6:	d8e9      	bhi.n	800258c <__ledf2+0x5c>
 80025b8:	d016      	beq.n	80025e8 <__ledf2+0xb8>
 80025ba:	2000      	movs	r0, #0
 80025bc:	42be      	cmp	r6, r7
 80025be:	d20a      	bcs.n	80025d6 <__ledf2+0xa6>
 80025c0:	4650      	mov	r0, sl
 80025c2:	2301      	movs	r3, #1
 80025c4:	3801      	subs	r0, #1
 80025c6:	4398      	bics	r0, r3
 80025c8:	3001      	adds	r0, #1
 80025ca:	e004      	b.n	80025d6 <__ledf2+0xa6>
 80025cc:	2201      	movs	r2, #1
 80025ce:	3b01      	subs	r3, #1
 80025d0:	4393      	bics	r3, r2
 80025d2:	0018      	movs	r0, r3
 80025d4:	3001      	adds	r0, #1
 80025d6:	bc1c      	pop	{r2, r3, r4}
 80025d8:	4690      	mov	r8, r2
 80025da:	4699      	mov	r9, r3
 80025dc:	46a2      	mov	sl, r4
 80025de:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80025e0:	433a      	orrs	r2, r7
 80025e2:	d0e1      	beq.n	80025a8 <__ledf2+0x78>
 80025e4:	2002      	movs	r0, #2
 80025e6:	e7f6      	b.n	80025d6 <__ledf2+0xa6>
 80025e8:	45c8      	cmp	r8, r9
 80025ea:	d8cf      	bhi.n	800258c <__ledf2+0x5c>
 80025ec:	2000      	movs	r0, #0
 80025ee:	45c8      	cmp	r8, r9
 80025f0:	d2f1      	bcs.n	80025d6 <__ledf2+0xa6>
 80025f2:	e7e5      	b.n	80025c0 <__ledf2+0x90>
 80025f4:	000007ff 	.word	0x000007ff
	...

08002600 <__aeabi_dmul>:
 8002600:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002602:	4657      	mov	r7, sl
 8002604:	464e      	mov	r6, r9
 8002606:	4645      	mov	r5, r8
 8002608:	46de      	mov	lr, fp
 800260a:	b5e0      	push	{r5, r6, r7, lr}
 800260c:	030c      	lsls	r4, r1, #12
 800260e:	4681      	mov	r9, r0
 8002610:	001f      	movs	r7, r3
 8002612:	0005      	movs	r5, r0
 8002614:	0b23      	lsrs	r3, r4, #12
 8002616:	0048      	lsls	r0, r1, #1
 8002618:	b087      	sub	sp, #28
 800261a:	4692      	mov	sl, r2
 800261c:	4698      	mov	r8, r3
 800261e:	0d40      	lsrs	r0, r0, #21
 8002620:	0fce      	lsrs	r6, r1, #31
 8002622:	2800      	cmp	r0, #0
 8002624:	d100      	bne.n	8002628 <__aeabi_dmul+0x28>
 8002626:	e07c      	b.n	8002722 <__aeabi_dmul+0x122>
 8002628:	4b7d      	ldr	r3, [pc, #500]	; (8002820 <__aeabi_dmul+0x220>)
 800262a:	4298      	cmp	r0, r3
 800262c:	d100      	bne.n	8002630 <__aeabi_dmul+0x30>
 800262e:	e096      	b.n	800275e <__aeabi_dmul+0x15e>
 8002630:	4643      	mov	r3, r8
 8002632:	0f6c      	lsrs	r4, r5, #29
 8002634:	00db      	lsls	r3, r3, #3
 8002636:	431c      	orrs	r4, r3
 8002638:	2380      	movs	r3, #128	; 0x80
 800263a:	4a7a      	ldr	r2, [pc, #488]	; (8002824 <__aeabi_dmul+0x224>)
 800263c:	041b      	lsls	r3, r3, #16
 800263e:	431c      	orrs	r4, r3
 8002640:	4694      	mov	ip, r2
 8002642:	0003      	movs	r3, r0
 8002644:	4463      	add	r3, ip
 8002646:	9301      	str	r3, [sp, #4]
 8002648:	2300      	movs	r3, #0
 800264a:	4698      	mov	r8, r3
 800264c:	469b      	mov	fp, r3
 800264e:	00ed      	lsls	r5, r5, #3
 8002650:	033b      	lsls	r3, r7, #12
 8002652:	0b1b      	lsrs	r3, r3, #12
 8002654:	4699      	mov	r9, r3
 8002656:	007a      	lsls	r2, r7, #1
 8002658:	0ffb      	lsrs	r3, r7, #31
 800265a:	4651      	mov	r1, sl
 800265c:	0d52      	lsrs	r2, r2, #21
 800265e:	9302      	str	r3, [sp, #8]
 8002660:	d100      	bne.n	8002664 <__aeabi_dmul+0x64>
 8002662:	e087      	b.n	8002774 <__aeabi_dmul+0x174>
 8002664:	4b6e      	ldr	r3, [pc, #440]	; (8002820 <__aeabi_dmul+0x220>)
 8002666:	429a      	cmp	r2, r3
 8002668:	d022      	beq.n	80026b0 <__aeabi_dmul+0xb0>
 800266a:	486e      	ldr	r0, [pc, #440]	; (8002824 <__aeabi_dmul+0x224>)
 800266c:	0f4b      	lsrs	r3, r1, #29
 800266e:	4684      	mov	ip, r0
 8002670:	9801      	ldr	r0, [sp, #4]
 8002672:	4462      	add	r2, ip
 8002674:	4684      	mov	ip, r0
 8002676:	4649      	mov	r1, r9
 8002678:	4494      	add	ip, r2
 800267a:	4662      	mov	r2, ip
 800267c:	00c9      	lsls	r1, r1, #3
 800267e:	430b      	orrs	r3, r1
 8002680:	2180      	movs	r1, #128	; 0x80
 8002682:	9201      	str	r2, [sp, #4]
 8002684:	2200      	movs	r2, #0
 8002686:	0409      	lsls	r1, r1, #16
 8002688:	430b      	orrs	r3, r1
 800268a:	4651      	mov	r1, sl
 800268c:	4694      	mov	ip, r2
 800268e:	00c9      	lsls	r1, r1, #3
 8002690:	0032      	movs	r2, r6
 8002692:	9802      	ldr	r0, [sp, #8]
 8002694:	4042      	eors	r2, r0
 8002696:	9801      	ldr	r0, [sp, #4]
 8002698:	3001      	adds	r0, #1
 800269a:	9003      	str	r0, [sp, #12]
 800269c:	4640      	mov	r0, r8
 800269e:	280f      	cmp	r0, #15
 80026a0:	d900      	bls.n	80026a4 <__aeabi_dmul+0xa4>
 80026a2:	e0c7      	b.n	8002834 <__aeabi_dmul+0x234>
 80026a4:	0080      	lsls	r0, r0, #2
 80026a6:	4680      	mov	r8, r0
 80026a8:	4647      	mov	r7, r8
 80026aa:	485f      	ldr	r0, [pc, #380]	; (8002828 <__aeabi_dmul+0x228>)
 80026ac:	59c0      	ldr	r0, [r0, r7]
 80026ae:	4687      	mov	pc, r0
 80026b0:	464a      	mov	r2, r9
 80026b2:	4653      	mov	r3, sl
 80026b4:	485a      	ldr	r0, [pc, #360]	; (8002820 <__aeabi_dmul+0x220>)
 80026b6:	4313      	orrs	r3, r2
 80026b8:	4684      	mov	ip, r0
 80026ba:	9a01      	ldr	r2, [sp, #4]
 80026bc:	4462      	add	r2, ip
 80026be:	9201      	str	r2, [sp, #4]
 80026c0:	2b00      	cmp	r3, #0
 80026c2:	d000      	beq.n	80026c6 <__aeabi_dmul+0xc6>
 80026c4:	e08c      	b.n	80027e0 <__aeabi_dmul+0x1e0>
 80026c6:	2202      	movs	r2, #2
 80026c8:	4641      	mov	r1, r8
 80026ca:	4311      	orrs	r1, r2
 80026cc:	4688      	mov	r8, r1
 80026ce:	4694      	mov	ip, r2
 80026d0:	2100      	movs	r1, #0
 80026d2:	e7dd      	b.n	8002690 <__aeabi_dmul+0x90>
 80026d4:	9a02      	ldr	r2, [sp, #8]
 80026d6:	001c      	movs	r4, r3
 80026d8:	000d      	movs	r5, r1
 80026da:	46e3      	mov	fp, ip
 80026dc:	465b      	mov	r3, fp
 80026de:	2b02      	cmp	r3, #2
 80026e0:	d06b      	beq.n	80027ba <__aeabi_dmul+0x1ba>
 80026e2:	2b03      	cmp	r3, #3
 80026e4:	d100      	bne.n	80026e8 <__aeabi_dmul+0xe8>
 80026e6:	e1ff      	b.n	8002ae8 <__aeabi_dmul+0x4e8>
 80026e8:	2b01      	cmp	r3, #1
 80026ea:	d000      	beq.n	80026ee <__aeabi_dmul+0xee>
 80026ec:	e165      	b.n	80029ba <__aeabi_dmul+0x3ba>
 80026ee:	2600      	movs	r6, #0
 80026f0:	2400      	movs	r4, #0
 80026f2:	2500      	movs	r5, #0
 80026f4:	2100      	movs	r1, #0
 80026f6:	0324      	lsls	r4, r4, #12
 80026f8:	0b23      	lsrs	r3, r4, #12
 80026fa:	0d0c      	lsrs	r4, r1, #20
 80026fc:	0524      	lsls	r4, r4, #20
 80026fe:	431c      	orrs	r4, r3
 8002700:	4b4a      	ldr	r3, [pc, #296]	; (800282c <__aeabi_dmul+0x22c>)
 8002702:	0536      	lsls	r6, r6, #20
 8002704:	4023      	ands	r3, r4
 8002706:	4333      	orrs	r3, r6
 8002708:	005b      	lsls	r3, r3, #1
 800270a:	07d2      	lsls	r2, r2, #31
 800270c:	085b      	lsrs	r3, r3, #1
 800270e:	4313      	orrs	r3, r2
 8002710:	0028      	movs	r0, r5
 8002712:	0019      	movs	r1, r3
 8002714:	b007      	add	sp, #28
 8002716:	bc3c      	pop	{r2, r3, r4, r5}
 8002718:	4690      	mov	r8, r2
 800271a:	4699      	mov	r9, r3
 800271c:	46a2      	mov	sl, r4
 800271e:	46ab      	mov	fp, r5
 8002720:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8002722:	001c      	movs	r4, r3
 8002724:	432c      	orrs	r4, r5
 8002726:	d053      	beq.n	80027d0 <__aeabi_dmul+0x1d0>
 8002728:	4643      	mov	r3, r8
 800272a:	2b00      	cmp	r3, #0
 800272c:	d100      	bne.n	8002730 <__aeabi_dmul+0x130>
 800272e:	e181      	b.n	8002a34 <__aeabi_dmul+0x434>
 8002730:	4640      	mov	r0, r8
 8002732:	f000 ff35 	bl	80035a0 <__clzsi2>
 8002736:	0002      	movs	r2, r0
 8002738:	3a0b      	subs	r2, #11
 800273a:	231d      	movs	r3, #29
 800273c:	0001      	movs	r1, r0
 800273e:	1a9b      	subs	r3, r3, r2
 8002740:	4644      	mov	r4, r8
 8002742:	464a      	mov	r2, r9
 8002744:	464d      	mov	r5, r9
 8002746:	3908      	subs	r1, #8
 8002748:	408c      	lsls	r4, r1
 800274a:	40da      	lsrs	r2, r3
 800274c:	408d      	lsls	r5, r1
 800274e:	4314      	orrs	r4, r2
 8002750:	4b37      	ldr	r3, [pc, #220]	; (8002830 <__aeabi_dmul+0x230>)
 8002752:	1a1b      	subs	r3, r3, r0
 8002754:	9301      	str	r3, [sp, #4]
 8002756:	2300      	movs	r3, #0
 8002758:	4698      	mov	r8, r3
 800275a:	469b      	mov	fp, r3
 800275c:	e778      	b.n	8002650 <__aeabi_dmul+0x50>
 800275e:	464c      	mov	r4, r9
 8002760:	4643      	mov	r3, r8
 8002762:	431c      	orrs	r4, r3
 8002764:	d12d      	bne.n	80027c2 <__aeabi_dmul+0x1c2>
 8002766:	2308      	movs	r3, #8
 8002768:	4698      	mov	r8, r3
 800276a:	3b06      	subs	r3, #6
 800276c:	2500      	movs	r5, #0
 800276e:	9001      	str	r0, [sp, #4]
 8002770:	469b      	mov	fp, r3
 8002772:	e76d      	b.n	8002650 <__aeabi_dmul+0x50>
 8002774:	464b      	mov	r3, r9
 8002776:	2201      	movs	r2, #1
 8002778:	430b      	orrs	r3, r1
 800277a:	d0a5      	beq.n	80026c8 <__aeabi_dmul+0xc8>
 800277c:	464b      	mov	r3, r9
 800277e:	2b00      	cmp	r3, #0
 8002780:	d100      	bne.n	8002784 <__aeabi_dmul+0x184>
 8002782:	e147      	b.n	8002a14 <__aeabi_dmul+0x414>
 8002784:	4648      	mov	r0, r9
 8002786:	f000 ff0b 	bl	80035a0 <__clzsi2>
 800278a:	0002      	movs	r2, r0
 800278c:	3a0b      	subs	r2, #11
 800278e:	271d      	movs	r7, #29
 8002790:	1aba      	subs	r2, r7, r2
 8002792:	4657      	mov	r7, sl
 8002794:	0001      	movs	r1, r0
 8002796:	40d7      	lsrs	r7, r2
 8002798:	4652      	mov	r2, sl
 800279a:	3908      	subs	r1, #8
 800279c:	464b      	mov	r3, r9
 800279e:	408a      	lsls	r2, r1
 80027a0:	408b      	lsls	r3, r1
 80027a2:	0011      	movs	r1, r2
 80027a4:	433b      	orrs	r3, r7
 80027a6:	9a01      	ldr	r2, [sp, #4]
 80027a8:	4f21      	ldr	r7, [pc, #132]	; (8002830 <__aeabi_dmul+0x230>)
 80027aa:	1a10      	subs	r0, r2, r0
 80027ac:	46bc      	mov	ip, r7
 80027ae:	0002      	movs	r2, r0
 80027b0:	4462      	add	r2, ip
 80027b2:	9201      	str	r2, [sp, #4]
 80027b4:	2200      	movs	r2, #0
 80027b6:	4694      	mov	ip, r2
 80027b8:	e76a      	b.n	8002690 <__aeabi_dmul+0x90>
 80027ba:	4e19      	ldr	r6, [pc, #100]	; (8002820 <__aeabi_dmul+0x220>)
 80027bc:	2400      	movs	r4, #0
 80027be:	2500      	movs	r5, #0
 80027c0:	e798      	b.n	80026f4 <__aeabi_dmul+0xf4>
 80027c2:	230c      	movs	r3, #12
 80027c4:	4644      	mov	r4, r8
 80027c6:	4698      	mov	r8, r3
 80027c8:	3b09      	subs	r3, #9
 80027ca:	9001      	str	r0, [sp, #4]
 80027cc:	469b      	mov	fp, r3
 80027ce:	e73f      	b.n	8002650 <__aeabi_dmul+0x50>
 80027d0:	2304      	movs	r3, #4
 80027d2:	4698      	mov	r8, r3
 80027d4:	2300      	movs	r3, #0
 80027d6:	9301      	str	r3, [sp, #4]
 80027d8:	3301      	adds	r3, #1
 80027da:	2500      	movs	r5, #0
 80027dc:	469b      	mov	fp, r3
 80027de:	e737      	b.n	8002650 <__aeabi_dmul+0x50>
 80027e0:	2303      	movs	r3, #3
 80027e2:	4642      	mov	r2, r8
 80027e4:	431a      	orrs	r2, r3
 80027e6:	4690      	mov	r8, r2
 80027e8:	2203      	movs	r2, #3
 80027ea:	464b      	mov	r3, r9
 80027ec:	4694      	mov	ip, r2
 80027ee:	e74f      	b.n	8002690 <__aeabi_dmul+0x90>
 80027f0:	0032      	movs	r2, r6
 80027f2:	e773      	b.n	80026dc <__aeabi_dmul+0xdc>
 80027f4:	2480      	movs	r4, #128	; 0x80
 80027f6:	2200      	movs	r2, #0
 80027f8:	0324      	lsls	r4, r4, #12
 80027fa:	2500      	movs	r5, #0
 80027fc:	4e08      	ldr	r6, [pc, #32]	; (8002820 <__aeabi_dmul+0x220>)
 80027fe:	e779      	b.n	80026f4 <__aeabi_dmul+0xf4>
 8002800:	2280      	movs	r2, #128	; 0x80
 8002802:	0312      	lsls	r2, r2, #12
 8002804:	4214      	tst	r4, r2
 8002806:	d100      	bne.n	800280a <__aeabi_dmul+0x20a>
 8002808:	e0fc      	b.n	8002a04 <__aeabi_dmul+0x404>
 800280a:	4213      	tst	r3, r2
 800280c:	d000      	beq.n	8002810 <__aeabi_dmul+0x210>
 800280e:	e0f9      	b.n	8002a04 <__aeabi_dmul+0x404>
 8002810:	431a      	orrs	r2, r3
 8002812:	0314      	lsls	r4, r2, #12
 8002814:	0b24      	lsrs	r4, r4, #12
 8002816:	9a02      	ldr	r2, [sp, #8]
 8002818:	000d      	movs	r5, r1
 800281a:	4e01      	ldr	r6, [pc, #4]	; (8002820 <__aeabi_dmul+0x220>)
 800281c:	e76a      	b.n	80026f4 <__aeabi_dmul+0xf4>
 800281e:	46c0      	nop			; (mov r8, r8)
 8002820:	000007ff 	.word	0x000007ff
 8002824:	fffffc01 	.word	0xfffffc01
 8002828:	080134ec 	.word	0x080134ec
 800282c:	800fffff 	.word	0x800fffff
 8002830:	fffffc0d 	.word	0xfffffc0d
 8002834:	0c2f      	lsrs	r7, r5, #16
 8002836:	042d      	lsls	r5, r5, #16
 8002838:	0c2d      	lsrs	r5, r5, #16
 800283a:	0028      	movs	r0, r5
 800283c:	0c0e      	lsrs	r6, r1, #16
 800283e:	0409      	lsls	r1, r1, #16
 8002840:	0c09      	lsrs	r1, r1, #16
 8002842:	4348      	muls	r0, r1
 8002844:	4680      	mov	r8, r0
 8002846:	0008      	movs	r0, r1
 8002848:	4378      	muls	r0, r7
 800284a:	4681      	mov	r9, r0
 800284c:	0030      	movs	r0, r6
 800284e:	4378      	muls	r0, r7
 8002850:	9002      	str	r0, [sp, #8]
 8002852:	0028      	movs	r0, r5
 8002854:	4370      	muls	r0, r6
 8002856:	4684      	mov	ip, r0
 8002858:	4640      	mov	r0, r8
 800285a:	0c00      	lsrs	r0, r0, #16
 800285c:	4682      	mov	sl, r0
 800285e:	44cc      	add	ip, r9
 8002860:	44d4      	add	ip, sl
 8002862:	45e1      	cmp	r9, ip
 8002864:	d907      	bls.n	8002876 <__aeabi_dmul+0x276>
 8002866:	9802      	ldr	r0, [sp, #8]
 8002868:	4682      	mov	sl, r0
 800286a:	2080      	movs	r0, #128	; 0x80
 800286c:	0240      	lsls	r0, r0, #9
 800286e:	4681      	mov	r9, r0
 8002870:	44ca      	add	sl, r9
 8002872:	4650      	mov	r0, sl
 8002874:	9002      	str	r0, [sp, #8]
 8002876:	4660      	mov	r0, ip
 8002878:	0c00      	lsrs	r0, r0, #16
 800287a:	4683      	mov	fp, r0
 800287c:	4660      	mov	r0, ip
 800287e:	0400      	lsls	r0, r0, #16
 8002880:	4684      	mov	ip, r0
 8002882:	4640      	mov	r0, r8
 8002884:	0400      	lsls	r0, r0, #16
 8002886:	0c00      	lsrs	r0, r0, #16
 8002888:	4680      	mov	r8, r0
 800288a:	4660      	mov	r0, ip
 800288c:	4440      	add	r0, r8
 800288e:	9004      	str	r0, [sp, #16]
 8002890:	0c18      	lsrs	r0, r3, #16
 8002892:	4680      	mov	r8, r0
 8002894:	0028      	movs	r0, r5
 8002896:	041b      	lsls	r3, r3, #16
 8002898:	0c1b      	lsrs	r3, r3, #16
 800289a:	4358      	muls	r0, r3
 800289c:	4684      	mov	ip, r0
 800289e:	0018      	movs	r0, r3
 80028a0:	4378      	muls	r0, r7
 80028a2:	4681      	mov	r9, r0
 80028a4:	4640      	mov	r0, r8
 80028a6:	4378      	muls	r0, r7
 80028a8:	4682      	mov	sl, r0
 80028aa:	4640      	mov	r0, r8
 80028ac:	4345      	muls	r5, r0
 80028ae:	4660      	mov	r0, ip
 80028b0:	444d      	add	r5, r9
 80028b2:	0c07      	lsrs	r7, r0, #16
 80028b4:	197d      	adds	r5, r7, r5
 80028b6:	45a9      	cmp	r9, r5
 80028b8:	d903      	bls.n	80028c2 <__aeabi_dmul+0x2c2>
 80028ba:	2080      	movs	r0, #128	; 0x80
 80028bc:	0240      	lsls	r0, r0, #9
 80028be:	4681      	mov	r9, r0
 80028c0:	44ca      	add	sl, r9
 80028c2:	4660      	mov	r0, ip
 80028c4:	0c2f      	lsrs	r7, r5, #16
 80028c6:	44ba      	add	sl, r7
 80028c8:	0407      	lsls	r7, r0, #16
 80028ca:	0c3f      	lsrs	r7, r7, #16
 80028cc:	042d      	lsls	r5, r5, #16
 80028ce:	19ed      	adds	r5, r5, r7
 80028d0:	44ab      	add	fp, r5
 80028d2:	4658      	mov	r0, fp
 80028d4:	0c27      	lsrs	r7, r4, #16
 80028d6:	0424      	lsls	r4, r4, #16
 80028d8:	0c24      	lsrs	r4, r4, #16
 80028da:	9005      	str	r0, [sp, #20]
 80028dc:	0020      	movs	r0, r4
 80028de:	4348      	muls	r0, r1
 80028e0:	4379      	muls	r1, r7
 80028e2:	4689      	mov	r9, r1
 80028e4:	0039      	movs	r1, r7
 80028e6:	4684      	mov	ip, r0
 80028e8:	0c00      	lsrs	r0, r0, #16
 80028ea:	4683      	mov	fp, r0
 80028ec:	4371      	muls	r1, r6
 80028ee:	4366      	muls	r6, r4
 80028f0:	444e      	add	r6, r9
 80028f2:	445e      	add	r6, fp
 80028f4:	45b1      	cmp	r9, r6
 80028f6:	d903      	bls.n	8002900 <__aeabi_dmul+0x300>
 80028f8:	2080      	movs	r0, #128	; 0x80
 80028fa:	0240      	lsls	r0, r0, #9
 80028fc:	4681      	mov	r9, r0
 80028fe:	4449      	add	r1, r9
 8002900:	0c30      	lsrs	r0, r6, #16
 8002902:	4681      	mov	r9, r0
 8002904:	4660      	mov	r0, ip
 8002906:	0400      	lsls	r0, r0, #16
 8002908:	0c00      	lsrs	r0, r0, #16
 800290a:	4684      	mov	ip, r0
 800290c:	0020      	movs	r0, r4
 800290e:	4358      	muls	r0, r3
 8002910:	4449      	add	r1, r9
 8002912:	4681      	mov	r9, r0
 8002914:	4640      	mov	r0, r8
 8002916:	4378      	muls	r0, r7
 8002918:	0436      	lsls	r6, r6, #16
 800291a:	4466      	add	r6, ip
 800291c:	4684      	mov	ip, r0
 800291e:	4640      	mov	r0, r8
 8002920:	4344      	muls	r4, r0
 8002922:	4648      	mov	r0, r9
 8002924:	437b      	muls	r3, r7
 8002926:	0c07      	lsrs	r7, r0, #16
 8002928:	18e4      	adds	r4, r4, r3
 800292a:	193c      	adds	r4, r7, r4
 800292c:	42a3      	cmp	r3, r4
 800292e:	d903      	bls.n	8002938 <__aeabi_dmul+0x338>
 8002930:	2380      	movs	r3, #128	; 0x80
 8002932:	025b      	lsls	r3, r3, #9
 8002934:	4698      	mov	r8, r3
 8002936:	44c4      	add	ip, r8
 8002938:	9805      	ldr	r0, [sp, #20]
 800293a:	9b02      	ldr	r3, [sp, #8]
 800293c:	4680      	mov	r8, r0
 800293e:	4648      	mov	r0, r9
 8002940:	0400      	lsls	r0, r0, #16
 8002942:	0c00      	lsrs	r0, r0, #16
 8002944:	4443      	add	r3, r8
 8002946:	4681      	mov	r9, r0
 8002948:	42ab      	cmp	r3, r5
 800294a:	41ad      	sbcs	r5, r5
 800294c:	199b      	adds	r3, r3, r6
 800294e:	42b3      	cmp	r3, r6
 8002950:	41b6      	sbcs	r6, r6
 8002952:	0427      	lsls	r7, r4, #16
 8002954:	444f      	add	r7, r9
 8002956:	426d      	negs	r5, r5
 8002958:	4457      	add	r7, sl
 800295a:	1978      	adds	r0, r7, r5
 800295c:	4680      	mov	r8, r0
 800295e:	4276      	negs	r6, r6
 8002960:	468b      	mov	fp, r1
 8002962:	46b1      	mov	r9, r6
 8002964:	44c3      	add	fp, r8
 8002966:	44d9      	add	r9, fp
 8002968:	4557      	cmp	r7, sl
 800296a:	41bf      	sbcs	r7, r7
 800296c:	45a8      	cmp	r8, r5
 800296e:	41ad      	sbcs	r5, r5
 8002970:	458b      	cmp	fp, r1
 8002972:	4189      	sbcs	r1, r1
 8002974:	45b1      	cmp	r9, r6
 8002976:	41b6      	sbcs	r6, r6
 8002978:	426d      	negs	r5, r5
 800297a:	427f      	negs	r7, r7
 800297c:	432f      	orrs	r7, r5
 800297e:	0c24      	lsrs	r4, r4, #16
 8002980:	4249      	negs	r1, r1
 8002982:	4276      	negs	r6, r6
 8002984:	4331      	orrs	r1, r6
 8002986:	193c      	adds	r4, r7, r4
 8002988:	1864      	adds	r4, r4, r1
 800298a:	4649      	mov	r1, r9
 800298c:	4464      	add	r4, ip
 800298e:	0dc9      	lsrs	r1, r1, #23
 8002990:	0264      	lsls	r4, r4, #9
 8002992:	430c      	orrs	r4, r1
 8002994:	9904      	ldr	r1, [sp, #16]
 8002996:	025d      	lsls	r5, r3, #9
 8002998:	430d      	orrs	r5, r1
 800299a:	1e69      	subs	r1, r5, #1
 800299c:	418d      	sbcs	r5, r1
 800299e:	0ddb      	lsrs	r3, r3, #23
 80029a0:	431d      	orrs	r5, r3
 80029a2:	464b      	mov	r3, r9
 80029a4:	025b      	lsls	r3, r3, #9
 80029a6:	431d      	orrs	r5, r3
 80029a8:	01e3      	lsls	r3, r4, #7
 80029aa:	d57a      	bpl.n	8002aa2 <__aeabi_dmul+0x4a2>
 80029ac:	2101      	movs	r1, #1
 80029ae:	086b      	lsrs	r3, r5, #1
 80029b0:	400d      	ands	r5, r1
 80029b2:	431d      	orrs	r5, r3
 80029b4:	07e3      	lsls	r3, r4, #31
 80029b6:	431d      	orrs	r5, r3
 80029b8:	0864      	lsrs	r4, r4, #1
 80029ba:	4b4f      	ldr	r3, [pc, #316]	; (8002af8 <__aeabi_dmul+0x4f8>)
 80029bc:	9903      	ldr	r1, [sp, #12]
 80029be:	18ce      	adds	r6, r1, r3
 80029c0:	2e00      	cmp	r6, #0
 80029c2:	dd46      	ble.n	8002a52 <__aeabi_dmul+0x452>
 80029c4:	076b      	lsls	r3, r5, #29
 80029c6:	d009      	beq.n	80029dc <__aeabi_dmul+0x3dc>
 80029c8:	210f      	movs	r1, #15
 80029ca:	4029      	ands	r1, r5
 80029cc:	2904      	cmp	r1, #4
 80029ce:	d005      	beq.n	80029dc <__aeabi_dmul+0x3dc>
 80029d0:	1d2b      	adds	r3, r5, #4
 80029d2:	42ab      	cmp	r3, r5
 80029d4:	41ad      	sbcs	r5, r5
 80029d6:	426d      	negs	r5, r5
 80029d8:	1964      	adds	r4, r4, r5
 80029da:	001d      	movs	r5, r3
 80029dc:	01e3      	lsls	r3, r4, #7
 80029de:	d505      	bpl.n	80029ec <__aeabi_dmul+0x3ec>
 80029e0:	4b46      	ldr	r3, [pc, #280]	; (8002afc <__aeabi_dmul+0x4fc>)
 80029e2:	9903      	ldr	r1, [sp, #12]
 80029e4:	401c      	ands	r4, r3
 80029e6:	2380      	movs	r3, #128	; 0x80
 80029e8:	00db      	lsls	r3, r3, #3
 80029ea:	18ce      	adds	r6, r1, r3
 80029ec:	4944      	ldr	r1, [pc, #272]	; (8002b00 <__aeabi_dmul+0x500>)
 80029ee:	428e      	cmp	r6, r1
 80029f0:	dd00      	ble.n	80029f4 <__aeabi_dmul+0x3f4>
 80029f2:	e6e2      	b.n	80027ba <__aeabi_dmul+0x1ba>
 80029f4:	0763      	lsls	r3, r4, #29
 80029f6:	08ed      	lsrs	r5, r5, #3
 80029f8:	0264      	lsls	r4, r4, #9
 80029fa:	0576      	lsls	r6, r6, #21
 80029fc:	431d      	orrs	r5, r3
 80029fe:	0b24      	lsrs	r4, r4, #12
 8002a00:	0d76      	lsrs	r6, r6, #21
 8002a02:	e677      	b.n	80026f4 <__aeabi_dmul+0xf4>
 8002a04:	2380      	movs	r3, #128	; 0x80
 8002a06:	031b      	lsls	r3, r3, #12
 8002a08:	431c      	orrs	r4, r3
 8002a0a:	0324      	lsls	r4, r4, #12
 8002a0c:	0032      	movs	r2, r6
 8002a0e:	0b24      	lsrs	r4, r4, #12
 8002a10:	4e3c      	ldr	r6, [pc, #240]	; (8002b04 <__aeabi_dmul+0x504>)
 8002a12:	e66f      	b.n	80026f4 <__aeabi_dmul+0xf4>
 8002a14:	4650      	mov	r0, sl
 8002a16:	f000 fdc3 	bl	80035a0 <__clzsi2>
 8002a1a:	0003      	movs	r3, r0
 8002a1c:	001a      	movs	r2, r3
 8002a1e:	3215      	adds	r2, #21
 8002a20:	3020      	adds	r0, #32
 8002a22:	2a1c      	cmp	r2, #28
 8002a24:	dc00      	bgt.n	8002a28 <__aeabi_dmul+0x428>
 8002a26:	e6b2      	b.n	800278e <__aeabi_dmul+0x18e>
 8002a28:	4652      	mov	r2, sl
 8002a2a:	3b08      	subs	r3, #8
 8002a2c:	409a      	lsls	r2, r3
 8002a2e:	2100      	movs	r1, #0
 8002a30:	0013      	movs	r3, r2
 8002a32:	e6b8      	b.n	80027a6 <__aeabi_dmul+0x1a6>
 8002a34:	4648      	mov	r0, r9
 8002a36:	f000 fdb3 	bl	80035a0 <__clzsi2>
 8002a3a:	0003      	movs	r3, r0
 8002a3c:	001a      	movs	r2, r3
 8002a3e:	3215      	adds	r2, #21
 8002a40:	3020      	adds	r0, #32
 8002a42:	2a1c      	cmp	r2, #28
 8002a44:	dc00      	bgt.n	8002a48 <__aeabi_dmul+0x448>
 8002a46:	e678      	b.n	800273a <__aeabi_dmul+0x13a>
 8002a48:	464c      	mov	r4, r9
 8002a4a:	3b08      	subs	r3, #8
 8002a4c:	409c      	lsls	r4, r3
 8002a4e:	2500      	movs	r5, #0
 8002a50:	e67e      	b.n	8002750 <__aeabi_dmul+0x150>
 8002a52:	2101      	movs	r1, #1
 8002a54:	1b89      	subs	r1, r1, r6
 8002a56:	2938      	cmp	r1, #56	; 0x38
 8002a58:	dd00      	ble.n	8002a5c <__aeabi_dmul+0x45c>
 8002a5a:	e648      	b.n	80026ee <__aeabi_dmul+0xee>
 8002a5c:	291f      	cmp	r1, #31
 8002a5e:	dc23      	bgt.n	8002aa8 <__aeabi_dmul+0x4a8>
 8002a60:	4b29      	ldr	r3, [pc, #164]	; (8002b08 <__aeabi_dmul+0x508>)
 8002a62:	002e      	movs	r6, r5
 8002a64:	469c      	mov	ip, r3
 8002a66:	9b03      	ldr	r3, [sp, #12]
 8002a68:	40ce      	lsrs	r6, r1
 8002a6a:	4463      	add	r3, ip
 8002a6c:	0018      	movs	r0, r3
 8002a6e:	0023      	movs	r3, r4
 8002a70:	4085      	lsls	r5, r0
 8002a72:	4083      	lsls	r3, r0
 8002a74:	1e68      	subs	r0, r5, #1
 8002a76:	4185      	sbcs	r5, r0
 8002a78:	4333      	orrs	r3, r6
 8002a7a:	432b      	orrs	r3, r5
 8002a7c:	40cc      	lsrs	r4, r1
 8002a7e:	0759      	lsls	r1, r3, #29
 8002a80:	d009      	beq.n	8002a96 <__aeabi_dmul+0x496>
 8002a82:	210f      	movs	r1, #15
 8002a84:	4019      	ands	r1, r3
 8002a86:	2904      	cmp	r1, #4
 8002a88:	d005      	beq.n	8002a96 <__aeabi_dmul+0x496>
 8002a8a:	1d19      	adds	r1, r3, #4
 8002a8c:	4299      	cmp	r1, r3
 8002a8e:	419b      	sbcs	r3, r3
 8002a90:	425b      	negs	r3, r3
 8002a92:	18e4      	adds	r4, r4, r3
 8002a94:	000b      	movs	r3, r1
 8002a96:	0221      	lsls	r1, r4, #8
 8002a98:	d51f      	bpl.n	8002ada <__aeabi_dmul+0x4da>
 8002a9a:	2601      	movs	r6, #1
 8002a9c:	2400      	movs	r4, #0
 8002a9e:	2500      	movs	r5, #0
 8002aa0:	e628      	b.n	80026f4 <__aeabi_dmul+0xf4>
 8002aa2:	9b01      	ldr	r3, [sp, #4]
 8002aa4:	9303      	str	r3, [sp, #12]
 8002aa6:	e788      	b.n	80029ba <__aeabi_dmul+0x3ba>
 8002aa8:	231f      	movs	r3, #31
 8002aaa:	425b      	negs	r3, r3
 8002aac:	1b9e      	subs	r6, r3, r6
 8002aae:	0023      	movs	r3, r4
 8002ab0:	40f3      	lsrs	r3, r6
 8002ab2:	2920      	cmp	r1, #32
 8002ab4:	d005      	beq.n	8002ac2 <__aeabi_dmul+0x4c2>
 8002ab6:	4915      	ldr	r1, [pc, #84]	; (8002b0c <__aeabi_dmul+0x50c>)
 8002ab8:	468c      	mov	ip, r1
 8002aba:	9903      	ldr	r1, [sp, #12]
 8002abc:	4461      	add	r1, ip
 8002abe:	408c      	lsls	r4, r1
 8002ac0:	4325      	orrs	r5, r4
 8002ac2:	1e69      	subs	r1, r5, #1
 8002ac4:	418d      	sbcs	r5, r1
 8002ac6:	432b      	orrs	r3, r5
 8002ac8:	2507      	movs	r5, #7
 8002aca:	2400      	movs	r4, #0
 8002acc:	401d      	ands	r5, r3
 8002ace:	d007      	beq.n	8002ae0 <__aeabi_dmul+0x4e0>
 8002ad0:	210f      	movs	r1, #15
 8002ad2:	2400      	movs	r4, #0
 8002ad4:	4019      	ands	r1, r3
 8002ad6:	2904      	cmp	r1, #4
 8002ad8:	d1d7      	bne.n	8002a8a <__aeabi_dmul+0x48a>
 8002ada:	0765      	lsls	r5, r4, #29
 8002adc:	0264      	lsls	r4, r4, #9
 8002ade:	0b24      	lsrs	r4, r4, #12
 8002ae0:	08db      	lsrs	r3, r3, #3
 8002ae2:	431d      	orrs	r5, r3
 8002ae4:	2600      	movs	r6, #0
 8002ae6:	e605      	b.n	80026f4 <__aeabi_dmul+0xf4>
 8002ae8:	2380      	movs	r3, #128	; 0x80
 8002aea:	031b      	lsls	r3, r3, #12
 8002aec:	431c      	orrs	r4, r3
 8002aee:	0324      	lsls	r4, r4, #12
 8002af0:	0b24      	lsrs	r4, r4, #12
 8002af2:	4e04      	ldr	r6, [pc, #16]	; (8002b04 <__aeabi_dmul+0x504>)
 8002af4:	e5fe      	b.n	80026f4 <__aeabi_dmul+0xf4>
 8002af6:	46c0      	nop			; (mov r8, r8)
 8002af8:	000003ff 	.word	0x000003ff
 8002afc:	feffffff 	.word	0xfeffffff
 8002b00:	000007fe 	.word	0x000007fe
 8002b04:	000007ff 	.word	0x000007ff
 8002b08:	0000041e 	.word	0x0000041e
 8002b0c:	0000043e 	.word	0x0000043e

08002b10 <__aeabi_dsub>:
 8002b10:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002b12:	4657      	mov	r7, sl
 8002b14:	4645      	mov	r5, r8
 8002b16:	464e      	mov	r6, r9
 8002b18:	46de      	mov	lr, fp
 8002b1a:	b5e0      	push	{r5, r6, r7, lr}
 8002b1c:	030f      	lsls	r7, r1, #12
 8002b1e:	0a7f      	lsrs	r7, r7, #9
 8002b20:	0f45      	lsrs	r5, r0, #29
 8002b22:	433d      	orrs	r5, r7
 8002b24:	46ac      	mov	ip, r5
 8002b26:	005d      	lsls	r5, r3, #1
 8002b28:	004e      	lsls	r6, r1, #1
 8002b2a:	0fcc      	lsrs	r4, r1, #31
 8002b2c:	0d69      	lsrs	r1, r5, #21
 8002b2e:	468a      	mov	sl, r1
 8002b30:	031f      	lsls	r7, r3, #12
 8002b32:	49cc      	ldr	r1, [pc, #816]	; (8002e64 <__aeabi_dsub+0x354>)
 8002b34:	0f55      	lsrs	r5, r2, #29
 8002b36:	b083      	sub	sp, #12
 8002b38:	00c0      	lsls	r0, r0, #3
 8002b3a:	0a7f      	lsrs	r7, r7, #9
 8002b3c:	00d2      	lsls	r2, r2, #3
 8002b3e:	0d76      	lsrs	r6, r6, #21
 8002b40:	4680      	mov	r8, r0
 8002b42:	0fdb      	lsrs	r3, r3, #31
 8002b44:	432f      	orrs	r7, r5
 8002b46:	9201      	str	r2, [sp, #4]
 8002b48:	458a      	cmp	sl, r1
 8002b4a:	d100      	bne.n	8002b4e <__aeabi_dsub+0x3e>
 8002b4c:	e0c0      	b.n	8002cd0 <__aeabi_dsub+0x1c0>
 8002b4e:	4655      	mov	r5, sl
 8002b50:	1b75      	subs	r5, r6, r5
 8002b52:	46a9      	mov	r9, r5
 8002b54:	2501      	movs	r5, #1
 8002b56:	46ab      	mov	fp, r5
 8002b58:	465d      	mov	r5, fp
 8002b5a:	406b      	eors	r3, r5
 8002b5c:	469b      	mov	fp, r3
 8002b5e:	429c      	cmp	r4, r3
 8002b60:	d100      	bne.n	8002b64 <__aeabi_dsub+0x54>
 8002b62:	e090      	b.n	8002c86 <__aeabi_dsub+0x176>
 8002b64:	464d      	mov	r5, r9
 8002b66:	2d00      	cmp	r5, #0
 8002b68:	dc00      	bgt.n	8002b6c <__aeabi_dsub+0x5c>
 8002b6a:	e0bb      	b.n	8002ce4 <__aeabi_dsub+0x1d4>
 8002b6c:	4653      	mov	r3, sl
 8002b6e:	2b00      	cmp	r3, #0
 8002b70:	d100      	bne.n	8002b74 <__aeabi_dsub+0x64>
 8002b72:	e0d5      	b.n	8002d20 <__aeabi_dsub+0x210>
 8002b74:	428e      	cmp	r6, r1
 8002b76:	d100      	bne.n	8002b7a <__aeabi_dsub+0x6a>
 8002b78:	e1b5      	b.n	8002ee6 <__aeabi_dsub+0x3d6>
 8002b7a:	2380      	movs	r3, #128	; 0x80
 8002b7c:	041b      	lsls	r3, r3, #16
 8002b7e:	431f      	orrs	r7, r3
 8002b80:	464b      	mov	r3, r9
 8002b82:	2b38      	cmp	r3, #56	; 0x38
 8002b84:	dd00      	ble.n	8002b88 <__aeabi_dsub+0x78>
 8002b86:	e18b      	b.n	8002ea0 <__aeabi_dsub+0x390>
 8002b88:	2b1f      	cmp	r3, #31
 8002b8a:	dd00      	ble.n	8002b8e <__aeabi_dsub+0x7e>
 8002b8c:	e236      	b.n	8002ffc <__aeabi_dsub+0x4ec>
 8002b8e:	4649      	mov	r1, r9
 8002b90:	2320      	movs	r3, #32
 8002b92:	003d      	movs	r5, r7
 8002b94:	1a5b      	subs	r3, r3, r1
 8002b96:	0011      	movs	r1, r2
 8002b98:	409a      	lsls	r2, r3
 8002b9a:	409d      	lsls	r5, r3
 8002b9c:	1e53      	subs	r3, r2, #1
 8002b9e:	419a      	sbcs	r2, r3
 8002ba0:	464b      	mov	r3, r9
 8002ba2:	46a8      	mov	r8, r5
 8002ba4:	464d      	mov	r5, r9
 8002ba6:	40df      	lsrs	r7, r3
 8002ba8:	4663      	mov	r3, ip
 8002baa:	40e9      	lsrs	r1, r5
 8002bac:	4645      	mov	r5, r8
 8002bae:	1bdb      	subs	r3, r3, r7
 8002bb0:	469c      	mov	ip, r3
 8002bb2:	430d      	orrs	r5, r1
 8002bb4:	4315      	orrs	r5, r2
 8002bb6:	1b45      	subs	r5, r0, r5
 8002bb8:	42a8      	cmp	r0, r5
 8002bba:	4180      	sbcs	r0, r0
 8002bbc:	4663      	mov	r3, ip
 8002bbe:	4241      	negs	r1, r0
 8002bc0:	1a59      	subs	r1, r3, r1
 8002bc2:	020b      	lsls	r3, r1, #8
 8002bc4:	d400      	bmi.n	8002bc8 <__aeabi_dsub+0xb8>
 8002bc6:	e10d      	b.n	8002de4 <__aeabi_dsub+0x2d4>
 8002bc8:	0249      	lsls	r1, r1, #9
 8002bca:	0a4b      	lsrs	r3, r1, #9
 8002bcc:	4698      	mov	r8, r3
 8002bce:	4643      	mov	r3, r8
 8002bd0:	2b00      	cmp	r3, #0
 8002bd2:	d100      	bne.n	8002bd6 <__aeabi_dsub+0xc6>
 8002bd4:	e157      	b.n	8002e86 <__aeabi_dsub+0x376>
 8002bd6:	4640      	mov	r0, r8
 8002bd8:	f000 fce2 	bl	80035a0 <__clzsi2>
 8002bdc:	0003      	movs	r3, r0
 8002bde:	3b08      	subs	r3, #8
 8002be0:	2220      	movs	r2, #32
 8002be2:	0029      	movs	r1, r5
 8002be4:	4647      	mov	r7, r8
 8002be6:	1ad2      	subs	r2, r2, r3
 8002be8:	409f      	lsls	r7, r3
 8002bea:	40d1      	lsrs	r1, r2
 8002bec:	409d      	lsls	r5, r3
 8002bee:	430f      	orrs	r7, r1
 8002bf0:	429e      	cmp	r6, r3
 8002bf2:	dd00      	ble.n	8002bf6 <__aeabi_dsub+0xe6>
 8002bf4:	e140      	b.n	8002e78 <__aeabi_dsub+0x368>
 8002bf6:	1b9e      	subs	r6, r3, r6
 8002bf8:	1c73      	adds	r3, r6, #1
 8002bfa:	2b1f      	cmp	r3, #31
 8002bfc:	dd00      	ble.n	8002c00 <__aeabi_dsub+0xf0>
 8002bfe:	e1d2      	b.n	8002fa6 <__aeabi_dsub+0x496>
 8002c00:	2220      	movs	r2, #32
 8002c02:	0028      	movs	r0, r5
 8002c04:	1ad2      	subs	r2, r2, r3
 8002c06:	0039      	movs	r1, r7
 8002c08:	4095      	lsls	r5, r2
 8002c0a:	4091      	lsls	r1, r2
 8002c0c:	40d8      	lsrs	r0, r3
 8002c0e:	1e6a      	subs	r2, r5, #1
 8002c10:	4195      	sbcs	r5, r2
 8002c12:	4301      	orrs	r1, r0
 8002c14:	430d      	orrs	r5, r1
 8002c16:	0039      	movs	r1, r7
 8002c18:	2600      	movs	r6, #0
 8002c1a:	40d9      	lsrs	r1, r3
 8002c1c:	076b      	lsls	r3, r5, #29
 8002c1e:	d009      	beq.n	8002c34 <__aeabi_dsub+0x124>
 8002c20:	230f      	movs	r3, #15
 8002c22:	402b      	ands	r3, r5
 8002c24:	2b04      	cmp	r3, #4
 8002c26:	d005      	beq.n	8002c34 <__aeabi_dsub+0x124>
 8002c28:	1d2b      	adds	r3, r5, #4
 8002c2a:	42ab      	cmp	r3, r5
 8002c2c:	41ad      	sbcs	r5, r5
 8002c2e:	426d      	negs	r5, r5
 8002c30:	1949      	adds	r1, r1, r5
 8002c32:	001d      	movs	r5, r3
 8002c34:	020b      	lsls	r3, r1, #8
 8002c36:	d400      	bmi.n	8002c3a <__aeabi_dsub+0x12a>
 8002c38:	e0d7      	b.n	8002dea <__aeabi_dsub+0x2da>
 8002c3a:	1c72      	adds	r2, r6, #1
 8002c3c:	4b89      	ldr	r3, [pc, #548]	; (8002e64 <__aeabi_dsub+0x354>)
 8002c3e:	0556      	lsls	r6, r2, #21
 8002c40:	0d76      	lsrs	r6, r6, #21
 8002c42:	429a      	cmp	r2, r3
 8002c44:	d100      	bne.n	8002c48 <__aeabi_dsub+0x138>
 8002c46:	e0df      	b.n	8002e08 <__aeabi_dsub+0x2f8>
 8002c48:	4f87      	ldr	r7, [pc, #540]	; (8002e68 <__aeabi_dsub+0x358>)
 8002c4a:	08ed      	lsrs	r5, r5, #3
 8002c4c:	400f      	ands	r7, r1
 8002c4e:	0778      	lsls	r0, r7, #29
 8002c50:	4328      	orrs	r0, r5
 8002c52:	4682      	mov	sl, r0
 8002c54:	027a      	lsls	r2, r7, #9
 8002c56:	0b12      	lsrs	r2, r2, #12
 8002c58:	2100      	movs	r1, #0
 8002c5a:	0312      	lsls	r2, r2, #12
 8002c5c:	0b13      	lsrs	r3, r2, #12
 8002c5e:	0d0a      	lsrs	r2, r1, #20
 8002c60:	0512      	lsls	r2, r2, #20
 8002c62:	431a      	orrs	r2, r3
 8002c64:	4b81      	ldr	r3, [pc, #516]	; (8002e6c <__aeabi_dsub+0x35c>)
 8002c66:	0536      	lsls	r6, r6, #20
 8002c68:	4013      	ands	r3, r2
 8002c6a:	4333      	orrs	r3, r6
 8002c6c:	005b      	lsls	r3, r3, #1
 8002c6e:	07e4      	lsls	r4, r4, #31
 8002c70:	085b      	lsrs	r3, r3, #1
 8002c72:	4323      	orrs	r3, r4
 8002c74:	4650      	mov	r0, sl
 8002c76:	0019      	movs	r1, r3
 8002c78:	b003      	add	sp, #12
 8002c7a:	bc3c      	pop	{r2, r3, r4, r5}
 8002c7c:	4690      	mov	r8, r2
 8002c7e:	4699      	mov	r9, r3
 8002c80:	46a2      	mov	sl, r4
 8002c82:	46ab      	mov	fp, r5
 8002c84:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8002c86:	464d      	mov	r5, r9
 8002c88:	2d00      	cmp	r5, #0
 8002c8a:	dd5c      	ble.n	8002d46 <__aeabi_dsub+0x236>
 8002c8c:	4653      	mov	r3, sl
 8002c8e:	2b00      	cmp	r3, #0
 8002c90:	d100      	bne.n	8002c94 <__aeabi_dsub+0x184>
 8002c92:	e08b      	b.n	8002dac <__aeabi_dsub+0x29c>
 8002c94:	428e      	cmp	r6, r1
 8002c96:	d100      	bne.n	8002c9a <__aeabi_dsub+0x18a>
 8002c98:	e216      	b.n	80030c8 <__aeabi_dsub+0x5b8>
 8002c9a:	2380      	movs	r3, #128	; 0x80
 8002c9c:	041b      	lsls	r3, r3, #16
 8002c9e:	431f      	orrs	r7, r3
 8002ca0:	464b      	mov	r3, r9
 8002ca2:	2b38      	cmp	r3, #56	; 0x38
 8002ca4:	dd00      	ble.n	8002ca8 <__aeabi_dsub+0x198>
 8002ca6:	e18e      	b.n	8002fc6 <__aeabi_dsub+0x4b6>
 8002ca8:	2b1f      	cmp	r3, #31
 8002caa:	dc00      	bgt.n	8002cae <__aeabi_dsub+0x19e>
 8002cac:	e1c0      	b.n	8003030 <__aeabi_dsub+0x520>
 8002cae:	0039      	movs	r1, r7
 8002cb0:	3b20      	subs	r3, #32
 8002cb2:	40d9      	lsrs	r1, r3
 8002cb4:	464b      	mov	r3, r9
 8002cb6:	2b20      	cmp	r3, #32
 8002cb8:	d005      	beq.n	8002cc6 <__aeabi_dsub+0x1b6>
 8002cba:	2340      	movs	r3, #64	; 0x40
 8002cbc:	464d      	mov	r5, r9
 8002cbe:	1b5b      	subs	r3, r3, r5
 8002cc0:	409f      	lsls	r7, r3
 8002cc2:	433a      	orrs	r2, r7
 8002cc4:	9201      	str	r2, [sp, #4]
 8002cc6:	9d01      	ldr	r5, [sp, #4]
 8002cc8:	1e6f      	subs	r7, r5, #1
 8002cca:	41bd      	sbcs	r5, r7
 8002ccc:	430d      	orrs	r5, r1
 8002cce:	e17e      	b.n	8002fce <__aeabi_dsub+0x4be>
 8002cd0:	4967      	ldr	r1, [pc, #412]	; (8002e70 <__aeabi_dsub+0x360>)
 8002cd2:	003d      	movs	r5, r7
 8002cd4:	4689      	mov	r9, r1
 8002cd6:	4315      	orrs	r5, r2
 8002cd8:	44b1      	add	r9, r6
 8002cda:	2d00      	cmp	r5, #0
 8002cdc:	d02e      	beq.n	8002d3c <__aeabi_dsub+0x22c>
 8002cde:	469b      	mov	fp, r3
 8002ce0:	429c      	cmp	r4, r3
 8002ce2:	d030      	beq.n	8002d46 <__aeabi_dsub+0x236>
 8002ce4:	4649      	mov	r1, r9
 8002ce6:	2900      	cmp	r1, #0
 8002ce8:	d14a      	bne.n	8002d80 <__aeabi_dsub+0x270>
 8002cea:	4d62      	ldr	r5, [pc, #392]	; (8002e74 <__aeabi_dsub+0x364>)
 8002cec:	1c71      	adds	r1, r6, #1
 8002cee:	4229      	tst	r1, r5
 8002cf0:	d000      	beq.n	8002cf4 <__aeabi_dsub+0x1e4>
 8002cf2:	e0e1      	b.n	8002eb8 <__aeabi_dsub+0x3a8>
 8002cf4:	003d      	movs	r5, r7
 8002cf6:	4661      	mov	r1, ip
 8002cf8:	4315      	orrs	r5, r2
 8002cfa:	4301      	orrs	r1, r0
 8002cfc:	46aa      	mov	sl, r5
 8002cfe:	2e00      	cmp	r6, #0
 8002d00:	d000      	beq.n	8002d04 <__aeabi_dsub+0x1f4>
 8002d02:	e1ef      	b.n	80030e4 <__aeabi_dsub+0x5d4>
 8002d04:	2900      	cmp	r1, #0
 8002d06:	d100      	bne.n	8002d0a <__aeabi_dsub+0x1fa>
 8002d08:	e1c5      	b.n	8003096 <__aeabi_dsub+0x586>
 8002d0a:	2d00      	cmp	r5, #0
 8002d0c:	d000      	beq.n	8002d10 <__aeabi_dsub+0x200>
 8002d0e:	e200      	b.n	8003112 <__aeabi_dsub+0x602>
 8002d10:	4663      	mov	r3, ip
 8002d12:	08c0      	lsrs	r0, r0, #3
 8002d14:	075b      	lsls	r3, r3, #29
 8002d16:	4318      	orrs	r0, r3
 8002d18:	4663      	mov	r3, ip
 8002d1a:	4682      	mov	sl, r0
 8002d1c:	08d9      	lsrs	r1, r3, #3
 8002d1e:	e06d      	b.n	8002dfc <__aeabi_dsub+0x2ec>
 8002d20:	003b      	movs	r3, r7
 8002d22:	4313      	orrs	r3, r2
 8002d24:	d100      	bne.n	8002d28 <__aeabi_dsub+0x218>
 8002d26:	e0c0      	b.n	8002eaa <__aeabi_dsub+0x39a>
 8002d28:	464b      	mov	r3, r9
 8002d2a:	3b01      	subs	r3, #1
 8002d2c:	2b00      	cmp	r3, #0
 8002d2e:	d100      	bne.n	8002d32 <__aeabi_dsub+0x222>
 8002d30:	e1c1      	b.n	80030b6 <__aeabi_dsub+0x5a6>
 8002d32:	4589      	cmp	r9, r1
 8002d34:	d100      	bne.n	8002d38 <__aeabi_dsub+0x228>
 8002d36:	e0d6      	b.n	8002ee6 <__aeabi_dsub+0x3d6>
 8002d38:	4699      	mov	r9, r3
 8002d3a:	e721      	b.n	8002b80 <__aeabi_dsub+0x70>
 8002d3c:	2501      	movs	r5, #1
 8002d3e:	406b      	eors	r3, r5
 8002d40:	469b      	mov	fp, r3
 8002d42:	429c      	cmp	r4, r3
 8002d44:	d1ce      	bne.n	8002ce4 <__aeabi_dsub+0x1d4>
 8002d46:	4649      	mov	r1, r9
 8002d48:	2900      	cmp	r1, #0
 8002d4a:	d000      	beq.n	8002d4e <__aeabi_dsub+0x23e>
 8002d4c:	e0d2      	b.n	8002ef4 <__aeabi_dsub+0x3e4>
 8002d4e:	1c71      	adds	r1, r6, #1
 8002d50:	468a      	mov	sl, r1
 8002d52:	4655      	mov	r5, sl
 8002d54:	4947      	ldr	r1, [pc, #284]	; (8002e74 <__aeabi_dsub+0x364>)
 8002d56:	420d      	tst	r5, r1
 8002d58:	d135      	bne.n	8002dc6 <__aeabi_dsub+0x2b6>
 8002d5a:	4661      	mov	r1, ip
 8002d5c:	4301      	orrs	r1, r0
 8002d5e:	2e00      	cmp	r6, #0
 8002d60:	d000      	beq.n	8002d64 <__aeabi_dsub+0x254>
 8002d62:	e18a      	b.n	800307a <__aeabi_dsub+0x56a>
 8002d64:	2900      	cmp	r1, #0
 8002d66:	d100      	bne.n	8002d6a <__aeabi_dsub+0x25a>
 8002d68:	e20c      	b.n	8003184 <__aeabi_dsub+0x674>
 8002d6a:	003b      	movs	r3, r7
 8002d6c:	4313      	orrs	r3, r2
 8002d6e:	d000      	beq.n	8002d72 <__aeabi_dsub+0x262>
 8002d70:	e20e      	b.n	8003190 <__aeabi_dsub+0x680>
 8002d72:	4663      	mov	r3, ip
 8002d74:	08c0      	lsrs	r0, r0, #3
 8002d76:	075a      	lsls	r2, r3, #29
 8002d78:	4302      	orrs	r2, r0
 8002d7a:	4692      	mov	sl, r2
 8002d7c:	08d9      	lsrs	r1, r3, #3
 8002d7e:	e03d      	b.n	8002dfc <__aeabi_dsub+0x2ec>
 8002d80:	4651      	mov	r1, sl
 8002d82:	1b89      	subs	r1, r1, r6
 8002d84:	4689      	mov	r9, r1
 8002d86:	465c      	mov	r4, fp
 8002d88:	2e00      	cmp	r6, #0
 8002d8a:	d000      	beq.n	8002d8e <__aeabi_dsub+0x27e>
 8002d8c:	e0e4      	b.n	8002f58 <__aeabi_dsub+0x448>
 8002d8e:	4663      	mov	r3, ip
 8002d90:	4303      	orrs	r3, r0
 8002d92:	d100      	bne.n	8002d96 <__aeabi_dsub+0x286>
 8002d94:	e16b      	b.n	800306e <__aeabi_dsub+0x55e>
 8002d96:	000b      	movs	r3, r1
 8002d98:	3b01      	subs	r3, #1
 8002d9a:	2b00      	cmp	r3, #0
 8002d9c:	d100      	bne.n	8002da0 <__aeabi_dsub+0x290>
 8002d9e:	e1e8      	b.n	8003172 <__aeabi_dsub+0x662>
 8002da0:	4d30      	ldr	r5, [pc, #192]	; (8002e64 <__aeabi_dsub+0x354>)
 8002da2:	42a9      	cmp	r1, r5
 8002da4:	d100      	bne.n	8002da8 <__aeabi_dsub+0x298>
 8002da6:	e1de      	b.n	8003166 <__aeabi_dsub+0x656>
 8002da8:	4699      	mov	r9, r3
 8002daa:	e0de      	b.n	8002f6a <__aeabi_dsub+0x45a>
 8002dac:	003b      	movs	r3, r7
 8002dae:	4313      	orrs	r3, r2
 8002db0:	d07b      	beq.n	8002eaa <__aeabi_dsub+0x39a>
 8002db2:	464b      	mov	r3, r9
 8002db4:	3b01      	subs	r3, #1
 8002db6:	2b00      	cmp	r3, #0
 8002db8:	d100      	bne.n	8002dbc <__aeabi_dsub+0x2ac>
 8002dba:	e14c      	b.n	8003056 <__aeabi_dsub+0x546>
 8002dbc:	4589      	cmp	r9, r1
 8002dbe:	d100      	bne.n	8002dc2 <__aeabi_dsub+0x2b2>
 8002dc0:	e182      	b.n	80030c8 <__aeabi_dsub+0x5b8>
 8002dc2:	4699      	mov	r9, r3
 8002dc4:	e76c      	b.n	8002ca0 <__aeabi_dsub+0x190>
 8002dc6:	4b27      	ldr	r3, [pc, #156]	; (8002e64 <__aeabi_dsub+0x354>)
 8002dc8:	459a      	cmp	sl, r3
 8002dca:	d100      	bne.n	8002dce <__aeabi_dsub+0x2be>
 8002dcc:	e1ed      	b.n	80031aa <__aeabi_dsub+0x69a>
 8002dce:	1882      	adds	r2, r0, r2
 8002dd0:	4282      	cmp	r2, r0
 8002dd2:	4189      	sbcs	r1, r1
 8002dd4:	4656      	mov	r6, sl
 8002dd6:	4467      	add	r7, ip
 8002dd8:	4249      	negs	r1, r1
 8002dda:	1879      	adds	r1, r7, r1
 8002ddc:	07cd      	lsls	r5, r1, #31
 8002dde:	0852      	lsrs	r2, r2, #1
 8002de0:	4315      	orrs	r5, r2
 8002de2:	0849      	lsrs	r1, r1, #1
 8002de4:	076b      	lsls	r3, r5, #29
 8002de6:	d000      	beq.n	8002dea <__aeabi_dsub+0x2da>
 8002de8:	e71a      	b.n	8002c20 <__aeabi_dsub+0x110>
 8002dea:	074b      	lsls	r3, r1, #29
 8002dec:	08ed      	lsrs	r5, r5, #3
 8002dee:	431d      	orrs	r5, r3
 8002df0:	46aa      	mov	sl, r5
 8002df2:	46b1      	mov	r9, r6
 8002df4:	08c9      	lsrs	r1, r1, #3
 8002df6:	4b1b      	ldr	r3, [pc, #108]	; (8002e64 <__aeabi_dsub+0x354>)
 8002df8:	4599      	cmp	r9, r3
 8002dfa:	d027      	beq.n	8002e4c <__aeabi_dsub+0x33c>
 8002dfc:	464b      	mov	r3, r9
 8002dfe:	030a      	lsls	r2, r1, #12
 8002e00:	055e      	lsls	r6, r3, #21
 8002e02:	0b12      	lsrs	r2, r2, #12
 8002e04:	0d76      	lsrs	r6, r6, #21
 8002e06:	e727      	b.n	8002c58 <__aeabi_dsub+0x148>
 8002e08:	0016      	movs	r6, r2
 8002e0a:	2300      	movs	r3, #0
 8002e0c:	2200      	movs	r2, #0
 8002e0e:	469a      	mov	sl, r3
 8002e10:	e722      	b.n	8002c58 <__aeabi_dsub+0x148>
 8002e12:	4663      	mov	r3, ip
 8002e14:	08c0      	lsrs	r0, r0, #3
 8002e16:	075e      	lsls	r6, r3, #29
 8002e18:	4330      	orrs	r0, r6
 8002e1a:	08d9      	lsrs	r1, r3, #3
 8002e1c:	4682      	mov	sl, r0
 8002e1e:	2d00      	cmp	r5, #0
 8002e20:	d014      	beq.n	8002e4c <__aeabi_dsub+0x33c>
 8002e22:	2580      	movs	r5, #128	; 0x80
 8002e24:	032d      	lsls	r5, r5, #12
 8002e26:	4229      	tst	r1, r5
 8002e28:	d007      	beq.n	8002e3a <__aeabi_dsub+0x32a>
 8002e2a:	08fe      	lsrs	r6, r7, #3
 8002e2c:	422e      	tst	r6, r5
 8002e2e:	d104      	bne.n	8002e3a <__aeabi_dsub+0x32a>
 8002e30:	465c      	mov	r4, fp
 8002e32:	0031      	movs	r1, r6
 8002e34:	08d2      	lsrs	r2, r2, #3
 8002e36:	0778      	lsls	r0, r7, #29
 8002e38:	4310      	orrs	r0, r2
 8002e3a:	00ca      	lsls	r2, r1, #3
 8002e3c:	0f41      	lsrs	r1, r0, #29
 8002e3e:	4311      	orrs	r1, r2
 8002e40:	00c0      	lsls	r0, r0, #3
 8002e42:	074a      	lsls	r2, r1, #29
 8002e44:	08c0      	lsrs	r0, r0, #3
 8002e46:	4310      	orrs	r0, r2
 8002e48:	4682      	mov	sl, r0
 8002e4a:	08c9      	lsrs	r1, r1, #3
 8002e4c:	4653      	mov	r3, sl
 8002e4e:	430b      	orrs	r3, r1
 8002e50:	d100      	bne.n	8002e54 <__aeabi_dsub+0x344>
 8002e52:	e1ee      	b.n	8003232 <__aeabi_dsub+0x722>
 8002e54:	2280      	movs	r2, #128	; 0x80
 8002e56:	0312      	lsls	r2, r2, #12
 8002e58:	430a      	orrs	r2, r1
 8002e5a:	0312      	lsls	r2, r2, #12
 8002e5c:	0b12      	lsrs	r2, r2, #12
 8002e5e:	4e01      	ldr	r6, [pc, #4]	; (8002e64 <__aeabi_dsub+0x354>)
 8002e60:	e6fa      	b.n	8002c58 <__aeabi_dsub+0x148>
 8002e62:	46c0      	nop			; (mov r8, r8)
 8002e64:	000007ff 	.word	0x000007ff
 8002e68:	ff7fffff 	.word	0xff7fffff
 8002e6c:	800fffff 	.word	0x800fffff
 8002e70:	fffff801 	.word	0xfffff801
 8002e74:	000007fe 	.word	0x000007fe
 8002e78:	49d1      	ldr	r1, [pc, #836]	; (80031c0 <__aeabi_dsub+0x6b0>)
 8002e7a:	1af6      	subs	r6, r6, r3
 8002e7c:	4039      	ands	r1, r7
 8002e7e:	076b      	lsls	r3, r5, #29
 8002e80:	d000      	beq.n	8002e84 <__aeabi_dsub+0x374>
 8002e82:	e6cd      	b.n	8002c20 <__aeabi_dsub+0x110>
 8002e84:	e7b1      	b.n	8002dea <__aeabi_dsub+0x2da>
 8002e86:	0028      	movs	r0, r5
 8002e88:	f000 fb8a 	bl	80035a0 <__clzsi2>
 8002e8c:	0003      	movs	r3, r0
 8002e8e:	3318      	adds	r3, #24
 8002e90:	2b1f      	cmp	r3, #31
 8002e92:	dc00      	bgt.n	8002e96 <__aeabi_dsub+0x386>
 8002e94:	e6a4      	b.n	8002be0 <__aeabi_dsub+0xd0>
 8002e96:	3808      	subs	r0, #8
 8002e98:	4085      	lsls	r5, r0
 8002e9a:	002f      	movs	r7, r5
 8002e9c:	2500      	movs	r5, #0
 8002e9e:	e6a7      	b.n	8002bf0 <__aeabi_dsub+0xe0>
 8002ea0:	433a      	orrs	r2, r7
 8002ea2:	0015      	movs	r5, r2
 8002ea4:	1e6a      	subs	r2, r5, #1
 8002ea6:	4195      	sbcs	r5, r2
 8002ea8:	e685      	b.n	8002bb6 <__aeabi_dsub+0xa6>
 8002eaa:	4663      	mov	r3, ip
 8002eac:	08c0      	lsrs	r0, r0, #3
 8002eae:	075a      	lsls	r2, r3, #29
 8002eb0:	4302      	orrs	r2, r0
 8002eb2:	4692      	mov	sl, r2
 8002eb4:	08d9      	lsrs	r1, r3, #3
 8002eb6:	e79e      	b.n	8002df6 <__aeabi_dsub+0x2e6>
 8002eb8:	4661      	mov	r1, ip
 8002eba:	1a85      	subs	r5, r0, r2
 8002ebc:	1bcb      	subs	r3, r1, r7
 8002ebe:	42a8      	cmp	r0, r5
 8002ec0:	4189      	sbcs	r1, r1
 8002ec2:	4249      	negs	r1, r1
 8002ec4:	4688      	mov	r8, r1
 8002ec6:	0019      	movs	r1, r3
 8002ec8:	4643      	mov	r3, r8
 8002eca:	1ac9      	subs	r1, r1, r3
 8002ecc:	000b      	movs	r3, r1
 8002ece:	4688      	mov	r8, r1
 8002ed0:	021b      	lsls	r3, r3, #8
 8002ed2:	d500      	bpl.n	8002ed6 <__aeabi_dsub+0x3c6>
 8002ed4:	e113      	b.n	80030fe <__aeabi_dsub+0x5ee>
 8002ed6:	000b      	movs	r3, r1
 8002ed8:	432b      	orrs	r3, r5
 8002eda:	469a      	mov	sl, r3
 8002edc:	d000      	beq.n	8002ee0 <__aeabi_dsub+0x3d0>
 8002ede:	e676      	b.n	8002bce <__aeabi_dsub+0xbe>
 8002ee0:	2100      	movs	r1, #0
 8002ee2:	2400      	movs	r4, #0
 8002ee4:	e78a      	b.n	8002dfc <__aeabi_dsub+0x2ec>
 8002ee6:	4663      	mov	r3, ip
 8002ee8:	08c0      	lsrs	r0, r0, #3
 8002eea:	075a      	lsls	r2, r3, #29
 8002eec:	4302      	orrs	r2, r0
 8002eee:	4692      	mov	sl, r2
 8002ef0:	08d9      	lsrs	r1, r3, #3
 8002ef2:	e7ab      	b.n	8002e4c <__aeabi_dsub+0x33c>
 8002ef4:	4653      	mov	r3, sl
 8002ef6:	1b9b      	subs	r3, r3, r6
 8002ef8:	4699      	mov	r9, r3
 8002efa:	2e00      	cmp	r6, #0
 8002efc:	d000      	beq.n	8002f00 <__aeabi_dsub+0x3f0>
 8002efe:	e08e      	b.n	800301e <__aeabi_dsub+0x50e>
 8002f00:	4663      	mov	r3, ip
 8002f02:	4303      	orrs	r3, r0
 8002f04:	d100      	bne.n	8002f08 <__aeabi_dsub+0x3f8>
 8002f06:	e0b2      	b.n	800306e <__aeabi_dsub+0x55e>
 8002f08:	464b      	mov	r3, r9
 8002f0a:	3b01      	subs	r3, #1
 8002f0c:	2b00      	cmp	r3, #0
 8002f0e:	d100      	bne.n	8002f12 <__aeabi_dsub+0x402>
 8002f10:	e170      	b.n	80031f4 <__aeabi_dsub+0x6e4>
 8002f12:	4dac      	ldr	r5, [pc, #688]	; (80031c4 <__aeabi_dsub+0x6b4>)
 8002f14:	45a9      	cmp	r9, r5
 8002f16:	d100      	bne.n	8002f1a <__aeabi_dsub+0x40a>
 8002f18:	e125      	b.n	8003166 <__aeabi_dsub+0x656>
 8002f1a:	4699      	mov	r9, r3
 8002f1c:	464b      	mov	r3, r9
 8002f1e:	2b38      	cmp	r3, #56	; 0x38
 8002f20:	dd00      	ble.n	8002f24 <__aeabi_dsub+0x414>
 8002f22:	e108      	b.n	8003136 <__aeabi_dsub+0x626>
 8002f24:	2b1f      	cmp	r3, #31
 8002f26:	dd00      	ble.n	8002f2a <__aeabi_dsub+0x41a>
 8002f28:	e14e      	b.n	80031c8 <__aeabi_dsub+0x6b8>
 8002f2a:	4649      	mov	r1, r9
 8002f2c:	2320      	movs	r3, #32
 8002f2e:	464e      	mov	r6, r9
 8002f30:	1a5b      	subs	r3, r3, r1
 8002f32:	4665      	mov	r5, ip
 8002f34:	0001      	movs	r1, r0
 8002f36:	4098      	lsls	r0, r3
 8002f38:	409d      	lsls	r5, r3
 8002f3a:	40f1      	lsrs	r1, r6
 8002f3c:	1e43      	subs	r3, r0, #1
 8002f3e:	4198      	sbcs	r0, r3
 8002f40:	430d      	orrs	r5, r1
 8002f42:	4305      	orrs	r5, r0
 8002f44:	4660      	mov	r0, ip
 8002f46:	40f0      	lsrs	r0, r6
 8002f48:	183f      	adds	r7, r7, r0
 8002f4a:	18ad      	adds	r5, r5, r2
 8002f4c:	4295      	cmp	r5, r2
 8002f4e:	4189      	sbcs	r1, r1
 8002f50:	4249      	negs	r1, r1
 8002f52:	19c9      	adds	r1, r1, r7
 8002f54:	4656      	mov	r6, sl
 8002f56:	e03f      	b.n	8002fd8 <__aeabi_dsub+0x4c8>
 8002f58:	4b9a      	ldr	r3, [pc, #616]	; (80031c4 <__aeabi_dsub+0x6b4>)
 8002f5a:	459a      	cmp	sl, r3
 8002f5c:	d100      	bne.n	8002f60 <__aeabi_dsub+0x450>
 8002f5e:	e0a4      	b.n	80030aa <__aeabi_dsub+0x59a>
 8002f60:	2380      	movs	r3, #128	; 0x80
 8002f62:	4661      	mov	r1, ip
 8002f64:	041b      	lsls	r3, r3, #16
 8002f66:	4319      	orrs	r1, r3
 8002f68:	468c      	mov	ip, r1
 8002f6a:	464b      	mov	r3, r9
 8002f6c:	2b38      	cmp	r3, #56	; 0x38
 8002f6e:	dd00      	ble.n	8002f72 <__aeabi_dsub+0x462>
 8002f70:	e0b2      	b.n	80030d8 <__aeabi_dsub+0x5c8>
 8002f72:	2b1f      	cmp	r3, #31
 8002f74:	dd00      	ble.n	8002f78 <__aeabi_dsub+0x468>
 8002f76:	e0e4      	b.n	8003142 <__aeabi_dsub+0x632>
 8002f78:	4649      	mov	r1, r9
 8002f7a:	2320      	movs	r3, #32
 8002f7c:	464e      	mov	r6, r9
 8002f7e:	1a5b      	subs	r3, r3, r1
 8002f80:	4665      	mov	r5, ip
 8002f82:	0001      	movs	r1, r0
 8002f84:	4098      	lsls	r0, r3
 8002f86:	409d      	lsls	r5, r3
 8002f88:	40f1      	lsrs	r1, r6
 8002f8a:	1e43      	subs	r3, r0, #1
 8002f8c:	4198      	sbcs	r0, r3
 8002f8e:	430d      	orrs	r5, r1
 8002f90:	4305      	orrs	r5, r0
 8002f92:	4660      	mov	r0, ip
 8002f94:	40f0      	lsrs	r0, r6
 8002f96:	1a3f      	subs	r7, r7, r0
 8002f98:	1b55      	subs	r5, r2, r5
 8002f9a:	42aa      	cmp	r2, r5
 8002f9c:	4189      	sbcs	r1, r1
 8002f9e:	4249      	negs	r1, r1
 8002fa0:	1a79      	subs	r1, r7, r1
 8002fa2:	4656      	mov	r6, sl
 8002fa4:	e60d      	b.n	8002bc2 <__aeabi_dsub+0xb2>
 8002fa6:	003a      	movs	r2, r7
 8002fa8:	3e1f      	subs	r6, #31
 8002faa:	40f2      	lsrs	r2, r6
 8002fac:	0016      	movs	r6, r2
 8002fae:	2b20      	cmp	r3, #32
 8002fb0:	d003      	beq.n	8002fba <__aeabi_dsub+0x4aa>
 8002fb2:	2240      	movs	r2, #64	; 0x40
 8002fb4:	1ad3      	subs	r3, r2, r3
 8002fb6:	409f      	lsls	r7, r3
 8002fb8:	433d      	orrs	r5, r7
 8002fba:	1e6b      	subs	r3, r5, #1
 8002fbc:	419d      	sbcs	r5, r3
 8002fbe:	2100      	movs	r1, #0
 8002fc0:	4335      	orrs	r5, r6
 8002fc2:	2600      	movs	r6, #0
 8002fc4:	e70e      	b.n	8002de4 <__aeabi_dsub+0x2d4>
 8002fc6:	433a      	orrs	r2, r7
 8002fc8:	0015      	movs	r5, r2
 8002fca:	1e6a      	subs	r2, r5, #1
 8002fcc:	4195      	sbcs	r5, r2
 8002fce:	182d      	adds	r5, r5, r0
 8002fd0:	4285      	cmp	r5, r0
 8002fd2:	4180      	sbcs	r0, r0
 8002fd4:	4241      	negs	r1, r0
 8002fd6:	4461      	add	r1, ip
 8002fd8:	020b      	lsls	r3, r1, #8
 8002fda:	d400      	bmi.n	8002fde <__aeabi_dsub+0x4ce>
 8002fdc:	e702      	b.n	8002de4 <__aeabi_dsub+0x2d4>
 8002fde:	4b79      	ldr	r3, [pc, #484]	; (80031c4 <__aeabi_dsub+0x6b4>)
 8002fe0:	3601      	adds	r6, #1
 8002fe2:	429e      	cmp	r6, r3
 8002fe4:	d100      	bne.n	8002fe8 <__aeabi_dsub+0x4d8>
 8002fe6:	e710      	b.n	8002e0a <__aeabi_dsub+0x2fa>
 8002fe8:	2201      	movs	r2, #1
 8002fea:	4f75      	ldr	r7, [pc, #468]	; (80031c0 <__aeabi_dsub+0x6b0>)
 8002fec:	086b      	lsrs	r3, r5, #1
 8002fee:	4039      	ands	r1, r7
 8002ff0:	4015      	ands	r5, r2
 8002ff2:	431d      	orrs	r5, r3
 8002ff4:	07cb      	lsls	r3, r1, #31
 8002ff6:	431d      	orrs	r5, r3
 8002ff8:	0849      	lsrs	r1, r1, #1
 8002ffa:	e60f      	b.n	8002c1c <__aeabi_dsub+0x10c>
 8002ffc:	0039      	movs	r1, r7
 8002ffe:	3b20      	subs	r3, #32
 8003000:	40d9      	lsrs	r1, r3
 8003002:	464b      	mov	r3, r9
 8003004:	2b20      	cmp	r3, #32
 8003006:	d005      	beq.n	8003014 <__aeabi_dsub+0x504>
 8003008:	2340      	movs	r3, #64	; 0x40
 800300a:	464d      	mov	r5, r9
 800300c:	1b5b      	subs	r3, r3, r5
 800300e:	409f      	lsls	r7, r3
 8003010:	433a      	orrs	r2, r7
 8003012:	9201      	str	r2, [sp, #4]
 8003014:	9d01      	ldr	r5, [sp, #4]
 8003016:	1e6f      	subs	r7, r5, #1
 8003018:	41bd      	sbcs	r5, r7
 800301a:	430d      	orrs	r5, r1
 800301c:	e5cb      	b.n	8002bb6 <__aeabi_dsub+0xa6>
 800301e:	4b69      	ldr	r3, [pc, #420]	; (80031c4 <__aeabi_dsub+0x6b4>)
 8003020:	459a      	cmp	sl, r3
 8003022:	d042      	beq.n	80030aa <__aeabi_dsub+0x59a>
 8003024:	2380      	movs	r3, #128	; 0x80
 8003026:	4661      	mov	r1, ip
 8003028:	041b      	lsls	r3, r3, #16
 800302a:	4319      	orrs	r1, r3
 800302c:	468c      	mov	ip, r1
 800302e:	e775      	b.n	8002f1c <__aeabi_dsub+0x40c>
 8003030:	4649      	mov	r1, r9
 8003032:	2320      	movs	r3, #32
 8003034:	003d      	movs	r5, r7
 8003036:	1a5b      	subs	r3, r3, r1
 8003038:	409d      	lsls	r5, r3
 800303a:	0011      	movs	r1, r2
 800303c:	409a      	lsls	r2, r3
 800303e:	46a8      	mov	r8, r5
 8003040:	464d      	mov	r5, r9
 8003042:	1e53      	subs	r3, r2, #1
 8003044:	419a      	sbcs	r2, r3
 8003046:	464b      	mov	r3, r9
 8003048:	40e9      	lsrs	r1, r5
 800304a:	4645      	mov	r5, r8
 800304c:	40df      	lsrs	r7, r3
 800304e:	430d      	orrs	r5, r1
 8003050:	4315      	orrs	r5, r2
 8003052:	44bc      	add	ip, r7
 8003054:	e7bb      	b.n	8002fce <__aeabi_dsub+0x4be>
 8003056:	1885      	adds	r5, r0, r2
 8003058:	4285      	cmp	r5, r0
 800305a:	4189      	sbcs	r1, r1
 800305c:	4467      	add	r7, ip
 800305e:	4249      	negs	r1, r1
 8003060:	1879      	adds	r1, r7, r1
 8003062:	2601      	movs	r6, #1
 8003064:	020b      	lsls	r3, r1, #8
 8003066:	d400      	bmi.n	800306a <__aeabi_dsub+0x55a>
 8003068:	e6bc      	b.n	8002de4 <__aeabi_dsub+0x2d4>
 800306a:	2602      	movs	r6, #2
 800306c:	e7bc      	b.n	8002fe8 <__aeabi_dsub+0x4d8>
 800306e:	08d2      	lsrs	r2, r2, #3
 8003070:	077b      	lsls	r3, r7, #29
 8003072:	431a      	orrs	r2, r3
 8003074:	4692      	mov	sl, r2
 8003076:	08f9      	lsrs	r1, r7, #3
 8003078:	e6bd      	b.n	8002df6 <__aeabi_dsub+0x2e6>
 800307a:	2900      	cmp	r1, #0
 800307c:	d015      	beq.n	80030aa <__aeabi_dsub+0x59a>
 800307e:	4663      	mov	r3, ip
 8003080:	003d      	movs	r5, r7
 8003082:	075e      	lsls	r6, r3, #29
 8003084:	08d9      	lsrs	r1, r3, #3
 8003086:	4315      	orrs	r5, r2
 8003088:	08c0      	lsrs	r0, r0, #3
 800308a:	2d00      	cmp	r5, #0
 800308c:	d000      	beq.n	8003090 <__aeabi_dsub+0x580>
 800308e:	e0b8      	b.n	8003202 <__aeabi_dsub+0x6f2>
 8003090:	4330      	orrs	r0, r6
 8003092:	4682      	mov	sl, r0
 8003094:	e6da      	b.n	8002e4c <__aeabi_dsub+0x33c>
 8003096:	2d00      	cmp	r5, #0
 8003098:	d100      	bne.n	800309c <__aeabi_dsub+0x58c>
 800309a:	e721      	b.n	8002ee0 <__aeabi_dsub+0x3d0>
 800309c:	0779      	lsls	r1, r7, #29
 800309e:	08d2      	lsrs	r2, r2, #3
 80030a0:	430a      	orrs	r2, r1
 80030a2:	4692      	mov	sl, r2
 80030a4:	08f9      	lsrs	r1, r7, #3
 80030a6:	465c      	mov	r4, fp
 80030a8:	e6a8      	b.n	8002dfc <__aeabi_dsub+0x2ec>
 80030aa:	0778      	lsls	r0, r7, #29
 80030ac:	08d2      	lsrs	r2, r2, #3
 80030ae:	4310      	orrs	r0, r2
 80030b0:	4682      	mov	sl, r0
 80030b2:	08f9      	lsrs	r1, r7, #3
 80030b4:	e6ca      	b.n	8002e4c <__aeabi_dsub+0x33c>
 80030b6:	1a85      	subs	r5, r0, r2
 80030b8:	4663      	mov	r3, ip
 80030ba:	42a8      	cmp	r0, r5
 80030bc:	4180      	sbcs	r0, r0
 80030be:	1bdf      	subs	r7, r3, r7
 80030c0:	4240      	negs	r0, r0
 80030c2:	1a39      	subs	r1, r7, r0
 80030c4:	2601      	movs	r6, #1
 80030c6:	e57c      	b.n	8002bc2 <__aeabi_dsub+0xb2>
 80030c8:	4663      	mov	r3, ip
 80030ca:	08c0      	lsrs	r0, r0, #3
 80030cc:	075b      	lsls	r3, r3, #29
 80030ce:	4318      	orrs	r0, r3
 80030d0:	4663      	mov	r3, ip
 80030d2:	4682      	mov	sl, r0
 80030d4:	08d9      	lsrs	r1, r3, #3
 80030d6:	e6b9      	b.n	8002e4c <__aeabi_dsub+0x33c>
 80030d8:	4663      	mov	r3, ip
 80030da:	4303      	orrs	r3, r0
 80030dc:	001d      	movs	r5, r3
 80030de:	1e68      	subs	r0, r5, #1
 80030e0:	4185      	sbcs	r5, r0
 80030e2:	e759      	b.n	8002f98 <__aeabi_dsub+0x488>
 80030e4:	2900      	cmp	r1, #0
 80030e6:	d000      	beq.n	80030ea <__aeabi_dsub+0x5da>
 80030e8:	e693      	b.n	8002e12 <__aeabi_dsub+0x302>
 80030ea:	2d00      	cmp	r5, #0
 80030ec:	d100      	bne.n	80030f0 <__aeabi_dsub+0x5e0>
 80030ee:	e07d      	b.n	80031ec <__aeabi_dsub+0x6dc>
 80030f0:	0779      	lsls	r1, r7, #29
 80030f2:	08d2      	lsrs	r2, r2, #3
 80030f4:	430a      	orrs	r2, r1
 80030f6:	4692      	mov	sl, r2
 80030f8:	08f9      	lsrs	r1, r7, #3
 80030fa:	465c      	mov	r4, fp
 80030fc:	e6a6      	b.n	8002e4c <__aeabi_dsub+0x33c>
 80030fe:	1a15      	subs	r5, r2, r0
 8003100:	4663      	mov	r3, ip
 8003102:	42aa      	cmp	r2, r5
 8003104:	4192      	sbcs	r2, r2
 8003106:	1aff      	subs	r7, r7, r3
 8003108:	4252      	negs	r2, r2
 800310a:	1abb      	subs	r3, r7, r2
 800310c:	4698      	mov	r8, r3
 800310e:	465c      	mov	r4, fp
 8003110:	e55d      	b.n	8002bce <__aeabi_dsub+0xbe>
 8003112:	4663      	mov	r3, ip
 8003114:	1a85      	subs	r5, r0, r2
 8003116:	1bd9      	subs	r1, r3, r7
 8003118:	42a8      	cmp	r0, r5
 800311a:	419b      	sbcs	r3, r3
 800311c:	425b      	negs	r3, r3
 800311e:	1ac9      	subs	r1, r1, r3
 8003120:	020b      	lsls	r3, r1, #8
 8003122:	d547      	bpl.n	80031b4 <__aeabi_dsub+0x6a4>
 8003124:	1a15      	subs	r5, r2, r0
 8003126:	4663      	mov	r3, ip
 8003128:	42aa      	cmp	r2, r5
 800312a:	4192      	sbcs	r2, r2
 800312c:	1aff      	subs	r7, r7, r3
 800312e:	4252      	negs	r2, r2
 8003130:	1ab9      	subs	r1, r7, r2
 8003132:	465c      	mov	r4, fp
 8003134:	e572      	b.n	8002c1c <__aeabi_dsub+0x10c>
 8003136:	4663      	mov	r3, ip
 8003138:	4303      	orrs	r3, r0
 800313a:	001d      	movs	r5, r3
 800313c:	1e68      	subs	r0, r5, #1
 800313e:	4185      	sbcs	r5, r0
 8003140:	e703      	b.n	8002f4a <__aeabi_dsub+0x43a>
 8003142:	4666      	mov	r6, ip
 8003144:	3b20      	subs	r3, #32
 8003146:	40de      	lsrs	r6, r3
 8003148:	464b      	mov	r3, r9
 800314a:	2b20      	cmp	r3, #32
 800314c:	d006      	beq.n	800315c <__aeabi_dsub+0x64c>
 800314e:	4649      	mov	r1, r9
 8003150:	2340      	movs	r3, #64	; 0x40
 8003152:	1a5b      	subs	r3, r3, r1
 8003154:	4661      	mov	r1, ip
 8003156:	4099      	lsls	r1, r3
 8003158:	4308      	orrs	r0, r1
 800315a:	4680      	mov	r8, r0
 800315c:	4645      	mov	r5, r8
 800315e:	1e69      	subs	r1, r5, #1
 8003160:	418d      	sbcs	r5, r1
 8003162:	4335      	orrs	r5, r6
 8003164:	e718      	b.n	8002f98 <__aeabi_dsub+0x488>
 8003166:	08d2      	lsrs	r2, r2, #3
 8003168:	077b      	lsls	r3, r7, #29
 800316a:	431a      	orrs	r2, r3
 800316c:	4692      	mov	sl, r2
 800316e:	08f9      	lsrs	r1, r7, #3
 8003170:	e66c      	b.n	8002e4c <__aeabi_dsub+0x33c>
 8003172:	1a15      	subs	r5, r2, r0
 8003174:	4663      	mov	r3, ip
 8003176:	42aa      	cmp	r2, r5
 8003178:	4192      	sbcs	r2, r2
 800317a:	1aff      	subs	r7, r7, r3
 800317c:	4252      	negs	r2, r2
 800317e:	1ab9      	subs	r1, r7, r2
 8003180:	2601      	movs	r6, #1
 8003182:	e51e      	b.n	8002bc2 <__aeabi_dsub+0xb2>
 8003184:	0778      	lsls	r0, r7, #29
 8003186:	08d2      	lsrs	r2, r2, #3
 8003188:	4310      	orrs	r0, r2
 800318a:	4682      	mov	sl, r0
 800318c:	08f9      	lsrs	r1, r7, #3
 800318e:	e635      	b.n	8002dfc <__aeabi_dsub+0x2ec>
 8003190:	1885      	adds	r5, r0, r2
 8003192:	4285      	cmp	r5, r0
 8003194:	4189      	sbcs	r1, r1
 8003196:	4467      	add	r7, ip
 8003198:	4249      	negs	r1, r1
 800319a:	1879      	adds	r1, r7, r1
 800319c:	020b      	lsls	r3, r1, #8
 800319e:	d400      	bmi.n	80031a2 <__aeabi_dsub+0x692>
 80031a0:	e620      	b.n	8002de4 <__aeabi_dsub+0x2d4>
 80031a2:	4b07      	ldr	r3, [pc, #28]	; (80031c0 <__aeabi_dsub+0x6b0>)
 80031a4:	2601      	movs	r6, #1
 80031a6:	4019      	ands	r1, r3
 80031a8:	e61c      	b.n	8002de4 <__aeabi_dsub+0x2d4>
 80031aa:	2300      	movs	r3, #0
 80031ac:	4656      	mov	r6, sl
 80031ae:	2200      	movs	r2, #0
 80031b0:	469a      	mov	sl, r3
 80031b2:	e551      	b.n	8002c58 <__aeabi_dsub+0x148>
 80031b4:	002b      	movs	r3, r5
 80031b6:	430b      	orrs	r3, r1
 80031b8:	469a      	mov	sl, r3
 80031ba:	d100      	bne.n	80031be <__aeabi_dsub+0x6ae>
 80031bc:	e690      	b.n	8002ee0 <__aeabi_dsub+0x3d0>
 80031be:	e611      	b.n	8002de4 <__aeabi_dsub+0x2d4>
 80031c0:	ff7fffff 	.word	0xff7fffff
 80031c4:	000007ff 	.word	0x000007ff
 80031c8:	4666      	mov	r6, ip
 80031ca:	3b20      	subs	r3, #32
 80031cc:	40de      	lsrs	r6, r3
 80031ce:	464b      	mov	r3, r9
 80031d0:	2b20      	cmp	r3, #32
 80031d2:	d006      	beq.n	80031e2 <__aeabi_dsub+0x6d2>
 80031d4:	4649      	mov	r1, r9
 80031d6:	2340      	movs	r3, #64	; 0x40
 80031d8:	1a5b      	subs	r3, r3, r1
 80031da:	4661      	mov	r1, ip
 80031dc:	4099      	lsls	r1, r3
 80031de:	4308      	orrs	r0, r1
 80031e0:	4680      	mov	r8, r0
 80031e2:	4645      	mov	r5, r8
 80031e4:	1e69      	subs	r1, r5, #1
 80031e6:	418d      	sbcs	r5, r1
 80031e8:	4335      	orrs	r5, r6
 80031ea:	e6ae      	b.n	8002f4a <__aeabi_dsub+0x43a>
 80031ec:	2180      	movs	r1, #128	; 0x80
 80031ee:	2400      	movs	r4, #0
 80031f0:	0309      	lsls	r1, r1, #12
 80031f2:	e62f      	b.n	8002e54 <__aeabi_dsub+0x344>
 80031f4:	1885      	adds	r5, r0, r2
 80031f6:	4295      	cmp	r5, r2
 80031f8:	4192      	sbcs	r2, r2
 80031fa:	4467      	add	r7, ip
 80031fc:	4251      	negs	r1, r2
 80031fe:	1879      	adds	r1, r7, r1
 8003200:	e72f      	b.n	8003062 <__aeabi_dsub+0x552>
 8003202:	4306      	orrs	r6, r0
 8003204:	2080      	movs	r0, #128	; 0x80
 8003206:	0300      	lsls	r0, r0, #12
 8003208:	4201      	tst	r1, r0
 800320a:	d008      	beq.n	800321e <__aeabi_dsub+0x70e>
 800320c:	08fd      	lsrs	r5, r7, #3
 800320e:	4205      	tst	r5, r0
 8003210:	d105      	bne.n	800321e <__aeabi_dsub+0x70e>
 8003212:	08d2      	lsrs	r2, r2, #3
 8003214:	077f      	lsls	r7, r7, #29
 8003216:	433a      	orrs	r2, r7
 8003218:	0016      	movs	r6, r2
 800321a:	465c      	mov	r4, fp
 800321c:	0029      	movs	r1, r5
 800321e:	00ca      	lsls	r2, r1, #3
 8003220:	0f71      	lsrs	r1, r6, #29
 8003222:	4311      	orrs	r1, r2
 8003224:	00f6      	lsls	r6, r6, #3
 8003226:	074a      	lsls	r2, r1, #29
 8003228:	08f6      	lsrs	r6, r6, #3
 800322a:	4332      	orrs	r2, r6
 800322c:	4692      	mov	sl, r2
 800322e:	08c9      	lsrs	r1, r1, #3
 8003230:	e60c      	b.n	8002e4c <__aeabi_dsub+0x33c>
 8003232:	2300      	movs	r3, #0
 8003234:	4e01      	ldr	r6, [pc, #4]	; (800323c <__aeabi_dsub+0x72c>)
 8003236:	469a      	mov	sl, r3
 8003238:	001a      	movs	r2, r3
 800323a:	e50d      	b.n	8002c58 <__aeabi_dsub+0x148>
 800323c:	000007ff 	.word	0x000007ff

08003240 <__aeabi_dcmpun>:
 8003240:	b570      	push	{r4, r5, r6, lr}
 8003242:	4e0c      	ldr	r6, [pc, #48]	; (8003274 <__aeabi_dcmpun+0x34>)
 8003244:	030d      	lsls	r5, r1, #12
 8003246:	031c      	lsls	r4, r3, #12
 8003248:	0049      	lsls	r1, r1, #1
 800324a:	005b      	lsls	r3, r3, #1
 800324c:	0b2d      	lsrs	r5, r5, #12
 800324e:	0d49      	lsrs	r1, r1, #21
 8003250:	0b24      	lsrs	r4, r4, #12
 8003252:	0d5b      	lsrs	r3, r3, #21
 8003254:	42b1      	cmp	r1, r6
 8003256:	d008      	beq.n	800326a <__aeabi_dcmpun+0x2a>
 8003258:	4906      	ldr	r1, [pc, #24]	; (8003274 <__aeabi_dcmpun+0x34>)
 800325a:	2000      	movs	r0, #0
 800325c:	428b      	cmp	r3, r1
 800325e:	d103      	bne.n	8003268 <__aeabi_dcmpun+0x28>
 8003260:	4314      	orrs	r4, r2
 8003262:	0020      	movs	r0, r4
 8003264:	1e44      	subs	r4, r0, #1
 8003266:	41a0      	sbcs	r0, r4
 8003268:	bd70      	pop	{r4, r5, r6, pc}
 800326a:	4305      	orrs	r5, r0
 800326c:	2001      	movs	r0, #1
 800326e:	2d00      	cmp	r5, #0
 8003270:	d1fa      	bne.n	8003268 <__aeabi_dcmpun+0x28>
 8003272:	e7f1      	b.n	8003258 <__aeabi_dcmpun+0x18>
 8003274:	000007ff 	.word	0x000007ff
	...

08003280 <__aeabi_d2iz>:
 8003280:	b530      	push	{r4, r5, lr}
 8003282:	4d14      	ldr	r5, [pc, #80]	; (80032d4 <__aeabi_d2iz+0x54>)
 8003284:	030a      	lsls	r2, r1, #12
 8003286:	004b      	lsls	r3, r1, #1
 8003288:	0b12      	lsrs	r2, r2, #12
 800328a:	0d5b      	lsrs	r3, r3, #21
 800328c:	0fc9      	lsrs	r1, r1, #31
 800328e:	2400      	movs	r4, #0
 8003290:	42ab      	cmp	r3, r5
 8003292:	dd04      	ble.n	800329e <__aeabi_d2iz+0x1e>
 8003294:	4c10      	ldr	r4, [pc, #64]	; (80032d8 <__aeabi_d2iz+0x58>)
 8003296:	42a3      	cmp	r3, r4
 8003298:	dd03      	ble.n	80032a2 <__aeabi_d2iz+0x22>
 800329a:	4b10      	ldr	r3, [pc, #64]	; (80032dc <__aeabi_d2iz+0x5c>)
 800329c:	18cc      	adds	r4, r1, r3
 800329e:	0020      	movs	r0, r4
 80032a0:	bd30      	pop	{r4, r5, pc}
 80032a2:	2480      	movs	r4, #128	; 0x80
 80032a4:	0364      	lsls	r4, r4, #13
 80032a6:	4322      	orrs	r2, r4
 80032a8:	4c0d      	ldr	r4, [pc, #52]	; (80032e0 <__aeabi_d2iz+0x60>)
 80032aa:	1ae4      	subs	r4, r4, r3
 80032ac:	2c1f      	cmp	r4, #31
 80032ae:	dd08      	ble.n	80032c2 <__aeabi_d2iz+0x42>
 80032b0:	480c      	ldr	r0, [pc, #48]	; (80032e4 <__aeabi_d2iz+0x64>)
 80032b2:	1ac3      	subs	r3, r0, r3
 80032b4:	40da      	lsrs	r2, r3
 80032b6:	0013      	movs	r3, r2
 80032b8:	425c      	negs	r4, r3
 80032ba:	2900      	cmp	r1, #0
 80032bc:	d1ef      	bne.n	800329e <__aeabi_d2iz+0x1e>
 80032be:	001c      	movs	r4, r3
 80032c0:	e7ed      	b.n	800329e <__aeabi_d2iz+0x1e>
 80032c2:	4d09      	ldr	r5, [pc, #36]	; (80032e8 <__aeabi_d2iz+0x68>)
 80032c4:	40e0      	lsrs	r0, r4
 80032c6:	46ac      	mov	ip, r5
 80032c8:	4463      	add	r3, ip
 80032ca:	409a      	lsls	r2, r3
 80032cc:	0013      	movs	r3, r2
 80032ce:	4303      	orrs	r3, r0
 80032d0:	e7f2      	b.n	80032b8 <__aeabi_d2iz+0x38>
 80032d2:	46c0      	nop			; (mov r8, r8)
 80032d4:	000003fe 	.word	0x000003fe
 80032d8:	0000041d 	.word	0x0000041d
 80032dc:	7fffffff 	.word	0x7fffffff
 80032e0:	00000433 	.word	0x00000433
 80032e4:	00000413 	.word	0x00000413
 80032e8:	fffffbed 	.word	0xfffffbed
 80032ec:	00000000 	.word	0x00000000

080032f0 <__aeabi_i2d>:
 80032f0:	b570      	push	{r4, r5, r6, lr}
 80032f2:	2800      	cmp	r0, #0
 80032f4:	d018      	beq.n	8003328 <__aeabi_i2d+0x38>
 80032f6:	17c3      	asrs	r3, r0, #31
 80032f8:	18c5      	adds	r5, r0, r3
 80032fa:	405d      	eors	r5, r3
 80032fc:	0fc4      	lsrs	r4, r0, #31
 80032fe:	0028      	movs	r0, r5
 8003300:	f000 f94e 	bl	80035a0 <__clzsi2>
 8003304:	4b16      	ldr	r3, [pc, #88]	; (8003360 <__aeabi_i2d+0x70>)
 8003306:	1a1b      	subs	r3, r3, r0
 8003308:	055b      	lsls	r3, r3, #21
 800330a:	0d5e      	lsrs	r6, r3, #21
 800330c:	280a      	cmp	r0, #10
 800330e:	dc20      	bgt.n	8003352 <__aeabi_i2d+0x62>
 8003310:	0003      	movs	r3, r0
 8003312:	002a      	movs	r2, r5
 8003314:	3315      	adds	r3, #21
 8003316:	409a      	lsls	r2, r3
 8003318:	0013      	movs	r3, r2
 800331a:	220b      	movs	r2, #11
 800331c:	1a10      	subs	r0, r2, r0
 800331e:	002a      	movs	r2, r5
 8003320:	40c2      	lsrs	r2, r0
 8003322:	0312      	lsls	r2, r2, #12
 8003324:	0b12      	lsrs	r2, r2, #12
 8003326:	e003      	b.n	8003330 <__aeabi_i2d+0x40>
 8003328:	2400      	movs	r4, #0
 800332a:	2600      	movs	r6, #0
 800332c:	2200      	movs	r2, #0
 800332e:	2300      	movs	r3, #0
 8003330:	2100      	movs	r1, #0
 8003332:	0312      	lsls	r2, r2, #12
 8003334:	0018      	movs	r0, r3
 8003336:	0b13      	lsrs	r3, r2, #12
 8003338:	0d0a      	lsrs	r2, r1, #20
 800333a:	4d0a      	ldr	r5, [pc, #40]	; (8003364 <__aeabi_i2d+0x74>)
 800333c:	0512      	lsls	r2, r2, #20
 800333e:	431a      	orrs	r2, r3
 8003340:	402a      	ands	r2, r5
 8003342:	0533      	lsls	r3, r6, #20
 8003344:	4313      	orrs	r3, r2
 8003346:	005b      	lsls	r3, r3, #1
 8003348:	07e4      	lsls	r4, r4, #31
 800334a:	085b      	lsrs	r3, r3, #1
 800334c:	4323      	orrs	r3, r4
 800334e:	0019      	movs	r1, r3
 8003350:	bd70      	pop	{r4, r5, r6, pc}
 8003352:	002a      	movs	r2, r5
 8003354:	380b      	subs	r0, #11
 8003356:	4082      	lsls	r2, r0
 8003358:	0312      	lsls	r2, r2, #12
 800335a:	0b12      	lsrs	r2, r2, #12
 800335c:	2300      	movs	r3, #0
 800335e:	e7e7      	b.n	8003330 <__aeabi_i2d+0x40>
 8003360:	0000041e 	.word	0x0000041e
 8003364:	800fffff 	.word	0x800fffff
	...

08003370 <__aeabi_ui2d>:
 8003370:	b510      	push	{r4, lr}
 8003372:	1e04      	subs	r4, r0, #0
 8003374:	d012      	beq.n	800339c <__aeabi_ui2d+0x2c>
 8003376:	f000 f913 	bl	80035a0 <__clzsi2>
 800337a:	4b14      	ldr	r3, [pc, #80]	; (80033cc <__aeabi_ui2d+0x5c>)
 800337c:	1a1b      	subs	r3, r3, r0
 800337e:	055b      	lsls	r3, r3, #21
 8003380:	0d5b      	lsrs	r3, r3, #21
 8003382:	280a      	cmp	r0, #10
 8003384:	dc1b      	bgt.n	80033be <__aeabi_ui2d+0x4e>
 8003386:	0002      	movs	r2, r0
 8003388:	0021      	movs	r1, r4
 800338a:	3215      	adds	r2, #21
 800338c:	4091      	lsls	r1, r2
 800338e:	000a      	movs	r2, r1
 8003390:	210b      	movs	r1, #11
 8003392:	1a08      	subs	r0, r1, r0
 8003394:	40c4      	lsrs	r4, r0
 8003396:	0324      	lsls	r4, r4, #12
 8003398:	0b24      	lsrs	r4, r4, #12
 800339a:	e002      	b.n	80033a2 <__aeabi_ui2d+0x32>
 800339c:	2300      	movs	r3, #0
 800339e:	2400      	movs	r4, #0
 80033a0:	2200      	movs	r2, #0
 80033a2:	2100      	movs	r1, #0
 80033a4:	0010      	movs	r0, r2
 80033a6:	0324      	lsls	r4, r4, #12
 80033a8:	0d0a      	lsrs	r2, r1, #20
 80033aa:	0b24      	lsrs	r4, r4, #12
 80033ac:	0512      	lsls	r2, r2, #20
 80033ae:	4322      	orrs	r2, r4
 80033b0:	4c07      	ldr	r4, [pc, #28]	; (80033d0 <__aeabi_ui2d+0x60>)
 80033b2:	051b      	lsls	r3, r3, #20
 80033b4:	4022      	ands	r2, r4
 80033b6:	4313      	orrs	r3, r2
 80033b8:	005b      	lsls	r3, r3, #1
 80033ba:	0859      	lsrs	r1, r3, #1
 80033bc:	bd10      	pop	{r4, pc}
 80033be:	380b      	subs	r0, #11
 80033c0:	4084      	lsls	r4, r0
 80033c2:	0324      	lsls	r4, r4, #12
 80033c4:	0b24      	lsrs	r4, r4, #12
 80033c6:	2200      	movs	r2, #0
 80033c8:	e7eb      	b.n	80033a2 <__aeabi_ui2d+0x32>
 80033ca:	46c0      	nop			; (mov r8, r8)
 80033cc:	0000041e 	.word	0x0000041e
 80033d0:	800fffff 	.word	0x800fffff
	...

080033e0 <__aeabi_f2d>:
 80033e0:	b570      	push	{r4, r5, r6, lr}
 80033e2:	0041      	lsls	r1, r0, #1
 80033e4:	0246      	lsls	r6, r0, #9
 80033e6:	0fc4      	lsrs	r4, r0, #31
 80033e8:	20fe      	movs	r0, #254	; 0xfe
 80033ea:	0e09      	lsrs	r1, r1, #24
 80033ec:	1c4b      	adds	r3, r1, #1
 80033ee:	0a75      	lsrs	r5, r6, #9
 80033f0:	4218      	tst	r0, r3
 80033f2:	d014      	beq.n	800341e <__aeabi_f2d+0x3e>
 80033f4:	23e0      	movs	r3, #224	; 0xe0
 80033f6:	009b      	lsls	r3, r3, #2
 80033f8:	076d      	lsls	r5, r5, #29
 80033fa:	0b36      	lsrs	r6, r6, #12
 80033fc:	18cb      	adds	r3, r1, r3
 80033fe:	2100      	movs	r1, #0
 8003400:	0d0a      	lsrs	r2, r1, #20
 8003402:	0028      	movs	r0, r5
 8003404:	0512      	lsls	r2, r2, #20
 8003406:	4d1c      	ldr	r5, [pc, #112]	; (8003478 <__aeabi_f2d+0x98>)
 8003408:	4332      	orrs	r2, r6
 800340a:	055b      	lsls	r3, r3, #21
 800340c:	402a      	ands	r2, r5
 800340e:	085b      	lsrs	r3, r3, #1
 8003410:	4313      	orrs	r3, r2
 8003412:	005b      	lsls	r3, r3, #1
 8003414:	07e4      	lsls	r4, r4, #31
 8003416:	085b      	lsrs	r3, r3, #1
 8003418:	4323      	orrs	r3, r4
 800341a:	0019      	movs	r1, r3
 800341c:	bd70      	pop	{r4, r5, r6, pc}
 800341e:	2900      	cmp	r1, #0
 8003420:	d114      	bne.n	800344c <__aeabi_f2d+0x6c>
 8003422:	2d00      	cmp	r5, #0
 8003424:	d01e      	beq.n	8003464 <__aeabi_f2d+0x84>
 8003426:	0028      	movs	r0, r5
 8003428:	f000 f8ba 	bl	80035a0 <__clzsi2>
 800342c:	280a      	cmp	r0, #10
 800342e:	dc1c      	bgt.n	800346a <__aeabi_f2d+0x8a>
 8003430:	230b      	movs	r3, #11
 8003432:	002a      	movs	r2, r5
 8003434:	1a1b      	subs	r3, r3, r0
 8003436:	40da      	lsrs	r2, r3
 8003438:	0003      	movs	r3, r0
 800343a:	3315      	adds	r3, #21
 800343c:	409d      	lsls	r5, r3
 800343e:	4b0f      	ldr	r3, [pc, #60]	; (800347c <__aeabi_f2d+0x9c>)
 8003440:	0312      	lsls	r2, r2, #12
 8003442:	1a1b      	subs	r3, r3, r0
 8003444:	055b      	lsls	r3, r3, #21
 8003446:	0b16      	lsrs	r6, r2, #12
 8003448:	0d5b      	lsrs	r3, r3, #21
 800344a:	e7d8      	b.n	80033fe <__aeabi_f2d+0x1e>
 800344c:	2d00      	cmp	r5, #0
 800344e:	d006      	beq.n	800345e <__aeabi_f2d+0x7e>
 8003450:	0b32      	lsrs	r2, r6, #12
 8003452:	2680      	movs	r6, #128	; 0x80
 8003454:	0336      	lsls	r6, r6, #12
 8003456:	076d      	lsls	r5, r5, #29
 8003458:	4316      	orrs	r6, r2
 800345a:	4b09      	ldr	r3, [pc, #36]	; (8003480 <__aeabi_f2d+0xa0>)
 800345c:	e7cf      	b.n	80033fe <__aeabi_f2d+0x1e>
 800345e:	4b08      	ldr	r3, [pc, #32]	; (8003480 <__aeabi_f2d+0xa0>)
 8003460:	2600      	movs	r6, #0
 8003462:	e7cc      	b.n	80033fe <__aeabi_f2d+0x1e>
 8003464:	2300      	movs	r3, #0
 8003466:	2600      	movs	r6, #0
 8003468:	e7c9      	b.n	80033fe <__aeabi_f2d+0x1e>
 800346a:	0003      	movs	r3, r0
 800346c:	002a      	movs	r2, r5
 800346e:	3b0b      	subs	r3, #11
 8003470:	409a      	lsls	r2, r3
 8003472:	2500      	movs	r5, #0
 8003474:	e7e3      	b.n	800343e <__aeabi_f2d+0x5e>
 8003476:	46c0      	nop			; (mov r8, r8)
 8003478:	800fffff 	.word	0x800fffff
 800347c:	00000389 	.word	0x00000389
 8003480:	000007ff 	.word	0x000007ff
	...

08003490 <__aeabi_d2f>:
 8003490:	004a      	lsls	r2, r1, #1
 8003492:	b5f0      	push	{r4, r5, r6, r7, lr}
 8003494:	030b      	lsls	r3, r1, #12
 8003496:	0d52      	lsrs	r2, r2, #21
 8003498:	4d3d      	ldr	r5, [pc, #244]	; (8003590 <__aeabi_d2f+0x100>)
 800349a:	0a5b      	lsrs	r3, r3, #9
 800349c:	0f47      	lsrs	r7, r0, #29
 800349e:	1c56      	adds	r6, r2, #1
 80034a0:	0fc9      	lsrs	r1, r1, #31
 80034a2:	431f      	orrs	r7, r3
 80034a4:	00c4      	lsls	r4, r0, #3
 80034a6:	422e      	tst	r6, r5
 80034a8:	d028      	beq.n	80034fc <__aeabi_d2f+0x6c>
 80034aa:	4b3a      	ldr	r3, [pc, #232]	; (8003594 <__aeabi_d2f+0x104>)
 80034ac:	18d5      	adds	r5, r2, r3
 80034ae:	2dfe      	cmp	r5, #254	; 0xfe
 80034b0:	dd08      	ble.n	80034c4 <__aeabi_d2f+0x34>
 80034b2:	22ff      	movs	r2, #255	; 0xff
 80034b4:	2000      	movs	r0, #0
 80034b6:	0240      	lsls	r0, r0, #9
 80034b8:	05d2      	lsls	r2, r2, #23
 80034ba:	0a40      	lsrs	r0, r0, #9
 80034bc:	07c9      	lsls	r1, r1, #31
 80034be:	4310      	orrs	r0, r2
 80034c0:	4308      	orrs	r0, r1
 80034c2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80034c4:	2d00      	cmp	r5, #0
 80034c6:	dd2d      	ble.n	8003524 <__aeabi_d2f+0x94>
 80034c8:	0180      	lsls	r0, r0, #6
 80034ca:	0002      	movs	r2, r0
 80034cc:	1e50      	subs	r0, r2, #1
 80034ce:	4182      	sbcs	r2, r0
 80034d0:	00fb      	lsls	r3, r7, #3
 80034d2:	0f64      	lsrs	r4, r4, #29
 80034d4:	4313      	orrs	r3, r2
 80034d6:	4323      	orrs	r3, r4
 80034d8:	075a      	lsls	r2, r3, #29
 80034da:	d057      	beq.n	800358c <__aeabi_d2f+0xfc>
 80034dc:	220f      	movs	r2, #15
 80034de:	401a      	ands	r2, r3
 80034e0:	2a04      	cmp	r2, #4
 80034e2:	d000      	beq.n	80034e6 <__aeabi_d2f+0x56>
 80034e4:	3304      	adds	r3, #4
 80034e6:	2280      	movs	r2, #128	; 0x80
 80034e8:	04d2      	lsls	r2, r2, #19
 80034ea:	401a      	ands	r2, r3
 80034ec:	d04e      	beq.n	800358c <__aeabi_d2f+0xfc>
 80034ee:	3501      	adds	r5, #1
 80034f0:	b2ea      	uxtb	r2, r5
 80034f2:	2dff      	cmp	r5, #255	; 0xff
 80034f4:	d0dd      	beq.n	80034b2 <__aeabi_d2f+0x22>
 80034f6:	019b      	lsls	r3, r3, #6
 80034f8:	0a58      	lsrs	r0, r3, #9
 80034fa:	e7dc      	b.n	80034b6 <__aeabi_d2f+0x26>
 80034fc:	433c      	orrs	r4, r7
 80034fe:	2a00      	cmp	r2, #0
 8003500:	d106      	bne.n	8003510 <__aeabi_d2f+0x80>
 8003502:	2c00      	cmp	r4, #0
 8003504:	d00b      	beq.n	800351e <__aeabi_d2f+0x8e>
 8003506:	2305      	movs	r3, #5
 8003508:	019b      	lsls	r3, r3, #6
 800350a:	0a58      	lsrs	r0, r3, #9
 800350c:	b2d2      	uxtb	r2, r2
 800350e:	e7d2      	b.n	80034b6 <__aeabi_d2f+0x26>
 8003510:	2c00      	cmp	r4, #0
 8003512:	d0ce      	beq.n	80034b2 <__aeabi_d2f+0x22>
 8003514:	2080      	movs	r0, #128	; 0x80
 8003516:	03c0      	lsls	r0, r0, #15
 8003518:	4338      	orrs	r0, r7
 800351a:	22ff      	movs	r2, #255	; 0xff
 800351c:	e7cb      	b.n	80034b6 <__aeabi_d2f+0x26>
 800351e:	2200      	movs	r2, #0
 8003520:	2000      	movs	r0, #0
 8003522:	e7c8      	b.n	80034b6 <__aeabi_d2f+0x26>
 8003524:	002b      	movs	r3, r5
 8003526:	3317      	adds	r3, #23
 8003528:	db22      	blt.n	8003570 <__aeabi_d2f+0xe0>
 800352a:	2380      	movs	r3, #128	; 0x80
 800352c:	261e      	movs	r6, #30
 800352e:	041b      	lsls	r3, r3, #16
 8003530:	433b      	orrs	r3, r7
 8003532:	1b76      	subs	r6, r6, r5
 8003534:	2e1f      	cmp	r6, #31
 8003536:	dd1d      	ble.n	8003574 <__aeabi_d2f+0xe4>
 8003538:	2002      	movs	r0, #2
 800353a:	4240      	negs	r0, r0
 800353c:	1b45      	subs	r5, r0, r5
 800353e:	0018      	movs	r0, r3
 8003540:	40e8      	lsrs	r0, r5
 8003542:	0005      	movs	r5, r0
 8003544:	2e20      	cmp	r6, #32
 8003546:	d004      	beq.n	8003552 <__aeabi_d2f+0xc2>
 8003548:	4813      	ldr	r0, [pc, #76]	; (8003598 <__aeabi_d2f+0x108>)
 800354a:	4684      	mov	ip, r0
 800354c:	4462      	add	r2, ip
 800354e:	4093      	lsls	r3, r2
 8003550:	431c      	orrs	r4, r3
 8003552:	0023      	movs	r3, r4
 8003554:	1e5c      	subs	r4, r3, #1
 8003556:	41a3      	sbcs	r3, r4
 8003558:	432b      	orrs	r3, r5
 800355a:	2500      	movs	r5, #0
 800355c:	075a      	lsls	r2, r3, #29
 800355e:	d1bd      	bne.n	80034dc <__aeabi_d2f+0x4c>
 8003560:	2080      	movs	r0, #128	; 0x80
 8003562:	04c0      	lsls	r0, r0, #19
 8003564:	4018      	ands	r0, r3
 8003566:	2201      	movs	r2, #1
 8003568:	42a8      	cmp	r0, r5
 800356a:	d1c4      	bne.n	80034f6 <__aeabi_d2f+0x66>
 800356c:	0002      	movs	r2, r0
 800356e:	e7cb      	b.n	8003508 <__aeabi_d2f+0x78>
 8003570:	2200      	movs	r2, #0
 8003572:	e7c8      	b.n	8003506 <__aeabi_d2f+0x76>
 8003574:	4809      	ldr	r0, [pc, #36]	; (800359c <__aeabi_d2f+0x10c>)
 8003576:	1810      	adds	r0, r2, r0
 8003578:	0022      	movs	r2, r4
 800357a:	4084      	lsls	r4, r0
 800357c:	0025      	movs	r5, r4
 800357e:	4083      	lsls	r3, r0
 8003580:	1e6c      	subs	r4, r5, #1
 8003582:	41a5      	sbcs	r5, r4
 8003584:	40f2      	lsrs	r2, r6
 8003586:	432b      	orrs	r3, r5
 8003588:	4313      	orrs	r3, r2
 800358a:	e7e6      	b.n	800355a <__aeabi_d2f+0xca>
 800358c:	002a      	movs	r2, r5
 800358e:	e7bb      	b.n	8003508 <__aeabi_d2f+0x78>
 8003590:	000007fe 	.word	0x000007fe
 8003594:	fffffc80 	.word	0xfffffc80
 8003598:	fffffca2 	.word	0xfffffca2
 800359c:	fffffc82 	.word	0xfffffc82

080035a0 <__clzsi2>:
 80035a0:	211c      	movs	r1, #28
 80035a2:	2301      	movs	r3, #1
 80035a4:	041b      	lsls	r3, r3, #16
 80035a6:	4298      	cmp	r0, r3
 80035a8:	d301      	bcc.n	80035ae <__clzsi2+0xe>
 80035aa:	0c00      	lsrs	r0, r0, #16
 80035ac:	3910      	subs	r1, #16
 80035ae:	0a1b      	lsrs	r3, r3, #8
 80035b0:	4298      	cmp	r0, r3
 80035b2:	d301      	bcc.n	80035b8 <__clzsi2+0x18>
 80035b4:	0a00      	lsrs	r0, r0, #8
 80035b6:	3908      	subs	r1, #8
 80035b8:	091b      	lsrs	r3, r3, #4
 80035ba:	4298      	cmp	r0, r3
 80035bc:	d301      	bcc.n	80035c2 <__clzsi2+0x22>
 80035be:	0900      	lsrs	r0, r0, #4
 80035c0:	3904      	subs	r1, #4
 80035c2:	a202      	add	r2, pc, #8	; (adr r2, 80035cc <__clzsi2+0x2c>)
 80035c4:	5c10      	ldrb	r0, [r2, r0]
 80035c6:	1840      	adds	r0, r0, r1
 80035c8:	4770      	bx	lr
 80035ca:	46c0      	nop			; (mov r8, r8)
 80035cc:	02020304 	.word	0x02020304
 80035d0:	01010101 	.word	0x01010101
	...

080035e0 <__clzdi2>:
 80035e0:	b510      	push	{r4, lr}
 80035e2:	2900      	cmp	r1, #0
 80035e4:	d103      	bne.n	80035ee <__clzdi2+0xe>
 80035e6:	f7ff ffdb 	bl	80035a0 <__clzsi2>
 80035ea:	3020      	adds	r0, #32
 80035ec:	e002      	b.n	80035f4 <__clzdi2+0x14>
 80035ee:	1c08      	adds	r0, r1, #0
 80035f0:	f7ff ffd6 	bl	80035a0 <__clzsi2>
 80035f4:	bd10      	pop	{r4, pc}
 80035f6:	46c0      	nop			; (mov r8, r8)
	...

08003600 <__divdi3>:
 8003600:	b5f0      	push	{r4, r5, r6, r7, lr}
 8003602:	4657      	mov	r7, sl
 8003604:	464e      	mov	r6, r9
 8003606:	4645      	mov	r5, r8
 8003608:	46de      	mov	lr, fp
 800360a:	b5e0      	push	{r5, r6, r7, lr}
 800360c:	000f      	movs	r7, r1
 800360e:	2100      	movs	r1, #0
 8003610:	b083      	sub	sp, #12
 8003612:	0006      	movs	r6, r0
 8003614:	4688      	mov	r8, r1
 8003616:	2f00      	cmp	r7, #0
 8003618:	da06      	bge.n	8003628 <__divdi3+0x28>
 800361a:	0039      	movs	r1, r7
 800361c:	2700      	movs	r7, #0
 800361e:	4246      	negs	r6, r0
 8003620:	418f      	sbcs	r7, r1
 8003622:	2101      	movs	r1, #1
 8003624:	4249      	negs	r1, r1
 8003626:	4688      	mov	r8, r1
 8003628:	2b00      	cmp	r3, #0
 800362a:	da07      	bge.n	800363c <__divdi3+0x3c>
 800362c:	4641      	mov	r1, r8
 800362e:	43c9      	mvns	r1, r1
 8003630:	0010      	movs	r0, r2
 8003632:	4688      	mov	r8, r1
 8003634:	0019      	movs	r1, r3
 8003636:	2300      	movs	r3, #0
 8003638:	4242      	negs	r2, r0
 800363a:	418b      	sbcs	r3, r1
 800363c:	0034      	movs	r4, r6
 800363e:	003d      	movs	r5, r7
 8003640:	4692      	mov	sl, r2
 8003642:	4699      	mov	r9, r3
 8003644:	42bb      	cmp	r3, r7
 8003646:	d86b      	bhi.n	8003720 <__divdi3+0x120>
 8003648:	d068      	beq.n	800371c <__divdi3+0x11c>
 800364a:	4649      	mov	r1, r9
 800364c:	4650      	mov	r0, sl
 800364e:	f7ff ffc7 	bl	80035e0 <__clzdi2>
 8003652:	4683      	mov	fp, r0
 8003654:	0039      	movs	r1, r7
 8003656:	0030      	movs	r0, r6
 8003658:	f7ff ffc2 	bl	80035e0 <__clzdi2>
 800365c:	465b      	mov	r3, fp
 800365e:	1a1b      	subs	r3, r3, r0
 8003660:	469c      	mov	ip, r3
 8003662:	3b20      	subs	r3, #32
 8003664:	469b      	mov	fp, r3
 8003666:	d46c      	bmi.n	8003742 <__divdi3+0x142>
 8003668:	4658      	mov	r0, fp
 800366a:	4651      	mov	r1, sl
 800366c:	4081      	lsls	r1, r0
 800366e:	4660      	mov	r0, ip
 8003670:	000b      	movs	r3, r1
 8003672:	4651      	mov	r1, sl
 8003674:	4081      	lsls	r1, r0
 8003676:	000a      	movs	r2, r1
 8003678:	42bb      	cmp	r3, r7
 800367a:	d900      	bls.n	800367e <__divdi3+0x7e>
 800367c:	e074      	b.n	8003768 <__divdi3+0x168>
 800367e:	42bb      	cmp	r3, r7
 8003680:	d100      	bne.n	8003684 <__divdi3+0x84>
 8003682:	e07b      	b.n	800377c <__divdi3+0x17c>
 8003684:	0034      	movs	r4, r6
 8003686:	003d      	movs	r5, r7
 8003688:	4659      	mov	r1, fp
 800368a:	1aa4      	subs	r4, r4, r2
 800368c:	419d      	sbcs	r5, r3
 800368e:	2900      	cmp	r1, #0
 8003690:	da00      	bge.n	8003694 <__divdi3+0x94>
 8003692:	e076      	b.n	8003782 <__divdi3+0x182>
 8003694:	2100      	movs	r1, #0
 8003696:	2000      	movs	r0, #0
 8003698:	2601      	movs	r6, #1
 800369a:	9000      	str	r0, [sp, #0]
 800369c:	9101      	str	r1, [sp, #4]
 800369e:	4659      	mov	r1, fp
 80036a0:	408e      	lsls	r6, r1
 80036a2:	9601      	str	r6, [sp, #4]
 80036a4:	4661      	mov	r1, ip
 80036a6:	2601      	movs	r6, #1
 80036a8:	408e      	lsls	r6, r1
 80036aa:	4661      	mov	r1, ip
 80036ac:	9600      	str	r6, [sp, #0]
 80036ae:	2900      	cmp	r1, #0
 80036b0:	d061      	beq.n	8003776 <__divdi3+0x176>
 80036b2:	07d9      	lsls	r1, r3, #31
 80036b4:	0856      	lsrs	r6, r2, #1
 80036b6:	430e      	orrs	r6, r1
 80036b8:	085f      	lsrs	r7, r3, #1
 80036ba:	4661      	mov	r1, ip
 80036bc:	2201      	movs	r2, #1
 80036be:	2300      	movs	r3, #0
 80036c0:	e00c      	b.n	80036dc <__divdi3+0xdc>
 80036c2:	42af      	cmp	r7, r5
 80036c4:	d101      	bne.n	80036ca <__divdi3+0xca>
 80036c6:	42a6      	cmp	r6, r4
 80036c8:	d80a      	bhi.n	80036e0 <__divdi3+0xe0>
 80036ca:	1ba4      	subs	r4, r4, r6
 80036cc:	41bd      	sbcs	r5, r7
 80036ce:	1924      	adds	r4, r4, r4
 80036d0:	416d      	adcs	r5, r5
 80036d2:	3901      	subs	r1, #1
 80036d4:	18a4      	adds	r4, r4, r2
 80036d6:	415d      	adcs	r5, r3
 80036d8:	2900      	cmp	r1, #0
 80036da:	d006      	beq.n	80036ea <__divdi3+0xea>
 80036dc:	42af      	cmp	r7, r5
 80036de:	d9f0      	bls.n	80036c2 <__divdi3+0xc2>
 80036e0:	3901      	subs	r1, #1
 80036e2:	1924      	adds	r4, r4, r4
 80036e4:	416d      	adcs	r5, r5
 80036e6:	2900      	cmp	r1, #0
 80036e8:	d1f8      	bne.n	80036dc <__divdi3+0xdc>
 80036ea:	9800      	ldr	r0, [sp, #0]
 80036ec:	9901      	ldr	r1, [sp, #4]
 80036ee:	465b      	mov	r3, fp
 80036f0:	1900      	adds	r0, r0, r4
 80036f2:	4169      	adcs	r1, r5
 80036f4:	2b00      	cmp	r3, #0
 80036f6:	db4f      	blt.n	8003798 <__divdi3+0x198>
 80036f8:	002e      	movs	r6, r5
 80036fa:	002c      	movs	r4, r5
 80036fc:	40de      	lsrs	r6, r3
 80036fe:	4663      	mov	r3, ip
 8003700:	40dc      	lsrs	r4, r3
 8003702:	465b      	mov	r3, fp
 8003704:	2b00      	cmp	r3, #0
 8003706:	db57      	blt.n	80037b8 <__divdi3+0x1b8>
 8003708:	0034      	movs	r4, r6
 800370a:	465d      	mov	r5, fp
 800370c:	40ac      	lsls	r4, r5
 800370e:	0023      	movs	r3, r4
 8003710:	4664      	mov	r4, ip
 8003712:	40a6      	lsls	r6, r4
 8003714:	0032      	movs	r2, r6
 8003716:	1a80      	subs	r0, r0, r2
 8003718:	4199      	sbcs	r1, r3
 800371a:	e003      	b.n	8003724 <__divdi3+0x124>
 800371c:	42b2      	cmp	r2, r6
 800371e:	d994      	bls.n	800364a <__divdi3+0x4a>
 8003720:	2000      	movs	r0, #0
 8003722:	2100      	movs	r1, #0
 8003724:	4643      	mov	r3, r8
 8003726:	2b00      	cmp	r3, #0
 8003728:	d004      	beq.n	8003734 <__divdi3+0x134>
 800372a:	0003      	movs	r3, r0
 800372c:	000c      	movs	r4, r1
 800372e:	2100      	movs	r1, #0
 8003730:	4258      	negs	r0, r3
 8003732:	41a1      	sbcs	r1, r4
 8003734:	b003      	add	sp, #12
 8003736:	bc3c      	pop	{r2, r3, r4, r5}
 8003738:	4690      	mov	r8, r2
 800373a:	4699      	mov	r9, r3
 800373c:	46a2      	mov	sl, r4
 800373e:	46ab      	mov	fp, r5
 8003740:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003742:	4662      	mov	r2, ip
 8003744:	2320      	movs	r3, #32
 8003746:	4651      	mov	r1, sl
 8003748:	1a9b      	subs	r3, r3, r2
 800374a:	40d9      	lsrs	r1, r3
 800374c:	4648      	mov	r0, r9
 800374e:	9100      	str	r1, [sp, #0]
 8003750:	4661      	mov	r1, ip
 8003752:	4088      	lsls	r0, r1
 8003754:	0003      	movs	r3, r0
 8003756:	9900      	ldr	r1, [sp, #0]
 8003758:	4660      	mov	r0, ip
 800375a:	430b      	orrs	r3, r1
 800375c:	4651      	mov	r1, sl
 800375e:	4081      	lsls	r1, r0
 8003760:	000a      	movs	r2, r1
 8003762:	42bb      	cmp	r3, r7
 8003764:	d800      	bhi.n	8003768 <__divdi3+0x168>
 8003766:	e78a      	b.n	800367e <__divdi3+0x7e>
 8003768:	2100      	movs	r1, #0
 800376a:	2000      	movs	r0, #0
 800376c:	9000      	str	r0, [sp, #0]
 800376e:	9101      	str	r1, [sp, #4]
 8003770:	4661      	mov	r1, ip
 8003772:	2900      	cmp	r1, #0
 8003774:	d19d      	bne.n	80036b2 <__divdi3+0xb2>
 8003776:	9800      	ldr	r0, [sp, #0]
 8003778:	9901      	ldr	r1, [sp, #4]
 800377a:	e7d3      	b.n	8003724 <__divdi3+0x124>
 800377c:	42b1      	cmp	r1, r6
 800377e:	d8f3      	bhi.n	8003768 <__divdi3+0x168>
 8003780:	e780      	b.n	8003684 <__divdi3+0x84>
 8003782:	4661      	mov	r1, ip
 8003784:	2620      	movs	r6, #32
 8003786:	2701      	movs	r7, #1
 8003788:	1a76      	subs	r6, r6, r1
 800378a:	2000      	movs	r0, #0
 800378c:	2100      	movs	r1, #0
 800378e:	40f7      	lsrs	r7, r6
 8003790:	9000      	str	r0, [sp, #0]
 8003792:	9101      	str	r1, [sp, #4]
 8003794:	9701      	str	r7, [sp, #4]
 8003796:	e785      	b.n	80036a4 <__divdi3+0xa4>
 8003798:	4662      	mov	r2, ip
 800379a:	2320      	movs	r3, #32
 800379c:	1a9b      	subs	r3, r3, r2
 800379e:	002a      	movs	r2, r5
 80037a0:	409a      	lsls	r2, r3
 80037a2:	0026      	movs	r6, r4
 80037a4:	0013      	movs	r3, r2
 80037a6:	4662      	mov	r2, ip
 80037a8:	40d6      	lsrs	r6, r2
 80037aa:	002c      	movs	r4, r5
 80037ac:	431e      	orrs	r6, r3
 80037ae:	4663      	mov	r3, ip
 80037b0:	40dc      	lsrs	r4, r3
 80037b2:	465b      	mov	r3, fp
 80037b4:	2b00      	cmp	r3, #0
 80037b6:	daa7      	bge.n	8003708 <__divdi3+0x108>
 80037b8:	4667      	mov	r7, ip
 80037ba:	2320      	movs	r3, #32
 80037bc:	4662      	mov	r2, ip
 80037be:	0035      	movs	r5, r6
 80037c0:	40bc      	lsls	r4, r7
 80037c2:	1a9b      	subs	r3, r3, r2
 80037c4:	40dd      	lsrs	r5, r3
 80037c6:	0023      	movs	r3, r4
 80037c8:	432b      	orrs	r3, r5
 80037ca:	e7a1      	b.n	8003710 <__divdi3+0x110>
 80037cc:	0000      	movs	r0, r0
	...

080037d0 <strcmp>:
 80037d0:	7802      	ldrb	r2, [r0, #0]
 80037d2:	780b      	ldrb	r3, [r1, #0]
 80037d4:	2a00      	cmp	r2, #0
 80037d6:	d003      	beq.n	80037e0 <strcmp+0x10>
 80037d8:	3001      	adds	r0, #1
 80037da:	3101      	adds	r1, #1
 80037dc:	429a      	cmp	r2, r3
 80037de:	d0f7      	beq.n	80037d0 <strcmp>
 80037e0:	1ad0      	subs	r0, r2, r3
 80037e2:	4770      	bx	lr
	...

080037f0 <strlen>:
 80037f0:	2300      	movs	r3, #0
 80037f2:	5cc2      	ldrb	r2, [r0, r3]
 80037f4:	3301      	adds	r3, #1
 80037f6:	2a00      	cmp	r2, #0
 80037f8:	d1fb      	bne.n	80037f2 <strlen+0x2>
 80037fa:	1e58      	subs	r0, r3, #1
 80037fc:	4770      	bx	lr
	...

08003800 <__core_init>:

#if __CORTEX_M == 7
  SCB_EnableICache();
  SCB_EnableDCache();
#endif
}
 8003800:	4770      	bx	lr
 8003802:	46c0      	nop			; (mov r8, r8)
	...

08003810 <__late_init>:
 8003810:	4770      	bx	lr
 8003812:	46c0      	nop			; (mov r8, r8)
	...

08003820 <__default_exit>:
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
/*lint -restore*/

  while (true) {
  }
 8003820:	e7fe      	b.n	8003820 <__default_exit>
 8003822:	46c0      	nop			; (mov r8, r8)
	...

08003830 <__init_ram_areas>:
/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;
 8003830:	2280      	movs	r2, #128	; 0x80
 8003832:	4694      	mov	ip, r2
void __init_ram_areas(void) {
 8003834:	b5f0      	push	{r4, r5, r6, r7, lr}
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
      *p = 0;
 8003836:	2500      	movs	r5, #0
  const ram_init_area_t *rap = ram_areas;
 8003838:	4e10      	ldr	r6, [pc, #64]	; (800387c <__init_ram_areas+0x4c>)
void __init_ram_areas(void) {
 800383a:	4c11      	ldr	r4, [pc, #68]	; (8003880 <__init_ram_areas+0x50>)
 800383c:	4911      	ldr	r1, [pc, #68]	; (8003884 <__init_ram_areas+0x54>)
 800383e:	4b12      	ldr	r3, [pc, #72]	; (8003888 <__init_ram_areas+0x58>)
 8003840:	4812      	ldr	r0, [pc, #72]	; (800388c <__init_ram_areas+0x5c>)
 8003842:	44b4      	add	ip, r6
    while (p < rap->clear_area) {
 8003844:	4299      	cmp	r1, r3
 8003846:	d90d      	bls.n	8003864 <__init_ram_areas+0x34>
 8003848:	001a      	movs	r2, r3
      *p = *tp;
 800384a:	c880      	ldmia	r0!, {r7}
 800384c:	c280      	stmia	r2!, {r7}
    while (p < rap->clear_area) {
 800384e:	4291      	cmp	r1, r2
 8003850:	d8fb      	bhi.n	800384a <__init_ram_areas+0x1a>
 8003852:	3901      	subs	r1, #1
 8003854:	1ac9      	subs	r1, r1, r3
 8003856:	0889      	lsrs	r1, r1, #2
 8003858:	3101      	adds	r1, #1
 800385a:	0089      	lsls	r1, r1, #2
 800385c:	185b      	adds	r3, r3, r1
    while (p < rap->no_init_area) {
 800385e:	429c      	cmp	r4, r3
 8003860:	d902      	bls.n	8003868 <__init_ram_areas+0x38>
      *p = 0;
 8003862:	c320      	stmia	r3!, {r5}
    while (p < rap->no_init_area) {
 8003864:	429c      	cmp	r4, r3
 8003866:	d8fc      	bhi.n	8003862 <__init_ram_areas+0x32>
      p++;
    }
    rap++;
 8003868:	3610      	adds	r6, #16
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 800386a:	4566      	cmp	r6, ip
 800386c:	d004      	beq.n	8003878 <__init_ram_areas+0x48>
 800386e:	6830      	ldr	r0, [r6, #0]
 8003870:	6873      	ldr	r3, [r6, #4]
 8003872:	68b1      	ldr	r1, [r6, #8]
 8003874:	68f4      	ldr	r4, [r6, #12]
 8003876:	e7e5      	b.n	8003844 <__init_ram_areas+0x14>
#endif
}
 8003878:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800387a:	46c0      	nop			; (mov r8, r8)
 800387c:	0801352c 	.word	0x0801352c
 8003880:	200038b4 	.word	0x200038b4
 8003884:	200038b4 	.word	0x200038b4
 8003888:	200038b4 	.word	0x200038b4
 800388c:	08018024 	.word	0x08018024

08003890 <_unhandled_exception>:
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void _unhandled_exception(void) {
/*lint -restore*/

  while (true) {
  }
 8003890:	e7fe      	b.n	8003890 <_unhandled_exception>
 8003892:	46c0      	nop			; (mov r8, r8)
	...

080038a0 <_idle_thread>:
static inline void port_wait_for_interrupt(void) {

#if CORTEX_ENABLE_WFI_IDLE == TRUE
  __WFI();
#endif
}
 80038a0:	e7fe      	b.n	80038a0 <_idle_thread>
 80038a2:	46c0      	nop			; (mov r8, r8)
	...

080038b0 <chSysInit>:
 * @post    The main thread is created with priority @p NORMALPRIO and
 *          interrupts are enabled.
 *
 * @special
 */
void chSysInit(void) {
 80038b0:	b510      	push	{r4, lr}

  _scheduler_init();
 80038b2:	f000 f925 	bl	8003b00 <_scheduler_init>
  _vt_init();
 80038b6:	f000 f86b 	bl	8003990 <_vt_init>
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
#if CH_CFG_USE_REGISTRY == TRUE
  currp = _thread_init(&ch.mainthread, (const char *)&ch_debug, NORMALPRIO);
 80038ba:	4c0b      	ldr	r4, [pc, #44]	; (80038e8 <chSysInit+0x38>)
 80038bc:	2280      	movs	r2, #128	; 0x80
 80038be:	490b      	ldr	r1, [pc, #44]	; (80038ec <chSysInit+0x3c>)
 80038c0:	0020      	movs	r0, r4
 80038c2:	f000 fa1d 	bl	8003d00 <_thread_init>
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  {
    /* Setting up the base address of the static main thread stack, the
       symbol must be provided externally.*/
    extern stkalign_t __main_thread_stack_base__;
    currp->wabase = &__main_thread_stack_base__;
 80038c6:	4b0a      	ldr	r3, [pc, #40]	; (80038f0 <chSysInit+0x40>)
#elif CH_CFG_USE_DYNAMIC == TRUE
  currp->wabase = NULL;
#endif

  /* Setting up the caller as current thread.*/
  currp->state = CH_STATE_CURRENT;
 80038c8:	2201      	movs	r2, #1
    currp->wabase = &__main_thread_stack_base__;
 80038ca:	61c3      	str	r3, [r0, #28]
  currp->state = CH_STATE_CURRENT;
 80038cc:	2320      	movs	r3, #32
 80038ce:	54c2      	strb	r2, [r0, r3]
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if((int32_t)(IRQn) < 0) {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 80038d0:	4a08      	ldr	r2, [pc, #32]	; (80038f4 <chSysInit+0x44>)
 80038d2:	4909      	ldr	r1, [pc, #36]	; (80038f8 <chSysInit+0x48>)
 80038d4:	6a13      	ldr	r3, [r2, #32]
  currp = _thread_init(&ch.mainthread, (const char *)&ch_debug, NORMALPRIO);
 80038d6:	3c30      	subs	r4, #48	; 0x30
 80038d8:	400b      	ands	r3, r1
 80038da:	61a0      	str	r0, [r4, #24]
 80038dc:	6213      	str	r3, [r2, #32]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80038de:	b662      	cpsie	i
    };

    /* This thread has the lowest priority in the system, its role is just to
       serve interrupts in its context while keeping the lowest energy saving
       mode compatible with the system status.*/
    (void) chThdCreate(&idle_descriptor);
 80038e0:	4806      	ldr	r0, [pc, #24]	; (80038fc <chSysInit+0x4c>)
 80038e2:	f000 fa55 	bl	8003d90 <chThdCreate>
  }
#endif
}
 80038e6:	bd10      	pop	{r4, pc}
 80038e8:	200017c8 	.word	0x200017c8
 80038ec:	080135e4 	.word	0x080135e4
 80038f0:	20000200 	.word	0x20000200
 80038f4:	e000ed00 	.word	0xe000ed00
 80038f8:	ff00ffff 	.word	0xff00ffff
 80038fc:	080135ac 	.word	0x080135ac

08003900 <chSysHalt>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003900:	b672      	cpsid	i

  /* Logging the event.*/
  _trace_halt(reason);

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 8003902:	4b01      	ldr	r3, [pc, #4]	; (8003908 <chSysHalt+0x8>)
 8003904:	62d8      	str	r0, [r3, #44]	; 0x2c

  /* Harmless infinite loop.*/
  while (true) {
  }
 8003906:	e7fe      	b.n	8003906 <chSysHalt+0x6>
 8003908:	20001798 	.word	0x20001798
 800390c:	00000000 	.word	0x00000000

08003910 <chSysTimerHandlerI>:
 *          and, together with the @p CH_CFG_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
 8003910:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8003912:	2680      	movs	r6, #128	; 0x80
 8003914:	46ce      	mov	lr, r9
 8003916:	4647      	mov	r7, r8
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  virtual_timer_t *vtp;
  systime_t now, delta;

  /* First timer to be processed.*/
  vtp = ch.vtlist.next;
 8003918:	4d1b      	ldr	r5, [pc, #108]	; (8003988 <chSysTimerHandlerI+0x78>)
 800391a:	05f6      	lsls	r6, r6, #23
 800391c:	69ec      	ldr	r4, [r5, #28]
 800391e:	6a72      	ldr	r2, [r6, #36]	; 0x24

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
 8003920:	6aa8      	ldr	r0, [r5, #40]	; 0x28
 8003922:	68a3      	ldr	r3, [r4, #8]
 8003924:	b580      	push	{r7, lr}
 8003926:	1a11      	subs	r1, r2, r0
 8003928:	4299      	cmp	r1, r3
 800392a:	d31d      	bcc.n	8003968 <chSysTimerHandlerI+0x58>
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.lasttime += vtp->delta;

    vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 800392c:	002f      	movs	r7, r5
    ch.vtlist.next = vtp->next;
    fn = vtp->func;
    vtp->func = NULL;
 800392e:	2200      	movs	r2, #0
    vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 8003930:	371c      	adds	r7, #28
    vtp->func = NULL;
 8003932:	4690      	mov	r8, r2
 8003934:	e00a      	b.n	800394c <chSysTimerHandlerI+0x3c>
  __ASM volatile ("cpsie i" : : : "memory");
 8003936:	b662      	cpsie	i
       and in order to give a preemption chance to higher priority
       interrupts.*/
    chSysUnlockFromISR();

    /* The callback is invoked outside the kernel critical zone.*/
    fn(vtp->par);
 8003938:	6920      	ldr	r0, [r4, #16]
 800393a:	47c8      	blx	r9
  __ASM volatile ("cpsid i" : : : "memory");
 800393c:	b672      	cpsid	i
       of the list.*/
    chSysLockFromISR();

    /* Next element in the list, the current time could have advanced so
       recalculating the time window.*/
    vtp = ch.vtlist.next;
 800393e:	69ec      	ldr	r4, [r5, #28]
 8003940:	6a72      	ldr	r2, [r6, #36]	; 0x24
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
 8003942:	6aa8      	ldr	r0, [r5, #40]	; 0x28
 8003944:	68a3      	ldr	r3, [r4, #8]
 8003946:	1a11      	subs	r1, r2, r0
 8003948:	428b      	cmp	r3, r1
 800394a:	d80d      	bhi.n	8003968 <chSysTimerHandlerI+0x58>
    fn = vtp->func;
 800394c:	68e2      	ldr	r2, [r4, #12]
    ch.vtlist.lasttime += vtp->delta;
 800394e:	18c3      	adds	r3, r0, r3
    fn = vtp->func;
 8003950:	4691      	mov	r9, r2
    vtp->func = NULL;
 8003952:	4642      	mov	r2, r8
    ch.vtlist.lasttime += vtp->delta;
 8003954:	62ab      	str	r3, [r5, #40]	; 0x28
    vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 8003956:	6823      	ldr	r3, [r4, #0]
 8003958:	605f      	str	r7, [r3, #4]
    ch.vtlist.next = vtp->next;
 800395a:	61eb      	str	r3, [r5, #28]
    vtp->func = NULL;
 800395c:	60e2      	str	r2, [r4, #12]
    if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 800395e:	42bb      	cmp	r3, r7
 8003960:	d1e9      	bne.n	8003936 <chSysTimerHandlerI+0x26>
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {

  stStopAlarm();
 8003962:	f000 fc7d 	bl	8004260 <stStopAlarm>
 8003966:	e7e6      	b.n	8003936 <chSysTimerHandlerI+0x26>
    now = chVTGetSystemTimeX();
  }

  /* if the list is empty, nothing else to do.*/
  if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 8003968:	4908      	ldr	r1, [pc, #32]	; (800398c <chSysTimerHandlerI+0x7c>)
 800396a:	428c      	cmp	r4, r1
 800396c:	d006      	beq.n	800397c <chSysTimerHandlerI+0x6c>
    return;
  }

  /* Recalculating the next alarm time.*/
  delta = ch.vtlist.lasttime + vtp->delta - now;
 800396e:	1818      	adds	r0, r3, r0
 8003970:	1a80      	subs	r0, r0, r2
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
  }
  port_timer_set_alarm(now + delta);
 8003972:	2802      	cmp	r0, #2
 8003974:	d306      	bcc.n	8003984 <chSysTimerHandlerI+0x74>
 8003976:	1880      	adds	r0, r0, r2
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {

  stSetAlarm(time);
 8003978:	f000 fc7a 	bl	8004270 <stSetAlarm>
#if CH_DBG_THREADS_PROFILING == TRUE
  currp->time++;
#endif
  chVTDoTickI();
  CH_CFG_SYSTEM_TICK_HOOK();
}
 800397c:	bc0c      	pop	{r2, r3}
 800397e:	4690      	mov	r8, r2
 8003980:	4699      	mov	r9, r3
 8003982:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8003984:	2002      	movs	r0, #2
 8003986:	e7f6      	b.n	8003976 <chSysTimerHandlerI+0x66>
 8003988:	20001798 	.word	0x20001798
 800398c:	200017b4 	.word	0x200017b4

08003990 <_vt_init>:
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
 8003990:	4b05      	ldr	r3, [pc, #20]	; (80039a8 <_vt_init+0x18>)
 8003992:	001a      	movs	r2, r3
 8003994:	321c      	adds	r2, #28
 8003996:	61da      	str	r2, [r3, #28]
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
 8003998:	621a      	str	r2, [r3, #32]
  ch.vtlist.delta = (systime_t)-1;
 800399a:	2201      	movs	r2, #1
 800399c:	4252      	negs	r2, r2
 800399e:	625a      	str	r2, [r3, #36]	; 0x24
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.lasttime = (systime_t)0;
 80039a0:	2200      	movs	r2, #0
 80039a2:	629a      	str	r2, [r3, #40]	; 0x28
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 80039a4:	4770      	bx	lr
 80039a6:	46c0      	nop			; (mov r8, r8)
 80039a8:	20001798 	.word	0x20001798
 80039ac:	00000000 	.word	0x00000000

080039b0 <chVTDoSetI>:
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
 80039b0:	b570      	push	{r4, r5, r6, lr}
  systime_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->par = par;
 80039b2:	6103      	str	r3, [r0, #16]
 80039b4:	2380      	movs	r3, #128	; 0x80
 80039b6:	05db      	lsls	r3, r3, #23
                vtfunc_t vtfunc, void *par) {
 80039b8:	0005      	movs	r5, r0
  vtp->func = vtfunc;
 80039ba:	60c2      	str	r2, [r0, #12]
 80039bc:	6a58      	ldr	r0, [r3, #36]	; 0x24
  {
    systime_t now = chVTGetSystemTimeX();

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
 80039be:	2902      	cmp	r1, #2
 80039c0:	d200      	bcs.n	80039c4 <chVTDoSetI+0x14>
 80039c2:	2102      	movs	r1, #2
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 80039c4:	4e16      	ldr	r6, [pc, #88]	; (8003a20 <chVTDoSetI+0x70>)
 80039c6:	0032      	movs	r2, r6
 80039c8:	69f3      	ldr	r3, [r6, #28]
 80039ca:	321c      	adds	r2, #28
 80039cc:	4293      	cmp	r3, r2
 80039ce:	d01d      	beq.n	8003a0c <chVTDoSetI+0x5c>
      return;
    }

    /* Special case where the timer will be placed as first element in a
       non-empty list, the alarm needs to be recalculated.*/
    delta = now + delay - ch.vtlist.lasttime;
 80039d0:	6ab2      	ldr	r2, [r6, #40]	; 0x28
 80039d2:	1808      	adds	r0, r1, r0
 80039d4:	1a84      	subs	r4, r0, r2
    if (delta < ch.vtlist.next->delta) {
 80039d6:	689a      	ldr	r2, [r3, #8]
 80039d8:	42a2      	cmp	r2, r4
 80039da:	d903      	bls.n	80039e4 <chVTDoSetI+0x34>
 80039dc:	e011      	b.n	8003a02 <chVTDoSetI+0x52>
  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.next;
  while (p->delta < delta) {
    delta -= p->delta;
    p = p->next;
 80039de:	681b      	ldr	r3, [r3, #0]
    delta -= p->delta;
 80039e0:	1aa4      	subs	r4, r4, r2
  while (p->delta < delta) {
 80039e2:	689a      	ldr	r2, [r3, #8]
 80039e4:	42a2      	cmp	r2, r4
 80039e6:	d3fa      	bcc.n	80039de <chVTDoSetI+0x2e>
  }

  /* The timer is inserted in the delta list.*/
  vtp->next = p;
  vtp->prev = vtp->next->prev;
 80039e8:	685a      	ldr	r2, [r3, #4]
  vtp->next = p;
 80039ea:	602b      	str	r3, [r5, #0]
  vtp->prev = vtp->next->prev;
 80039ec:	606a      	str	r2, [r5, #4]
  vtp->prev->next = vtp;
 80039ee:	6015      	str	r5, [r2, #0]
  p->prev = vtp;
 80039f0:	605d      	str	r5, [r3, #4]
  vtp->delta = delta
 80039f2:	60ac      	str	r4, [r5, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->delta -= delta;
 80039f4:	689a      	ldr	r2, [r3, #8]
 80039f6:	1b14      	subs	r4, r2, r4
 80039f8:	609c      	str	r4, [r3, #8]
  ch.vtlist.delta = (systime_t)-1;
 80039fa:	2301      	movs	r3, #1
 80039fc:	425b      	negs	r3, r3
 80039fe:	6273      	str	r3, [r6, #36]	; 0x24
}
 8003a00:	bd70      	pop	{r4, r5, r6, pc}
 8003a02:	f000 fc35 	bl	8004270 <stSetAlarm>
 8003a06:	69f3      	ldr	r3, [r6, #28]
 8003a08:	689a      	ldr	r2, [r3, #8]
  while (p->delta < delta) {
 8003a0a:	e7eb      	b.n	80039e4 <chVTDoSetI+0x34>
      ch.vtlist.lasttime = now;
 8003a0c:	62b0      	str	r0, [r6, #40]	; 0x28
      ch.vtlist.next = vtp;
 8003a0e:	61f5      	str	r5, [r6, #28]
      ch.vtlist.prev = vtp;
 8003a10:	6235      	str	r5, [r6, #32]
      port_timer_start_alarm(ch.vtlist.lasttime + delay);
 8003a12:	1808      	adds	r0, r1, r0
      vtp->next = (virtual_timer_t *)&ch.vtlist;
 8003a14:	602b      	str	r3, [r5, #0]
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
 8003a16:	606b      	str	r3, [r5, #4]
      vtp->delta = delay;
 8003a18:	60a9      	str	r1, [r5, #8]
  stStartAlarm(time);
 8003a1a:	f000 fc19 	bl	8004250 <stStartAlarm>
      return;
 8003a1e:	e7ef      	b.n	8003a00 <chVTDoSetI+0x50>
 8003a20:	20001798 	.word	0x20001798
	...

08003a30 <chVTDoResetI>:
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  systime_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
 8003a30:	4b1c      	ldr	r3, [pc, #112]	; (8003aa4 <chVTDoResetI+0x74>)
void chVTDoResetI(virtual_timer_t *vtp) {
 8003a32:	b510      	push	{r4, lr}
  if (ch.vtlist.next != vtp) {
 8003a34:	69d9      	ldr	r1, [r3, #28]
 8003a36:	6802      	ldr	r2, [r0, #0]
 8003a38:	4281      	cmp	r1, r0
 8003a3a:	d00e      	beq.n	8003a5a <chVTDoResetI+0x2a>
    /* Removing the element from the delta list.*/
    vtp->prev->next = vtp->next;
 8003a3c:	6841      	ldr	r1, [r0, #4]
    vtp->next->prev = vtp->prev;
    vtp->func = NULL;

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 8003a3e:	331c      	adds	r3, #28
    vtp->prev->next = vtp->next;
 8003a40:	600a      	str	r2, [r1, #0]
    vtp->next->prev = vtp->prev;
 8003a42:	6802      	ldr	r2, [r0, #0]
 8003a44:	6051      	str	r1, [r2, #4]
    vtp->func = NULL;
 8003a46:	2100      	movs	r1, #0
 8003a48:	60c1      	str	r1, [r0, #12]
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 8003a4a:	429a      	cmp	r2, r3
 8003a4c:	d004      	beq.n	8003a58 <chVTDoResetI+0x28>
      vtp->next->delta += vtp->delta;
 8003a4e:	6891      	ldr	r1, [r2, #8]
 8003a50:	6883      	ldr	r3, [r0, #8]
 8003a52:	468c      	mov	ip, r1
 8003a54:	4463      	add	r3, ip
 8003a56:	6093      	str	r3, [r2, #8]
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
  }

  port_timer_set_alarm(ch.vtlist.lasttime + nowdelta + delta);
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8003a58:	bd10      	pop	{r4, pc}
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
 8003a5a:	0018      	movs	r0, r3
  vtp->func = NULL;
 8003a5c:	2400      	movs	r4, #0
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
 8003a5e:	301c      	adds	r0, #28
  ch.vtlist.next = vtp->next;
 8003a60:	61da      	str	r2, [r3, #28]
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
 8003a62:	6050      	str	r0, [r2, #4]
  vtp->func = NULL;
 8003a64:	60cc      	str	r4, [r1, #12]
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8003a66:	4282      	cmp	r2, r0
 8003a68:	d018      	beq.n	8003a9c <chVTDoResetI+0x6c>
  ch.vtlist.next->delta += vtp->delta;
 8003a6a:	6888      	ldr	r0, [r1, #8]
 8003a6c:	6891      	ldr	r1, [r2, #8]
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.lasttime;
 8003a6e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  ch.vtlist.next->delta += vtp->delta;
 8003a70:	468c      	mov	ip, r1
 8003a72:	4460      	add	r0, ip
 8003a74:	6090      	str	r0, [r2, #8]
 8003a76:	2280      	movs	r2, #128	; 0x80
 8003a78:	05d2      	lsls	r2, r2, #23
 8003a7a:	6a52      	ldr	r2, [r2, #36]	; 0x24
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.lasttime;
 8003a7c:	1ad1      	subs	r1, r2, r3
  if (nowdelta >= ch.vtlist.next->delta) {
 8003a7e:	4288      	cmp	r0, r1
 8003a80:	d9ea      	bls.n	8003a58 <chVTDoResetI+0x28>
  delta = ch.vtlist.next->delta - nowdelta;
 8003a82:	1a9b      	subs	r3, r3, r2
 8003a84:	1818      	adds	r0, r3, r0
  port_timer_set_alarm(ch.vtlist.lasttime + nowdelta + delta);
 8003a86:	2802      	cmp	r0, #2
 8003a88:	d303      	bcc.n	8003a92 <chVTDoResetI+0x62>
 8003a8a:	1880      	adds	r0, r0, r2
  stSetAlarm(time);
 8003a8c:	f000 fbf0 	bl	8004270 <stSetAlarm>
 8003a90:	e7e2      	b.n	8003a58 <chVTDoResetI+0x28>
 8003a92:	2002      	movs	r0, #2
 8003a94:	1880      	adds	r0, r0, r2
 8003a96:	f000 fbeb 	bl	8004270 <stSetAlarm>
 8003a9a:	e7dd      	b.n	8003a58 <chVTDoResetI+0x28>
  stStopAlarm();
 8003a9c:	f000 fbe0 	bl	8004260 <stStopAlarm>
    return;
 8003aa0:	e7da      	b.n	8003a58 <chVTDoResetI+0x28>
 8003aa2:	46c0      	nop			; (mov r8, r8)
 8003aa4:	20001798 	.word	0x20001798
	...

08003ab0 <wakeup>:
 8003ab0:	b672      	cpsid	i
 */
static void wakeup(void *p) {
  thread_t *tp = (thread_t *)p;

  chSysLockFromISR();
  switch (tp->state) {
 8003ab2:	2320      	movs	r3, #32
 8003ab4:	5cc3      	ldrb	r3, [r0, r3]
 8003ab6:	2b03      	cmp	r3, #3
 8003ab8:	d016      	beq.n	8003ae8 <wakeup+0x38>
 8003aba:	2b04      	cmp	r3, #4
 8003abc:	d018      	beq.n	8003af0 <wakeup+0x40>
 8003abe:	2b00      	cmp	r3, #0
 8003ac0:	d010      	beq.n	8003ae4 <wakeup+0x34>
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
 8003ac2:	2301      	movs	r3, #1
  tp->state = CH_STATE_READY;
 8003ac4:	2200      	movs	r2, #0
  tp->u.rdymsg = MSG_TIMEOUT;
 8003ac6:	425b      	negs	r3, r3
 8003ac8:	6243      	str	r3, [r0, #36]	; 0x24
  tp->state = CH_STATE_READY;
 8003aca:	3321      	adds	r3, #33	; 0x21
 8003acc:	54c2      	strb	r2, [r0, r3]
  } while (cp->prio >= tp->prio);
 8003ace:	6882      	ldr	r2, [r0, #8]
  cp = (thread_t *)&ch.rlist.queue;
 8003ad0:	4b0a      	ldr	r3, [pc, #40]	; (8003afc <wakeup+0x4c>)
    cp = cp->queue.next;
 8003ad2:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 8003ad4:	6899      	ldr	r1, [r3, #8]
 8003ad6:	4291      	cmp	r1, r2
 8003ad8:	d2fb      	bcs.n	8003ad2 <wakeup+0x22>
  tp->queue.prev             = cp->queue.prev;
 8003ada:	685a      	ldr	r2, [r3, #4]
  tp->queue.next             = cp;
 8003adc:	6003      	str	r3, [r0, #0]
  tp->queue.prev             = cp->queue.prev;
 8003ade:	6042      	str	r2, [r0, #4]
  tp->queue.prev->queue.next = tp;
 8003ae0:	6010      	str	r0, [r2, #0]
  cp->queue.prev             = tp;
 8003ae2:	6058      	str	r0, [r3, #4]
  __ASM volatile ("cpsie i" : : : "memory");
 8003ae4:	b662      	cpsie	i
  (void) chSchReadyI(tp);
  chSysUnlockFromISR();
}
 8003ae6:	4770      	bx	lr
    *tp->u.wttrp = NULL;
 8003ae8:	2200      	movs	r2, #0
 8003aea:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8003aec:	601a      	str	r2, [r3, #0]
    break;
 8003aee:	e7e8      	b.n	8003ac2 <wakeup+0x12>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 8003af0:	6842      	ldr	r2, [r0, #4]
 8003af2:	6803      	ldr	r3, [r0, #0]
 8003af4:	6013      	str	r3, [r2, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 8003af6:	605a      	str	r2, [r3, #4]

  return tp;
 8003af8:	e7e3      	b.n	8003ac2 <wakeup+0x12>
 8003afa:	46c0      	nop			; (mov r8, r8)
 8003afc:	20001798 	.word	0x20001798

08003b00 <_scheduler_init>:
  ch.rlist.prio = NOPRIO;
 8003b00:	2200      	movs	r2, #0
  tqp->next = (thread_t *)tqp;
 8003b02:	4b03      	ldr	r3, [pc, #12]	; (8003b10 <_scheduler_init+0x10>)
 8003b04:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8003b06:	605b      	str	r3, [r3, #4]
 8003b08:	609a      	str	r2, [r3, #8]
  ch.rlist.newer = (thread_t *)&ch.rlist;
 8003b0a:	611b      	str	r3, [r3, #16]
  ch.rlist.older = (thread_t *)&ch.rlist;
 8003b0c:	615b      	str	r3, [r3, #20]
}
 8003b0e:	4770      	bx	lr
 8003b10:	20001798 	.word	0x20001798
	...

08003b20 <chSchReadyI>:
  tp->state = CH_STATE_READY;
 8003b20:	2320      	movs	r3, #32
 8003b22:	2200      	movs	r2, #0
 8003b24:	54c2      	strb	r2, [r0, r3]
  } while (cp->prio >= tp->prio);
 8003b26:	6882      	ldr	r2, [r0, #8]
  cp = (thread_t *)&ch.rlist.queue;
 8003b28:	4b05      	ldr	r3, [pc, #20]	; (8003b40 <chSchReadyI+0x20>)
    cp = cp->queue.next;
 8003b2a:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 8003b2c:	6899      	ldr	r1, [r3, #8]
 8003b2e:	4291      	cmp	r1, r2
 8003b30:	d2fb      	bcs.n	8003b2a <chSchReadyI+0xa>
  tp->queue.prev             = cp->queue.prev;
 8003b32:	685a      	ldr	r2, [r3, #4]
  tp->queue.next             = cp;
 8003b34:	6003      	str	r3, [r0, #0]
  tp->queue.prev             = cp->queue.prev;
 8003b36:	6042      	str	r2, [r0, #4]
  tp->queue.prev->queue.next = tp;
 8003b38:	6010      	str	r0, [r2, #0]
  cp->queue.prev             = tp;
 8003b3a:	6058      	str	r0, [r3, #4]
}
 8003b3c:	4770      	bx	lr
 8003b3e:	46c0      	nop			; (mov r8, r8)
 8003b40:	20001798 	.word	0x20001798
	...

08003b50 <chSchGoSleepS>:
  otp->state = newstate;
 8003b50:	2320      	movs	r3, #32
void chSchGoSleepS(tstate_t newstate) {
 8003b52:	b570      	push	{r4, r5, r6, lr}
  thread_t *otp = currp;
 8003b54:	4c0c      	ldr	r4, [pc, #48]	; (8003b88 <chSchGoSleepS+0x38>)
 8003b56:	69a5      	ldr	r5, [r4, #24]
  otp->state = newstate;
 8003b58:	54e8      	strb	r0, [r5, r3]
  thread_t *tp = tqp->next;
 8003b5a:	6820      	ldr	r0, [r4, #0]
  tqp->next             = tp->queue.next;
 8003b5c:	6802      	ldr	r2, [r0, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8003b5e:	6054      	str	r4, [r2, #4]
  tqp->next             = tp->queue.next;
 8003b60:	6022      	str	r2, [r4, #0]
  currp->state = CH_STATE_CURRENT;
 8003b62:	2201      	movs	r2, #1
  currp = queue_fifo_remove(&ch.rlist.queue);
 8003b64:	61a0      	str	r0, [r4, #24]
  currp->state = CH_STATE_CURRENT;
 8003b66:	54c2      	strb	r2, [r0, r3]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8003b68:	f3ef 8309 	mrs	r3, PSP
  chSysSwitch(currp, otp);
 8003b6c:	69ea      	ldr	r2, [r5, #28]
 8003b6e:	3b24      	subs	r3, #36	; 0x24
 8003b70:	429a      	cmp	r2, r3
 8003b72:	d803      	bhi.n	8003b7c <chSchGoSleepS+0x2c>
 8003b74:	0029      	movs	r1, r5
 8003b76:	f7fc fb0b 	bl	8000190 <_port_switch>
}
 8003b7a:	bd70      	pop	{r4, r5, r6, pc}
  chSysSwitch(currp, otp);
 8003b7c:	4803      	ldr	r0, [pc, #12]	; (8003b8c <chSchGoSleepS+0x3c>)
 8003b7e:	f7ff febf 	bl	8003900 <chSysHalt>
 8003b82:	69a0      	ldr	r0, [r4, #24]
 8003b84:	e7f6      	b.n	8003b74 <chSchGoSleepS+0x24>
 8003b86:	46c0      	nop			; (mov r8, r8)
 8003b88:	20001798 	.word	0x20001798
 8003b8c:	080135cc 	.word	0x080135cc

08003b90 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 8003b90:	b530      	push	{r4, r5, lr}
 8003b92:	0005      	movs	r5, r0
 8003b94:	b087      	sub	sp, #28

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 8003b96:	1c4b      	adds	r3, r1, #1
 8003b98:	d012      	beq.n	8003bc0 <chSchGoSleepTimeoutS+0x30>
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
 8003b9a:	4c0b      	ldr	r4, [pc, #44]	; (8003bc8 <chSchGoSleepTimeoutS+0x38>)
 8003b9c:	4a0b      	ldr	r2, [pc, #44]	; (8003bcc <chSchGoSleepTimeoutS+0x3c>)
 8003b9e:	69a3      	ldr	r3, [r4, #24]
 8003ba0:	a801      	add	r0, sp, #4
 8003ba2:	f7ff ff05 	bl	80039b0 <chVTDoSetI>
    chSchGoSleepS(newstate);
 8003ba6:	0028      	movs	r0, r5
 8003ba8:	f7ff ffd2 	bl	8003b50 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 8003bac:	9b04      	ldr	r3, [sp, #16]
 8003bae:	2b00      	cmp	r3, #0
 8003bb0:	d002      	beq.n	8003bb8 <chSchGoSleepTimeoutS+0x28>
      chVTDoResetI(&vt);
 8003bb2:	a801      	add	r0, sp, #4
 8003bb4:	f7ff ff3c 	bl	8003a30 <chVTDoResetI>
  }
  else {
    chSchGoSleepS(newstate);
  }

  return currp->u.rdymsg;
 8003bb8:	69a3      	ldr	r3, [r4, #24]
 8003bba:	6a58      	ldr	r0, [r3, #36]	; 0x24
}
 8003bbc:	b007      	add	sp, #28
 8003bbe:	bd30      	pop	{r4, r5, pc}
    chSchGoSleepS(newstate);
 8003bc0:	f7ff ffc6 	bl	8003b50 <chSchGoSleepS>
 8003bc4:	4c00      	ldr	r4, [pc, #0]	; (8003bc8 <chSchGoSleepTimeoutS+0x38>)
 8003bc6:	e7f7      	b.n	8003bb8 <chSchGoSleepTimeoutS+0x28>
 8003bc8:	20001798 	.word	0x20001798
 8003bcc:	08003ab1 	.word	0x08003ab1

08003bd0 <chSchWakeupS>:
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
  thread_t *otp = currp;
 8003bd0:	4b1c      	ldr	r3, [pc, #112]	; (8003c44 <chSchWakeupS+0x74>)
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8003bd2:	b570      	push	{r4, r5, r6, lr}
  thread_t *otp = currp;
 8003bd4:	699d      	ldr	r5, [r3, #24]
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->u.rdymsg = msg;
 8003bd6:	6241      	str	r1, [r0, #36]	; 0x24

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->prio <= otp->prio) {
 8003bd8:	6882      	ldr	r2, [r0, #8]
 8003bda:	68a9      	ldr	r1, [r5, #8]
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8003bdc:	0004      	movs	r4, r0
  if (ntp->prio <= otp->prio) {
 8003bde:	428a      	cmp	r2, r1
 8003be0:	d80c      	bhi.n	8003bfc <chSchWakeupS+0x2c>
  tp->state = CH_STATE_READY;
 8003be2:	2120      	movs	r1, #32
 8003be4:	2000      	movs	r0, #0
 8003be6:	5460      	strb	r0, [r4, r1]
    cp = cp->queue.next;
 8003be8:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 8003bea:	6899      	ldr	r1, [r3, #8]
 8003bec:	428a      	cmp	r2, r1
 8003bee:	d9fb      	bls.n	8003be8 <chSchWakeupS+0x18>
  tp->queue.prev             = cp->queue.prev;
 8003bf0:	685a      	ldr	r2, [r3, #4]
  tp->queue.next             = cp;
 8003bf2:	6023      	str	r3, [r4, #0]
  tp->queue.prev             = cp->queue.prev;
 8003bf4:	6062      	str	r2, [r4, #4]
  tp->queue.prev->queue.next = tp;
 8003bf6:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
 8003bf8:	605c      	str	r4, [r3, #4]
    ntp->state = CH_STATE_CURRENT;

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
  }
}
 8003bfa:	bd70      	pop	{r4, r5, r6, pc}
  tp->state = CH_STATE_READY;
 8003bfc:	2220      	movs	r2, #32
 8003bfe:	2000      	movs	r0, #0
 8003c00:	54a8      	strb	r0, [r5, r2]
  cp = (thread_t *)&ch.rlist.queue;
 8003c02:	001a      	movs	r2, r3
    cp = cp->queue.next;
 8003c04:	6812      	ldr	r2, [r2, #0]
  } while (cp->prio >= tp->prio);
 8003c06:	6890      	ldr	r0, [r2, #8]
 8003c08:	4281      	cmp	r1, r0
 8003c0a:	d9fb      	bls.n	8003c04 <chSchWakeupS+0x34>
  tp->queue.prev             = cp->queue.prev;
 8003c0c:	6851      	ldr	r1, [r2, #4]
  tp->queue.next             = cp;
 8003c0e:	602a      	str	r2, [r5, #0]
  tp->queue.prev             = cp->queue.prev;
 8003c10:	6069      	str	r1, [r5, #4]
  tp->queue.prev->queue.next = tp;
 8003c12:	600d      	str	r5, [r1, #0]
  cp->queue.prev             = tp;
 8003c14:	6055      	str	r5, [r2, #4]
    currp = ntp;
 8003c16:	619c      	str	r4, [r3, #24]
    ntp->state = CH_STATE_CURRENT;
 8003c18:	2201      	movs	r2, #1
 8003c1a:	2320      	movs	r3, #32
 8003c1c:	54e2      	strb	r2, [r4, r3]
 8003c1e:	f3ef 8309 	mrs	r3, PSP
    chSysSwitch(ntp, otp);
 8003c22:	69ea      	ldr	r2, [r5, #28]
 8003c24:	3b24      	subs	r3, #36	; 0x24
 8003c26:	429a      	cmp	r2, r3
 8003c28:	d804      	bhi.n	8003c34 <chSchWakeupS+0x64>
 8003c2a:	0029      	movs	r1, r5
 8003c2c:	0020      	movs	r0, r4
 8003c2e:	f7fc faaf 	bl	8000190 <_port_switch>
}
 8003c32:	e7e2      	b.n	8003bfa <chSchWakeupS+0x2a>
    chSysSwitch(ntp, otp);
 8003c34:	4804      	ldr	r0, [pc, #16]	; (8003c48 <chSchWakeupS+0x78>)
 8003c36:	f7ff fe63 	bl	8003900 <chSysHalt>
 8003c3a:	0029      	movs	r1, r5
 8003c3c:	0020      	movs	r0, r4
 8003c3e:	f7fc faa7 	bl	8000190 <_port_switch>
 8003c42:	e7da      	b.n	8003bfa <chSchWakeupS+0x2a>
 8003c44:	20001798 	.word	0x20001798
 8003c48:	080135cc 	.word	0x080135cc
 8003c4c:	00000000 	.word	0x00000000

08003c50 <chSchIsPreemptionRequired>:
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.queue);
 8003c50:	4b04      	ldr	r3, [pc, #16]	; (8003c64 <chSchIsPreemptionRequired+0x14>)
  tprio_t p2 = currp->prio;
 8003c52:	699a      	ldr	r2, [r3, #24]
  tprio_t p1 = firstprio(&ch.rlist.queue);
 8003c54:	6819      	ldr	r1, [r3, #0]
     if the first thread on the ready queue has equal or higher priority.*/
  return (currp->preempt > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
 8003c56:	6890      	ldr	r0, [r2, #8]
 8003c58:	688b      	ldr	r3, [r1, #8]
 8003c5a:	4298      	cmp	r0, r3
 8003c5c:	4180      	sbcs	r0, r0
 8003c5e:	4240      	negs	r0, r0
#endif
}
 8003c60:	4770      	bx	lr
 8003c62:	46c0      	nop			; (mov r8, r8)
 8003c64:	20001798 	.word	0x20001798
	...

08003c70 <chSchDoRescheduleAhead>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
 8003c70:	b570      	push	{r4, r5, r6, lr}
  thread_t *otp = currp;
 8003c72:	4d13      	ldr	r5, [pc, #76]	; (8003cc0 <chSchDoRescheduleAhead+0x50>)

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 8003c74:	2120      	movs	r1, #32
  thread_t *tp = tqp->next;
 8003c76:	682b      	ldr	r3, [r5, #0]
  thread_t *otp = currp;
 8003c78:	69ac      	ldr	r4, [r5, #24]
  tqp->next             = tp->queue.next;
 8003c7a:	681a      	ldr	r2, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8003c7c:	6055      	str	r5, [r2, #4]
  tqp->next             = tp->queue.next;
 8003c7e:	602a      	str	r2, [r5, #0]
  currp->state = CH_STATE_CURRENT;
 8003c80:	2201      	movs	r2, #1
  currp = queue_fifo_remove(&ch.rlist.queue);
 8003c82:	61ab      	str	r3, [r5, #24]
  currp->state = CH_STATE_CURRENT;
 8003c84:	545a      	strb	r2, [r3, r1]
  tp->state = CH_STATE_READY;
 8003c86:	2300      	movs	r3, #0

  /* Handling idle-leave hook.*/
  if (otp->prio == IDLEPRIO) {
 8003c88:	68a2      	ldr	r2, [r4, #8]
  tp->state = CH_STATE_READY;
 8003c8a:	5463      	strb	r3, [r4, r1]
  cp = (thread_t *)&ch.rlist.queue;
 8003c8c:	002b      	movs	r3, r5
    cp = cp->queue.next;
 8003c8e:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio > tp->prio);
 8003c90:	6899      	ldr	r1, [r3, #8]
 8003c92:	428a      	cmp	r2, r1
 8003c94:	d3fb      	bcc.n	8003c8e <chSchDoRescheduleAhead+0x1e>
  tp->queue.prev             = cp->queue.prev;
 8003c96:	685a      	ldr	r2, [r3, #4]
  tp->queue.next             = cp;
 8003c98:	6023      	str	r3, [r4, #0]
  tp->queue.prev             = cp->queue.prev;
 8003c9a:	6062      	str	r2, [r4, #4]
  tp->queue.prev->queue.next = tp;
 8003c9c:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
 8003c9e:	605c      	str	r4, [r3, #4]
 8003ca0:	f3ef 8309 	mrs	r3, PSP

  /* Placing in ready list ahead of peers.*/
  otp = chSchReadyAheadI(otp);

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8003ca4:	69e2      	ldr	r2, [r4, #28]
 8003ca6:	3b24      	subs	r3, #36	; 0x24
 8003ca8:	429a      	cmp	r2, r3
 8003caa:	d804      	bhi.n	8003cb6 <chSchDoRescheduleAhead+0x46>
 8003cac:	69a8      	ldr	r0, [r5, #24]
 8003cae:	0021      	movs	r1, r4
 8003cb0:	f7fc fa6e 	bl	8000190 <_port_switch>
}
 8003cb4:	bd70      	pop	{r4, r5, r6, pc}
  chSysSwitch(currp, otp);
 8003cb6:	4803      	ldr	r0, [pc, #12]	; (8003cc4 <chSchDoRescheduleAhead+0x54>)
 8003cb8:	f7ff fe22 	bl	8003900 <chSysHalt>
 8003cbc:	e7f6      	b.n	8003cac <chSchDoRescheduleAhead+0x3c>
 8003cbe:	46c0      	nop			; (mov r8, r8)
 8003cc0:	20001798 	.word	0x20001798
 8003cc4:	080135cc 	.word	0x080135cc
	...

08003cd0 <chSchRescheduleS>:
 */
static inline bool chSchIsRescRequiredI(void) {

  chDbgCheckClassI();

  return firstprio(&ch.rlist.queue) > currp->prio;
 8003cd0:	4b05      	ldr	r3, [pc, #20]	; (8003ce8 <chSchRescheduleS+0x18>)
void chSchRescheduleS(void) {
 8003cd2:	b510      	push	{r4, lr}
 8003cd4:	681a      	ldr	r2, [r3, #0]
 8003cd6:	699b      	ldr	r3, [r3, #24]
  if (chSchIsRescRequiredI()) {
 8003cd8:	6892      	ldr	r2, [r2, #8]
 8003cda:	689b      	ldr	r3, [r3, #8]
 8003cdc:	429a      	cmp	r2, r3
 8003cde:	d800      	bhi.n	8003ce2 <chSchRescheduleS+0x12>
}
 8003ce0:	bd10      	pop	{r4, pc}
    chSchDoRescheduleAhead();
 8003ce2:	f7ff ffc5 	bl	8003c70 <chSchDoRescheduleAhead>
}
 8003ce6:	e7fb      	b.n	8003ce0 <chSchRescheduleS+0x10>
 8003ce8:	20001798 	.word	0x20001798
 8003cec:	00000000 	.word	0x00000000

08003cf0 <chSchDoReschedule>:
 8003cf0:	b510      	push	{r4, lr}
 8003cf2:	f7ff ffbd 	bl	8003c70 <chSchDoRescheduleAhead>
 8003cf6:	bd10      	pop	{r4, pc}
	...

08003d00 <_thread_init>:
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
  tp->mtxlist   = NULL;
 8003d00:	2300      	movs	r3, #0
  tp->prio      = prio;
 8003d02:	6082      	str	r2, [r0, #8]
  tp->realprio  = prio;
 8003d04:	6342      	str	r2, [r0, #52]	; 0x34
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 8003d06:	2201      	movs	r2, #1
  tp->mtxlist   = NULL;
 8003d08:	6303      	str	r3, [r0, #48]	; 0x30
  tp->epending  = (eventmask_t)0;
 8003d0a:	62c3      	str	r3, [r0, #44]	; 0x2c
  tp->state     = CH_STATE_WTSTART;
 8003d0c:	3302      	adds	r3, #2
 8003d0e:	8403      	strh	r3, [r0, #32]
  tp->refs      = (trefs_t)1;
 8003d10:	3320      	adds	r3, #32
 8003d12:	54c2      	strb	r2, [r0, r3]
  tp->name      = name;
  REG_INSERT(tp);
 8003d14:	4b05      	ldr	r3, [pc, #20]	; (8003d2c <_thread_init+0x2c>)
  tp->name      = name;
 8003d16:	6181      	str	r1, [r0, #24]
  REG_INSERT(tp);
 8003d18:	695a      	ldr	r2, [r3, #20]
 8003d1a:	6103      	str	r3, [r0, #16]
 8003d1c:	6142      	str	r2, [r0, #20]
 8003d1e:	6110      	str	r0, [r2, #16]
 8003d20:	6158      	str	r0, [r3, #20]
#else
  (void)name;
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->waiting);
 8003d22:	0003      	movs	r3, r0
 8003d24:	3328      	adds	r3, #40	; 0x28
  tlp->next = (thread_t *)tlp;
 8003d26:	6283      	str	r3, [r0, #40]	; 0x28
#if CH_DBG_STATISTICS == TRUE
  chTMObjectInit(&tp->stats);
#endif
  CH_CFG_THREAD_INIT_HOOK(tp);
  return tp;
}
 8003d28:	4770      	bx	lr
 8003d2a:	46c0      	nop			; (mov r8, r8)
 8003d2c:	20001798 	.word	0x20001798

08003d30 <chThdCreateSuspendedI>:
  chDbgCheck((tdp->prio <= HIGHPRIO) && (tdp->funcp != NULL));

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = (thread_t *)((uint8_t *)tdp->wend -
 8003d30:	6882      	ldr	r2, [r0, #8]
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
 8003d32:	6841      	ldr	r1, [r0, #4]
  tp = (thread_t *)((uint8_t *)tdp->wend -
 8003d34:	0013      	movs	r3, r2
 8003d36:	3b38      	subs	r3, #56	; 0x38
thread_t *chThdCreateSuspendedI(const thread_descriptor_t *tdp) {
 8003d38:	b510      	push	{r4, lr}
  tp->wabase = tdp->wbase;
 8003d3a:	61d9      	str	r1, [r3, #28]
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8003d3c:	0011      	movs	r1, r2
 8003d3e:	6904      	ldr	r4, [r0, #16]
 8003d40:	395c      	subs	r1, #92	; 0x5c
 8003d42:	60d9      	str	r1, [r3, #12]
 8003d44:	610c      	str	r4, [r1, #16]
 8003d46:	6944      	ldr	r4, [r0, #20]
 8003d48:	3a10      	subs	r2, #16
 8003d4a:	614c      	str	r4, [r1, #20]
 8003d4c:	4c0d      	ldr	r4, [pc, #52]	; (8003d84 <chThdCreateSuspendedI+0x54>)
 8003d4e:	620c      	str	r4, [r1, #32]

  /* The driver object is initialized but not started.*/
  return _thread_init(tp, tdp->name, tdp->prio);
 8003d50:	6801      	ldr	r1, [r0, #0]
  tp->state     = CH_STATE_WTSTART;
 8003d52:	2402      	movs	r4, #2
  return _thread_init(tp, tdp->name, tdp->prio);
 8003d54:	6199      	str	r1, [r3, #24]
  tp->state     = CH_STATE_WTSTART;
 8003d56:	2120      	movs	r1, #32
  return _thread_init(tp, tdp->name, tdp->prio);
 8003d58:	68c0      	ldr	r0, [r0, #12]
  tp->prio      = prio;
 8003d5a:	6098      	str	r0, [r3, #8]
  tp->state     = CH_STATE_WTSTART;
 8003d5c:	545c      	strb	r4, [r3, r1]
  tp->flags     = CH_FLAG_MODE_STATIC;
 8003d5e:	2100      	movs	r1, #0
 8003d60:	341f      	adds	r4, #31
 8003d62:	5519      	strb	r1, [r3, r4]
  tp->realprio  = prio;
 8003d64:	6358      	str	r0, [r3, #52]	; 0x34
  tp->refs      = (trefs_t)1;
 8003d66:	2001      	movs	r0, #1
  tp->mtxlist   = NULL;
 8003d68:	6319      	str	r1, [r3, #48]	; 0x30
  tp->epending  = (eventmask_t)0;
 8003d6a:	62d9      	str	r1, [r3, #44]	; 0x2c
  tp->refs      = (trefs_t)1;
 8003d6c:	3122      	adds	r1, #34	; 0x22
 8003d6e:	5458      	strb	r0, [r3, r1]
  REG_INSERT(tp);
 8003d70:	4905      	ldr	r1, [pc, #20]	; (8003d88 <chThdCreateSuspendedI+0x58>)
 8003d72:	6948      	ldr	r0, [r1, #20]
 8003d74:	6119      	str	r1, [r3, #16]
 8003d76:	6158      	str	r0, [r3, #20]
 8003d78:	6103      	str	r3, [r0, #16]
 8003d7a:	614b      	str	r3, [r1, #20]
}
 8003d7c:	0018      	movs	r0, r3
 8003d7e:	6012      	str	r2, [r2, #0]
 8003d80:	bd10      	pop	{r4, pc}
 8003d82:	46c0      	nop			; (mov r8, r8)
 8003d84:	080001b1 	.word	0x080001b1
 8003d88:	20001798 	.word	0x20001798
 8003d8c:	00000000 	.word	0x00000000

08003d90 <chThdCreate>:
  chDbgAssert(chRegFindThreadByWorkingArea(tdp->wbase) == NULL,
              "working area in use");
#endif

#if CH_DBG_FILL_THREADS == TRUE
  _thread_memfill((uint8_t *)tdp->wbase,
 8003d90:	6843      	ldr	r3, [r0, #4]
                  (uint8_t *)tdp->wend,
 8003d92:	6882      	ldr	r2, [r0, #8]
thread_t *chThdCreate(const thread_descriptor_t *tdp) {
 8003d94:	b510      	push	{r4, lr}
  while (startp < endp) {
 8003d96:	4293      	cmp	r3, r2
 8003d98:	d204      	bcs.n	8003da4 <chThdCreate+0x14>
    *startp++ = v;
 8003d9a:	2155      	movs	r1, #85	; 0x55
 8003d9c:	7019      	strb	r1, [r3, #0]
 8003d9e:	3301      	adds	r3, #1
  while (startp < endp) {
 8003da0:	429a      	cmp	r2, r3
 8003da2:	d1fb      	bne.n	8003d9c <chThdCreate+0xc>
  __ASM volatile ("cpsid i" : : : "memory");
 8003da4:	b672      	cpsid	i
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateSuspendedI(tdp);
 8003da6:	f7ff ffc3 	bl	8003d30 <chThdCreateSuspendedI>
  chSchWakeupS(tp, MSG_OK);
 8003daa:	2100      	movs	r1, #0
  tp = chThdCreateSuspendedI(tdp);
 8003dac:	0004      	movs	r4, r0
  chSchWakeupS(tp, MSG_OK);
 8003dae:	f7ff ff0f 	bl	8003bd0 <chSchWakeupS>
  __ASM volatile ("cpsie i" : : : "memory");
 8003db2:	b662      	cpsie	i
  chSysUnlock();

  return tp;
}
 8003db4:	0020      	movs	r0, r4
 8003db6:	bd10      	pop	{r4, pc}
	...

08003dc0 <chThdCreateStatic>:
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
                            tprio_t prio, tfunc_t pf, void *arg) {
 8003dc0:	b570      	push	{r4, r5, r6, lr}
  chDbgAssert(chRegFindThreadByWorkingArea(wsp) == NULL,
              "working area in use");
#endif

#if CH_DBG_FILL_THREADS == TRUE
  _thread_memfill((uint8_t *)wsp,
 8003dc2:	1845      	adds	r5, r0, r1
  while (startp < endp) {
 8003dc4:	42a8      	cmp	r0, r5
 8003dc6:	d205      	bcs.n	8003dd4 <chThdCreateStatic+0x14>
 8003dc8:	0004      	movs	r4, r0
    *startp++ = v;
 8003dca:	2655      	movs	r6, #85	; 0x55
 8003dcc:	7026      	strb	r6, [r4, #0]
 8003dce:	3401      	adds	r4, #1
  while (startp < endp) {
 8003dd0:	42a5      	cmp	r5, r4
 8003dd2:	d1fb      	bne.n	8003dcc <chThdCreateStatic+0xc>
  __ASM volatile ("cpsid i" : : : "memory");
 8003dd4:	b672      	cpsid	i
  chSysLock();

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = (thread_t *)((uint8_t *)wsp + size -
 8003dd6:	3938      	subs	r1, #56	; 0x38
 8003dd8:	1844      	adds	r4, r0, r1
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8003dda:	0021      	movs	r1, r4
 8003ddc:	3924      	subs	r1, #36	; 0x24
 8003dde:	60e1      	str	r1, [r4, #12]
  tp->wabase = (stkalign_t *)wsp;
 8003de0:	61e0      	str	r0, [r4, #28]
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8003de2:	610b      	str	r3, [r1, #16]
 8003de4:	9b04      	ldr	r3, [sp, #16]

  tp = _thread_init(tp, "noname", prio);

  /* Starting the thread immediately.*/
  chSchWakeupS(tp, MSG_OK);
 8003de6:	0020      	movs	r0, r4
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8003de8:	614b      	str	r3, [r1, #20]
 8003dea:	4b0e      	ldr	r3, [pc, #56]	; (8003e24 <chThdCreateStatic+0x64>)
 8003dec:	620b      	str	r3, [r1, #32]
  tp->mtxlist   = NULL;
 8003dee:	2300      	movs	r3, #0
  tp->prio      = prio;
 8003df0:	60a2      	str	r2, [r4, #8]
  tp->realprio  = prio;
 8003df2:	6362      	str	r2, [r4, #52]	; 0x34
  tp->refs      = (trefs_t)1;
 8003df4:	2201      	movs	r2, #1
  tp->mtxlist   = NULL;
 8003df6:	6323      	str	r3, [r4, #48]	; 0x30
  tp->epending  = (eventmask_t)0;
 8003df8:	62e3      	str	r3, [r4, #44]	; 0x2c
  tp->state     = CH_STATE_WTSTART;
 8003dfa:	3302      	adds	r3, #2
 8003dfc:	8423      	strh	r3, [r4, #32]
  tp->refs      = (trefs_t)1;
 8003dfe:	3320      	adds	r3, #32
 8003e00:	54e2      	strb	r2, [r4, r3]
  tp->name      = name;
 8003e02:	4b09      	ldr	r3, [pc, #36]	; (8003e28 <chThdCreateStatic+0x68>)
  chSchWakeupS(tp, MSG_OK);
 8003e04:	2100      	movs	r1, #0
  tp->name      = name;
 8003e06:	61a3      	str	r3, [r4, #24]
  REG_INSERT(tp);
 8003e08:	4b08      	ldr	r3, [pc, #32]	; (8003e2c <chThdCreateStatic+0x6c>)
 8003e0a:	695a      	ldr	r2, [r3, #20]
 8003e0c:	6123      	str	r3, [r4, #16]
 8003e0e:	6162      	str	r2, [r4, #20]
 8003e10:	6114      	str	r4, [r2, #16]
 8003e12:	615c      	str	r4, [r3, #20]
  list_init(&tp->waiting);
 8003e14:	0023      	movs	r3, r4
 8003e16:	3328      	adds	r3, #40	; 0x28
 8003e18:	62a3      	str	r3, [r4, #40]	; 0x28
  chSchWakeupS(tp, MSG_OK);
 8003e1a:	f7ff fed9 	bl	8003bd0 <chSchWakeupS>
  __ASM volatile ("cpsie i" : : : "memory");
 8003e1e:	b662      	cpsie	i
  chSysUnlock();

  return tp;
}
 8003e20:	0020      	movs	r0, r4
 8003e22:	bd70      	pop	{r4, r5, r6, pc}
 8003e24:	080001b1 	.word	0x080001b1
 8003e28:	080135dc 	.word	0x080135dc
 8003e2c:	20001798 	.word	0x20001798

08003e30 <chThdRelease>:
  __ASM volatile ("cpsid i" : : : "memory");
 8003e30:	b672      	cpsid	i
 */
void chThdRelease(thread_t *tp) {

  chSysLock();
  chDbgAssert(tp->refs > (trefs_t)0, "not referenced");
  tp->refs--;
 8003e32:	2222      	movs	r2, #34	; 0x22
 8003e34:	5c83      	ldrb	r3, [r0, r2]
 8003e36:	3b01      	subs	r3, #1
 8003e38:	5483      	strb	r3, [r0, r2]

  /* If the references counter reaches zero and the thread is in its
     terminated state then the memory can be returned to the proper
     allocator.*/
  if ((tp->refs == (trefs_t)0) && (tp->state == CH_STATE_FINAL)) {
 8003e3a:	6a02      	ldr	r2, [r0, #32]
 8003e3c:	4b06      	ldr	r3, [pc, #24]	; (8003e58 <chThdRelease+0x28>)
 8003e3e:	4013      	ands	r3, r2
 8003e40:	2b0f      	cmp	r3, #15
 8003e42:	d001      	beq.n	8003e48 <chThdRelease+0x18>
  __ASM volatile ("cpsie i" : : : "memory");
 8003e44:	b662      	cpsie	i
    }
#endif /* CH_CFG_USE_DYNAMIC == TRUE */
    return;
  }
  chSysUnlock();
}
 8003e46:	4770      	bx	lr
    REG_REMOVE(tp);
 8003e48:	6902      	ldr	r2, [r0, #16]
 8003e4a:	6943      	ldr	r3, [r0, #20]
 8003e4c:	611a      	str	r2, [r3, #16]
 8003e4e:	6902      	ldr	r2, [r0, #16]
 8003e50:	6153      	str	r3, [r2, #20]
 8003e52:	b662      	cpsie	i
    return;
 8003e54:	e7f7      	b.n	8003e46 <chThdRelease+0x16>
 8003e56:	46c0      	nop			; (mov r8, r8)
 8003e58:	00ff00ff 	.word	0x00ff00ff
 8003e5c:	00000000 	.word	0x00000000

08003e60 <chThdExitS>:
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
  thread_t *tp = currp;
 8003e60:	4b0d      	ldr	r3, [pc, #52]	; (8003e98 <chThdExitS+0x38>)
void chThdExitS(msg_t msg) {
 8003e62:	b570      	push	{r4, r5, r6, lr}
  thread_t *tp = currp;
 8003e64:	699c      	ldr	r4, [r3, #24]
  /* Exit handler hook.*/
  CH_CFG_THREAD_EXIT_HOOK(tp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (list_notempty(&tp->waiting)) {
 8003e66:	0025      	movs	r5, r4
  tp->u.exitcode = msg;
 8003e68:	6260      	str	r0, [r4, #36]	; 0x24
  return (bool)(tlp->next != (thread_t *)tlp);
 8003e6a:	6aa0      	ldr	r0, [r4, #40]	; 0x28
  while (list_notempty(&tp->waiting)) {
 8003e6c:	3528      	adds	r5, #40	; 0x28
 8003e6e:	42a8      	cmp	r0, r5
 8003e70:	d006      	beq.n	8003e80 <chThdExitS+0x20>
  tlp->next = tp->queue.next;
 8003e72:	6803      	ldr	r3, [r0, #0]
 8003e74:	62a3      	str	r3, [r4, #40]	; 0x28
    (void) chSchReadyI(list_remove(&tp->waiting));
 8003e76:	f7ff fe53 	bl	8003b20 <chSchReadyI>
  return (bool)(tlp->next != (thread_t *)tlp);
 8003e7a:	6aa0      	ldr	r0, [r4, #40]	; 0x28
  while (list_notempty(&tp->waiting)) {
 8003e7c:	42a8      	cmp	r0, r5
 8003e7e:	d1f8      	bne.n	8003e72 <chThdExitS+0x12>
  if ((tp->refs == (trefs_t)0) &&
      ((tp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC)) {
    REG_REMOVE(tp);
  }
#else
  if (tp->refs == (trefs_t)0) {
 8003e80:	2322      	movs	r3, #34	; 0x22
 8003e82:	5ce3      	ldrb	r3, [r4, r3]
 8003e84:	2b00      	cmp	r3, #0
 8003e86:	d103      	bne.n	8003e90 <chThdExitS+0x30>
    REG_REMOVE(tp);
 8003e88:	6962      	ldr	r2, [r4, #20]
 8003e8a:	6923      	ldr	r3, [r4, #16]
 8003e8c:	6113      	str	r3, [r2, #16]
 8003e8e:	615a      	str	r2, [r3, #20]
  }
#endif
#endif

  /* Going into final state.*/
  chSchGoSleepS(CH_STATE_FINAL);
 8003e90:	200f      	movs	r0, #15
 8003e92:	f7ff fe5d 	bl	8003b50 <chSchGoSleepS>

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
}
 8003e96:	bd70      	pop	{r4, r5, r6, pc}
 8003e98:	20001798 	.word	0x20001798
 8003e9c:	00000000 	.word	0x00000000

08003ea0 <chThdExit>:
void chThdExit(msg_t msg) {
 8003ea0:	b510      	push	{r4, lr}
  __ASM volatile ("cpsid i" : : : "memory");
 8003ea2:	b672      	cpsid	i
  chThdExitS(msg);
 8003ea4:	f7ff ffdc 	bl	8003e60 <chThdExitS>
}
 8003ea8:	bd10      	pop	{r4, pc}
 8003eaa:	46c0      	nop			; (mov r8, r8)
 8003eac:	0000      	movs	r0, r0
	...

08003eb0 <chThdWait>:
 * @param[in] tp        pointer to the thread
 * @return              The exit code from the terminated thread.
 *
 * @api
 */
msg_t chThdWait(thread_t *tp) {
 8003eb0:	b570      	push	{r4, r5, r6, lr}
 8003eb2:	0004      	movs	r4, r0
 8003eb4:	b672      	cpsid	i
  chDbgAssert(tp != currp, "waiting self");
#if CH_CFG_USE_REGISTRY == TRUE
  chDbgAssert(tp->refs > (trefs_t)0, "no references");
#endif

  if (tp->state != CH_STATE_FINAL) {
 8003eb6:	2320      	movs	r3, #32
 8003eb8:	5cc3      	ldrb	r3, [r0, r3]
 8003eba:	2b0f      	cmp	r3, #15
 8003ebc:	d007      	beq.n	8003ece <chThdWait+0x1e>
    list_insert(currp, &tp->waiting);
 8003ebe:	4b07      	ldr	r3, [pc, #28]	; (8003edc <chThdWait+0x2c>)
  tp->queue.next = tlp->next;
 8003ec0:	6a82      	ldr	r2, [r0, #40]	; 0x28
 8003ec2:	699b      	ldr	r3, [r3, #24]
 8003ec4:	601a      	str	r2, [r3, #0]
  tlp->next = tp;
 8003ec6:	6283      	str	r3, [r0, #40]	; 0x28
    chSchGoSleepS(CH_STATE_WTEXIT);
 8003ec8:	2009      	movs	r0, #9
 8003eca:	f7ff fe41 	bl	8003b50 <chSchGoSleepS>
  }
  msg = tp->u.exitcode;
 8003ece:	6a65      	ldr	r5, [r4, #36]	; 0x24
  __ASM volatile ("cpsie i" : : : "memory");
 8003ed0:	b662      	cpsie	i
  chSysUnlock();

#if CH_CFG_USE_REGISTRY == TRUE
  /* Releasing a reference to the thread.*/
  chThdRelease(tp);
 8003ed2:	0020      	movs	r0, r4
 8003ed4:	f7ff ffac 	bl	8003e30 <chThdRelease>
#endif

  return msg;
}
 8003ed8:	0028      	movs	r0, r5
 8003eda:	bd70      	pop	{r4, r5, r6, pc}
 8003edc:	20001798 	.word	0x20001798

08003ee0 <chThdSetPriority>:
 * @param[in] newprio   the new priority level of the running thread
 * @return              The old priority level.
 *
 * @api
 */
tprio_t chThdSetPriority(tprio_t newprio) {
 8003ee0:	b510      	push	{r4, lr}
  __ASM volatile ("cpsid i" : : : "memory");
 8003ee2:	b672      	cpsid	i

  chDbgCheck(newprio <= HIGHPRIO);

  chSysLock();
#if CH_CFG_USE_MUTEXES == TRUE
  oldprio = currp->realprio;
 8003ee4:	4b07      	ldr	r3, [pc, #28]	; (8003f04 <chThdSetPriority+0x24>)
 8003ee6:	699b      	ldr	r3, [r3, #24]
 8003ee8:	6b5c      	ldr	r4, [r3, #52]	; 0x34
  if ((currp->prio == currp->realprio) || (newprio > currp->prio)) {
 8003eea:	689a      	ldr	r2, [r3, #8]
 8003eec:	42a2      	cmp	r2, r4
 8003eee:	d001      	beq.n	8003ef4 <chThdSetPriority+0x14>
 8003ef0:	4282      	cmp	r2, r0
 8003ef2:	d200      	bcs.n	8003ef6 <chThdSetPriority+0x16>
    currp->prio = newprio;
 8003ef4:	6098      	str	r0, [r3, #8]
  }
  currp->realprio = newprio;
 8003ef6:	6358      	str	r0, [r3, #52]	; 0x34
#else
  oldprio = currp->prio;
  currp->prio = newprio;
#endif
  chSchRescheduleS();
 8003ef8:	f7ff feea 	bl	8003cd0 <chSchRescheduleS>
  __ASM volatile ("cpsie i" : : : "memory");
 8003efc:	b662      	cpsie	i
  chSysUnlock();

  return oldprio;
}
 8003efe:	0020      	movs	r0, r4
 8003f00:	bd10      	pop	{r4, pc}
 8003f02:	46c0      	nop			; (mov r8, r8)
 8003f04:	20001798 	.word	0x20001798
	...

08003f10 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
 8003f10:	b510      	push	{r4, lr}
 8003f12:	0001      	movs	r1, r0
  __ASM volatile ("cpsid i" : : : "memory");
 8003f14:	b672      	cpsid	i
 */
static inline void chThdSleepS(systime_t time) {

  chDbgCheck(time != TIME_IMMEDIATE);

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
 8003f16:	2008      	movs	r0, #8
 8003f18:	f7ff fe3a 	bl	8003b90 <chSchGoSleepTimeoutS>
  __ASM volatile ("cpsie i" : : : "memory");
 8003f1c:	b662      	cpsie	i

  chSysLock();
  chThdSleepS(time);
  chSysUnlock();
}
 8003f1e:	bd10      	pop	{r4, pc}

08003f20 <chThdSuspendTimeoutS>:
  return ch.rlist.current;
 8003f20:	4b06      	ldr	r3, [pc, #24]	; (8003f3c <chThdSuspendTimeoutS+0x1c>)
 * @return              The wake up message.
 * @retval MSG_TIMEOUT  if the operation timed out.
 *
 * @sclass
 */
msg_t chThdSuspendTimeoutS(thread_reference_t *trp, systime_t timeout) {
 8003f22:	b510      	push	{r4, lr}
 8003f24:	699b      	ldr	r3, [r3, #24]
  thread_t *tp = chThdGetSelfX();

  chDbgAssert(*trp == NULL, "not NULL");

  if (TIME_IMMEDIATE == timeout) {
 8003f26:	2900      	cmp	r1, #0
 8003f28:	d005      	beq.n	8003f36 <chThdSuspendTimeoutS+0x16>
    return MSG_TIMEOUT;
  }

  *trp = tp;
 8003f2a:	6003      	str	r3, [r0, #0]
  tp->u.wttrp = trp;
 8003f2c:	6258      	str	r0, [r3, #36]	; 0x24

  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
 8003f2e:	2003      	movs	r0, #3
 8003f30:	f7ff fe2e 	bl	8003b90 <chSchGoSleepTimeoutS>
}
 8003f34:	bd10      	pop	{r4, pc}
    return MSG_TIMEOUT;
 8003f36:	2001      	movs	r0, #1
 8003f38:	4240      	negs	r0, r0
 8003f3a:	e7fb      	b.n	8003f34 <chThdSuspendTimeoutS+0x14>
 8003f3c:	20001798 	.word	0x20001798

08003f40 <chThdResumeI>:
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {

  if (*trp != NULL) {
 8003f40:	6803      	ldr	r3, [r0, #0]
void chThdResumeI(thread_reference_t *trp, msg_t msg) {
 8003f42:	b510      	push	{r4, lr}
  if (*trp != NULL) {
 8003f44:	2b00      	cmp	r3, #0
 8003f46:	d005      	beq.n	8003f54 <chThdResumeI+0x14>
    thread_t *tp = *trp;

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");

    *trp = NULL;
 8003f48:	2200      	movs	r2, #0
 8003f4a:	6002      	str	r2, [r0, #0]
    tp->u.rdymsg = msg;
 8003f4c:	6259      	str	r1, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
 8003f4e:	0018      	movs	r0, r3
 8003f50:	f7ff fde6 	bl	8003b20 <chSchReadyI>
  }
}
 8003f54:	bd10      	pop	{r4, pc}
 8003f56:	46c0      	nop			; (mov r8, r8)
	...

08003f60 <chThdEnqueueTimeoutS>:
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {
 8003f60:	b510      	push	{r4, lr}

  if (TIME_IMMEDIATE == timeout) {
 8003f62:	2900      	cmp	r1, #0
 8003f64:	d00a      	beq.n	8003f7c <chThdEnqueueTimeoutS+0x1c>
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);
 8003f66:	4b07      	ldr	r3, [pc, #28]	; (8003f84 <chThdEnqueueTimeoutS+0x24>)
  tp->queue.prev             = tqp->prev;
 8003f68:	6842      	ldr	r2, [r0, #4]
 8003f6a:	699b      	ldr	r3, [r3, #24]
  tp->queue.next             = (thread_t *)tqp;
 8003f6c:	6018      	str	r0, [r3, #0]
  tp->queue.prev             = tqp->prev;
 8003f6e:	605a      	str	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
 8003f70:	6013      	str	r3, [r2, #0]
  tqp->prev                  = tp;
 8003f72:	6043      	str	r3, [r0, #4]

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8003f74:	2004      	movs	r0, #4
 8003f76:	f7ff fe0b 	bl	8003b90 <chSchGoSleepTimeoutS>
}
 8003f7a:	bd10      	pop	{r4, pc}
    return MSG_TIMEOUT;
 8003f7c:	2001      	movs	r0, #1
 8003f7e:	4240      	negs	r0, r0
 8003f80:	e7fb      	b.n	8003f7a <chThdEnqueueTimeoutS+0x1a>
 8003f82:	46c0      	nop			; (mov r8, r8)
 8003f84:	20001798 	.word	0x20001798
	...

08003f90 <chThdDequeueNextI>:
  return (bool)(tqp->next != (const thread_t *)tqp);
 8003f90:	6803      	ldr	r3, [r0, #0]
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 8003f92:	b510      	push	{r4, lr}

  if (queue_notempty(tqp)) {
 8003f94:	4298      	cmp	r0, r3
 8003f96:	d006      	beq.n	8003fa6 <chThdDequeueNextI+0x16>
  tqp->next             = tp->queue.next;
 8003f98:	681a      	ldr	r2, [r3, #0]
 8003f9a:	6002      	str	r2, [r0, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8003f9c:	6050      	str	r0, [r2, #4]

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");

  tp->u.rdymsg = msg;
 8003f9e:	6259      	str	r1, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
 8003fa0:	0018      	movs	r0, r3
 8003fa2:	f7ff fdbd 	bl	8003b20 <chSchReadyI>
    chThdDoDequeueNextI(tqp, msg);
  }
}
 8003fa6:	bd10      	pop	{r4, pc}
	...

08003fb0 <chThdDequeueAllI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueAllI(threads_queue_t *tqp, msg_t msg) {
 8003fb0:	b570      	push	{r4, r5, r6, lr}
 8003fb2:	0004      	movs	r4, r0
  return (bool)(tqp->next != (const thread_t *)tqp);
 8003fb4:	6800      	ldr	r0, [r0, #0]
 8003fb6:	000d      	movs	r5, r1

  while (queue_notempty(tqp)) {
 8003fb8:	4284      	cmp	r4, r0
 8003fba:	d008      	beq.n	8003fce <chThdDequeueAllI+0x1e>
  tqp->next             = tp->queue.next;
 8003fbc:	6803      	ldr	r3, [r0, #0]
 8003fbe:	6023      	str	r3, [r4, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8003fc0:	605c      	str	r4, [r3, #4]
  tp->u.rdymsg = msg;
 8003fc2:	6245      	str	r5, [r0, #36]	; 0x24
  (void) chSchReadyI(tp);
 8003fc4:	f7ff fdac 	bl	8003b20 <chSchReadyI>
  return (bool)(tqp->next != (const thread_t *)tqp);
 8003fc8:	6820      	ldr	r0, [r4, #0]
 8003fca:	4284      	cmp	r4, r0
 8003fcc:	d1f6      	bne.n	8003fbc <chThdDequeueAllI+0xc>
    chThdDoDequeueNextI(tqp, msg);
  }
}
 8003fce:	bd70      	pop	{r4, r5, r6, pc}

08003fd0 <chRegFirstThread>:
  __ASM volatile ("cpsid i" : : : "memory");
 8003fd0:	b672      	cpsid	i
 */
thread_t *chRegFirstThread(void) {
  thread_t *tp;

  chSysLock();
  tp = ch.rlist.newer;
 8003fd2:	4b02      	ldr	r3, [pc, #8]	; (8003fdc <chRegFirstThread+0xc>)
 8003fd4:	6918      	ldr	r0, [r3, #16]
  __ASM volatile ("cpsie i" : : : "memory");
 8003fd6:	b662      	cpsie	i
  tp->refs++;
#endif
  chSysUnlock();

  return tp;
}
 8003fd8:	4770      	bx	lr
 8003fda:	46c0      	nop			; (mov r8, r8)
 8003fdc:	20001798 	.word	0x20001798

08003fe0 <chRegNextThread>:
  __ASM volatile ("cpsid i" : : : "memory");
 8003fe0:	b672      	cpsid	i
  thread_t *ntp;

  chSysLock();
  ntp = tp->newer;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  if (ntp == (thread_t *)&ch.rlist) {
 8003fe2:	4b04      	ldr	r3, [pc, #16]	; (8003ff4 <chRegNextThread+0x14>)
  ntp = tp->newer;
 8003fe4:	6900      	ldr	r0, [r0, #16]
  /*lint -restore*/
    ntp = NULL;
 8003fe6:	1ac3      	subs	r3, r0, r3
 8003fe8:	1e5a      	subs	r2, r3, #1
 8003fea:	4193      	sbcs	r3, r2
 8003fec:	425b      	negs	r3, r3
 8003fee:	4018      	ands	r0, r3
  __ASM volatile ("cpsie i" : : : "memory");
 8003ff0:	b662      	cpsie	i
#if CH_CFG_USE_DYNAMIC == TRUE
  chThdRelease(tp);
#endif

  return ntp;
}
 8003ff2:	4770      	bx	lr
 8003ff4:	20001798 	.word	0x20001798
	...

08004000 <chMtxObjectInit>:
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);

  queue_init(&mp->queue);
  mp->owner = NULL;
 8004000:	2300      	movs	r3, #0
  tqp->next = (thread_t *)tqp;
 8004002:	6000      	str	r0, [r0, #0]
  tqp->prev = (thread_t *)tqp;
 8004004:	6040      	str	r0, [r0, #4]
 8004006:	6083      	str	r3, [r0, #8]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  mp->cnt = (cnt_t)0;
 8004008:	6103      	str	r3, [r0, #16]
#endif
}
 800400a:	4770      	bx	lr
 800400c:	0000      	movs	r0, r0
	...

08004010 <chMtxLockS>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
 8004010:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8004012:	0005      	movs	r5, r0
  thread_t *ctp = currp;
 8004014:	4b27      	ldr	r3, [pc, #156]	; (80040b4 <chMtxLockS+0xa4>)

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  /* Is the mutex already locked? */
  if (mp->owner != NULL) {
 8004016:	6880      	ldr	r0, [r0, #8]
  thread_t *ctp = currp;
 8004018:	699c      	ldr	r4, [r3, #24]
  if (mp->owner != NULL) {
 800401a:	2800      	cmp	r0, #0
 800401c:	d03a      	beq.n	8004094 <chMtxLockS+0x84>

    chDbgAssert(mp->cnt >= (cnt_t)1, "counter is not positive");

    /* If the mutex is already owned by this thread, the counter is increased
       and there is no need of more actions.*/
    if (mp->owner == ctp) {
 800401e:	42a0      	cmp	r0, r4
 8004020:	d034      	beq.n	800408c <chMtxLockS+0x7c>
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->prio < ctp->prio) {
 8004022:	68a2      	ldr	r2, [r4, #8]
 8004024:	6883      	ldr	r3, [r0, #8]
        /* Make priority of thread tp match the running thread's priority.*/
        tp->prio = ctp->prio;

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
 8004026:	2620      	movs	r6, #32
      while (tp->prio < ctp->prio) {
 8004028:	4293      	cmp	r3, r2
 800402a:	d21c      	bcs.n	8004066 <chMtxLockS+0x56>
        tp->prio = ctp->prio;
 800402c:	6082      	str	r2, [r0, #8]
        switch (tp->state) {
 800402e:	5d83      	ldrb	r3, [r0, r6]
 8004030:	2b00      	cmp	r3, #0
 8004032:	d037      	beq.n	80040a4 <chMtxLockS+0x94>
 8004034:	2b06      	cmp	r3, #6
 8004036:	d116      	bne.n	8004066 <chMtxLockS+0x56>
  tp->queue.prev->queue.next = tp->queue.next;
 8004038:	6841      	ldr	r1, [r0, #4]
 800403a:	6803      	ldr	r3, [r0, #0]
 800403c:	600b      	str	r3, [r1, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 800403e:	6059      	str	r1, [r3, #4]
        case CH_STATE_WTMTX:
          /* Re-enqueues the mutex owner with its new priority.*/
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
 8004040:	6a41      	ldr	r1, [r0, #36]	; 0x24
  thread_t *cp = (thread_t *)tqp;
 8004042:	000b      	movs	r3, r1
 8004044:	e002      	b.n	800404c <chMtxLockS+0x3c>
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8004046:	689f      	ldr	r7, [r3, #8]
 8004048:	4297      	cmp	r7, r2
 800404a:	d302      	bcc.n	8004052 <chMtxLockS+0x42>
    cp = cp->queue.next;
 800404c:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 800404e:	4299      	cmp	r1, r3
 8004050:	d1f9      	bne.n	8004046 <chMtxLockS+0x36>
  tp->queue.prev             = cp->queue.prev;
 8004052:	685a      	ldr	r2, [r3, #4]
  tp->queue.next             = cp;
 8004054:	6003      	str	r3, [r0, #0]
  tp->queue.prev             = cp->queue.prev;
 8004056:	6042      	str	r2, [r0, #4]
  tp->queue.prev->queue.next = tp;
 8004058:	6010      	str	r0, [r2, #0]
  cp->queue.prev             = tp;
 800405a:	6058      	str	r0, [r3, #4]
          tp = tp->u.wtmtxp->owner;
 800405c:	6888      	ldr	r0, [r1, #8]
      while (tp->prio < ctp->prio) {
 800405e:	68a2      	ldr	r2, [r4, #8]
 8004060:	6883      	ldr	r3, [r0, #8]
 8004062:	4293      	cmp	r3, r2
 8004064:	d3e2      	bcc.n	800402c <chMtxLockS+0x1c>
  thread_t *cp = (thread_t *)tqp;
 8004066:	002b      	movs	r3, r5
 8004068:	e003      	b.n	8004072 <chMtxLockS+0x62>
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 800406a:	689a      	ldr	r2, [r3, #8]
 800406c:	68a1      	ldr	r1, [r4, #8]
 800406e:	428a      	cmp	r2, r1
 8004070:	d302      	bcc.n	8004078 <chMtxLockS+0x68>
    cp = cp->queue.next;
 8004072:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8004074:	429d      	cmp	r5, r3
 8004076:	d1f8      	bne.n	800406a <chMtxLockS+0x5a>
  tp->queue.prev             = cp->queue.prev;
 8004078:	685a      	ldr	r2, [r3, #4]
  tp->queue.next             = cp;
 800407a:	6023      	str	r3, [r4, #0]
  tp->queue.prev             = cp->queue.prev;
 800407c:	6062      	str	r2, [r4, #4]
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->queue);
      ctp->u.wtmtxp = mp;
      chSchGoSleepS(CH_STATE_WTMTX);
 800407e:	2006      	movs	r0, #6
  tp->queue.prev->queue.next = tp;
 8004080:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
 8004082:	605c      	str	r4, [r3, #4]
      ctp->u.wtmtxp = mp;
 8004084:	6265      	str	r5, [r4, #36]	; 0x24
      chSchGoSleepS(CH_STATE_WTMTX);
 8004086:	f7ff fd63 	bl	8003b50 <chSchGoSleepS>

      /* It is assumed that the thread performing the unlock operation assigns
         the mutex to this thread.*/
      chDbgAssert(mp->owner == ctp, "not owner");
      chDbgAssert(ctp->mtxlist == mp, "not owned");
 800408a:	e002      	b.n	8004092 <chMtxLockS+0x82>
      mp->cnt++;
 800408c:	692b      	ldr	r3, [r5, #16]
 800408e:	3301      	adds	r3, #1
 8004090:	612b      	str	r3, [r5, #16]
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->owner = ctp;
    mp->next = ctp->mtxlist;
    ctp->mtxlist = mp;
  }
}
 8004092:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    mp->cnt++;
 8004094:	692b      	ldr	r3, [r5, #16]
    mp->owner = ctp;
 8004096:	60ac      	str	r4, [r5, #8]
    mp->cnt++;
 8004098:	3301      	adds	r3, #1
 800409a:	612b      	str	r3, [r5, #16]
    mp->next = ctp->mtxlist;
 800409c:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800409e:	60eb      	str	r3, [r5, #12]
    ctp->mtxlist = mp;
 80040a0:	6325      	str	r5, [r4, #48]	; 0x30
}
 80040a2:	e7f6      	b.n	8004092 <chMtxLockS+0x82>
  tp->queue.prev->queue.next = tp->queue.next;
 80040a4:	6842      	ldr	r2, [r0, #4]
 80040a6:	6803      	ldr	r3, [r0, #0]
 80040a8:	6013      	str	r3, [r2, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 80040aa:	605a      	str	r2, [r3, #4]
          (void) chSchReadyI(queue_dequeue(tp));
 80040ac:	f7ff fd38 	bl	8003b20 <chSchReadyI>
          break;
 80040b0:	e7d9      	b.n	8004066 <chMtxLockS+0x56>
 80040b2:	46c0      	nop			; (mov r8, r8)
 80040b4:	20001798 	.word	0x20001798
	...

080040c0 <chMtxLock>:
void chMtxLock(mutex_t *mp) {
 80040c0:	b510      	push	{r4, lr}
  __ASM volatile ("cpsid i" : : : "memory");
 80040c2:	b672      	cpsid	i
  chMtxLockS(mp);
 80040c4:	f7ff ffa4 	bl	8004010 <chMtxLockS>
  __ASM volatile ("cpsie i" : : : "memory");
 80040c8:	b662      	cpsie	i
}
 80040ca:	bd10      	pop	{r4, pc}
 80040cc:	0000      	movs	r0, r0
	...

080040d0 <chMtxUnlock>:
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
  thread_t *ctp = currp;
 80040d0:	4b16      	ldr	r3, [pc, #88]	; (800412c <chMtxUnlock+0x5c>)
void chMtxUnlock(mutex_t *mp) {
 80040d2:	b570      	push	{r4, r5, r6, lr}
  thread_t *ctp = currp;
 80040d4:	699d      	ldr	r5, [r3, #24]
  __ASM volatile ("cpsid i" : : : "memory");
 80040d6:	b672      	cpsid	i
  chDbgAssert(ctp->mtxlist != NULL, "owned mutexes list empty");
  chDbgAssert(ctp->mtxlist->owner == ctp, "ownership failure");
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  chDbgAssert(mp->cnt >= (cnt_t)1, "counter is not positive");

  if (--mp->cnt == (cnt_t)0) {
 80040d8:	6903      	ldr	r3, [r0, #16]
 80040da:	1e5a      	subs	r2, r3, #1
 80040dc:	6102      	str	r2, [r0, #16]
 80040de:	2a00      	cmp	r2, #0
 80040e0:	d120      	bne.n	8004124 <chMtxUnlock+0x54>
    chDbgAssert(ctp->mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->mtxlist = mp->next;
 80040e2:	68c3      	ldr	r3, [r0, #12]
  return (bool)(tqp->next != (const thread_t *)tqp);
 80040e4:	6804      	ldr	r4, [r0, #0]
 80040e6:	632b      	str	r3, [r5, #48]	; 0x30

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 80040e8:	4284      	cmp	r4, r0
 80040ea:	d01d      	beq.n	8004128 <chMtxUnlock+0x58>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
 80040ec:	6b69      	ldr	r1, [r5, #52]	; 0x34
      lmp = ctp->mtxlist;
      while (lmp != NULL) {
 80040ee:	2b00      	cmp	r3, #0
 80040f0:	d009      	beq.n	8004106 <chMtxUnlock+0x36>
 80040f2:	681a      	ldr	r2, [r3, #0]
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 80040f4:	4293      	cmp	r3, r2
 80040f6:	d003      	beq.n	8004100 <chMtxUnlock+0x30>
 80040f8:	6892      	ldr	r2, [r2, #8]
 80040fa:	4291      	cmp	r1, r2
 80040fc:	d200      	bcs.n	8004100 <chMtxUnlock+0x30>
 80040fe:	0011      	movs	r1, r2
            (lmp->queue.next->prio > newprio)) {
          newprio = lmp->queue.next->prio;
        }
        lmp = lmp->next;
 8004100:	68db      	ldr	r3, [r3, #12]
      while (lmp != NULL) {
 8004102:	2b00      	cmp	r3, #0
 8004104:	d1f5      	bne.n	80040f2 <chMtxUnlock+0x22>
      ctp->prio = newprio;

      /* Awakens the highest priority thread waiting for the unlocked mutex and
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
 8004106:	2301      	movs	r3, #1
      ctp->prio = newprio;
 8004108:	60a9      	str	r1, [r5, #8]
      mp->cnt = (cnt_t)1;
 800410a:	6103      	str	r3, [r0, #16]
  tqp->next             = tp->queue.next;
 800410c:	6823      	ldr	r3, [r4, #0]
 800410e:	6003      	str	r3, [r0, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8004110:	6058      	str	r0, [r3, #4]
#endif
      tp = queue_fifo_remove(&mp->queue);
      mp->owner = tp;
      mp->next = tp->mtxlist;
 8004112:	6b23      	ldr	r3, [r4, #48]	; 0x30
      mp->owner = tp;
 8004114:	6084      	str	r4, [r0, #8]
      mp->next = tp->mtxlist;
 8004116:	60c3      	str	r3, [r0, #12]
      tp->mtxlist = mp;
 8004118:	6320      	str	r0, [r4, #48]	; 0x30

      /* Note, not using chSchWakeupS() becuase that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 800411a:	0020      	movs	r0, r4
 800411c:	f7ff fd00 	bl	8003b20 <chSchReadyI>
      chSchRescheduleS();
 8004120:	f7ff fdd6 	bl	8003cd0 <chSchRescheduleS>
  __ASM volatile ("cpsie i" : : : "memory");
 8004124:	b662      	cpsie	i
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif

  chSysUnlock();
}
 8004126:	bd70      	pop	{r4, r5, r6, pc}
      mp->owner = NULL;
 8004128:	60a2      	str	r2, [r4, #8]
 800412a:	e7fb      	b.n	8004124 <chMtxUnlock+0x54>
 800412c:	20001798 	.word	0x20001798

08004130 <chEvtSignalI>:
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->epending |= events;
 8004130:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
void chEvtSignalI(thread_t *tp, eventmask_t events) {
 8004132:	b510      	push	{r4, lr}
  tp->epending |= events;
 8004134:	4319      	orrs	r1, r3
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
 8004136:	2320      	movs	r3, #32
  tp->epending |= events;
 8004138:	62c1      	str	r1, [r0, #44]	; 0x2c
  if (((tp->state == CH_STATE_WTOREVT) &&
 800413a:	5cc3      	ldrb	r3, [r0, r3]
 800413c:	2b0a      	cmp	r3, #10
 800413e:	d00b      	beq.n	8004158 <chEvtSignalI+0x28>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 8004140:	2b0b      	cmp	r3, #11
 8004142:	d000      	beq.n	8004146 <chEvtSignalI+0x16>
      ((tp->state == CH_STATE_WTANDEVT) &&
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
    tp->u.rdymsg = MSG_OK;
    (void) chSchReadyI(tp);
  }
}
 8004144:	bd10      	pop	{r4, pc}
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
 8004146:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8004148:	4019      	ands	r1, r3
      ((tp->state == CH_STATE_WTANDEVT) &&
 800414a:	428b      	cmp	r3, r1
 800414c:	d1fa      	bne.n	8004144 <chEvtSignalI+0x14>
    tp->u.rdymsg = MSG_OK;
 800414e:	2300      	movs	r3, #0
 8004150:	6243      	str	r3, [r0, #36]	; 0x24
    (void) chSchReadyI(tp);
 8004152:	f7ff fce5 	bl	8003b20 <chSchReadyI>
}
 8004156:	e7f5      	b.n	8004144 <chEvtSignalI+0x14>
  if (((tp->state == CH_STATE_WTOREVT) &&
 8004158:	6a43      	ldr	r3, [r0, #36]	; 0x24
 800415a:	420b      	tst	r3, r1
 800415c:	d0f2      	beq.n	8004144 <chEvtSignalI+0x14>
    tp->u.rdymsg = MSG_OK;
 800415e:	2300      	movs	r3, #0
 8004160:	6243      	str	r3, [r0, #36]	; 0x24
    (void) chSchReadyI(tp);
 8004162:	f7ff fcdd 	bl	8003b20 <chSchReadyI>
 8004166:	e7ed      	b.n	8004144 <chEvtSignalI+0x14>
	...

08004170 <chEvtBroadcastFlagsI>:
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 8004170:	b570      	push	{r4, r5, r6, lr}
  elp = esp->next;
 8004172:	6804      	ldr	r4, [r0, #0]
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 8004174:	0006      	movs	r6, r0
 8004176:	000d      	movs	r5, r1
  while (elp != (event_listener_t *)esp) {
 8004178:	42a0      	cmp	r0, r4
 800417a:	d00e      	beq.n	800419a <chEvtBroadcastFlagsI+0x2a>
    elp->flags |= flags;
 800417c:	68e3      	ldr	r3, [r4, #12]
 800417e:	432b      	orrs	r3, r5
 8004180:	60e3      	str	r3, [r4, #12]
    if ((flags == (eventflags_t)0) ||
 8004182:	2d00      	cmp	r5, #0
 8004184:	d002      	beq.n	800418c <chEvtBroadcastFlagsI+0x1c>
 8004186:	6922      	ldr	r2, [r4, #16]
 8004188:	421a      	tst	r2, r3
 800418a:	d003      	beq.n	8004194 <chEvtBroadcastFlagsI+0x24>
      chEvtSignalI(elp->listener, elp->events);
 800418c:	68a1      	ldr	r1, [r4, #8]
 800418e:	6860      	ldr	r0, [r4, #4]
 8004190:	f7ff ffce 	bl	8004130 <chEvtSignalI>
    elp = elp->next;
 8004194:	6824      	ldr	r4, [r4, #0]
  while (elp != (event_listener_t *)esp) {
 8004196:	42a6      	cmp	r6, r4
 8004198:	d1f0      	bne.n	800417c <chEvtBroadcastFlagsI+0xc>
}
 800419a:	bd70      	pop	{r4, r5, r6, pc}
 800419c:	0000      	movs	r0, r0
	...

080041a0 <NMI_Handler>:
 * @brief   NMI vector.
 * @details The NMI vector is used for exception mode re-entering after a
 *          context switch.
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void NMI_Handler(void) {
 80041a0:	b580      	push	{r7, lr}
 80041a2:	af00      	add	r7, sp, #0
  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 80041a4:	f3ef 8309 	mrs	r3, PSP
  /* The port_extctx structure is pointed by the PSP register.*/
  struct port_extctx *ctxp = (struct port_extctx *)__get_PSP();

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
 80041a8:	3320      	adds	r3, #32

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 80041aa:	f383 8809 	msr	PSP, r3
  __ASM volatile ("cpsie i" : : : "memory");
 80041ae:	b662      	cpsie	i
  /* Writing back the modified PSP value.*/
  __set_PSP((uint32_t)ctxp);

  /* Restoring the normal interrupts status.*/
  port_unlock_from_isr();
}
 80041b0:	46bd      	mov	sp, r7
 80041b2:	bd80      	pop	{r7, pc}
	...

080041c0 <_port_irq_epilogue>:
/**
 * @brief   IRQ epilogue code.
 *
 * @param[in] lr        value of the @p LR register on ISR entry
 */
void _port_irq_epilogue(regarm_t lr) {
 80041c0:	b5b0      	push	{r4, r5, r7, lr}
 80041c2:	af00      	add	r7, sp, #0

  if (lr != (regarm_t)0xFFFFFFF1U) {
 80041c4:	300f      	adds	r0, #15
 80041c6:	d00e      	beq.n	80041e6 <_port_irq_epilogue+0x26>
  __ASM volatile ("cpsid i" : : : "memory");
 80041c8:	b672      	cpsid	i
  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 80041ca:	f3ef 8409 	mrs	r4, PSP
    /* The extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 80041ce:	3c20      	subs	r4, #32
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 80041d0:	f384 8809 	msr	PSP, r4

    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 80041d4:	2380      	movs	r3, #128	; 0x80
 80041d6:	045b      	lsls	r3, r3, #17
 80041d8:	61e3      	str	r3, [r4, #28]

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 80041da:	f7ff fd39 	bl	8003c50 <chSchIsPreemptionRequired>
 80041de:	2800      	cmp	r0, #0
 80041e0:	d003      	beq.n	80041ea <_port_irq_epilogue+0x2a>
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 80041e2:	4b03      	ldr	r3, [pc, #12]	; (80041f0 <_port_irq_epilogue+0x30>)
 80041e4:	61a3      	str	r3, [r4, #24]
    }

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
  }
}
 80041e6:	46bd      	mov	sp, r7
 80041e8:	bdb0      	pop	{r4, r5, r7, pc}
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 80041ea:	4b02      	ldr	r3, [pc, #8]	; (80041f4 <_port_irq_epilogue+0x34>)
 80041ec:	61a3      	str	r3, [r4, #24]
}
 80041ee:	e7fa      	b.n	80041e6 <_port_irq_epilogue+0x26>
 80041f0:	080001bd 	.word	0x080001bd
 80041f4:	080001c0 	.word	0x080001c0
	...

08004200 <halInit>:
 *          board-specific initialization is performed by invoking
 *          @p boardInit() (usually defined in @p board.c).
 *
 * @init
 */
void halInit(void) {
 8004200:	b510      	push	{r4, lr}

  /* Initializes the OS Abstraction Layer.*/
  osalInit();

  /* Platform low level initializations.*/
  hal_lld_init();
 8004202:	f001 fb6d 	bl	80058e0 <hal_lld_init>

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
  palInit(&pal_default_config);
 8004206:	480d      	ldr	r0, [pc, #52]	; (800423c <halInit+0x3c>)
 8004208:	f001 fe82 	bl	8005f10 <_pal_lld_init>
#endif
#if (HAL_USE_DAC == TRUE) || defined(__DOXYGEN__)
  dacInit();
#endif
#if (HAL_USE_EXT == TRUE) || defined(__DOXYGEN__)
  extInit();
 800420c:	f000 fbe8 	bl	80049e0 <extInit>
#endif
#if (HAL_USE_GPT == TRUE) || defined(__DOXYGEN__)
  gptInit();
 8004210:	f000 fc06 	bl	8004a20 <gptInit>
#endif
#if (HAL_USE_I2C == TRUE) || defined(__DOXYGEN__)
  i2cInit();
 8004214:	f000 fc3c 	bl	8004a90 <i2cInit>
#endif
#if (HAL_USE_I2S == TRUE) || defined(__DOXYGEN__)
  i2sInit();
 8004218:	f000 fc92 	bl	8004b40 <i2sInit>
#endif
#if (HAL_USE_PWM == TRUE) || defined(__DOXYGEN__)
  pwmInit();
#endif
#if (HAL_USE_SERIAL == TRUE) || defined(__DOXYGEN__)
  sdInit();
 800421c:	f000 fd10 	bl	8004c40 <sdInit>
#endif
#if (HAL_USE_SDC == TRUE) || defined(__DOXYGEN__)
  sdcInit();
#endif
#if (HAL_USE_SPI == TRUE) || defined(__DOXYGEN__)
  spiInit();
 8004220:	f000 ff7e 	bl	8005120 <spiInit>
#endif
#if (HAL_USE_UART == TRUE) || defined(__DOXYGEN__)
  uartInit();
#endif
#if (HAL_USE_USB == TRUE) || defined(__DOXYGEN__)
  usbInit();
 8004224:	f000 ffac 	bl	8005180 <usbInit>
#endif
#if (HAL_USE_MMC_SPI == TRUE) || defined(__DOXYGEN__)
  mmcInit();
#endif
#if (HAL_USE_SERIAL_USB == TRUE) || defined(__DOXYGEN__)
  sduInit();
 8004228:	f000 fe3a 	bl	8004ea0 <sduInit>
#endif
#if (HAL_USE_RTC == TRUE) || defined(__DOXYGEN__)
  rtcInit();
 800422c:	f000 fcb8 	bl	8004ba0 <rtcInit>
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
 8004230:	f002 fea6 	bl	8006f80 <boardInit>
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
 8004234:	f000 f804 	bl	8004240 <stInit>
#endif
}
 8004238:	bd10      	pop	{r4, pc}
 800423a:	46c0      	nop			; (mov r8, r8)
 800423c:	08013720 	.word	0x08013720

08004240 <stInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void stInit(void) {
 8004240:	b510      	push	{r4, lr}

  st_lld_init();
 8004242:	f001 fc8d 	bl	8005b60 <st_lld_init>
}
 8004246:	bd10      	pop	{r4, pc}
	...

08004250 <stStartAlarm>:
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8004250:	2380      	movs	r3, #128	; 0x80
  STM32_ST_TIM->SR     = 0;
 8004252:	2200      	movs	r2, #0
  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8004254:	05db      	lsls	r3, r3, #23
 8004256:	6358      	str	r0, [r3, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 8004258:	611a      	str	r2, [r3, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 800425a:	3202      	adds	r2, #2
 800425c:	60da      	str	r2, [r3, #12]
void stStartAlarm(systime_t abstime) {

  osalDbgAssert(stIsAlarmActive() == false, "already active");

  st_lld_start_alarm(abstime);
}
 800425e:	4770      	bx	lr

08004260 <stStopAlarm>:
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 8004260:	2380      	movs	r3, #128	; 0x80
 8004262:	2200      	movs	r2, #0
 8004264:	05db      	lsls	r3, r3, #23
 8004266:	60da      	str	r2, [r3, #12]
 * @api
 */
void stStopAlarm(void) {

  st_lld_stop_alarm();
}
 8004268:	4770      	bx	lr
 800426a:	46c0      	nop			; (mov r8, r8)
 800426c:	0000      	movs	r0, r0
	...

08004270 <stSetAlarm>:
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8004270:	2380      	movs	r3, #128	; 0x80
 8004272:	05db      	lsls	r3, r3, #23
 8004274:	6358      	str	r0, [r3, #52]	; 0x34
void stSetAlarm(systime_t abstime) {

  osalDbgAssert(stIsAlarmActive() != false, "not active");

  st_lld_set_alarm(abstime);
}
 8004276:	4770      	bx	lr
	...

08004280 <ibqObjectInit>:
 *
 * @init
 */
void ibqObjectInit(input_buffers_queue_t *ibqp, uint8_t *bp,
                   size_t size, size_t n,
                   bqnotify_t infy, void *link) {
 8004280:	b530      	push	{r4, r5, lr}

  osalThreadQueueObjectInit(&ibqp->waiting);
  ibqp->bcounter = 0;
  ibqp->brdptr   = bp;
  ibqp->bwrptr   = bp;
  ibqp->btop     = bp + ((size + sizeof (size_t)) * n);
 8004282:	001d      	movs	r5, r3
  ibqp->bcounter = 0;
 8004284:	2400      	movs	r4, #0
  ibqp->btop     = bp + ((size + sizeof (size_t)) * n);
 8004286:	3204      	adds	r2, #4
 8004288:	4355      	muls	r5, r2
  ibqp->bsize    = size + sizeof (size_t);
  ibqp->bn       = n;
 800428a:	61c3      	str	r3, [r0, #28]
  ibqp->buffers  = bp;
  ibqp->ptr      = NULL;
  ibqp->top      = NULL;
  ibqp->notify   = infy;
 800428c:	9b03      	ldr	r3, [sp, #12]
  ibqp->btop     = bp + ((size + sizeof (size_t)) * n);
 800428e:	194d      	adds	r5, r1, r5
  ibqp->notify   = infy;
 8004290:	62c3      	str	r3, [r0, #44]	; 0x2c
  ibqp->link     = link;
 8004292:	9b04      	ldr	r3, [sp, #16]
  ibqp->btop     = bp + ((size + sizeof (size_t)) * n);
 8004294:	6145      	str	r5, [r0, #20]
  tqp->next = (thread_t *)tqp;
 8004296:	6000      	str	r0, [r0, #0]
  tqp->prev = (thread_t *)tqp;
 8004298:	6040      	str	r0, [r0, #4]
  ibqp->bcounter = 0;
 800429a:	6084      	str	r4, [r0, #8]
  ibqp->brdptr   = bp;
 800429c:	6101      	str	r1, [r0, #16]
  ibqp->bwrptr   = bp;
 800429e:	60c1      	str	r1, [r0, #12]
  ibqp->bsize    = size + sizeof (size_t);
 80042a0:	6182      	str	r2, [r0, #24]
  ibqp->buffers  = bp;
 80042a2:	6201      	str	r1, [r0, #32]
  ibqp->ptr      = NULL;
 80042a4:	6244      	str	r4, [r0, #36]	; 0x24
  ibqp->top      = NULL;
 80042a6:	6284      	str	r4, [r0, #40]	; 0x28
  ibqp->link     = link;
 80042a8:	6303      	str	r3, [r0, #48]	; 0x30
}
 80042aa:	bd30      	pop	{r4, r5, pc}
 80042ac:	0000      	movs	r0, r0
	...

080042b0 <ibqResetI>:
 */
void ibqResetI(input_buffers_queue_t *ibqp) {

  osalDbgCheckClassI();

  ibqp->bcounter = 0;
 80042b0:	2300      	movs	r3, #0
 *
 * @iclass
 */
static inline void osalThreadDequeueAllI(threads_queue_t *tqp, msg_t msg) {

  chThdDequeueAllI(tqp, msg);
 80042b2:	2102      	movs	r1, #2
void ibqResetI(input_buffers_queue_t *ibqp) {
 80042b4:	b510      	push	{r4, lr}
  ibqp->brdptr   = ibqp->buffers;
 80042b6:	6a02      	ldr	r2, [r0, #32]
  ibqp->bcounter = 0;
 80042b8:	6083      	str	r3, [r0, #8]
  ibqp->brdptr   = ibqp->buffers;
 80042ba:	6102      	str	r2, [r0, #16]
  ibqp->bwrptr   = ibqp->buffers;
 80042bc:	60c2      	str	r2, [r0, #12]
  ibqp->ptr      = NULL;
 80042be:	6243      	str	r3, [r0, #36]	; 0x24
  ibqp->top      = NULL;
 80042c0:	6283      	str	r3, [r0, #40]	; 0x28
 80042c2:	4249      	negs	r1, r1
 80042c4:	f7ff fe74 	bl	8003fb0 <chThdDequeueAllI>
  osalThreadDequeueAllI(&ibqp->waiting, MSG_RESET);
}
 80042c8:	bd10      	pop	{r4, pc}
 80042ca:	46c0      	nop			; (mov r8, r8)
 80042cc:	0000      	movs	r0, r0
	...

080042d0 <ibqGetEmptyBufferI>:
 */
uint8_t *ibqGetEmptyBufferI(input_buffers_queue_t *ibqp) {

  osalDbgCheckClassI();

  if (ibqIsFullI(ibqp)) {
 80042d0:	68c3      	ldr	r3, [r0, #12]
 80042d2:	6902      	ldr	r2, [r0, #16]
 80042d4:	4293      	cmp	r3, r2
 80042d6:	d001      	beq.n	80042dc <ibqGetEmptyBufferI+0xc>
    return NULL;
  }

  return ibqp->bwrptr + sizeof (size_t);
 80042d8:	1d18      	adds	r0, r3, #4
}
 80042da:	4770      	bx	lr
  if (ibqIsFullI(ibqp)) {
 80042dc:	6882      	ldr	r2, [r0, #8]
    return NULL;
 80042de:	2000      	movs	r0, #0
  if (ibqIsFullI(ibqp)) {
 80042e0:	2a00      	cmp	r2, #0
 80042e2:	d1fa      	bne.n	80042da <ibqGetEmptyBufferI+0xa>
 80042e4:	e7f8      	b.n	80042d8 <ibqGetEmptyBufferI+0x8>
 80042e6:	46c0      	nop			; (mov r8, r8)
	...

080042f0 <ibqPostFullBufferI>:

  osalDbgCheck((size > 0U) && (size <= (ibqp->bsize - sizeof (size_t))));
  osalDbgAssert(!ibqIsFullI(ibqp), "buffers queue full");

  /* Writing size field in the buffer.*/
  *((size_t *)ibqp->bwrptr) = size;
 80042f0:	68c3      	ldr	r3, [r0, #12]
void ibqPostFullBufferI(input_buffers_queue_t *ibqp, size_t size) {
 80042f2:	b510      	push	{r4, lr}
  *((size_t *)ibqp->bwrptr) = size;
 80042f4:	6019      	str	r1, [r3, #0]

  /* Posting the buffer in the queue.*/
  ibqp->bcounter++;
 80042f6:	6882      	ldr	r2, [r0, #8]
 80042f8:	3201      	adds	r2, #1
 80042fa:	6082      	str	r2, [r0, #8]
  ibqp->bwrptr += ibqp->bsize;
 80042fc:	6982      	ldr	r2, [r0, #24]
 80042fe:	4694      	mov	ip, r2
  if (ibqp->bwrptr >= ibqp->btop) {
 8004300:	6942      	ldr	r2, [r0, #20]
  ibqp->bwrptr += ibqp->bsize;
 8004302:	4463      	add	r3, ip
 8004304:	60c3      	str	r3, [r0, #12]
  if (ibqp->bwrptr >= ibqp->btop) {
 8004306:	4293      	cmp	r3, r2
 8004308:	d301      	bcc.n	800430e <ibqPostFullBufferI+0x1e>
    ibqp->bwrptr = ibqp->buffers;
 800430a:	6a03      	ldr	r3, [r0, #32]
 800430c:	60c3      	str	r3, [r0, #12]
  chThdDequeueNextI(tqp, msg);
 800430e:	2100      	movs	r1, #0
 8004310:	f7ff fe3e 	bl	8003f90 <chThdDequeueNextI>
  }

  /* Waking up one waiting thread, if any.*/
  osalThreadDequeueNextI(&ibqp->waiting, MSG_OK);
}
 8004314:	bd10      	pop	{r4, pc}
 8004316:	46c0      	nop			; (mov r8, r8)
	...

08004320 <ibqGetFullBufferTimeoutS>:
   * @retval MSG_RESET    if the queue has been reset.
   *
   * @sclass
   */
  msg_t ibqGetFullBufferTimeoutS(input_buffers_queue_t *ibqp,
                                 systime_t timeout) {
 8004320:	b570      	push	{r4, r5, r6, lr}
 8004322:	0004      	movs	r4, r0
 8004324:	000d      	movs	r5, r1

  osalDbgCheckClassS();

  while (ibqIsEmptyI(ibqp)) {
 8004326:	e005      	b.n	8004334 <ibqGetFullBufferTimeoutS+0x14>
  return chThdEnqueueTimeoutS(tqp, time);
 8004328:	0029      	movs	r1, r5
 800432a:	0020      	movs	r0, r4
 800432c:	f7ff fe18 	bl	8003f60 <chThdEnqueueTimeoutS>
    msg_t msg = osalThreadEnqueueTimeoutS(&ibqp->waiting, timeout);
    if (msg < MSG_OK) {
 8004330:	2800      	cmp	r0, #0
 8004332:	db09      	blt.n	8004348 <ibqGetFullBufferTimeoutS+0x28>
  while (ibqIsEmptyI(ibqp)) {
 8004334:	68a3      	ldr	r3, [r4, #8]
 8004336:	2b00      	cmp	r3, #0
 8004338:	d0f6      	beq.n	8004328 <ibqGetFullBufferTimeoutS+0x8>

  osalDbgAssert(!ibqIsEmptyI(ibqp), "still empty");

  /* Setting up the "current" buffer and its boundary.*/
  ibqp->ptr = ibqp->brdptr + sizeof (size_t);
  ibqp->top = ibqp->ptr + *((size_t *)ibqp->brdptr);
 800433a:	2000      	movs	r0, #0
  ibqp->ptr = ibqp->brdptr + sizeof (size_t);
 800433c:	6922      	ldr	r2, [r4, #16]
 800433e:	1d13      	adds	r3, r2, #4
  ibqp->top = ibqp->ptr + *((size_t *)ibqp->brdptr);
 8004340:	6812      	ldr	r2, [r2, #0]
  ibqp->ptr = ibqp->brdptr + sizeof (size_t);
 8004342:	6263      	str	r3, [r4, #36]	; 0x24
  ibqp->top = ibqp->ptr + *((size_t *)ibqp->brdptr);
 8004344:	189b      	adds	r3, r3, r2
 8004346:	62a3      	str	r3, [r4, #40]	; 0x28

  return MSG_OK;
}
 8004348:	bd70      	pop	{r4, r5, r6, pc}
 800434a:	46c0      	nop			; (mov r8, r8)
 800434c:	0000      	movs	r0, r0
	...

08004350 <ibqGetTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t ibqGetTimeout(input_buffers_queue_t *ibqp, systime_t timeout) {
 8004350:	b570      	push	{r4, r5, r6, lr}
 8004352:	0004      	movs	r4, r0
  __ASM volatile ("cpsid i" : : : "memory");
 8004354:	b672      	cpsid	i
  msg_t msg;

  osalSysLock();

  /* This condition indicates that a new buffer must be acquired.*/
  if (ibqp->ptr == NULL) {
 8004356:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8004358:	2b00      	cmp	r3, #0
 800435a:	d01c      	beq.n	8004396 <ibqGetTimeout+0x46>
  msg = (msg_t)*ibqp->ptr;
  ibqp->ptr++;

  /* If the current buffer has been fully read then it is returned as
     empty in the queue.*/
  if (ibqp->ptr >= ibqp->top) {
 800435c:	6aa2      	ldr	r2, [r4, #40]	; 0x28
  msg = (msg_t)*ibqp->ptr;
 800435e:	781d      	ldrb	r5, [r3, #0]
  ibqp->ptr++;
 8004360:	3301      	adds	r3, #1
 8004362:	6263      	str	r3, [r4, #36]	; 0x24
  if (ibqp->ptr >= ibqp->top) {
 8004364:	4293      	cmp	r3, r2
 8004366:	d313      	bcc.n	8004390 <ibqGetTimeout+0x40>
  ibqp->brdptr += ibqp->bsize;
 8004368:	69a2      	ldr	r2, [r4, #24]
  ibqp->bcounter--;
 800436a:	68a3      	ldr	r3, [r4, #8]
  ibqp->brdptr += ibqp->bsize;
 800436c:	4694      	mov	ip, r2
  ibqp->bcounter--;
 800436e:	3b01      	subs	r3, #1
 8004370:	60a3      	str	r3, [r4, #8]
  ibqp->brdptr += ibqp->bsize;
 8004372:	6923      	ldr	r3, [r4, #16]
  if (ibqp->brdptr >= ibqp->btop) {
 8004374:	6962      	ldr	r2, [r4, #20]
  ibqp->brdptr += ibqp->bsize;
 8004376:	4463      	add	r3, ip
 8004378:	6123      	str	r3, [r4, #16]
  if (ibqp->brdptr >= ibqp->btop) {
 800437a:	4293      	cmp	r3, r2
 800437c:	d301      	bcc.n	8004382 <ibqGetTimeout+0x32>
    ibqp->brdptr = ibqp->buffers;
 800437e:	6a23      	ldr	r3, [r4, #32]
 8004380:	6123      	str	r3, [r4, #16]
  ibqp->ptr = NULL;
 8004382:	2300      	movs	r3, #0
 8004384:	6263      	str	r3, [r4, #36]	; 0x24
  if (ibqp->notify != NULL) {
 8004386:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8004388:	2b00      	cmp	r3, #0
 800438a:	d001      	beq.n	8004390 <ibqGetTimeout+0x40>
    ibqp->notify(ibqp);
 800438c:	0020      	movs	r0, r4
 800438e:	4798      	blx	r3
  __ASM volatile ("cpsie i" : : : "memory");
 8004390:	b662      	cpsie	i
    ibqReleaseEmptyBufferS(ibqp);
  }

  osalSysUnlock();
  return msg;
}
 8004392:	0028      	movs	r0, r5
 8004394:	bd70      	pop	{r4, r5, r6, pc}
    msg = ibqGetFullBufferTimeoutS(ibqp, timeout);
 8004396:	f7ff ffc3 	bl	8004320 <ibqGetFullBufferTimeoutS>
 800439a:	1e05      	subs	r5, r0, #0
    if (msg != MSG_OK) {
 800439c:	d1f8      	bne.n	8004390 <ibqGetTimeout+0x40>
 800439e:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80043a0:	e7dc      	b.n	800435c <ibqGetTimeout+0xc>
 80043a2:	46c0      	nop			; (mov r8, r8)
	...

080043b0 <ibqReadTimeout>:
 * @retval 0            if a timeout occurred.
 *
 * @api
 */
size_t ibqReadTimeout(input_buffers_queue_t *ibqp, uint8_t *bp,
                      size_t n, systime_t timeout) {
 80043b0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80043b2:	4657      	mov	r7, sl
 80043b4:	4645      	mov	r5, r8
 80043b6:	46de      	mov	lr, fp
 80043b8:	464e      	mov	r6, r9
 80043ba:	b5e0      	push	{r5, r6, r7, lr}
 80043bc:	0004      	movs	r4, r0
 80043be:	b083      	sub	sp, #12
 80043c0:	000f      	movs	r7, r1
 80043c2:	4690      	mov	r8, r2
 80043c4:	469a      	mov	sl, r3
  __ASM volatile ("cpsid i" : : : "memory");
 80043c6:	b672      	cpsid	i
  return (systime_t)STM32_ST_TIM->CNT;
 80043c8:	2380      	movs	r3, #128	; 0x80
 80043ca:	05db      	lsls	r3, r3, #23
 80043cc:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80043ce:	469b      	mov	fp, r3
  osalDbgCheck(n > 0U);

  osalSysLock();

  /* Time window for the whole operation.*/
  deadline = osalOsGetSystemTimeX() + timeout;
 80043d0:	4452      	add	r2, sl
 80043d2:	9201      	str	r2, [sp, #4]
    if (ibqp->ptr == NULL) {
      msg_t msg;

      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 80043d4:	4652      	mov	r2, sl
  ibqp->ptr = NULL;
 80043d6:	2300      	movs	r3, #0
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 80043d8:	3a01      	subs	r2, #1
  size_t r = 0;
 80043da:	2600      	movs	r6, #0
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 80043dc:	9200      	str	r2, [sp, #0]
  ibqp->ptr = NULL;
 80043de:	4699      	mov	r9, r3
 80043e0:	e023      	b.n	800442a <ibqReadTimeout+0x7a>

    /* Smaller chunks in order to not make the critical zone too long,
       this impacts throughput however.*/
    if (size > 64U) {
      /* Giving the compiler a chance to optimize for a fixed size move.*/
      memcpy(bp, ibqp->ptr, 64U);
 80043e2:	0038      	movs	r0, r7
 80043e4:	2240      	movs	r2, #64	; 0x40
 80043e6:	f00e fe73 	bl	80130d0 <memcpy>
      bp        += 64U;
      ibqp->ptr += 64U;
 80043ea:	6a63      	ldr	r3, [r4, #36]	; 0x24
      bp        += 64U;
 80043ec:	3740      	adds	r7, #64	; 0x40
      ibqp->ptr += 64U;
 80043ee:	3340      	adds	r3, #64	; 0x40
 80043f0:	6263      	str	r3, [r4, #36]	; 0x24
      r         += 64U;
 80043f2:	3640      	adds	r6, #64	; 0x40
      ibqp->ptr += size;
      r         += size;
    }

    /* Has the current data buffer been finished? if so then release it.*/
    if (ibqp->ptr >= ibqp->top) {
 80043f4:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 80043f6:	429a      	cmp	r2, r3
 80043f8:	d813      	bhi.n	8004422 <ibqReadTimeout+0x72>
  ibqp->brdptr += ibqp->bsize;
 80043fa:	69a2      	ldr	r2, [r4, #24]
  ibqp->bcounter--;
 80043fc:	68a3      	ldr	r3, [r4, #8]
  ibqp->brdptr += ibqp->bsize;
 80043fe:	4694      	mov	ip, r2
  ibqp->bcounter--;
 8004400:	3b01      	subs	r3, #1
 8004402:	60a3      	str	r3, [r4, #8]
  ibqp->brdptr += ibqp->bsize;
 8004404:	6923      	ldr	r3, [r4, #16]
  if (ibqp->brdptr >= ibqp->btop) {
 8004406:	6962      	ldr	r2, [r4, #20]
  ibqp->brdptr += ibqp->bsize;
 8004408:	4463      	add	r3, ip
 800440a:	6123      	str	r3, [r4, #16]
  if (ibqp->brdptr >= ibqp->btop) {
 800440c:	4293      	cmp	r3, r2
 800440e:	d301      	bcc.n	8004414 <ibqReadTimeout+0x64>
    ibqp->brdptr = ibqp->buffers;
 8004410:	6a23      	ldr	r3, [r4, #32]
 8004412:	6123      	str	r3, [r4, #16]
  ibqp->ptr = NULL;
 8004414:	464b      	mov	r3, r9
 8004416:	6263      	str	r3, [r4, #36]	; 0x24
  if (ibqp->notify != NULL) {
 8004418:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800441a:	2b00      	cmp	r3, #0
 800441c:	d001      	beq.n	8004422 <ibqReadTimeout+0x72>
    ibqp->notify(ibqp);
 800441e:	0020      	movs	r0, r4
 8004420:	4798      	blx	r3
  __ASM volatile ("cpsie i" : : : "memory");
 8004422:	b662      	cpsie	i
      ibqReleaseEmptyBufferS(ibqp);
    }

    /* Giving a preemption chance.*/
    osalSysUnlock();
    if (r >= n) {
 8004424:	4546      	cmp	r6, r8
 8004426:	d22d      	bcs.n	8004484 <ibqReadTimeout+0xd4>
  __ASM volatile ("cpsid i" : : : "memory");
 8004428:	b672      	cpsid	i
    if (ibqp->ptr == NULL) {
 800442a:	6a61      	ldr	r1, [r4, #36]	; 0x24
 800442c:	2900      	cmp	r1, #0
 800442e:	d012      	beq.n	8004456 <ibqReadTimeout+0xa6>
    if (size > (n - r)) {
 8004430:	4642      	mov	r2, r8
    size = (size_t)ibqp->top - (size_t)ibqp->ptr;
 8004432:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    if (size > (n - r)) {
 8004434:	1b95      	subs	r5, r2, r6
    size = (size_t)ibqp->top - (size_t)ibqp->ptr;
 8004436:	1a5b      	subs	r3, r3, r1
    if (size > (n - r)) {
 8004438:	429d      	cmp	r5, r3
 800443a:	d900      	bls.n	800443e <ibqReadTimeout+0x8e>
 800443c:	001d      	movs	r5, r3
    if (size > 64U) {
 800443e:	2d40      	cmp	r5, #64	; 0x40
 8004440:	d8cf      	bhi.n	80043e2 <ibqReadTimeout+0x32>
      memcpy(bp, ibqp->ptr, size);
 8004442:	0038      	movs	r0, r7
 8004444:	002a      	movs	r2, r5
 8004446:	f00e fe43 	bl	80130d0 <memcpy>
      ibqp->ptr += size;
 800444a:	6a63      	ldr	r3, [r4, #36]	; 0x24
      bp        += size;
 800444c:	197f      	adds	r7, r7, r5
      ibqp->ptr += size;
 800444e:	195b      	adds	r3, r3, r5
 8004450:	6263      	str	r3, [r4, #36]	; 0x24
      r         += size;
 8004452:	1976      	adds	r6, r6, r5
 8004454:	e7ce      	b.n	80043f4 <ibqReadTimeout+0x44>
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 8004456:	9b00      	ldr	r3, [sp, #0]
 8004458:	3303      	adds	r3, #3
 800445a:	d80c      	bhi.n	8004476 <ibqReadTimeout+0xc6>
 800445c:	465b      	mov	r3, fp
 800445e:	6a59      	ldr	r1, [r3, #36]	; 0x24
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
 8004460:	9b01      	ldr	r3, [sp, #4]
 8004462:	1a59      	subs	r1, r3, r1
        if (next_timeout > timeout) {
 8004464:	458a      	cmp	sl, r1
 8004466:	d30c      	bcc.n	8004482 <ibqReadTimeout+0xd2>
        msg = ibqGetFullBufferTimeoutS(ibqp, next_timeout);
 8004468:	0020      	movs	r0, r4
 800446a:	f7ff ff59 	bl	8004320 <ibqGetFullBufferTimeoutS>
      if (msg != MSG_OK) {
 800446e:	2800      	cmp	r0, #0
 8004470:	d107      	bne.n	8004482 <ibqReadTimeout+0xd2>
 8004472:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8004474:	e7dc      	b.n	8004430 <ibqReadTimeout+0x80>
        msg = ibqGetFullBufferTimeoutS(ibqp, timeout);
 8004476:	4651      	mov	r1, sl
 8004478:	0020      	movs	r0, r4
 800447a:	f7ff ff51 	bl	8004320 <ibqGetFullBufferTimeoutS>
      if (msg != MSG_OK) {
 800447e:	2800      	cmp	r0, #0
 8004480:	d0f7      	beq.n	8004472 <ibqReadTimeout+0xc2>
  __ASM volatile ("cpsie i" : : : "memory");
 8004482:	b662      	cpsie	i
      return r;
    }
    osalSysLock();
  }
}
 8004484:	0030      	movs	r0, r6
 8004486:	b003      	add	sp, #12
 8004488:	bc3c      	pop	{r2, r3, r4, r5}
 800448a:	4690      	mov	r8, r2
 800448c:	4699      	mov	r9, r3
 800448e:	46a2      	mov	sl, r4
 8004490:	46ab      	mov	fp, r5
 8004492:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

080044a0 <obqObjectInit>:
 *
 * @init
 */
void obqObjectInit(output_buffers_queue_t *obqp, uint8_t *bp,
                   size_t size, size_t n,
                   bqnotify_t onfy, void *link) {
 80044a0:	b510      	push	{r4, lr}

  osalThreadQueueObjectInit(&obqp->waiting);
  obqp->bcounter = n;
  obqp->brdptr   = bp;
  obqp->bwrptr   = bp;
  obqp->btop     = bp + ((size + sizeof (size_t)) * n);
 80044a2:	001c      	movs	r4, r3
  obqp->bcounter = n;
 80044a4:	6083      	str	r3, [r0, #8]
  obqp->bsize    = size + sizeof (size_t);
  obqp->bn       = n;
 80044a6:	61c3      	str	r3, [r0, #28]
  obqp->buffers  = bp;
  obqp->ptr      = NULL;
 80044a8:	2300      	movs	r3, #0
  obqp->btop     = bp + ((size + sizeof (size_t)) * n);
 80044aa:	3204      	adds	r2, #4
 80044ac:	4354      	muls	r4, r2
  obqp->ptr      = NULL;
 80044ae:	6243      	str	r3, [r0, #36]	; 0x24
  obqp->top      = NULL;
 80044b0:	6283      	str	r3, [r0, #40]	; 0x28
  obqp->notify   = onfy;
 80044b2:	9b02      	ldr	r3, [sp, #8]
  obqp->btop     = bp + ((size + sizeof (size_t)) * n);
 80044b4:	190c      	adds	r4, r1, r4
  obqp->notify   = onfy;
 80044b6:	62c3      	str	r3, [r0, #44]	; 0x2c
  obqp->link     = link;
 80044b8:	9b03      	ldr	r3, [sp, #12]
  tqp->next = (thread_t *)tqp;
 80044ba:	6000      	str	r0, [r0, #0]
  tqp->prev = (thread_t *)tqp;
 80044bc:	6040      	str	r0, [r0, #4]
  obqp->brdptr   = bp;
 80044be:	6101      	str	r1, [r0, #16]
  obqp->bwrptr   = bp;
 80044c0:	60c1      	str	r1, [r0, #12]
  obqp->btop     = bp + ((size + sizeof (size_t)) * n);
 80044c2:	6144      	str	r4, [r0, #20]
  obqp->bsize    = size + sizeof (size_t);
 80044c4:	6182      	str	r2, [r0, #24]
  obqp->buffers  = bp;
 80044c6:	6201      	str	r1, [r0, #32]
  obqp->link     = link;
 80044c8:	6303      	str	r3, [r0, #48]	; 0x30
}
 80044ca:	bd10      	pop	{r4, pc}
 80044cc:	0000      	movs	r0, r0
	...

080044d0 <obqResetI>:
 */
void obqResetI(output_buffers_queue_t *obqp) {

  osalDbgCheckClassI();

  obqp->bcounter = bqSizeX(obqp);
 80044d0:	69c3      	ldr	r3, [r0, #28]
  chThdDequeueAllI(tqp, msg);
 80044d2:	2102      	movs	r1, #2
 80044d4:	6083      	str	r3, [r0, #8]
  obqp->brdptr   = obqp->buffers;
 80044d6:	6a03      	ldr	r3, [r0, #32]
void obqResetI(output_buffers_queue_t *obqp) {
 80044d8:	b510      	push	{r4, lr}
  obqp->brdptr   = obqp->buffers;
 80044da:	6103      	str	r3, [r0, #16]
  obqp->bwrptr   = obqp->buffers;
 80044dc:	60c3      	str	r3, [r0, #12]
  obqp->ptr      = NULL;
 80044de:	2300      	movs	r3, #0
 80044e0:	4249      	negs	r1, r1
 80044e2:	6243      	str	r3, [r0, #36]	; 0x24
  obqp->top      = NULL;
 80044e4:	6283      	str	r3, [r0, #40]	; 0x28
 80044e6:	f7ff fd63 	bl	8003fb0 <chThdDequeueAllI>
  osalThreadDequeueAllI(&obqp->waiting, MSG_RESET);
}
 80044ea:	bd10      	pop	{r4, pc}
 80044ec:	0000      	movs	r0, r0
	...

080044f0 <obqGetFullBufferI>:
uint8_t *obqGetFullBufferI(output_buffers_queue_t *obqp,
                           size_t *sizep) {

  osalDbgCheckClassI();

  if (obqIsEmptyI(obqp)) {
 80044f0:	6903      	ldr	r3, [r0, #16]
 80044f2:	68c2      	ldr	r2, [r0, #12]
 80044f4:	429a      	cmp	r2, r3
 80044f6:	d003      	beq.n	8004500 <obqGetFullBufferI+0x10>
    return NULL;
  }

  /* Buffer size.*/
  *sizep = *((size_t *)obqp->brdptr);
 80044f8:	0018      	movs	r0, r3
 80044fa:	c808      	ldmia	r0!, {r3}
 80044fc:	600b      	str	r3, [r1, #0]

  return obqp->brdptr + sizeof (size_t);
}
 80044fe:	4770      	bx	lr
  if (obqIsEmptyI(obqp)) {
 8004500:	6882      	ldr	r2, [r0, #8]
    return NULL;
 8004502:	2000      	movs	r0, #0
  if (obqIsEmptyI(obqp)) {
 8004504:	2a00      	cmp	r2, #0
 8004506:	d1fa      	bne.n	80044fe <obqGetFullBufferI+0xe>
 8004508:	e7f6      	b.n	80044f8 <obqGetFullBufferI+0x8>
 800450a:	46c0      	nop			; (mov r8, r8)
 800450c:	0000      	movs	r0, r0
	...

08004510 <obqReleaseEmptyBufferI>:
  osalDbgCheckClassI();
  osalDbgAssert(!obqIsEmptyI(obqp), "buffers queue empty");

  /* Freeing a buffer slot in the queue.*/
  obqp->bcounter++;
  obqp->brdptr += obqp->bsize;
 8004510:	6982      	ldr	r2, [r0, #24]
  obqp->bcounter++;
 8004512:	6883      	ldr	r3, [r0, #8]
  obqp->brdptr += obqp->bsize;
 8004514:	4694      	mov	ip, r2
  obqp->bcounter++;
 8004516:	3301      	adds	r3, #1
 8004518:	6083      	str	r3, [r0, #8]
  obqp->brdptr += obqp->bsize;
 800451a:	6903      	ldr	r3, [r0, #16]
  if (obqp->brdptr >= obqp->btop) {
 800451c:	6942      	ldr	r2, [r0, #20]
  obqp->brdptr += obqp->bsize;
 800451e:	4463      	add	r3, ip
void obqReleaseEmptyBufferI(output_buffers_queue_t *obqp) {
 8004520:	b510      	push	{r4, lr}
  obqp->brdptr += obqp->bsize;
 8004522:	6103      	str	r3, [r0, #16]
  if (obqp->brdptr >= obqp->btop) {
 8004524:	4293      	cmp	r3, r2
 8004526:	d301      	bcc.n	800452c <obqReleaseEmptyBufferI+0x1c>
    obqp->brdptr = obqp->buffers;
 8004528:	6a03      	ldr	r3, [r0, #32]
 800452a:	6103      	str	r3, [r0, #16]
  chThdDequeueNextI(tqp, msg);
 800452c:	2100      	movs	r1, #0
 800452e:	f7ff fd2f 	bl	8003f90 <chThdDequeueNextI>
  }

  /* Waking up one waiting thread, if any.*/
  osalThreadDequeueNextI(&obqp->waiting, MSG_OK);
}
 8004532:	bd10      	pop	{r4, pc}
	...

08004540 <obqGetEmptyBufferTimeoutS>:
   * @retval MSG_RESET    if the queue has been reset.
   *
   * @sclass
   */
  msg_t obqGetEmptyBufferTimeoutS(output_buffers_queue_t *obqp,
                                  systime_t timeout) {
 8004540:	b570      	push	{r4, r5, r6, lr}
 8004542:	0004      	movs	r4, r0
 8004544:	000d      	movs	r5, r1

  osalDbgCheckClassS();

  while (obqIsFullI(obqp)) {
 8004546:	e005      	b.n	8004554 <obqGetEmptyBufferTimeoutS+0x14>
  return chThdEnqueueTimeoutS(tqp, time);
 8004548:	0029      	movs	r1, r5
 800454a:	0020      	movs	r0, r4
 800454c:	f7ff fd08 	bl	8003f60 <chThdEnqueueTimeoutS>
    msg_t msg = osalThreadEnqueueTimeoutS(&obqp->waiting, timeout);
    if (msg < MSG_OK) {
 8004550:	2800      	cmp	r0, #0
 8004552:	db0a      	blt.n	800456a <obqGetEmptyBufferTimeoutS+0x2a>
  while (obqIsFullI(obqp)) {
 8004554:	68a3      	ldr	r3, [r4, #8]
 8004556:	2b00      	cmp	r3, #0
 8004558:	d0f6      	beq.n	8004548 <obqGetEmptyBufferTimeoutS+0x8>
  }

  osalDbgAssert(!obqIsFullI(obqp), "still full");

  /* Setting up the "current" buffer and its boundary.*/
  obqp->ptr = obqp->bwrptr + sizeof (size_t);
 800455a:	68e3      	ldr	r3, [r4, #12]
  obqp->top = obqp->bwrptr + obqp->bsize;
 800455c:	2000      	movs	r0, #0
  obqp->ptr = obqp->bwrptr + sizeof (size_t);
 800455e:	1d1a      	adds	r2, r3, #4
 8004560:	6262      	str	r2, [r4, #36]	; 0x24
  obqp->top = obqp->bwrptr + obqp->bsize;
 8004562:	69a2      	ldr	r2, [r4, #24]
 8004564:	4694      	mov	ip, r2
 8004566:	4463      	add	r3, ip
 8004568:	62a3      	str	r3, [r4, #40]	; 0x28

  return MSG_OK;
}
 800456a:	bd70      	pop	{r4, r5, r6, pc}
 800456c:	0000      	movs	r0, r0
	...

08004570 <obqPutTimeout>:
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t obqPutTimeout(output_buffers_queue_t *obqp, uint8_t b,
                    systime_t timeout) {
 8004570:	b570      	push	{r4, r5, r6, lr}
 8004572:	0004      	movs	r4, r0
 8004574:	000d      	movs	r5, r1
  __ASM volatile ("cpsid i" : : : "memory");
 8004576:	b672      	cpsid	i
  msg_t msg;

  osalSysLock();

  /* This condition indicates that a new buffer must be acquired.*/
  if (obqp->ptr == NULL) {
 8004578:	6a43      	ldr	r3, [r0, #36]	; 0x24
 800457a:	2b00      	cmp	r3, #0
 800457c:	d020      	beq.n	80045c0 <obqPutTimeout+0x50>
      return msg;
    }
  }

  /* Writing the byte to the buffer.*/
  *obqp->ptr = b;
 800457e:	701d      	strb	r5, [r3, #0]
  obqp->ptr++;
 8004580:	6a63      	ldr	r3, [r4, #36]	; 0x24

  /* If the current buffer has been fully written then it is posted as
     full in the queue.*/
  if (obqp->ptr >= obqp->top) {
 8004582:	6aa2      	ldr	r2, [r4, #40]	; 0x28
  obqp->ptr++;
 8004584:	3301      	adds	r3, #1
 8004586:	6263      	str	r3, [r4, #36]	; 0x24
  if (obqp->ptr >= obqp->top) {
 8004588:	4293      	cmp	r3, r2
 800458a:	d316      	bcc.n	80045ba <obqPutTimeout+0x4a>
    obqPostFullBufferS(obqp, obqp->bsize - sizeof (size_t));
 800458c:	69a2      	ldr	r2, [r4, #24]
  *((size_t *)obqp->bwrptr) = size;
 800458e:	68e3      	ldr	r3, [r4, #12]
    obqPostFullBufferS(obqp, obqp->bsize - sizeof (size_t));
 8004590:	3a04      	subs	r2, #4
  *((size_t *)obqp->bwrptr) = size;
 8004592:	601a      	str	r2, [r3, #0]
  obqp->bcounter--;
 8004594:	68a2      	ldr	r2, [r4, #8]
 8004596:	3a01      	subs	r2, #1
 8004598:	60a2      	str	r2, [r4, #8]
  obqp->bwrptr += obqp->bsize;
 800459a:	69a2      	ldr	r2, [r4, #24]
 800459c:	4694      	mov	ip, r2
  if (obqp->bwrptr >= obqp->btop) {
 800459e:	6962      	ldr	r2, [r4, #20]
  obqp->bwrptr += obqp->bsize;
 80045a0:	4463      	add	r3, ip
 80045a2:	60e3      	str	r3, [r4, #12]
  if (obqp->bwrptr >= obqp->btop) {
 80045a4:	4293      	cmp	r3, r2
 80045a6:	d301      	bcc.n	80045ac <obqPutTimeout+0x3c>
    obqp->bwrptr = obqp->buffers;
 80045a8:	6a23      	ldr	r3, [r4, #32]
 80045aa:	60e3      	str	r3, [r4, #12]
  obqp->ptr = NULL;
 80045ac:	2300      	movs	r3, #0
 80045ae:	6263      	str	r3, [r4, #36]	; 0x24
  if (obqp->notify != NULL) {
 80045b0:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 80045b2:	2b00      	cmp	r3, #0
 80045b4:	d001      	beq.n	80045ba <obqPutTimeout+0x4a>
    obqp->notify(obqp);
 80045b6:	0020      	movs	r0, r4
 80045b8:	4798      	blx	r3
  __ASM volatile ("cpsie i" : : : "memory");
 80045ba:	b662      	cpsie	i
  }

  osalSysUnlock();
  return MSG_OK;
 80045bc:	2000      	movs	r0, #0
}
 80045be:	bd70      	pop	{r4, r5, r6, pc}
    msg = obqGetEmptyBufferTimeoutS(obqp, timeout);
 80045c0:	0011      	movs	r1, r2
 80045c2:	f7ff ffbd 	bl	8004540 <obqGetEmptyBufferTimeoutS>
    if (msg != MSG_OK) {
 80045c6:	2800      	cmp	r0, #0
 80045c8:	d101      	bne.n	80045ce <obqPutTimeout+0x5e>
 80045ca:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80045cc:	e7d7      	b.n	800457e <obqPutTimeout+0xe>
 80045ce:	b662      	cpsie	i
      return msg;
 80045d0:	e7f5      	b.n	80045be <obqPutTimeout+0x4e>
 80045d2:	46c0      	nop			; (mov r8, r8)
	...

080045e0 <obqWriteTimeout>:
 * @retval 0            if a timeout occurred.
 *
 * @api
 */
size_t obqWriteTimeout(output_buffers_queue_t *obqp, const uint8_t *bp,
                       size_t n, systime_t timeout) {
 80045e0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80045e2:	4657      	mov	r7, sl
 80045e4:	4645      	mov	r5, r8
 80045e6:	46de      	mov	lr, fp
 80045e8:	464e      	mov	r6, r9
 80045ea:	b5e0      	push	{r5, r6, r7, lr}
 80045ec:	0004      	movs	r4, r0
 80045ee:	b083      	sub	sp, #12
 80045f0:	000f      	movs	r7, r1
 80045f2:	4690      	mov	r8, r2
 80045f4:	469a      	mov	sl, r3
  __ASM volatile ("cpsid i" : : : "memory");
 80045f6:	b672      	cpsid	i
 80045f8:	2380      	movs	r3, #128	; 0x80
 80045fa:	05db      	lsls	r3, r3, #23
 80045fc:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80045fe:	469b      	mov	fp, r3
  osalDbgCheck(n > 0U);

  osalSysLock();

  /* Time window for the whole operation.*/
  deadline = osalOsGetSystemTimeX() + timeout;
 8004600:	4452      	add	r2, sl
 8004602:	9201      	str	r2, [sp, #4]
    if (obqp->ptr == NULL) {
      msg_t msg;

      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 8004604:	4652      	mov	r2, sl
  obqp->ptr = NULL;
 8004606:	2300      	movs	r3, #0
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 8004608:	3a01      	subs	r2, #1
  size_t w = 0;
 800460a:	2600      	movs	r6, #0
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 800460c:	9200      	str	r2, [sp, #0]
  obqp->ptr = NULL;
 800460e:	4699      	mov	r9, r3
 8004610:	e026      	b.n	8004660 <obqWriteTimeout+0x80>

    /* Smaller chunks in order to not make the critical zone too long,
       this impacts throughput however.*/
    if (size > 64U) {
      /* Giving the compiler a chance to optimize for a fixed size move.*/
      memcpy(obqp->ptr, bp, 64U);
 8004612:	0039      	movs	r1, r7
 8004614:	2240      	movs	r2, #64	; 0x40
 8004616:	f00e fd5b 	bl	80130d0 <memcpy>
      bp        += 64U;
      obqp->ptr += 64U;
 800461a:	6a63      	ldr	r3, [r4, #36]	; 0x24
      bp        += 64U;
 800461c:	3740      	adds	r7, #64	; 0x40
      obqp->ptr += 64U;
 800461e:	3340      	adds	r3, #64	; 0x40
 8004620:	6263      	str	r3, [r4, #36]	; 0x24
      w         += 64U;
 8004622:	3640      	adds	r6, #64	; 0x40
      obqp->ptr += size;
      w         += size;
    }

    /* Has the current data buffer been finished? if so then release it.*/
    if (obqp->ptr >= obqp->top) {
 8004624:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8004626:	429a      	cmp	r2, r3
 8004628:	d816      	bhi.n	8004658 <obqWriteTimeout+0x78>
      obqPostFullBufferS(obqp, obqp->bsize - sizeof (size_t));
 800462a:	69a2      	ldr	r2, [r4, #24]
  *((size_t *)obqp->bwrptr) = size;
 800462c:	68e3      	ldr	r3, [r4, #12]
      obqPostFullBufferS(obqp, obqp->bsize - sizeof (size_t));
 800462e:	3a04      	subs	r2, #4
  *((size_t *)obqp->bwrptr) = size;
 8004630:	601a      	str	r2, [r3, #0]
  obqp->bcounter--;
 8004632:	68a2      	ldr	r2, [r4, #8]
 8004634:	3a01      	subs	r2, #1
 8004636:	60a2      	str	r2, [r4, #8]
  obqp->bwrptr += obqp->bsize;
 8004638:	69a2      	ldr	r2, [r4, #24]
 800463a:	4694      	mov	ip, r2
  if (obqp->bwrptr >= obqp->btop) {
 800463c:	6962      	ldr	r2, [r4, #20]
  obqp->bwrptr += obqp->bsize;
 800463e:	4463      	add	r3, ip
 8004640:	60e3      	str	r3, [r4, #12]
  if (obqp->bwrptr >= obqp->btop) {
 8004642:	4293      	cmp	r3, r2
 8004644:	d301      	bcc.n	800464a <obqWriteTimeout+0x6a>
    obqp->bwrptr = obqp->buffers;
 8004646:	6a23      	ldr	r3, [r4, #32]
 8004648:	60e3      	str	r3, [r4, #12]
  obqp->ptr = NULL;
 800464a:	464b      	mov	r3, r9
 800464c:	6263      	str	r3, [r4, #36]	; 0x24
  if (obqp->notify != NULL) {
 800464e:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8004650:	2b00      	cmp	r3, #0
 8004652:	d001      	beq.n	8004658 <obqWriteTimeout+0x78>
    obqp->notify(obqp);
 8004654:	0020      	movs	r0, r4
 8004656:	4798      	blx	r3
  __ASM volatile ("cpsie i" : : : "memory");
 8004658:	b662      	cpsie	i
    }

    /* Giving a preemption chance.*/
    osalSysUnlock();
    if (w >= n) {
 800465a:	4546      	cmp	r6, r8
 800465c:	d22d      	bcs.n	80046ba <obqWriteTimeout+0xda>
  __ASM volatile ("cpsid i" : : : "memory");
 800465e:	b672      	cpsid	i
    if (obqp->ptr == NULL) {
 8004660:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8004662:	2800      	cmp	r0, #0
 8004664:	d012      	beq.n	800468c <obqWriteTimeout+0xac>
    if (size > (n - w)) {
 8004666:	4642      	mov	r2, r8
    size = (size_t)obqp->top - (size_t)obqp->ptr;
 8004668:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    if (size > (n - w)) {
 800466a:	1b95      	subs	r5, r2, r6
    size = (size_t)obqp->top - (size_t)obqp->ptr;
 800466c:	1a1b      	subs	r3, r3, r0
    if (size > (n - w)) {
 800466e:	429d      	cmp	r5, r3
 8004670:	d900      	bls.n	8004674 <obqWriteTimeout+0x94>
 8004672:	001d      	movs	r5, r3
    if (size > 64U) {
 8004674:	2d40      	cmp	r5, #64	; 0x40
 8004676:	d8cc      	bhi.n	8004612 <obqWriteTimeout+0x32>
      memcpy(obqp->ptr, bp, size);
 8004678:	0039      	movs	r1, r7
 800467a:	002a      	movs	r2, r5
 800467c:	f00e fd28 	bl	80130d0 <memcpy>
      obqp->ptr += size;
 8004680:	6a63      	ldr	r3, [r4, #36]	; 0x24
      bp        += size;
 8004682:	197f      	adds	r7, r7, r5
      obqp->ptr += size;
 8004684:	195b      	adds	r3, r3, r5
 8004686:	6263      	str	r3, [r4, #36]	; 0x24
      w         += size;
 8004688:	1976      	adds	r6, r6, r5
 800468a:	e7cb      	b.n	8004624 <obqWriteTimeout+0x44>
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 800468c:	9b00      	ldr	r3, [sp, #0]
 800468e:	3303      	adds	r3, #3
 8004690:	d80c      	bhi.n	80046ac <obqWriteTimeout+0xcc>
 8004692:	465b      	mov	r3, fp
 8004694:	6a59      	ldr	r1, [r3, #36]	; 0x24
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
 8004696:	9b01      	ldr	r3, [sp, #4]
 8004698:	1a59      	subs	r1, r3, r1
        if (next_timeout > timeout) {
 800469a:	458a      	cmp	sl, r1
 800469c:	d30c      	bcc.n	80046b8 <obqWriteTimeout+0xd8>
        msg = obqGetEmptyBufferTimeoutS(obqp, next_timeout);
 800469e:	0020      	movs	r0, r4
 80046a0:	f7ff ff4e 	bl	8004540 <obqGetEmptyBufferTimeoutS>
      if (msg != MSG_OK) {
 80046a4:	2800      	cmp	r0, #0
 80046a6:	d107      	bne.n	80046b8 <obqWriteTimeout+0xd8>
 80046a8:	6a60      	ldr	r0, [r4, #36]	; 0x24
 80046aa:	e7dc      	b.n	8004666 <obqWriteTimeout+0x86>
        msg = obqGetEmptyBufferTimeoutS(obqp, timeout);
 80046ac:	4651      	mov	r1, sl
 80046ae:	0020      	movs	r0, r4
 80046b0:	f7ff ff46 	bl	8004540 <obqGetEmptyBufferTimeoutS>
      if (msg != MSG_OK) {
 80046b4:	2800      	cmp	r0, #0
 80046b6:	d0f7      	beq.n	80046a8 <obqWriteTimeout+0xc8>
  __ASM volatile ("cpsie i" : : : "memory");
 80046b8:	b662      	cpsie	i
      return w;
    }
    osalSysLock();
  }
}
 80046ba:	0030      	movs	r0, r6
 80046bc:	b003      	add	sp, #12
 80046be:	bc3c      	pop	{r2, r3, r4, r5}
 80046c0:	4690      	mov	r8, r2
 80046c2:	4699      	mov	r9, r3
 80046c4:	46a2      	mov	sl, r4
 80046c6:	46ab      	mov	fp, r5
 80046c8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80046ca:	46c0      	nop			; (mov r8, r8)
 80046cc:	0000      	movs	r0, r0
	...

080046d0 <obqTryFlushI>:
 * @retval false        if no new filled buffer has been posted to the queue.
 * @retval true         if a new filled buffer has been posted to the queue.
 *
 * @iclass
 */
bool obqTryFlushI(output_buffers_queue_t *obqp) {
 80046d0:	0003      	movs	r3, r0

  osalDbgCheckClassI();

  /* If queue is empty and there is a buffer partially filled and
     it is not being written.*/
  if (obqIsEmptyI(obqp) && (obqp->ptr != NULL)) {
 80046d2:	68c2      	ldr	r2, [r0, #12]
 80046d4:	6919      	ldr	r1, [r3, #16]
      obqp->ptr = NULL;

      return true;
    }
  }
  return false;
 80046d6:	2000      	movs	r0, #0
  if (obqIsEmptyI(obqp) && (obqp->ptr != NULL)) {
 80046d8:	428a      	cmp	r2, r1
 80046da:	d000      	beq.n	80046de <obqTryFlushI+0xe>
}
 80046dc:	4770      	bx	lr
  if (obqIsEmptyI(obqp) && (obqp->ptr != NULL)) {
 80046de:	6899      	ldr	r1, [r3, #8]
 80046e0:	2900      	cmp	r1, #0
 80046e2:	d0fb      	beq.n	80046dc <obqTryFlushI+0xc>
 80046e4:	6a59      	ldr	r1, [r3, #36]	; 0x24
 80046e6:	2900      	cmp	r1, #0
 80046e8:	d0f8      	beq.n	80046dc <obqTryFlushI+0xc>
    size_t size = (size_t)obqp->ptr - ((size_t)obqp->bwrptr + sizeof (size_t));
 80046ea:	3904      	subs	r1, #4
 80046ec:	1a89      	subs	r1, r1, r2
    if (size > 0U) {
 80046ee:	d0f5      	beq.n	80046dc <obqTryFlushI+0xc>
      *((size_t *)obqp->bwrptr) = size;
 80046f0:	6011      	str	r1, [r2, #0]
      obqp->bcounter--;
 80046f2:	6899      	ldr	r1, [r3, #8]
 80046f4:	3901      	subs	r1, #1
 80046f6:	6099      	str	r1, [r3, #8]
      obqp->bwrptr += obqp->bsize;
 80046f8:	6999      	ldr	r1, [r3, #24]
 80046fa:	468c      	mov	ip, r1
      if (obqp->bwrptr >= obqp->btop) {
 80046fc:	6959      	ldr	r1, [r3, #20]
      obqp->bwrptr += obqp->bsize;
 80046fe:	4462      	add	r2, ip
 8004700:	60da      	str	r2, [r3, #12]
      if (obqp->bwrptr >= obqp->btop) {
 8004702:	428a      	cmp	r2, r1
 8004704:	d301      	bcc.n	800470a <obqTryFlushI+0x3a>
        obqp->bwrptr = obqp->buffers;
 8004706:	6a1a      	ldr	r2, [r3, #32]
 8004708:	60da      	str	r2, [r3, #12]
      obqp->ptr = NULL;
 800470a:	2200      	movs	r2, #0
      return true;
 800470c:	2001      	movs	r0, #1
      obqp->ptr = NULL;
 800470e:	625a      	str	r2, [r3, #36]	; 0x24
      return true;
 8004710:	e7e4      	b.n	80046dc <obqTryFlushI+0xc>
 8004712:	46c0      	nop			; (mov r8, r8)
	...

08004720 <iqObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {
 8004720:	b510      	push	{r4, lr}

  osalThreadQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 8004722:	2400      	movs	r4, #0
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
  iqp->q_notify  = infy;
 8004724:	61c3      	str	r3, [r0, #28]
  iqp->q_link    = link;
 8004726:	9b02      	ldr	r3, [sp, #8]
  iqp->q_buffer  = bp;
 8004728:	60c1      	str	r1, [r0, #12]
  iqp->q_rdptr   = bp;
 800472a:	6181      	str	r1, [r0, #24]
  iqp->q_wrptr   = bp;
 800472c:	6141      	str	r1, [r0, #20]
  iqp->q_top     = bp + size;
 800472e:	1889      	adds	r1, r1, r2
  tqp->next = (thread_t *)tqp;
 8004730:	6000      	str	r0, [r0, #0]
  tqp->prev = (thread_t *)tqp;
 8004732:	6040      	str	r0, [r0, #4]
  iqp->q_counter = 0;
 8004734:	6084      	str	r4, [r0, #8]
  iqp->q_top     = bp + size;
 8004736:	6101      	str	r1, [r0, #16]
  iqp->q_link    = link;
 8004738:	6203      	str	r3, [r0, #32]
}
 800473a:	bd10      	pop	{r4, pc}
 800473c:	0000      	movs	r0, r0
	...

08004740 <iqPutI>:
 */
msg_t iqPutI(input_queue_t *iqp, uint8_t b) {

  osalDbgCheckClassI();

  if (iqIsFullI(iqp)) {
 8004740:	6943      	ldr	r3, [r0, #20]
 8004742:	6982      	ldr	r2, [r0, #24]
msg_t iqPutI(input_queue_t *iqp, uint8_t b) {
 8004744:	b510      	push	{r4, lr}
  if (iqIsFullI(iqp)) {
 8004746:	4293      	cmp	r3, r2
 8004748:	d011      	beq.n	800476e <iqPutI+0x2e>
    return MSG_TIMEOUT;
  }

  iqp->q_counter++;
 800474a:	6882      	ldr	r2, [r0, #8]
 800474c:	3201      	adds	r2, #1
 800474e:	6082      	str	r2, [r0, #8]
  *iqp->q_wrptr++ = b;
 8004750:	1c5a      	adds	r2, r3, #1
 8004752:	6142      	str	r2, [r0, #20]
 8004754:	7019      	strb	r1, [r3, #0]
  if (iqp->q_wrptr >= iqp->q_top) {
 8004756:	6943      	ldr	r3, [r0, #20]
 8004758:	6902      	ldr	r2, [r0, #16]
 800475a:	4293      	cmp	r3, r2
 800475c:	d204      	bcs.n	8004768 <iqPutI+0x28>
  chThdDequeueNextI(tqp, msg);
 800475e:	2100      	movs	r1, #0
 8004760:	f7ff fc16 	bl	8003f90 <chThdDequeueNextI>
    iqp->q_wrptr = iqp->q_buffer;
  }

  osalThreadDequeueNextI(&iqp->q_waiting, MSG_OK);

  return MSG_OK;
 8004764:	2000      	movs	r0, #0
}
 8004766:	bd10      	pop	{r4, pc}
    iqp->q_wrptr = iqp->q_buffer;
 8004768:	68c3      	ldr	r3, [r0, #12]
 800476a:	6143      	str	r3, [r0, #20]
 800476c:	e7f7      	b.n	800475e <iqPutI+0x1e>
  if (iqIsFullI(iqp)) {
 800476e:	6882      	ldr	r2, [r0, #8]
 8004770:	2a00      	cmp	r2, #0
 8004772:	d0ea      	beq.n	800474a <iqPutI+0xa>
    return MSG_TIMEOUT;
 8004774:	2001      	movs	r0, #1
 8004776:	4240      	negs	r0, r0
 8004778:	e7f5      	b.n	8004766 <iqPutI+0x26>
 800477a:	46c0      	nop			; (mov r8, r8)
 800477c:	0000      	movs	r0, r0
	...

08004780 <iqGetTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t iqGetTimeout(input_queue_t *iqp, systime_t timeout) {
 8004780:	b570      	push	{r4, r5, r6, lr}
 8004782:	0004      	movs	r4, r0
 8004784:	000d      	movs	r5, r1
  __ASM volatile ("cpsid i" : : : "memory");
 8004786:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8004788:	e005      	b.n	8004796 <iqGetTimeout+0x16>
  return chThdEnqueueTimeoutS(tqp, time);
 800478a:	0029      	movs	r1, r5
 800478c:	0020      	movs	r0, r4
 800478e:	f7ff fbe7 	bl	8003f60 <chThdEnqueueTimeoutS>
  osalSysLock();

  /* Waiting until there is a character available or a timeout occurs.*/
  while (iqIsEmptyI(iqp)) {
    msg_t msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);
    if (msg < MSG_OK) {
 8004792:	2800      	cmp	r0, #0
 8004794:	db16      	blt.n	80047c4 <iqGetTimeout+0x44>
  while (iqIsEmptyI(iqp)) {
 8004796:	68a3      	ldr	r3, [r4, #8]
 8004798:	2b00      	cmp	r3, #0
 800479a:	d0f6      	beq.n	800478a <iqGetTimeout+0xa>
      return msg;
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
 800479c:	68a3      	ldr	r3, [r4, #8]
  b = *iqp->q_rdptr++;
 800479e:	69a2      	ldr	r2, [r4, #24]
  iqp->q_counter--;
 80047a0:	3b01      	subs	r3, #1
 80047a2:	60a3      	str	r3, [r4, #8]
  b = *iqp->q_rdptr++;
 80047a4:	1c53      	adds	r3, r2, #1
 80047a6:	61a3      	str	r3, [r4, #24]
 80047a8:	7815      	ldrb	r5, [r2, #0]
  if (iqp->q_rdptr >= iqp->q_top) {
 80047aa:	6922      	ldr	r2, [r4, #16]
 80047ac:	4293      	cmp	r3, r2
 80047ae:	d301      	bcc.n	80047b4 <iqGetTimeout+0x34>
    iqp->q_rdptr = iqp->q_buffer;
 80047b0:	68e3      	ldr	r3, [r4, #12]
 80047b2:	61a3      	str	r3, [r4, #24]
  }

  /* Inform the low side that the queue has at least one slot available.*/
  if (iqp->q_notify != NULL) {
 80047b4:	69e3      	ldr	r3, [r4, #28]
 80047b6:	2b00      	cmp	r3, #0
 80047b8:	d001      	beq.n	80047be <iqGetTimeout+0x3e>
    iqp->q_notify(iqp);
 80047ba:	0020      	movs	r0, r4
 80047bc:	4798      	blx	r3
  __ASM volatile ("cpsie i" : : : "memory");
 80047be:	b662      	cpsie	i
  }

  osalSysUnlock();

  return (msg_t)b;
 80047c0:	0028      	movs	r0, r5
}
 80047c2:	bd70      	pop	{r4, r5, r6, pc}
 80047c4:	b662      	cpsie	i
      return msg;
 80047c6:	e7fc      	b.n	80047c2 <iqGetTimeout+0x42>
	...

080047d0 <iqReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t iqReadTimeout(input_queue_t *iqp, uint8_t *bp,
                     size_t n, systime_t timeout) {
 80047d0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80047d2:	4657      	mov	r7, sl
 80047d4:	464e      	mov	r6, r9
 80047d6:	4645      	mov	r5, r8
 80047d8:	46de      	mov	lr, fp
 80047da:	b5e0      	push	{r5, r6, r7, lr}
 80047dc:	469a      	mov	sl, r3
  systime_t deadline;
  qnotify_t nfy = iqp->q_notify;
 80047de:	69c3      	ldr	r3, [r0, #28]
                     size_t n, systime_t timeout) {
 80047e0:	b083      	sub	sp, #12
 80047e2:	0004      	movs	r4, r0
 80047e4:	000e      	movs	r6, r1
 80047e6:	0015      	movs	r5, r2
  qnotify_t nfy = iqp->q_notify;
 80047e8:	4699      	mov	r9, r3
  __ASM volatile ("cpsid i" : : : "memory");
 80047ea:	b672      	cpsid	i
 80047ec:	2380      	movs	r3, #128	; 0x80
 80047ee:	05db      	lsls	r3, r3, #23
 80047f0:	6a5a      	ldr	r2, [r3, #36]	; 0x24
  size_t r = 0;
 80047f2:	2700      	movs	r7, #0
  osalSysLock();

  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;
 80047f4:	4452      	add	r2, sl
 80047f6:	9201      	str	r2, [sp, #4]
    while (iqIsEmptyI(iqp)) {
      msg_t msg;

      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 80047f8:	4652      	mov	r2, sl
 80047fa:	469b      	mov	fp, r3
 80047fc:	3a01      	subs	r2, #1
 80047fe:	9200      	str	r2, [sp, #0]
    while (iqIsEmptyI(iqp)) {
 8004800:	68a3      	ldr	r3, [r4, #8]
 8004802:	2b00      	cmp	r3, #0
 8004804:	d01e      	beq.n	8004844 <iqReadTimeout+0x74>
        return r;
      }
    }

    /* Getting the character from the queue.*/
    iqp->q_counter--;
 8004806:	68a3      	ldr	r3, [r4, #8]
 8004808:	3b01      	subs	r3, #1
 800480a:	60a3      	str	r3, [r4, #8]
    *bp++ = *iqp->q_rdptr++;
 800480c:	69a3      	ldr	r3, [r4, #24]
 800480e:	1c5a      	adds	r2, r3, #1
 8004810:	61a2      	str	r2, [r4, #24]
 8004812:	781b      	ldrb	r3, [r3, #0]
 8004814:	1c72      	adds	r2, r6, #1
 8004816:	7033      	strb	r3, [r6, #0]
 8004818:	4690      	mov	r8, r2
    if (iqp->q_rdptr >= iqp->q_top) {
 800481a:	69a3      	ldr	r3, [r4, #24]
 800481c:	6922      	ldr	r2, [r4, #16]
 800481e:	4293      	cmp	r3, r2
 8004820:	d301      	bcc.n	8004826 <iqReadTimeout+0x56>
      iqp->q_rdptr = iqp->q_buffer;
 8004822:	68e3      	ldr	r3, [r4, #12]
 8004824:	61a3      	str	r3, [r4, #24]
    }

    /* Inform the low side that the queue has at least one slot available.*/
    if (nfy != NULL) {
 8004826:	464b      	mov	r3, r9
 8004828:	2b00      	cmp	r3, #0
 800482a:	d001      	beq.n	8004830 <iqReadTimeout+0x60>
      nfy(iqp);
 800482c:	0020      	movs	r0, r4
 800482e:	47c8      	blx	r9
  __ASM volatile ("cpsie i" : : : "memory");
 8004830:	b662      	cpsie	i

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();

    r++;
    if (--n == 0U) {
 8004832:	3d01      	subs	r5, #1
    r++;
 8004834:	3701      	adds	r7, #1
    if (--n == 0U) {
 8004836:	2d00      	cmp	r5, #0
 8004838:	d013      	beq.n	8004862 <iqReadTimeout+0x92>
  __ASM volatile ("cpsid i" : : : "memory");
 800483a:	b672      	cpsid	i
    while (iqIsEmptyI(iqp)) {
 800483c:	68a3      	ldr	r3, [r4, #8]
    *bp++ = *iqp->q_rdptr++;
 800483e:	4646      	mov	r6, r8
    while (iqIsEmptyI(iqp)) {
 8004840:	2b00      	cmp	r3, #0
 8004842:	d1e0      	bne.n	8004806 <iqReadTimeout+0x36>
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 8004844:	9b00      	ldr	r3, [sp, #0]
 8004846:	3303      	adds	r3, #3
 8004848:	d813      	bhi.n	8004872 <iqReadTimeout+0xa2>
 800484a:	465b      	mov	r3, fp
 800484c:	6a59      	ldr	r1, [r3, #36]	; 0x24
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
 800484e:	9b01      	ldr	r3, [sp, #4]
 8004850:	1a59      	subs	r1, r3, r1
        if (next_timeout > timeout) {
 8004852:	458a      	cmp	sl, r1
 8004854:	d304      	bcc.n	8004860 <iqReadTimeout+0x90>
 8004856:	0020      	movs	r0, r4
 8004858:	f7ff fb82 	bl	8003f60 <chThdEnqueueTimeoutS>
      if (msg != MSG_OK) {
 800485c:	2800      	cmp	r0, #0
 800485e:	d0cf      	beq.n	8004800 <iqReadTimeout+0x30>
  __ASM volatile ("cpsie i" : : : "memory");
 8004860:	b662      	cpsie	i
      return r;
    }

    osalSysLock();
  }
}
 8004862:	0038      	movs	r0, r7
 8004864:	b003      	add	sp, #12
 8004866:	bc3c      	pop	{r2, r3, r4, r5}
 8004868:	4690      	mov	r8, r2
 800486a:	4699      	mov	r9, r3
 800486c:	46a2      	mov	sl, r4
 800486e:	46ab      	mov	fp, r5
 8004870:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8004872:	4651      	mov	r1, sl
 8004874:	0020      	movs	r0, r4
 8004876:	f7ff fb73 	bl	8003f60 <chThdEnqueueTimeoutS>
 800487a:	e7ef      	b.n	800485c <iqReadTimeout+0x8c>
 800487c:	0000      	movs	r0, r0
	...

08004880 <oqObjectInit>:
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
  oqp->q_notify  = onfy;
 8004880:	61c3      	str	r3, [r0, #28]
  oqp->q_link    = link;
 8004882:	9b00      	ldr	r3, [sp, #0]
  oqp->q_buffer  = bp;
 8004884:	60c1      	str	r1, [r0, #12]
  oqp->q_rdptr   = bp;
 8004886:	6181      	str	r1, [r0, #24]
  oqp->q_wrptr   = bp;
 8004888:	6141      	str	r1, [r0, #20]
  oqp->q_top     = bp + size;
 800488a:	1889      	adds	r1, r1, r2
  tqp->next = (thread_t *)tqp;
 800488c:	6000      	str	r0, [r0, #0]
  tqp->prev = (thread_t *)tqp;
 800488e:	6040      	str	r0, [r0, #4]
  oqp->q_counter = size;
 8004890:	6082      	str	r2, [r0, #8]
  oqp->q_top     = bp + size;
 8004892:	6101      	str	r1, [r0, #16]
  oqp->q_link    = link;
 8004894:	6203      	str	r3, [r0, #32]
}
 8004896:	4770      	bx	lr
	...

080048a0 <oqPutTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
 80048a0:	b570      	push	{r4, r5, r6, lr}
 80048a2:	0004      	movs	r4, r0
 80048a4:	000e      	movs	r6, r1
 80048a6:	0015      	movs	r5, r2
  __ASM volatile ("cpsid i" : : : "memory");
 80048a8:	b672      	cpsid	i
 80048aa:	e005      	b.n	80048b8 <oqPutTimeout+0x18>
 80048ac:	0029      	movs	r1, r5
 80048ae:	0020      	movs	r0, r4
 80048b0:	f7ff fb56 	bl	8003f60 <chThdEnqueueTimeoutS>
  osalSysLock();

  /* Waiting until there is a slot available or a timeout occurs.*/
  while (oqIsFullI(oqp)) {
    msg_t msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
    if (msg < MSG_OK) {
 80048b4:	2800      	cmp	r0, #0
 80048b6:	db17      	blt.n	80048e8 <oqPutTimeout+0x48>
  while (oqIsFullI(oqp)) {
 80048b8:	68a3      	ldr	r3, [r4, #8]
 80048ba:	2b00      	cmp	r3, #0
 80048bc:	d0f6      	beq.n	80048ac <oqPutTimeout+0xc>
      return msg;
    }
  }

  /* Putting the character into the queue.*/
  oqp->q_counter--;
 80048be:	68a3      	ldr	r3, [r4, #8]
 80048c0:	3b01      	subs	r3, #1
 80048c2:	60a3      	str	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
 80048c4:	6963      	ldr	r3, [r4, #20]
 80048c6:	1c5a      	adds	r2, r3, #1
 80048c8:	6162      	str	r2, [r4, #20]
 80048ca:	701e      	strb	r6, [r3, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 80048cc:	6963      	ldr	r3, [r4, #20]
 80048ce:	6922      	ldr	r2, [r4, #16]
 80048d0:	4293      	cmp	r3, r2
 80048d2:	d301      	bcc.n	80048d8 <oqPutTimeout+0x38>
    oqp->q_wrptr = oqp->q_buffer;
 80048d4:	68e3      	ldr	r3, [r4, #12]
 80048d6:	6163      	str	r3, [r4, #20]
  }

  /* Inform the low side that the queue has at least one character available.*/
  if (oqp->q_notify != NULL) {
 80048d8:	69e3      	ldr	r3, [r4, #28]
 80048da:	2b00      	cmp	r3, #0
 80048dc:	d001      	beq.n	80048e2 <oqPutTimeout+0x42>
    oqp->q_notify(oqp);
 80048de:	0020      	movs	r0, r4
 80048e0:	4798      	blx	r3
  __ASM volatile ("cpsie i" : : : "memory");
 80048e2:	b662      	cpsie	i
  }

  osalSysUnlock();

  return MSG_OK;
 80048e4:	2000      	movs	r0, #0
}
 80048e6:	bd70      	pop	{r4, r5, r6, pc}
 80048e8:	b662      	cpsie	i
      return msg;
 80048ea:	e7fc      	b.n	80048e6 <oqPutTimeout+0x46>
 80048ec:	0000      	movs	r0, r0
	...

080048f0 <oqGetI>:
msg_t oqGetI(output_queue_t *oqp) {
  uint8_t b;

  osalDbgCheckClassI();

  if (oqIsEmptyI(oqp)) {
 80048f0:	6983      	ldr	r3, [r0, #24]
 80048f2:	6942      	ldr	r2, [r0, #20]
msg_t oqGetI(output_queue_t *oqp) {
 80048f4:	b510      	push	{r4, lr}
  if (oqIsEmptyI(oqp)) {
 80048f6:	429a      	cmp	r2, r3
 80048f8:	d010      	beq.n	800491c <oqGetI+0x2c>
    return MSG_TIMEOUT;
  }

  oqp->q_counter++;
 80048fa:	6882      	ldr	r2, [r0, #8]
 80048fc:	3201      	adds	r2, #1
 80048fe:	6082      	str	r2, [r0, #8]
  b = *oqp->q_rdptr++;
 8004900:	1c5a      	adds	r2, r3, #1
 8004902:	6182      	str	r2, [r0, #24]
 8004904:	781c      	ldrb	r4, [r3, #0]
  if (oqp->q_rdptr >= oqp->q_top) {
 8004906:	6903      	ldr	r3, [r0, #16]
 8004908:	429a      	cmp	r2, r3
 800490a:	d204      	bcs.n	8004916 <oqGetI+0x26>
  chThdDequeueNextI(tqp, msg);
 800490c:	2100      	movs	r1, #0
 800490e:	f7ff fb3f 	bl	8003f90 <chThdDequeueNextI>
    oqp->q_rdptr = oqp->q_buffer;
  }

  osalThreadDequeueNextI(&oqp->q_waiting, MSG_OK);

  return (msg_t)b;
 8004912:	0020      	movs	r0, r4
}
 8004914:	bd10      	pop	{r4, pc}
    oqp->q_rdptr = oqp->q_buffer;
 8004916:	68c3      	ldr	r3, [r0, #12]
 8004918:	6183      	str	r3, [r0, #24]
 800491a:	e7f7      	b.n	800490c <oqGetI+0x1c>
  if (oqIsEmptyI(oqp)) {
 800491c:	6882      	ldr	r2, [r0, #8]
 800491e:	2a00      	cmp	r2, #0
 8004920:	d0eb      	beq.n	80048fa <oqGetI+0xa>
    return MSG_TIMEOUT;
 8004922:	2001      	movs	r0, #1
 8004924:	4240      	negs	r0, r0
 8004926:	e7f5      	b.n	8004914 <oqGetI+0x24>
	...

08004930 <oqWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, systime_t timeout) {
 8004930:	b5f0      	push	{r4, r5, r6, r7, lr}
 8004932:	4657      	mov	r7, sl
 8004934:	464e      	mov	r6, r9
 8004936:	4645      	mov	r5, r8
 8004938:	46de      	mov	lr, fp
 800493a:	b5e0      	push	{r5, r6, r7, lr}
 800493c:	469a      	mov	sl, r3
  systime_t deadline;
  qnotify_t nfy = oqp->q_notify;
 800493e:	69c3      	ldr	r3, [r0, #28]
                      size_t n, systime_t timeout) {
 8004940:	b083      	sub	sp, #12
 8004942:	0004      	movs	r4, r0
 8004944:	000e      	movs	r6, r1
 8004946:	0015      	movs	r5, r2
  qnotify_t nfy = oqp->q_notify;
 8004948:	4699      	mov	r9, r3
  __ASM volatile ("cpsid i" : : : "memory");
 800494a:	b672      	cpsid	i
 800494c:	2380      	movs	r3, #128	; 0x80
 800494e:	05db      	lsls	r3, r3, #23
 8004950:	6a5a      	ldr	r2, [r3, #36]	; 0x24
  size_t w = 0;
 8004952:	2700      	movs	r7, #0
  osalSysLock();

  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;
 8004954:	4452      	add	r2, sl
 8004956:	9201      	str	r2, [sp, #4]
    msg_t msg;

    while (oqIsFullI(oqp)) {
      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 8004958:	4652      	mov	r2, sl
 800495a:	469b      	mov	fp, r3
 800495c:	3a01      	subs	r2, #1
 800495e:	9200      	str	r2, [sp, #0]
    while (oqIsFullI(oqp)) {
 8004960:	68a3      	ldr	r3, [r4, #8]
 8004962:	2b00      	cmp	r3, #0
 8004964:	d01e      	beq.n	80049a4 <oqWriteTimeout+0x74>
        return w;
      }
    }

    /* Putting the character into the queue.*/
    oqp->q_counter--;
 8004966:	68a3      	ldr	r3, [r4, #8]
 8004968:	3b01      	subs	r3, #1
 800496a:	60a3      	str	r3, [r4, #8]
    *oqp->q_wrptr++ = *bp++;
 800496c:	1c73      	adds	r3, r6, #1
 800496e:	4698      	mov	r8, r3
 8004970:	6963      	ldr	r3, [r4, #20]
 8004972:	1c5a      	adds	r2, r3, #1
 8004974:	6162      	str	r2, [r4, #20]
 8004976:	7832      	ldrb	r2, [r6, #0]
 8004978:	701a      	strb	r2, [r3, #0]
    if (oqp->q_wrptr >= oqp->q_top) {
 800497a:	6963      	ldr	r3, [r4, #20]
 800497c:	6922      	ldr	r2, [r4, #16]
 800497e:	4293      	cmp	r3, r2
 8004980:	d301      	bcc.n	8004986 <oqWriteTimeout+0x56>
      oqp->q_wrptr = oqp->q_buffer;
 8004982:	68e3      	ldr	r3, [r4, #12]
 8004984:	6163      	str	r3, [r4, #20]
    }

    /* Inform the low side that the queue has at least one character available.*/
    if (nfy != NULL) {
 8004986:	464b      	mov	r3, r9
 8004988:	2b00      	cmp	r3, #0
 800498a:	d001      	beq.n	8004990 <oqWriteTimeout+0x60>
      nfy(oqp);
 800498c:	0020      	movs	r0, r4
 800498e:	47c8      	blx	r9
  __ASM volatile ("cpsie i" : : : "memory");
 8004990:	b662      	cpsie	i

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();

    w++;
    if (--n == 0U) {
 8004992:	3d01      	subs	r5, #1
    w++;
 8004994:	3701      	adds	r7, #1
    if (--n == 0U) {
 8004996:	2d00      	cmp	r5, #0
 8004998:	d013      	beq.n	80049c2 <oqWriteTimeout+0x92>
  __ASM volatile ("cpsid i" : : : "memory");
 800499a:	b672      	cpsid	i
    while (oqIsFullI(oqp)) {
 800499c:	68a3      	ldr	r3, [r4, #8]
    *oqp->q_wrptr++ = *bp++;
 800499e:	4646      	mov	r6, r8
    while (oqIsFullI(oqp)) {
 80049a0:	2b00      	cmp	r3, #0
 80049a2:	d1e0      	bne.n	8004966 <oqWriteTimeout+0x36>
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 80049a4:	9b00      	ldr	r3, [sp, #0]
 80049a6:	3303      	adds	r3, #3
 80049a8:	d813      	bhi.n	80049d2 <oqWriteTimeout+0xa2>
 80049aa:	465b      	mov	r3, fp
 80049ac:	6a59      	ldr	r1, [r3, #36]	; 0x24
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
 80049ae:	9b01      	ldr	r3, [sp, #4]
 80049b0:	1a59      	subs	r1, r3, r1
        if (next_timeout > timeout) {
 80049b2:	458a      	cmp	sl, r1
 80049b4:	d304      	bcc.n	80049c0 <oqWriteTimeout+0x90>
  return chThdEnqueueTimeoutS(tqp, time);
 80049b6:	0020      	movs	r0, r4
 80049b8:	f7ff fad2 	bl	8003f60 <chThdEnqueueTimeoutS>
      if (msg != MSG_OK) {
 80049bc:	2800      	cmp	r0, #0
 80049be:	d0cf      	beq.n	8004960 <oqWriteTimeout+0x30>
  __ASM volatile ("cpsie i" : : : "memory");
 80049c0:	b662      	cpsie	i
      return w;
    }

    osalSysLock();
  }
}
 80049c2:	0038      	movs	r0, r7
 80049c4:	b003      	add	sp, #12
 80049c6:	bc3c      	pop	{r2, r3, r4, r5}
 80049c8:	4690      	mov	r8, r2
 80049ca:	4699      	mov	r9, r3
 80049cc:	46a2      	mov	sl, r4
 80049ce:	46ab      	mov	fp, r5
 80049d0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80049d2:	4651      	mov	r1, sl
 80049d4:	0020      	movs	r0, r4
 80049d6:	f7ff fac3 	bl	8003f60 <chThdEnqueueTimeoutS>
 80049da:	e7ef      	b.n	80049bc <oqWriteTimeout+0x8c>
 80049dc:	0000      	movs	r0, r0
	...

080049e0 <extInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void extInit(void) {
 80049e0:	b510      	push	{r4, lr}

  ext_lld_init();
 80049e2:	f001 f8e5 	bl	8005bb0 <ext_lld_init>
}
 80049e6:	bd10      	pop	{r4, pc}
	...

080049f0 <extObjectInit>:
 *
 * @init
 */
void extObjectInit(EXTDriver *extp) {

  extp->state  = EXT_STOP;
 80049f0:	2301      	movs	r3, #1
 80049f2:	7003      	strb	r3, [r0, #0]
  extp->config = NULL;
 80049f4:	2300      	movs	r3, #0
 80049f6:	6043      	str	r3, [r0, #4]
}
 80049f8:	4770      	bx	lr
 80049fa:	46c0      	nop			; (mov r8, r8)
 80049fc:	0000      	movs	r0, r0
	...

08004a00 <extStart>:
 * @param[in] extp      pointer to the @p EXTDriver object
 * @param[in] config    pointer to the @p EXTConfig object
 *
 * @api
 */
void extStart(EXTDriver *extp, const EXTConfig *config) {
 8004a00:	b510      	push	{r4, lr}
 8004a02:	0004      	movs	r4, r0
  __ASM volatile ("cpsid i" : : : "memory");
 8004a04:	b672      	cpsid	i
  osalDbgCheck((extp != NULL) && (config != NULL));

  osalSysLock();
  osalDbgAssert((extp->state == EXT_STOP) || (extp->state == EXT_ACTIVE),
                "invalid state");
  extp->config = config;
 8004a06:	6041      	str	r1, [r0, #4]
  ext_lld_start(extp);
 8004a08:	f001 f932 	bl	8005c70 <ext_lld_start>
  extp->state = EXT_ACTIVE;
 8004a0c:	2302      	movs	r3, #2
 8004a0e:	7023      	strb	r3, [r4, #0]
  __ASM volatile ("cpsie i" : : : "memory");
 8004a10:	b662      	cpsie	i
  osalSysUnlock();
}
 8004a12:	bd10      	pop	{r4, pc}
	...

08004a20 <gptInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void gptInit(void) {
 8004a20:	b510      	push	{r4, lr}

  gpt_lld_init();
 8004a22:	f001 fe2d 	bl	8006680 <gpt_lld_init>
}
 8004a26:	bd10      	pop	{r4, pc}
	...

08004a30 <gptObjectInit>:
 *
 * @init
 */
void gptObjectInit(GPTDriver *gptp) {

  gptp->state  = GPT_STOP;
 8004a30:	2301      	movs	r3, #1
 8004a32:	7003      	strb	r3, [r0, #0]
  gptp->config = NULL;
 8004a34:	2300      	movs	r3, #0
 8004a36:	6043      	str	r3, [r0, #4]
}
 8004a38:	4770      	bx	lr
 8004a3a:	46c0      	nop			; (mov r8, r8)
 8004a3c:	0000      	movs	r0, r0
	...

08004a40 <gptStart>:
 * @param[in] gptp      pointer to the @p GPTDriver object
 * @param[in] config    pointer to the @p GPTConfig object
 *
 * @api
 */
void gptStart(GPTDriver *gptp, const GPTConfig *config) {
 8004a40:	b510      	push	{r4, lr}
 8004a42:	0004      	movs	r4, r0
  __ASM volatile ("cpsid i" : : : "memory");
 8004a44:	b672      	cpsid	i
  osalDbgCheck((gptp != NULL) && (config != NULL));

  osalSysLock();
  osalDbgAssert((gptp->state == GPT_STOP) || (gptp->state == GPT_READY),
              "invalid state");
  gptp->config = config;
 8004a46:	6041      	str	r1, [r0, #4]
  gpt_lld_start(gptp);
 8004a48:	f001 fe2a 	bl	80066a0 <gpt_lld_start>
  gptp->state = GPT_READY;
 8004a4c:	2302      	movs	r3, #2
 8004a4e:	7023      	strb	r3, [r4, #0]
  __ASM volatile ("cpsie i" : : : "memory");
 8004a50:	b662      	cpsie	i
  osalSysUnlock();
}
 8004a52:	bd10      	pop	{r4, pc}
	...

08004a60 <gptStartContinuous>:
 * @param[in] gptp      pointer to the @p GPTDriver object
 * @param[in] interval  period in ticks
 *
 * @api
 */
void gptStartContinuous(GPTDriver *gptp, gptcnt_t interval) {
 8004a60:	b510      	push	{r4, lr}
  __ASM volatile ("cpsid i" : : : "memory");
 8004a62:	b672      	cpsid	i
  osalDbgCheckClassI();
  osalDbgCheck(gptp != NULL);
  osalDbgAssert(gptp->state == GPT_READY,
                "invalid state");

  gptp->state = GPT_CONTINUOUS;
 8004a64:	2303      	movs	r3, #3
 8004a66:	7003      	strb	r3, [r0, #0]
  gpt_lld_start_timer(gptp, interval);
 8004a68:	f001 fe52 	bl	8006710 <gpt_lld_start_timer>
  __ASM volatile ("cpsie i" : : : "memory");
 8004a6c:	b662      	cpsie	i
}
 8004a6e:	bd10      	pop	{r4, pc}

08004a70 <gptPolledDelay>:
void gptPolledDelay(GPTDriver *gptp, gptcnt_t interval) {

  osalDbgAssert(gptp->state == GPT_READY,
                "invalid state");

  gptp->state = GPT_ONESHOT;
 8004a70:	2304      	movs	r3, #4
void gptPolledDelay(GPTDriver *gptp, gptcnt_t interval) {
 8004a72:	b510      	push	{r4, lr}
  gptp->state = GPT_ONESHOT;
 8004a74:	7003      	strb	r3, [r0, #0]
void gptPolledDelay(GPTDriver *gptp, gptcnt_t interval) {
 8004a76:	0004      	movs	r4, r0
  gpt_lld_polled_delay(gptp, interval);
 8004a78:	f001 fe62 	bl	8006740 <gpt_lld_polled_delay>
  gptp->state = GPT_READY;
 8004a7c:	2302      	movs	r3, #2
 8004a7e:	7023      	strb	r3, [r4, #0]
}
 8004a80:	bd10      	pop	{r4, pc}
 8004a82:	46c0      	nop			; (mov r8, r8)
	...

08004a90 <i2cInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void i2cInit(void) {
 8004a90:	b510      	push	{r4, lr}

  i2c_lld_init();
 8004a92:	f001 fc25 	bl	80062e0 <i2c_lld_init>
}
 8004a96:	bd10      	pop	{r4, pc}
	...

08004aa0 <i2cObjectInit>:
 *
 * @init
 */
void i2cObjectInit(I2CDriver *i2cp) {

  i2cp->state  = I2C_STOP;
 8004aa0:	2301      	movs	r3, #1
void i2cObjectInit(I2CDriver *i2cp) {
 8004aa2:	b510      	push	{r4, lr}
  i2cp->state  = I2C_STOP;
 8004aa4:	7003      	strb	r3, [r0, #0]
  i2cp->config = NULL;
 8004aa6:	2300      	movs	r3, #0
 8004aa8:	6043      	str	r3, [r0, #4]

#if I2C_USE_MUTUAL_EXCLUSION == TRUE
  osalMutexObjectInit(&i2cp->mutex);
 8004aaa:	300c      	adds	r0, #12
 * @init
 */
static inline void osalMutexObjectInit(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxObjectInit(mp);
 8004aac:	f7ff faa8 	bl	8004000 <chMtxObjectInit>
#endif

#if defined(I2C_DRIVER_EXT_INIT_HOOK)
  I2C_DRIVER_EXT_INIT_HOOK(i2cp);
#endif
}
 8004ab0:	bd10      	pop	{r4, pc}
 8004ab2:	46c0      	nop			; (mov r8, r8)
	...

08004ac0 <i2cStart>:
 * @param[in] i2cp      pointer to the @p I2CDriver object
 * @param[in] config    pointer to the @p I2CConfig object
 *
 * @api
 */
void i2cStart(I2CDriver *i2cp, const I2CConfig *config) {
 8004ac0:	b510      	push	{r4, lr}
 8004ac2:	0004      	movs	r4, r0
  __ASM volatile ("cpsid i" : : : "memory");
 8004ac4:	b672      	cpsid	i
  osalDbgCheck((i2cp != NULL) && (config != NULL));
  osalDbgAssert((i2cp->state == I2C_STOP) || (i2cp->state == I2C_READY) ||
                (i2cp->state == I2C_LOCKED), "invalid state");

  osalSysLock();
  i2cp->config = config;
 8004ac6:	6041      	str	r1, [r0, #4]
  i2c_lld_start(i2cp);
 8004ac8:	f001 fc1a 	bl	8006300 <i2c_lld_start>
  i2cp->state = I2C_READY;
 8004acc:	2302      	movs	r3, #2
 8004ace:	7023      	strb	r3, [r4, #0]
  __ASM volatile ("cpsie i" : : : "memory");
 8004ad0:	b662      	cpsie	i
  osalSysUnlock();
}
 8004ad2:	bd10      	pop	{r4, pc}
	...

08004ae0 <i2cMasterTransmitTimeout>:
                               i2caddr_t addr,
                               const uint8_t *txbuf,
                               size_t txbytes,
                               uint8_t *rxbuf,
                               size_t rxbytes,
                               systime_t timeout) {
 8004ae0:	b510      	push	{r4, lr}
 8004ae2:	0004      	movs	r4, r0
 8004ae4:	b084      	sub	sp, #16
  __ASM volatile ("cpsid i" : : : "memory");
 8004ae6:	b672      	cpsid	i
               (timeout != TIME_IMMEDIATE));

  osalDbgAssert(i2cp->state == I2C_READY, "not ready");

  osalSysLock();
  i2cp->errors = I2C_NO_ERROR;
 8004ae8:	2000      	movs	r0, #0
 8004aea:	60a0      	str	r0, [r4, #8]
  i2cp->state = I2C_ACTIVE_TX;
 8004aec:	3003      	adds	r0, #3
 8004aee:	7020      	strb	r0, [r4, #0]
  rdymsg = i2c_lld_master_transmit_timeout(i2cp, addr, txbuf, txbytes,
 8004af0:	9808      	ldr	r0, [sp, #32]
 8004af2:	9002      	str	r0, [sp, #8]
 8004af4:	9807      	ldr	r0, [sp, #28]
 8004af6:	9001      	str	r0, [sp, #4]
 8004af8:	9806      	ldr	r0, [sp, #24]
 8004afa:	9000      	str	r0, [sp, #0]
 8004afc:	0020      	movs	r0, r4
 8004afe:	f001 fc2f 	bl	8006360 <i2c_lld_master_transmit_timeout>
                                           rxbuf, rxbytes, timeout);
  if (rdymsg == MSG_TIMEOUT) {
    i2cp->state = I2C_LOCKED;
 8004b02:	1c43      	adds	r3, r0, #1
 8004b04:	1e5a      	subs	r2, r3, #1
 8004b06:	4193      	sbcs	r3, r2
 8004b08:	2202      	movs	r2, #2
 8004b0a:	425b      	negs	r3, r3
 8004b0c:	4393      	bics	r3, r2
 8004b0e:	3305      	adds	r3, #5
 8004b10:	7023      	strb	r3, [r4, #0]
  __ASM volatile ("cpsie i" : : : "memory");
 8004b12:	b662      	cpsie	i
  else {
    i2cp->state = I2C_READY;
  }
  osalSysUnlock();
  return rdymsg;
}
 8004b14:	b004      	add	sp, #16
 8004b16:	bd10      	pop	{r4, pc}
	...

08004b20 <i2cAcquireBus>:
 *
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @api
 */
void i2cAcquireBus(I2CDriver *i2cp) {
 8004b20:	b510      	push	{r4, lr}

  osalDbgCheck(i2cp != NULL);

  osalMutexLock(&i2cp->mutex);
 8004b22:	300c      	adds	r0, #12
 * @api
 */
static inline void osalMutexLock(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxLock(mp);
 8004b24:	f7ff facc 	bl	80040c0 <chMtxLock>
}
 8004b28:	bd10      	pop	{r4, pc}
 8004b2a:	46c0      	nop			; (mov r8, r8)
 8004b2c:	0000      	movs	r0, r0
	...

08004b30 <i2cReleaseBus>:
 *
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @api
 */
void i2cReleaseBus(I2CDriver *i2cp) {
 8004b30:	b510      	push	{r4, lr}

  osalDbgCheck(i2cp != NULL);

  osalMutexUnlock(&i2cp->mutex);
 8004b32:	300c      	adds	r0, #12
 * @api
 */
static inline void osalMutexUnlock(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxUnlock(mp);
 8004b34:	f7ff facc 	bl	80040d0 <chMtxUnlock>
}
 8004b38:	bd10      	pop	{r4, pc}
 8004b3a:	46c0      	nop			; (mov r8, r8)
 8004b3c:	0000      	movs	r0, r0
	...

08004b40 <i2sInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void i2sInit(void) {
 8004b40:	b510      	push	{r4, lr}

  i2s_lld_init();
 8004b42:	f001 fccd 	bl	80064e0 <i2s_lld_init>
}
 8004b46:	bd10      	pop	{r4, pc}
	...

08004b50 <i2sObjectInit>:
 *
 * @init
 */
void i2sObjectInit(I2SDriver *i2sp) {

  i2sp->state  = I2S_STOP;
 8004b50:	2301      	movs	r3, #1
 8004b52:	7003      	strb	r3, [r0, #0]
  i2sp->config = NULL;
 8004b54:	2300      	movs	r3, #0
 8004b56:	6043      	str	r3, [r0, #4]
}
 8004b58:	4770      	bx	lr
 8004b5a:	46c0      	nop			; (mov r8, r8)
 8004b5c:	0000      	movs	r0, r0
	...

08004b60 <i2sStart>:
 * @param[in] i2sp      pointer to the @p I2SDriver object
 * @param[in] config    pointer to the @p I2SConfig object
 *
 * @api
 */
void i2sStart(I2SDriver *i2sp, const I2SConfig *config) {
 8004b60:	b510      	push	{r4, lr}
 8004b62:	0004      	movs	r4, r0
  __ASM volatile ("cpsid i" : : : "memory");
 8004b64:	b672      	cpsid	i
  osalDbgCheck((i2sp != NULL) && (config != NULL));

  osalSysLock();
  osalDbgAssert((i2sp->state == I2S_STOP) || (i2sp->state == I2S_READY),
                "invalid state");
  i2sp->config = config;
 8004b66:	6041      	str	r1, [r0, #4]
  i2s_lld_start(i2sp);
 8004b68:	f001 fcda 	bl	8006520 <i2s_lld_start>
  i2sp->state = I2S_READY;
 8004b6c:	2302      	movs	r3, #2
 8004b6e:	7023      	strb	r3, [r4, #0]
  __ASM volatile ("cpsie i" : : : "memory");
 8004b70:	b662      	cpsie	i
  osalSysUnlock();
}
 8004b72:	bd10      	pop	{r4, pc}
	...

08004b80 <i2sStartExchange>:
 *
 * @param[in] i2sp      pointer to the @p I2SDriver object
 *
 * @api
 */
void i2sStartExchange(I2SDriver *i2sp) {
 8004b80:	b510      	push	{r4, lr}
 8004b82:	0004      	movs	r4, r0
  __ASM volatile ("cpsid i" : : : "memory");
 8004b84:	b672      	cpsid	i

  osalDbgCheck(i2sp != NULL);

  osalSysLock();
  osalDbgAssert(i2sp->state == I2S_READY, "not ready");
  i2sStartExchangeI(i2sp);
 8004b86:	f001 fd03 	bl	8006590 <i2s_lld_start_exchange>
 8004b8a:	2303      	movs	r3, #3
 8004b8c:	7023      	strb	r3, [r4, #0]
  __ASM volatile ("cpsie i" : : : "memory");
 8004b8e:	b662      	cpsie	i
  osalSysUnlock();
}
 8004b90:	bd10      	pop	{r4, pc}
 8004b92:	46c0      	nop			; (mov r8, r8)
	...

08004ba0 <rtcInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void rtcInit(void) {
 8004ba0:	b510      	push	{r4, lr}

  rtc_lld_init();
 8004ba2:	f001 fc3d 	bl	8006420 <rtc_lld_init>
}
 8004ba6:	bd10      	pop	{r4, pc}
	...

08004bb0 <rtcObjectInit>:
#if RTC_HAS_STORAGE == TRUE
  rtcp->vmt = &_rtc_lld_vmt;
#else
  (void)rtcp;
#endif
}
 8004bb0:	4770      	bx	lr
 8004bb2:	46c0      	nop			; (mov r8, r8)
	...

08004bc0 <readt>:
static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
}

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {
 8004bc0:	b510      	push	{r4, lr}

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
 8004bc2:	300c      	adds	r0, #12
 8004bc4:	f7ff fe04 	bl	80047d0 <iqReadTimeout>
}
 8004bc8:	bd10      	pop	{r4, pc}
 8004bca:	46c0      	nop			; (mov r8, r8)
 8004bcc:	0000      	movs	r0, r0
	...

08004bd0 <read>:
  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 8004bd0:	2301      	movs	r3, #1
static size_t read(void *ip, uint8_t *bp, size_t n) {
 8004bd2:	b510      	push	{r4, lr}
  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 8004bd4:	300c      	adds	r0, #12
 8004bd6:	425b      	negs	r3, r3
 8004bd8:	f7ff fdfa 	bl	80047d0 <iqReadTimeout>
}
 8004bdc:	bd10      	pop	{r4, pc}
 8004bde:	46c0      	nop			; (mov r8, r8)

08004be0 <writet>:
static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {
 8004be0:	b510      	push	{r4, lr}
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
 8004be2:	3030      	adds	r0, #48	; 0x30
 8004be4:	f7ff fea4 	bl	8004930 <oqWriteTimeout>
}
 8004be8:	bd10      	pop	{r4, pc}
 8004bea:	46c0      	nop			; (mov r8, r8)
 8004bec:	0000      	movs	r0, r0
	...

08004bf0 <write>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 8004bf0:	2301      	movs	r3, #1
static size_t write(void *ip, const uint8_t *bp, size_t n) {
 8004bf2:	b510      	push	{r4, lr}
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 8004bf4:	3030      	adds	r0, #48	; 0x30
 8004bf6:	425b      	negs	r3, r3
 8004bf8:	f7ff fe9a 	bl	8004930 <oqWriteTimeout>
}
 8004bfc:	bd10      	pop	{r4, pc}
 8004bfe:	46c0      	nop			; (mov r8, r8)

08004c00 <gett>:
static msg_t gett(void *ip, systime_t timeout) {
 8004c00:	b510      	push	{r4, lr}
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 8004c02:	300c      	adds	r0, #12
 8004c04:	f7ff fdbc 	bl	8004780 <iqGetTimeout>
}
 8004c08:	bd10      	pop	{r4, pc}
 8004c0a:	46c0      	nop			; (mov r8, r8)
 8004c0c:	0000      	movs	r0, r0
	...

08004c10 <get>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 8004c10:	2101      	movs	r1, #1
static msg_t get(void *ip) {
 8004c12:	b510      	push	{r4, lr}
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 8004c14:	300c      	adds	r0, #12
 8004c16:	4249      	negs	r1, r1
 8004c18:	f7ff fdb2 	bl	8004780 <iqGetTimeout>
}
 8004c1c:	bd10      	pop	{r4, pc}
 8004c1e:	46c0      	nop			; (mov r8, r8)

08004c20 <putt>:
static msg_t putt(void *ip, uint8_t b, systime_t timeout) {
 8004c20:	b510      	push	{r4, lr}
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 8004c22:	3030      	adds	r0, #48	; 0x30
 8004c24:	f7ff fe3c 	bl	80048a0 <oqPutTimeout>
}
 8004c28:	bd10      	pop	{r4, pc}
 8004c2a:	46c0      	nop			; (mov r8, r8)
 8004c2c:	0000      	movs	r0, r0
	...

08004c30 <put>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 8004c30:	2201      	movs	r2, #1
static msg_t put(void *ip, uint8_t b) {
 8004c32:	b510      	push	{r4, lr}
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 8004c34:	3030      	adds	r0, #48	; 0x30
 8004c36:	4252      	negs	r2, r2
 8004c38:	f7ff fe32 	bl	80048a0 <oqPutTimeout>
}
 8004c3c:	bd10      	pop	{r4, pc}
 8004c3e:	46c0      	nop			; (mov r8, r8)

08004c40 <sdInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void sdInit(void) {
 8004c40:	b510      	push	{r4, lr}

  sd_lld_init();
 8004c42:	f001 fe05 	bl	8006850 <sd_lld_init>
}
 8004c46:	bd10      	pop	{r4, pc}
	...

08004c50 <sdObjectInit>:
 *                      some data is written in the Queue. The value can be
 *                      @p NULL.
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
 8004c50:	b530      	push	{r4, r5, lr}
 8004c52:	0015      	movs	r5, r2

  sdp->vmt = &vmt;
 8004c54:	0002      	movs	r2, r0
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
 8004c56:	000b      	movs	r3, r1
  sdp->vmt = &vmt;
 8004c58:	490c      	ldr	r1, [pc, #48]	; (8004c8c <sdObjectInit+0x3c>)
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
 8004c5a:	0004      	movs	r4, r0
  sdp->vmt = &vmt;
 8004c5c:	c202      	stmia	r2!, {r1}
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->next = (event_listener_t *)esp;
 8004c5e:	6042      	str	r2, [r0, #4]
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
 8004c60:	0001      	movs	r1, r0
  sdp->state = SD_STOP;
 8004c62:	2201      	movs	r2, #1
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
 8004c64:	b083      	sub	sp, #12
  sdp->state = SD_STOP;
 8004c66:	7202      	strb	r2, [r0, #8]
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
 8004c68:	3154      	adds	r1, #84	; 0x54
 8004c6a:	300c      	adds	r0, #12
 8004c6c:	9400      	str	r4, [sp, #0]
 8004c6e:	320f      	adds	r2, #15
 8004c70:	f7ff fd56 	bl	8004720 <iqObjectInit>
  oqObjectInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
 8004c74:	0021      	movs	r1, r4
 8004c76:	0020      	movs	r0, r4
 8004c78:	3164      	adds	r1, #100	; 0x64
 8004c7a:	3030      	adds	r0, #48	; 0x30
 8004c7c:	9400      	str	r4, [sp, #0]
 8004c7e:	002b      	movs	r3, r5
 8004c80:	2210      	movs	r2, #16
 8004c82:	f7ff fdfd 	bl	8004880 <oqObjectInit>
}
 8004c86:	b003      	add	sp, #12
 8004c88:	bd30      	pop	{r4, r5, pc}
 8004c8a:	46c0      	nop			; (mov r8, r8)
 8004c8c:	080135fc 	.word	0x080135fc

08004c90 <sdIncomingDataI>:
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
 8004c90:	6943      	ldr	r3, [r0, #20]
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
 8004c92:	b570      	push	{r4, r5, r6, lr}
 8004c94:	0004      	movs	r4, r0
 8004c96:	000d      	movs	r5, r1
  if (iqIsEmptyI(&sdp->iqueue))
 8004c98:	2b00      	cmp	r3, #0
 8004c9a:	d007      	beq.n	8004cac <sdIncomingDataI+0x1c>
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
  if (iqPutI(&sdp->iqueue, b) < MSG_OK)
 8004c9c:	0020      	movs	r0, r4
 8004c9e:	0029      	movs	r1, r5
 8004ca0:	300c      	adds	r0, #12
 8004ca2:	f7ff fd4d 	bl	8004740 <iqPutI>
 8004ca6:	2800      	cmp	r0, #0
 8004ca8:	db0b      	blt.n	8004cc2 <sdIncomingDataI+0x32>
    chnAddFlagsI(sdp, SD_OVERRUN_ERROR);
}
 8004caa:	bd70      	pop	{r4, r5, r6, pc}
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
 8004cac:	3004      	adds	r0, #4
  chEvtBroadcastFlagsI(esp, flags);
 8004cae:	2104      	movs	r1, #4
 8004cb0:	f7ff fa5e 	bl	8004170 <chEvtBroadcastFlagsI>
  if (iqPutI(&sdp->iqueue, b) < MSG_OK)
 8004cb4:	0020      	movs	r0, r4
 8004cb6:	0029      	movs	r1, r5
 8004cb8:	300c      	adds	r0, #12
 8004cba:	f7ff fd41 	bl	8004740 <iqPutI>
 8004cbe:	2800      	cmp	r0, #0
 8004cc0:	daf3      	bge.n	8004caa <sdIncomingDataI+0x1a>
    chnAddFlagsI(sdp, SD_OVERRUN_ERROR);
 8004cc2:	1d20      	adds	r0, r4, #4
 8004cc4:	2180      	movs	r1, #128	; 0x80
 8004cc6:	f7ff fa53 	bl	8004170 <chEvtBroadcastFlagsI>
}
 8004cca:	e7ee      	b.n	8004caa <sdIncomingDataI+0x1a>
 8004ccc:	0000      	movs	r0, r0
	...

08004cd0 <obnotify>:
/**
 * @brief   Notification of filled buffer inserted into the output buffers queue.
 *
 * @param[in] bqp       the buffers queue pointer.
 */
static void obnotify(io_buffers_queue_t *bqp) {
 8004cd0:	b530      	push	{r4, r5, lr}
  size_t n;
  SerialUSBDriver *sdup = bqGetLinkX(bqp);

  /* If the USB driver is not in the appropriate state then transactions
     must not be started.*/
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 8004cd2:	25be      	movs	r5, #190	; 0xbe
  SerialUSBDriver *sdup = bqGetLinkX(bqp);
 8004cd4:	6b04      	ldr	r4, [r0, #48]	; 0x30
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 8004cd6:	006d      	lsls	r5, r5, #1
 8004cd8:	5962      	ldr	r2, [r4, r5]
static void obnotify(io_buffers_queue_t *bqp) {
 8004cda:	b083      	sub	sp, #12
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 8004cdc:	6813      	ldr	r3, [r2, #0]
 8004cde:	7819      	ldrb	r1, [r3, #0]
 8004ce0:	2904      	cmp	r1, #4
 8004ce2:	d102      	bne.n	8004cea <obnotify+0x1a>
 8004ce4:	7a21      	ldrb	r1, [r4, #8]
 8004ce6:	2902      	cmp	r1, #2
 8004ce8:	d001      	beq.n	8004cee <obnotify+0x1e>
    if (buf != NULL) {
      /* Buffer found, starting a new transaction.*/
      usbStartTransmitI(sdup->config->usbp, sdup->config->bulk_in, buf, n);
    }
  }
}
 8004cea:	b003      	add	sp, #12
 8004cec:	bd30      	pop	{r4, r5, pc}
  if (!usbGetTransmitStatusI(sdup->config->usbp, sdup->config->bulk_in)) {
 8004cee:	7911      	ldrb	r1, [r2, #4]
 8004cf0:	2201      	movs	r2, #1
 8004cf2:	408a      	lsls	r2, r1
 8004cf4:	891b      	ldrh	r3, [r3, #8]
 8004cf6:	4213      	tst	r3, r2
 8004cf8:	d1f7      	bne.n	8004cea <obnotify+0x1a>
    uint8_t *buf = obqGetFullBufferI(&sdup->obqueue, &n);
 8004cfa:	0020      	movs	r0, r4
 8004cfc:	a901      	add	r1, sp, #4
 8004cfe:	3040      	adds	r0, #64	; 0x40
 8004d00:	f7ff fbf6 	bl	80044f0 <obqGetFullBufferI>
 8004d04:	1e02      	subs	r2, r0, #0
    if (buf != NULL) {
 8004d06:	d0f0      	beq.n	8004cea <obnotify+0x1a>
      usbStartTransmitI(sdup->config->usbp, sdup->config->bulk_in, buf, n);
 8004d08:	5963      	ldr	r3, [r4, r5]
 8004d0a:	7919      	ldrb	r1, [r3, #4]
 8004d0c:	6818      	ldr	r0, [r3, #0]
 8004d0e:	9b01      	ldr	r3, [sp, #4]
 8004d10:	f000 fa9e 	bl	8005250 <usbStartTransmitI>
 8004d14:	e7e9      	b.n	8004cea <obnotify+0x1a>
 8004d16:	46c0      	nop			; (mov r8, r8)
	...

08004d20 <ibnotify>:
static void ibnotify(io_buffers_queue_t *bqp) {
 8004d20:	b570      	push	{r4, r5, r6, lr}
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 8004d22:	25be      	movs	r5, #190	; 0xbe
  SerialUSBDriver *sdup = bqGetLinkX(bqp);
 8004d24:	6b04      	ldr	r4, [r0, #48]	; 0x30
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 8004d26:	006d      	lsls	r5, r5, #1
 8004d28:	5962      	ldr	r2, [r4, r5]
 8004d2a:	6813      	ldr	r3, [r2, #0]
 8004d2c:	7819      	ldrb	r1, [r3, #0]
 8004d2e:	2904      	cmp	r1, #4
 8004d30:	d102      	bne.n	8004d38 <ibnotify+0x18>
 8004d32:	7a21      	ldrb	r1, [r4, #8]
 8004d34:	2902      	cmp	r1, #2
 8004d36:	d000      	beq.n	8004d3a <ibnotify+0x1a>
}
 8004d38:	bd70      	pop	{r4, r5, r6, pc}
  if (!usbGetReceiveStatusI(sdup->config->usbp, sdup->config->bulk_out)) {
 8004d3a:	7951      	ldrb	r1, [r2, #5]
 8004d3c:	2201      	movs	r2, #1
 8004d3e:	408a      	lsls	r2, r1
 8004d40:	895b      	ldrh	r3, [r3, #10]
 8004d42:	4213      	tst	r3, r2
 8004d44:	d1f8      	bne.n	8004d38 <ibnotify+0x18>
    uint8_t *buf = ibqGetEmptyBufferI(&sdup->ibqueue);
 8004d46:	0020      	movs	r0, r4
 8004d48:	300c      	adds	r0, #12
 8004d4a:	f7ff fac1 	bl	80042d0 <ibqGetEmptyBufferI>
 8004d4e:	1e02      	subs	r2, r0, #0
    if (buf != NULL) {
 8004d50:	d0f2      	beq.n	8004d38 <ibnotify+0x18>
      usbStartReceiveI(sdup->config->usbp, sdup->config->bulk_out,
 8004d52:	5963      	ldr	r3, [r4, r5]
 8004d54:	7959      	ldrb	r1, [r3, #5]
 8004d56:	6818      	ldr	r0, [r3, #0]
 8004d58:	2380      	movs	r3, #128	; 0x80
 8004d5a:	f000 fa61 	bl	8005220 <usbStartReceiveI>
 8004d5e:	e7eb      	b.n	8004d38 <ibnotify+0x18>

08004d60 <readt>:
static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {
 8004d60:	b570      	push	{r4, r5, r6, lr}
 8004d62:	0004      	movs	r4, r0
  if (usbGetDriverStateI(((SerialUSBDriver *)ip)->config->usbp) != USB_ACTIVE) {
 8004d64:	20be      	movs	r0, #190	; 0xbe
 8004d66:	0040      	lsls	r0, r0, #1
 8004d68:	5820      	ldr	r0, [r4, r0]
 8004d6a:	6800      	ldr	r0, [r0, #0]
 8004d6c:	7805      	ldrb	r5, [r0, #0]
    return 0;
 8004d6e:	2000      	movs	r0, #0
  if (usbGetDriverStateI(((SerialUSBDriver *)ip)->config->usbp) != USB_ACTIVE) {
 8004d70:	2d04      	cmp	r5, #4
 8004d72:	d000      	beq.n	8004d76 <readt+0x16>
}
 8004d74:	bd70      	pop	{r4, r5, r6, pc}
  return ibqReadTimeout(&((SerialUSBDriver *)ip)->ibqueue, bp, n, timeout);
 8004d76:	0020      	movs	r0, r4
 8004d78:	300c      	adds	r0, #12
 8004d7a:	f7ff fb19 	bl	80043b0 <ibqReadTimeout>
 8004d7e:	e7f9      	b.n	8004d74 <readt+0x14>

08004d80 <writet>:
static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {
 8004d80:	b570      	push	{r4, r5, r6, lr}
 8004d82:	0004      	movs	r4, r0
  if (usbGetDriverStateI(((SerialUSBDriver *)ip)->config->usbp) != USB_ACTIVE) {
 8004d84:	20be      	movs	r0, #190	; 0xbe
 8004d86:	0040      	lsls	r0, r0, #1
 8004d88:	5820      	ldr	r0, [r4, r0]
 8004d8a:	6800      	ldr	r0, [r0, #0]
 8004d8c:	7805      	ldrb	r5, [r0, #0]
    return 0;
 8004d8e:	2000      	movs	r0, #0
  if (usbGetDriverStateI(((SerialUSBDriver *)ip)->config->usbp) != USB_ACTIVE) {
 8004d90:	2d04      	cmp	r5, #4
 8004d92:	d000      	beq.n	8004d96 <writet+0x16>
}
 8004d94:	bd70      	pop	{r4, r5, r6, pc}
  return obqWriteTimeout(&((SerialUSBDriver *)ip)->obqueue, bp, n, timeout);
 8004d96:	0020      	movs	r0, r4
 8004d98:	3040      	adds	r0, #64	; 0x40
 8004d9a:	f7ff fc21 	bl	80045e0 <obqWriteTimeout>
 8004d9e:	e7f9      	b.n	8004d94 <writet+0x14>

08004da0 <gett>:
  if (usbGetDriverStateI(((SerialUSBDriver *)ip)->config->usbp) != USB_ACTIVE) {
 8004da0:	23be      	movs	r3, #190	; 0xbe
 8004da2:	005b      	lsls	r3, r3, #1
 8004da4:	58c3      	ldr	r3, [r0, r3]
static msg_t gett(void *ip, systime_t timeout) {
 8004da6:	b510      	push	{r4, lr}
  if (usbGetDriverStateI(((SerialUSBDriver *)ip)->config->usbp) != USB_ACTIVE) {
 8004da8:	681b      	ldr	r3, [r3, #0]
 8004daa:	781b      	ldrb	r3, [r3, #0]
 8004dac:	2b04      	cmp	r3, #4
 8004dae:	d103      	bne.n	8004db8 <gett+0x18>
  return ibqGetTimeout(&((SerialUSBDriver *)ip)->ibqueue, timeout);
 8004db0:	300c      	adds	r0, #12
 8004db2:	f7ff facd 	bl	8004350 <ibqGetTimeout>
}
 8004db6:	bd10      	pop	{r4, pc}
    return MSG_RESET;
 8004db8:	2002      	movs	r0, #2
 8004dba:	4240      	negs	r0, r0
 8004dbc:	e7fb      	b.n	8004db6 <gett+0x16>
 8004dbe:	46c0      	nop			; (mov r8, r8)

08004dc0 <get>:
  if (usbGetDriverStateI(((SerialUSBDriver *)ip)->config->usbp) != USB_ACTIVE) {
 8004dc0:	23be      	movs	r3, #190	; 0xbe
 8004dc2:	005b      	lsls	r3, r3, #1
 8004dc4:	58c3      	ldr	r3, [r0, r3]
static msg_t get(void *ip) {
 8004dc6:	b510      	push	{r4, lr}
  if (usbGetDriverStateI(((SerialUSBDriver *)ip)->config->usbp) != USB_ACTIVE) {
 8004dc8:	681b      	ldr	r3, [r3, #0]
 8004dca:	781b      	ldrb	r3, [r3, #0]
 8004dcc:	2b04      	cmp	r3, #4
 8004dce:	d105      	bne.n	8004ddc <get+0x1c>
  return ibqGetTimeout(&((SerialUSBDriver *)ip)->ibqueue, TIME_INFINITE);
 8004dd0:	2101      	movs	r1, #1
 8004dd2:	300c      	adds	r0, #12
 8004dd4:	4249      	negs	r1, r1
 8004dd6:	f7ff fabb 	bl	8004350 <ibqGetTimeout>
}
 8004dda:	bd10      	pop	{r4, pc}
    return MSG_RESET;
 8004ddc:	2002      	movs	r0, #2
 8004dde:	4240      	negs	r0, r0
 8004de0:	e7fb      	b.n	8004dda <get+0x1a>
 8004de2:	46c0      	nop			; (mov r8, r8)
	...

08004df0 <putt>:
  if (usbGetDriverStateI(((SerialUSBDriver *)ip)->config->usbp) != USB_ACTIVE) {
 8004df0:	23be      	movs	r3, #190	; 0xbe
 8004df2:	005b      	lsls	r3, r3, #1
 8004df4:	58c3      	ldr	r3, [r0, r3]
static msg_t putt(void *ip, uint8_t b, systime_t timeout) {
 8004df6:	b510      	push	{r4, lr}
  if (usbGetDriverStateI(((SerialUSBDriver *)ip)->config->usbp) != USB_ACTIVE) {
 8004df8:	681b      	ldr	r3, [r3, #0]
 8004dfa:	781b      	ldrb	r3, [r3, #0]
 8004dfc:	2b04      	cmp	r3, #4
 8004dfe:	d103      	bne.n	8004e08 <putt+0x18>
  return obqPutTimeout(&((SerialUSBDriver *)ip)->obqueue, b, timeout);
 8004e00:	3040      	adds	r0, #64	; 0x40
 8004e02:	f7ff fbb5 	bl	8004570 <obqPutTimeout>
}
 8004e06:	bd10      	pop	{r4, pc}
    return MSG_RESET;
 8004e08:	2002      	movs	r0, #2
 8004e0a:	4240      	negs	r0, r0
 8004e0c:	e7fb      	b.n	8004e06 <putt+0x16>
 8004e0e:	46c0      	nop			; (mov r8, r8)

08004e10 <put>:
  if (usbGetDriverStateI(((SerialUSBDriver *)ip)->config->usbp) != USB_ACTIVE) {
 8004e10:	23be      	movs	r3, #190	; 0xbe
 8004e12:	005b      	lsls	r3, r3, #1
 8004e14:	58c3      	ldr	r3, [r0, r3]
static msg_t put(void *ip, uint8_t b) {
 8004e16:	b510      	push	{r4, lr}
  if (usbGetDriverStateI(((SerialUSBDriver *)ip)->config->usbp) != USB_ACTIVE) {
 8004e18:	681b      	ldr	r3, [r3, #0]
 8004e1a:	781b      	ldrb	r3, [r3, #0]
 8004e1c:	2b04      	cmp	r3, #4
 8004e1e:	d105      	bne.n	8004e2c <put+0x1c>
  return obqPutTimeout(&((SerialUSBDriver *)ip)->obqueue, b, TIME_INFINITE);
 8004e20:	2201      	movs	r2, #1
 8004e22:	3040      	adds	r0, #64	; 0x40
 8004e24:	4252      	negs	r2, r2
 8004e26:	f7ff fba3 	bl	8004570 <obqPutTimeout>
}
 8004e2a:	bd10      	pop	{r4, pc}
    return MSG_RESET;
 8004e2c:	2002      	movs	r0, #2
 8004e2e:	4240      	negs	r0, r0
 8004e30:	e7fb      	b.n	8004e2a <put+0x1a>
 8004e32:	46c0      	nop			; (mov r8, r8)
	...

08004e40 <read>:
static size_t read(void *ip, uint8_t *bp, size_t n) {
 8004e40:	0003      	movs	r3, r0
  if (usbGetDriverStateI(((SerialUSBDriver *)ip)->config->usbp) != USB_ACTIVE) {
 8004e42:	20be      	movs	r0, #190	; 0xbe
 8004e44:	0040      	lsls	r0, r0, #1
 8004e46:	5818      	ldr	r0, [r3, r0]
static size_t read(void *ip, uint8_t *bp, size_t n) {
 8004e48:	b510      	push	{r4, lr}
  if (usbGetDriverStateI(((SerialUSBDriver *)ip)->config->usbp) != USB_ACTIVE) {
 8004e4a:	6800      	ldr	r0, [r0, #0]
 8004e4c:	7804      	ldrb	r4, [r0, #0]
    return 0;
 8004e4e:	2000      	movs	r0, #0
  if (usbGetDriverStateI(((SerialUSBDriver *)ip)->config->usbp) != USB_ACTIVE) {
 8004e50:	2c04      	cmp	r4, #4
 8004e52:	d000      	beq.n	8004e56 <read+0x16>
}
 8004e54:	bd10      	pop	{r4, pc}
  return ibqReadTimeout(&((SerialUSBDriver *)ip)->ibqueue, bp,
 8004e56:	330c      	adds	r3, #12
 8004e58:	0018      	movs	r0, r3
 8004e5a:	2301      	movs	r3, #1
 8004e5c:	425b      	negs	r3, r3
 8004e5e:	f7ff faa7 	bl	80043b0 <ibqReadTimeout>
 8004e62:	e7f7      	b.n	8004e54 <read+0x14>
	...

08004e70 <write>:
static size_t write(void *ip, const uint8_t *bp, size_t n) {
 8004e70:	0003      	movs	r3, r0
  if (usbGetDriverStateI(((SerialUSBDriver *)ip)->config->usbp) != USB_ACTIVE) {
 8004e72:	20be      	movs	r0, #190	; 0xbe
 8004e74:	0040      	lsls	r0, r0, #1
 8004e76:	5818      	ldr	r0, [r3, r0]
static size_t write(void *ip, const uint8_t *bp, size_t n) {
 8004e78:	b510      	push	{r4, lr}
  if (usbGetDriverStateI(((SerialUSBDriver *)ip)->config->usbp) != USB_ACTIVE) {
 8004e7a:	6800      	ldr	r0, [r0, #0]
 8004e7c:	7804      	ldrb	r4, [r0, #0]
    return 0;
 8004e7e:	2000      	movs	r0, #0
  if (usbGetDriverStateI(((SerialUSBDriver *)ip)->config->usbp) != USB_ACTIVE) {
 8004e80:	2c04      	cmp	r4, #4
 8004e82:	d000      	beq.n	8004e86 <write+0x16>
}
 8004e84:	bd10      	pop	{r4, pc}
  return obqWriteTimeout(&((SerialUSBDriver *)ip)->obqueue, bp,
 8004e86:	3340      	adds	r3, #64	; 0x40
 8004e88:	0018      	movs	r0, r3
 8004e8a:	2301      	movs	r3, #1
 8004e8c:	425b      	negs	r3, r3
 8004e8e:	f7ff fba7 	bl	80045e0 <obqWriteTimeout>
 8004e92:	e7f7      	b.n	8004e84 <write+0x14>
	...

08004ea0 <sduInit>:
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void sduInit(void) {
}
 8004ea0:	4770      	bx	lr
 8004ea2:	46c0      	nop			; (mov r8, r8)
	...

08004eb0 <sduObjectInit>:
 *
 * @init
 */
void sduObjectInit(SerialUSBDriver *sdup) {

  sdup->vmt = &vmt;
 8004eb0:	0003      	movs	r3, r0
 8004eb2:	4a0f      	ldr	r2, [pc, #60]	; (8004ef0 <sduObjectInit+0x40>)
void sduObjectInit(SerialUSBDriver *sdup) {
 8004eb4:	b510      	push	{r4, lr}
  sdup->vmt = &vmt;
 8004eb6:	c304      	stmia	r3!, {r2}
 8004eb8:	6043      	str	r3, [r0, #4]
  osalEventObjectInit(&sdup->event);
  sdup->state = SDU_STOP;
 8004eba:	2301      	movs	r3, #1
void sduObjectInit(SerialUSBDriver *sdup) {
 8004ebc:	0004      	movs	r4, r0
  ibqObjectInit(&sdup->ibqueue, sdup->ib,
 8004ebe:	0001      	movs	r1, r0
  sdup->state = SDU_STOP;
 8004ec0:	7203      	strb	r3, [r0, #8]
  ibqObjectInit(&sdup->ibqueue, sdup->ib,
 8004ec2:	4b0c      	ldr	r3, [pc, #48]	; (8004ef4 <sduObjectInit+0x44>)
void sduObjectInit(SerialUSBDriver *sdup) {
 8004ec4:	b082      	sub	sp, #8
  ibqObjectInit(&sdup->ibqueue, sdup->ib,
 8004ec6:	9300      	str	r3, [sp, #0]
 8004ec8:	3174      	adds	r1, #116	; 0x74
 8004eca:	300c      	adds	r0, #12
 8004ecc:	9401      	str	r4, [sp, #4]
 8004ece:	2301      	movs	r3, #1
 8004ed0:	2280      	movs	r2, #128	; 0x80
 8004ed2:	f7ff f9d5 	bl	8004280 <ibqObjectInit>
                SERIAL_USB_BUFFERS_SIZE, SERIAL_USB_BUFFERS_NUMBER,
                ibnotify, sdup);
  obqObjectInit(&sdup->obqueue, sdup->ob,
 8004ed6:	0021      	movs	r1, r4
 8004ed8:	0020      	movs	r0, r4
 8004eda:	4b07      	ldr	r3, [pc, #28]	; (8004ef8 <sduObjectInit+0x48>)
 8004edc:	31f8      	adds	r1, #248	; 0xf8
 8004ede:	9300      	str	r3, [sp, #0]
 8004ee0:	3040      	adds	r0, #64	; 0x40
 8004ee2:	9401      	str	r4, [sp, #4]
 8004ee4:	2301      	movs	r3, #1
 8004ee6:	2280      	movs	r2, #128	; 0x80
 8004ee8:	f7ff fada 	bl	80044a0 <obqObjectInit>
                SERIAL_USB_BUFFERS_SIZE, SERIAL_USB_BUFFERS_NUMBER,
                obnotify, sdup);
}
 8004eec:	b002      	add	sp, #8
 8004eee:	bd10      	pop	{r4, pc}
 8004ef0:	0801361c 	.word	0x0801361c
 8004ef4:	08004d21 	.word	0x08004d21
 8004ef8:	08004cd1 	.word	0x08004cd1
 8004efc:	00000000 	.word	0x00000000

08004f00 <sduStart>:
 * @param[in] config    the serial over USB driver configuration
 *
 * @api
 */
void sduStart(SerialUSBDriver *sdup, const SerialUSBConfig *config) {
  USBDriver *usbp = config->usbp;
 8004f00:	680a      	ldr	r2, [r1, #0]
  __ASM volatile ("cpsid i" : : : "memory");
 8004f02:	b672      	cpsid	i
  osalDbgCheck(sdup != NULL);

  osalSysLock();
  osalDbgAssert((sdup->state == SDU_STOP) || (sdup->state == SDU_READY),
                "invalid state");
  usbp->in_params[config->bulk_in - 1U]   = sdup;
 8004f04:	790b      	ldrb	r3, [r1, #4]
 8004f06:	3309      	adds	r3, #9
 8004f08:	009b      	lsls	r3, r3, #2
 8004f0a:	18d3      	adds	r3, r2, r3
 8004f0c:	6058      	str	r0, [r3, #4]
  usbp->out_params[config->bulk_out - 1U] = sdup;
 8004f0e:	794b      	ldrb	r3, [r1, #5]
 8004f10:	3311      	adds	r3, #17
 8004f12:	009b      	lsls	r3, r3, #2
 8004f14:	5098      	str	r0, [r3, r2]
  if (config->int_in > 0U) {
 8004f16:	798b      	ldrb	r3, [r1, #6]
 8004f18:	2b00      	cmp	r3, #0
 8004f1a:	d003      	beq.n	8004f24 <sduStart+0x24>
    usbp->in_params[config->int_in - 1U]  = sdup;
 8004f1c:	3309      	adds	r3, #9
 8004f1e:	009b      	lsls	r3, r3, #2
 8004f20:	18d2      	adds	r2, r2, r3
 8004f22:	6050      	str	r0, [r2, #4]
  }
  sdup->config = config;
 8004f24:	23be      	movs	r3, #190	; 0xbe
 8004f26:	005b      	lsls	r3, r3, #1
 8004f28:	50c1      	str	r1, [r0, r3]
  sdup->state = SDU_READY;
 8004f2a:	3b7b      	subs	r3, #123	; 0x7b
 8004f2c:	3bff      	subs	r3, #255	; 0xff
 8004f2e:	7203      	strb	r3, [r0, #8]
  __ASM volatile ("cpsie i" : : : "memory");
 8004f30:	b662      	cpsie	i
  osalSysUnlock();
}
 8004f32:	4770      	bx	lr
	...

08004f40 <sduDisconnectI>:
 *
 * @param[in] sdup      pointer to a @p SerialUSBDriver object
 *
 * @iclass
 */
void sduDisconnectI(SerialUSBDriver *sdup) {
 8004f40:	b510      	push	{r4, lr}
 8004f42:	0004      	movs	r4, r0
 8004f44:	2102      	movs	r1, #2

  /* Queues reset in order to signal the driver stop to the application.*/
  chnAddFlagsI(sdup, CHN_DISCONNECTED);
 8004f46:	3004      	adds	r0, #4
 8004f48:	f7ff f912 	bl	8004170 <chEvtBroadcastFlagsI>
  ibqResetI(&sdup->ibqueue);
 8004f4c:	0020      	movs	r0, r4
 8004f4e:	300c      	adds	r0, #12
 8004f50:	f7ff f9ae 	bl	80042b0 <ibqResetI>
  obqResetI(&sdup->obqueue);
 8004f54:	0020      	movs	r0, r4
 8004f56:	3040      	adds	r0, #64	; 0x40
 8004f58:	f7ff faba 	bl	80044d0 <obqResetI>
}
 8004f5c:	bd10      	pop	{r4, pc}
 8004f5e:	46c0      	nop			; (mov r8, r8)

08004f60 <sduConfigureHookI>:
 *
 * @param[in] sdup      pointer to a @p SerialUSBDriver object
 *
 * @iclass
 */
void sduConfigureHookI(SerialUSBDriver *sdup) {
 8004f60:	b570      	push	{r4, r5, r6, lr}
  uint8_t *buf;

  ibqResetI(&sdup->ibqueue);
 8004f62:	0005      	movs	r5, r0
void sduConfigureHookI(SerialUSBDriver *sdup) {
 8004f64:	0004      	movs	r4, r0
  ibqResetI(&sdup->ibqueue);
 8004f66:	350c      	adds	r5, #12
 8004f68:	0028      	movs	r0, r5
 8004f6a:	f7ff f9a1 	bl	80042b0 <ibqResetI>
  obqResetI(&sdup->obqueue);
 8004f6e:	0020      	movs	r0, r4
 8004f70:	3040      	adds	r0, #64	; 0x40
 8004f72:	f7ff faad 	bl	80044d0 <obqResetI>
  chnAddFlagsI(sdup, CHN_CONNECTED);
 8004f76:	1d20      	adds	r0, r4, #4
 8004f78:	2101      	movs	r1, #1
 8004f7a:	f7ff f8f9 	bl	8004170 <chEvtBroadcastFlagsI>

  /* Starts the first OUT transaction immediately.*/
  buf = ibqGetEmptyBufferI(&sdup->ibqueue);
 8004f7e:	0028      	movs	r0, r5
 8004f80:	f7ff f9a6 	bl	80042d0 <ibqGetEmptyBufferI>

  osalDbgAssert(buf != NULL, "no free buffer");

  usbStartReceiveI(sdup->config->usbp, sdup->config->bulk_out,
 8004f84:	23be      	movs	r3, #190	; 0xbe
 8004f86:	005b      	lsls	r3, r3, #1
 8004f88:	58e3      	ldr	r3, [r4, r3]
  buf = ibqGetEmptyBufferI(&sdup->ibqueue);
 8004f8a:	0002      	movs	r2, r0
  usbStartReceiveI(sdup->config->usbp, sdup->config->bulk_out,
 8004f8c:	7959      	ldrb	r1, [r3, #5]
 8004f8e:	6818      	ldr	r0, [r3, #0]
 8004f90:	2380      	movs	r3, #128	; 0x80
 8004f92:	f000 f945 	bl	8005220 <usbStartReceiveI>
                   buf, SERIAL_USB_BUFFERS_SIZE);
}
 8004f96:	bd70      	pop	{r4, r5, r6, pc}
	...

08004fa0 <sduRequestsHook>:
 * @retval true         Message handled internally.
 * @retval false        Message not handled.
 */
bool sduRequestsHook(USBDriver *usbp) {

  if ((usbp->setup[0] & USB_RTYPE_TYPE_MASK) == USB_RTYPE_TYPE_CLASS) {
 8004fa0:	2374      	movs	r3, #116	; 0x74
 8004fa2:	5cc1      	ldrb	r1, [r0, r3]
 8004fa4:	3b14      	subs	r3, #20
bool sduRequestsHook(USBDriver *usbp) {
 8004fa6:	0002      	movs	r2, r0
  if ((usbp->setup[0] & USB_RTYPE_TYPE_MASK) == USB_RTYPE_TYPE_CLASS) {
 8004fa8:	400b      	ands	r3, r1
      return true;
    default:
      return false;
    }
  }
  return false;
 8004faa:	2000      	movs	r0, #0
  if ((usbp->setup[0] & USB_RTYPE_TYPE_MASK) == USB_RTYPE_TYPE_CLASS) {
 8004fac:	2b20      	cmp	r3, #32
 8004fae:	d000      	beq.n	8004fb2 <sduRequestsHook+0x12>
}
 8004fb0:	4770      	bx	lr
    switch (usbp->setup[1]) {
 8004fb2:	3355      	adds	r3, #85	; 0x55
 8004fb4:	5cd3      	ldrb	r3, [r2, r3]
 8004fb6:	2b20      	cmp	r3, #32
 8004fb8:	d3fa      	bcc.n	8004fb0 <sduRequestsHook+0x10>
 8004fba:	2b21      	cmp	r3, #33	; 0x21
 8004fbc:	d806      	bhi.n	8004fcc <sduRequestsHook+0x2c>
      usbSetupTransfer(usbp, (uint8_t *)&linecoding, sizeof(linecoding), NULL);
 8004fbe:	4b07      	ldr	r3, [pc, #28]	; (8004fdc <sduRequestsHook+0x3c>)
 8004fc0:	6710      	str	r0, [r2, #112]	; 0x70
 8004fc2:	6693      	str	r3, [r2, #104]	; 0x68
 8004fc4:	2307      	movs	r3, #7
      return true;
 8004fc6:	2001      	movs	r0, #1
      usbSetupTransfer(usbp, (uint8_t *)&linecoding, sizeof(linecoding), NULL);
 8004fc8:	66d3      	str	r3, [r2, #108]	; 0x6c
      return true;
 8004fca:	e7f1      	b.n	8004fb0 <sduRequestsHook+0x10>
    switch (usbp->setup[1]) {
 8004fcc:	2b22      	cmp	r3, #34	; 0x22
 8004fce:	d1ef      	bne.n	8004fb0 <sduRequestsHook+0x10>
      usbSetupTransfer(usbp, NULL, 0, NULL);
 8004fd0:	6690      	str	r0, [r2, #104]	; 0x68
 8004fd2:	66d0      	str	r0, [r2, #108]	; 0x6c
 8004fd4:	6710      	str	r0, [r2, #112]	; 0x70
      return true;
 8004fd6:	2001      	movs	r0, #1
 8004fd8:	e7ea      	b.n	8004fb0 <sduRequestsHook+0x10>
 8004fda:	46c0      	nop			; (mov r8, r8)
 8004fdc:	20000400 	.word	0x20000400

08004fe0 <sduSOFHookI>:
 *
 * @param[in] sdup      pointer to a @p SerialUSBDriver object
 *
 * @iclass
 */
void sduSOFHookI(SerialUSBDriver *sdup) {
 8004fe0:	b570      	push	{r4, r5, r6, lr}

  /* If the USB driver is not in the appropriate state then transactions
     must not be started.*/
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 8004fe2:	25be      	movs	r5, #190	; 0xbe
 8004fe4:	006d      	lsls	r5, r5, #1
 8004fe6:	5942      	ldr	r2, [r0, r5]
void sduSOFHookI(SerialUSBDriver *sdup) {
 8004fe8:	b082      	sub	sp, #8
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 8004fea:	6813      	ldr	r3, [r2, #0]
void sduSOFHookI(SerialUSBDriver *sdup) {
 8004fec:	0004      	movs	r4, r0
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 8004fee:	7819      	ldrb	r1, [r3, #0]
 8004ff0:	2904      	cmp	r1, #4
 8004ff2:	d102      	bne.n	8004ffa <sduSOFHookI+0x1a>
 8004ff4:	7a01      	ldrb	r1, [r0, #8]
 8004ff6:	2902      	cmp	r1, #2
 8004ff8:	d001      	beq.n	8004ffe <sduSOFHookI+0x1e>

    osalDbgAssert(buf != NULL, "queue is empty");

    usbStartTransmitI(sdup->config->usbp, sdup->config->bulk_in, buf, n);
  }
}
 8004ffa:	b002      	add	sp, #8
 8004ffc:	bd70      	pop	{r4, r5, r6, pc}
  if (usbGetTransmitStatusI(sdup->config->usbp, sdup->config->bulk_in)) {
 8004ffe:	7911      	ldrb	r1, [r2, #4]
 8005000:	2201      	movs	r2, #1
 8005002:	408a      	lsls	r2, r1
 8005004:	891b      	ldrh	r3, [r3, #8]
 8005006:	4213      	tst	r3, r2
 8005008:	d1f7      	bne.n	8004ffa <sduSOFHookI+0x1a>
  if (obqTryFlushI(&sdup->obqueue)) {
 800500a:	0006      	movs	r6, r0
 800500c:	3640      	adds	r6, #64	; 0x40
 800500e:	0030      	movs	r0, r6
 8005010:	f7ff fb5e 	bl	80046d0 <obqTryFlushI>
 8005014:	2800      	cmp	r0, #0
 8005016:	d0f0      	beq.n	8004ffa <sduSOFHookI+0x1a>
    uint8_t *buf = obqGetFullBufferI(&sdup->obqueue, &n);
 8005018:	a901      	add	r1, sp, #4
 800501a:	0030      	movs	r0, r6
 800501c:	f7ff fa68 	bl	80044f0 <obqGetFullBufferI>
    usbStartTransmitI(sdup->config->usbp, sdup->config->bulk_in, buf, n);
 8005020:	5963      	ldr	r3, [r4, r5]
    uint8_t *buf = obqGetFullBufferI(&sdup->obqueue, &n);
 8005022:	0002      	movs	r2, r0
    usbStartTransmitI(sdup->config->usbp, sdup->config->bulk_in, buf, n);
 8005024:	7919      	ldrb	r1, [r3, #4]
 8005026:	6818      	ldr	r0, [r3, #0]
 8005028:	9b01      	ldr	r3, [sp, #4]
 800502a:	f000 f911 	bl	8005250 <usbStartTransmitI>
 800502e:	e7e4      	b.n	8004ffa <sduSOFHookI+0x1a>

08005030 <sduDataTransmitted>:
 * @param[in] ep        IN endpoint number
 */
void sduDataTransmitted(USBDriver *usbp, usbep_t ep) {
  uint8_t *buf;
  size_t n;
  SerialUSBDriver *sdup = usbp->in_params[ep - 1U];
 8005030:	000b      	movs	r3, r1
void sduDataTransmitted(USBDriver *usbp, usbep_t ep) {
 8005032:	b5f0      	push	{r4, r5, r6, r7, lr}
  SerialUSBDriver *sdup = usbp->in_params[ep - 1U];
 8005034:	3309      	adds	r3, #9
 8005036:	009b      	lsls	r3, r3, #2
 8005038:	18c3      	adds	r3, r0, r3
 800503a:	685c      	ldr	r4, [r3, #4]
void sduDataTransmitted(USBDriver *usbp, usbep_t ep) {
 800503c:	b083      	sub	sp, #12
 800503e:	0005      	movs	r5, r0
 8005040:	000e      	movs	r6, r1

  if (sdup == NULL) {
 8005042:	2c00      	cmp	r4, #0
 8005044:	d019      	beq.n	800507a <sduDataTransmitted+0x4a>
  __ASM volatile ("cpsid i" : : : "memory");
 8005046:	b672      	cpsid	i
 8005048:	00b7      	lsls	r7, r6, #2
  }

  osalSysLockFromISR();

  /* Signaling that space is available in the output queue.*/
  chnAddFlagsI(sdup, CHN_OUTPUT_EMPTY);
 800504a:	1d20      	adds	r0, r4, #4
 800504c:	2108      	movs	r1, #8
 800504e:	19ef      	adds	r7, r5, r7
 8005050:	f7ff f88e 	bl	8004170 <chEvtBroadcastFlagsI>

  /* Freeing the buffer just transmitted, if it was not a zero size packet.*/
  if (usbp->epc[ep]->in_state->txsize > 0U) {
 8005054:	68fb      	ldr	r3, [r7, #12]
 8005056:	3440      	adds	r4, #64	; 0x40
 8005058:	695b      	ldr	r3, [r3, #20]
 800505a:	681b      	ldr	r3, [r3, #0]
 800505c:	2b00      	cmp	r3, #0
 800505e:	d11f      	bne.n	80050a0 <sduDataTransmitted+0x70>
    obqReleaseEmptyBufferI(&sdup->obqueue);
  }

  /* Checking if there is a buffer ready for transmission.*/
  buf = obqGetFullBufferI(&sdup->obqueue, &n);
 8005060:	a901      	add	r1, sp, #4
 8005062:	0020      	movs	r0, r4
 8005064:	f7ff fa44 	bl	80044f0 <obqGetFullBufferI>

  if (buf != NULL) {
 8005068:	2800      	cmp	r0, #0
 800506a:	d008      	beq.n	800507e <sduDataTransmitted+0x4e>
    /* The endpoint cannot be busy, we are in the context of the callback,
       so it is safe to transmit without a check.*/
    usbStartTransmitI(usbp, ep, buf, n);
 800506c:	0002      	movs	r2, r0
 800506e:	9b01      	ldr	r3, [sp, #4]
 8005070:	0031      	movs	r1, r6
 8005072:	0028      	movs	r0, r5
 8005074:	f000 f8ec 	bl	8005250 <usbStartTransmitI>
  __ASM volatile ("cpsie i" : : : "memory");
 8005078:	b662      	cpsie	i
  else {
    /* Nothing to transmit.*/
  }

  osalSysUnlockFromISR();
}
 800507a:	b003      	add	sp, #12
 800507c:	bdf0      	pop	{r4, r5, r6, r7, pc}
  else if ((usbp->epc[ep]->in_state->txsize > 0U) &&
 800507e:	68fa      	ldr	r2, [r7, #12]
 8005080:	6953      	ldr	r3, [r2, #20]
 8005082:	681b      	ldr	r3, [r3, #0]
 8005084:	2b00      	cmp	r3, #0
 8005086:	d0f7      	beq.n	8005078 <sduDataTransmitted+0x48>
            ((size_t)usbp->epc[ep]->in_maxsize - 1U)) == 0U)) {
 8005088:	8a12      	ldrh	r2, [r2, #16]
 800508a:	3a01      	subs	r2, #1
  else if ((usbp->epc[ep]->in_state->txsize > 0U) &&
 800508c:	4213      	tst	r3, r2
 800508e:	d1f3      	bne.n	8005078 <sduDataTransmitted+0x48>
    usbStartTransmitI(usbp, ep, usbp->setup, 0);
 8005090:	002a      	movs	r2, r5
 8005092:	2300      	movs	r3, #0
 8005094:	3274      	adds	r2, #116	; 0x74
 8005096:	0031      	movs	r1, r6
 8005098:	0028      	movs	r0, r5
 800509a:	f000 f8d9 	bl	8005250 <usbStartTransmitI>
 800509e:	e7eb      	b.n	8005078 <sduDataTransmitted+0x48>
    obqReleaseEmptyBufferI(&sdup->obqueue);
 80050a0:	0020      	movs	r0, r4
 80050a2:	f7ff fa35 	bl	8004510 <obqReleaseEmptyBufferI>
  buf = obqGetFullBufferI(&sdup->obqueue, &n);
 80050a6:	a901      	add	r1, sp, #4
 80050a8:	0020      	movs	r0, r4
 80050aa:	f7ff fa21 	bl	80044f0 <obqGetFullBufferI>
  if (buf != NULL) {
 80050ae:	2800      	cmp	r0, #0
 80050b0:	d1dc      	bne.n	800506c <sduDataTransmitted+0x3c>
 80050b2:	e7e4      	b.n	800507e <sduDataTransmitted+0x4e>
	...

080050c0 <sduDataReceived>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        OUT endpoint number
 */
void sduDataReceived(USBDriver *usbp, usbep_t ep) {
  uint8_t *buf;
  SerialUSBDriver *sdup = usbp->out_params[ep - 1U];
 80050c0:	3111      	adds	r1, #17
 80050c2:	0089      	lsls	r1, r1, #2
void sduDataReceived(USBDriver *usbp, usbep_t ep) {
 80050c4:	b570      	push	{r4, r5, r6, lr}
  SerialUSBDriver *sdup = usbp->out_params[ep - 1U];
 80050c6:	580c      	ldr	r4, [r1, r0]

  if (sdup == NULL) {
 80050c8:	2c00      	cmp	r4, #0
 80050ca:	d020      	beq.n	800510e <sduDataReceived+0x4e>
  __ASM volatile ("cpsid i" : : : "memory");
 80050cc:	b672      	cpsid	i
  /* Signaling that data is available in the input queue.*/
  chnAddFlagsI(sdup, CHN_INPUT_AVAILABLE);

  /* Posting the filled buffer in the queue.*/
  ibqPostFullBufferI(&sdup->ibqueue,
                     usbGetReceiveTransactionSizeX(sdup->config->usbp,
 80050ce:	26be      	movs	r6, #190	; 0xbe
  ibqPostFullBufferI(&sdup->ibqueue,
 80050d0:	0025      	movs	r5, r4
  chnAddFlagsI(sdup, CHN_INPUT_AVAILABLE);
 80050d2:	1d20      	adds	r0, r4, #4
 80050d4:	2104      	movs	r1, #4
                     usbGetReceiveTransactionSizeX(sdup->config->usbp,
 80050d6:	0076      	lsls	r6, r6, #1
 80050d8:	f7ff f84a 	bl	8004170 <chEvtBroadcastFlagsI>
 80050dc:	59a3      	ldr	r3, [r4, r6]
  ibqPostFullBufferI(&sdup->ibqueue,
 80050de:	350c      	adds	r5, #12
                     usbGetReceiveTransactionSizeX(sdup->config->usbp,
 80050e0:	681a      	ldr	r2, [r3, #0]
 80050e2:	795b      	ldrb	r3, [r3, #5]
  ibqPostFullBufferI(&sdup->ibqueue,
 80050e4:	0028      	movs	r0, r5
                     usbGetReceiveTransactionSizeX(sdup->config->usbp,
 80050e6:	3302      	adds	r3, #2
 80050e8:	009b      	lsls	r3, r3, #2
 80050ea:	18d3      	adds	r3, r2, r3
 80050ec:	685b      	ldr	r3, [r3, #4]
  ibqPostFullBufferI(&sdup->ibqueue,
 80050ee:	699b      	ldr	r3, [r3, #24]
 80050f0:	6859      	ldr	r1, [r3, #4]
 80050f2:	f7ff f8fd 	bl	80042f0 <ibqPostFullBufferI>
                                                   sdup->config->bulk_out));

  /* The endpoint cannot be busy, we are in the context of the callback,
     so a packet is in the buffer for sure. Trying to get a free buffer
     for the next transaction.*/
  buf = ibqGetEmptyBufferI(&sdup->ibqueue);
 80050f6:	0028      	movs	r0, r5
 80050f8:	f7ff f8ea 	bl	80042d0 <ibqGetEmptyBufferI>
 80050fc:	1e02      	subs	r2, r0, #0
  if (buf != NULL) {
 80050fe:	d005      	beq.n	800510c <sduDataReceived+0x4c>
    /* Buffer found, starting a new transaction.*/
    usbStartReceiveI(sdup->config->usbp, sdup->config->bulk_out,
 8005100:	59a3      	ldr	r3, [r4, r6]
 8005102:	7959      	ldrb	r1, [r3, #5]
 8005104:	6818      	ldr	r0, [r3, #0]
 8005106:	2380      	movs	r3, #128	; 0x80
 8005108:	f000 f88a 	bl	8005220 <usbStartReceiveI>
  __ASM volatile ("cpsie i" : : : "memory");
 800510c:	b662      	cpsie	i
                     buf, SERIAL_USB_BUFFERS_SIZE);
  }
  osalSysUnlockFromISR();
}
 800510e:	bd70      	pop	{r4, r5, r6, pc}

08005110 <sduInterruptTransmitted>:
 */
void sduInterruptTransmitted(USBDriver *usbp, usbep_t ep) {

  (void)usbp;
  (void)ep;
}
 8005110:	4770      	bx	lr
 8005112:	46c0      	nop			; (mov r8, r8)
	...

08005120 <spiInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void spiInit(void) {
 8005120:	b510      	push	{r4, lr}

  spi_lld_init();
 8005122:	f001 fa6d 	bl	8006600 <spi_lld_init>
}
 8005126:	bd10      	pop	{r4, pc}
	...

08005130 <spiObjectInit>:
 *
 * @init
 */
void spiObjectInit(SPIDriver *spip) {

  spip->state = SPI_STOP;
 8005130:	2301      	movs	r3, #1
void spiObjectInit(SPIDriver *spip) {
 8005132:	b510      	push	{r4, lr}
  spip->state = SPI_STOP;
 8005134:	7003      	strb	r3, [r0, #0]
  spip->config = NULL;
 8005136:	2300      	movs	r3, #0
 8005138:	6043      	str	r3, [r0, #4]
#if SPI_USE_WAIT == TRUE
  spip->thread = NULL;
 800513a:	6083      	str	r3, [r0, #8]
#endif
#if SPI_USE_MUTUAL_EXCLUSION == TRUE
  osalMutexObjectInit(&spip->mutex);
 800513c:	300c      	adds	r0, #12
  chMtxObjectInit(mp);
 800513e:	f7fe ff5f 	bl	8004000 <chMtxObjectInit>
#endif
#if defined(SPI_DRIVER_EXT_INIT_HOOK)
  SPI_DRIVER_EXT_INIT_HOOK(spip);
#endif
}
 8005142:	bd10      	pop	{r4, pc}
	...

08005150 <set_address>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 */
static void set_address(USBDriver *usbp) {

  usbp->address = usbp->setup[2];
 8005150:	2376      	movs	r3, #118	; 0x76
static void set_address(USBDriver *usbp) {
 8005152:	b510      	push	{r4, lr}
 8005154:	0004      	movs	r4, r0
  usbp->address = usbp->setup[2];
 8005156:	5cc2      	ldrb	r2, [r0, r3]
 8005158:	3308      	adds	r3, #8
 800515a:	54c2      	strb	r2, [r0, r3]
  usb_lld_set_address(usbp);
 800515c:	f001 fd28 	bl	8006bb0 <usb_lld_set_address>
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_ADDRESS);
 8005160:	6863      	ldr	r3, [r4, #4]
 8005162:	681b      	ldr	r3, [r3, #0]
 8005164:	2b00      	cmp	r3, #0
 8005166:	d002      	beq.n	800516e <set_address+0x1e>
 8005168:	2101      	movs	r1, #1
 800516a:	0020      	movs	r0, r4
 800516c:	4798      	blx	r3
  usbp->state = USB_SELECTED;
 800516e:	2303      	movs	r3, #3
 8005170:	7023      	strb	r3, [r4, #0]
}
 8005172:	bd10      	pop	{r4, pc}
	...

08005180 <usbInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void usbInit(void) {
 8005180:	b510      	push	{r4, lr}

  usb_lld_init();
 8005182:	f001 fce5 	bl	8006b50 <usb_lld_init>
}
 8005186:	bd10      	pop	{r4, pc}
	...

08005190 <usbObjectInit>:
 * @init
 */
void usbObjectInit(USBDriver *usbp) {
  unsigned i;

  usbp->state        = USB_STOP;
 8005190:	2301      	movs	r3, #1
 8005192:	7003      	strb	r3, [r0, #0]
  usbp->config       = NULL;
 8005194:	2300      	movs	r3, #0
 8005196:	0001      	movs	r1, r0
 8005198:	6043      	str	r3, [r0, #4]
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
 800519a:	0003      	movs	r3, r0
    usbp->in_params[i]  = NULL;
 800519c:	2200      	movs	r2, #0
 800519e:	332c      	adds	r3, #44	; 0x2c
 80051a0:	3148      	adds	r1, #72	; 0x48
 80051a2:	601a      	str	r2, [r3, #0]
    usbp->out_params[i] = NULL;
 80051a4:	61da      	str	r2, [r3, #28]
 80051a6:	3304      	adds	r3, #4
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
 80051a8:	428b      	cmp	r3, r1
 80051aa:	d1fa      	bne.n	80051a2 <usbObjectInit+0x12>
  }
  usbp->transmitting = 0;
 80051ac:	6082      	str	r2, [r0, #8]
  usbp->receiving    = 0;
}
 80051ae:	4770      	bx	lr

080051b0 <usbStart>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] config    pointer to the @p USBConfig object
 *
 * @api
 */
void usbStart(USBDriver *usbp, const USBConfig *config) {
 80051b0:	b510      	push	{r4, lr}
 80051b2:	0004      	movs	r4, r0
  __ASM volatile ("cpsid i" : : : "memory");
 80051b4:	b672      	cpsid	i
  osalSysLock();
  osalDbgAssert((usbp->state == USB_STOP) || (usbp->state == USB_READY),
                "invalid state");
  usbp->config = config;
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
    usbp->epc[i] = NULL;
 80051b6:	2300      	movs	r3, #0
  usbp->config = config;
 80051b8:	6041      	str	r1, [r0, #4]
    usbp->epc[i] = NULL;
 80051ba:	60c3      	str	r3, [r0, #12]
 80051bc:	6103      	str	r3, [r0, #16]
 80051be:	6143      	str	r3, [r0, #20]
 80051c0:	6183      	str	r3, [r0, #24]
 80051c2:	61c3      	str	r3, [r0, #28]
 80051c4:	6203      	str	r3, [r0, #32]
 80051c6:	6243      	str	r3, [r0, #36]	; 0x24
 80051c8:	6283      	str	r3, [r0, #40]	; 0x28
  }
  usb_lld_start(usbp);
 80051ca:	f001 fcc9 	bl	8006b60 <usb_lld_start>
  usbp->state = USB_READY;
 80051ce:	2302      	movs	r3, #2
 80051d0:	7023      	strb	r3, [r4, #0]
  __ASM volatile ("cpsie i" : : : "memory");
 80051d2:	b662      	cpsie	i
  osalSysUnlock();
}
 80051d4:	bd10      	pop	{r4, pc}
 80051d6:	46c0      	nop			; (mov r8, r8)
	...

080051e0 <usbInitEndpointI>:
  osalDbgAssert(usbp->state == USB_ACTIVE,
                "invalid state");
  osalDbgAssert(usbp->epc[ep] == NULL, "already initialized");

  /* Logically enabling the endpoint in the USBDriver structure.*/
  usbp->epc[ep] = epcp;
 80051e0:	1c8b      	adds	r3, r1, #2
 80051e2:	009b      	lsls	r3, r3, #2
                      const USBEndpointConfig *epcp) {
 80051e4:	b570      	push	{r4, r5, r6, lr}
  usbp->epc[ep] = epcp;
 80051e6:	18c3      	adds	r3, r0, r3
                      const USBEndpointConfig *epcp) {
 80051e8:	0005      	movs	r5, r0

  /* Clearing the state structures, custom fields as well.*/
  if (epcp->in_state != NULL) {
 80051ea:	6950      	ldr	r0, [r2, #20]
                      const USBEndpointConfig *epcp) {
 80051ec:	000e      	movs	r6, r1
 80051ee:	0014      	movs	r4, r2
  usbp->epc[ep] = epcp;
 80051f0:	605a      	str	r2, [r3, #4]
  if (epcp->in_state != NULL) {
 80051f2:	2800      	cmp	r0, #0
 80051f4:	d003      	beq.n	80051fe <usbInitEndpointI+0x1e>
    memset(epcp->in_state, 0, sizeof(USBInEndpointState));
 80051f6:	2210      	movs	r2, #16
 80051f8:	2100      	movs	r1, #0
 80051fa:	f00d ff79 	bl	80130f0 <memset>
  }
  if (epcp->out_state != NULL) {
 80051fe:	69a0      	ldr	r0, [r4, #24]
 8005200:	2800      	cmp	r0, #0
 8005202:	d003      	beq.n	800520c <usbInitEndpointI+0x2c>
    memset(epcp->out_state, 0, sizeof(USBOutEndpointState));
 8005204:	2210      	movs	r2, #16
 8005206:	2100      	movs	r1, #0
 8005208:	f00d ff72 	bl	80130f0 <memset>
  }

  /* Low level endpoint activation.*/
  usb_lld_init_endpoint(usbp, ep);
 800520c:	0031      	movs	r1, r6
 800520e:	0028      	movs	r0, r5
 8005210:	f001 fcde 	bl	8006bd0 <usb_lld_init_endpoint>
}
 8005214:	bd70      	pop	{r4, r5, r6, pc}
 8005216:	46c0      	nop			; (mov r8, r8)
	...

08005220 <usbStartReceiveI>:
 *                      the packet size because the excess is discarded.
 *
 * @iclass
 */
void usbStartReceiveI(USBDriver *usbp, usbep_t ep,
                      uint8_t *buf, size_t n) {
 8005220:	b570      	push	{r4, r5, r6, lr}
  osalDbgCheckClassI();
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
  //osalDbgAssert(!usbGetReceiveStatusI(usbp, ep), "already receiving");

  /* Marking the endpoint as active.*/
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8005222:	2501      	movs	r5, #1
 8005224:	408d      	lsls	r5, r1
 8005226:	8944      	ldrh	r4, [r0, #10]
 8005228:	432c      	orrs	r4, r5
 800522a:	8144      	strh	r4, [r0, #10]

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  osp = usbp->epc[ep]->out_state;
 800522c:	1c8c      	adds	r4, r1, #2
 800522e:	00a4      	lsls	r4, r4, #2
 8005230:	1904      	adds	r4, r0, r4
 8005232:	6864      	ldr	r4, [r4, #4]
 8005234:	69a4      	ldr	r4, [r4, #24]
  /*lint -restore*/
  osp->rxbuf  = buf;
  osp->rxsize = n;
 8005236:	6023      	str	r3, [r4, #0]
  osp->rxcnt  = 0;
 8005238:	2300      	movs	r3, #0
  osp->rxbuf  = buf;
 800523a:	60a2      	str	r2, [r4, #8]
  osp->rxcnt  = 0;
 800523c:	6063      	str	r3, [r4, #4]
#if USB_USE_WAIT == TRUE
  osp->thread = NULL;
#endif

  /* Starting transfer.*/
  usb_lld_start_out(usbp, ep);
 800523e:	f001 fdaf 	bl	8006da0 <usb_lld_start_out>
}
 8005242:	bd70      	pop	{r4, r5, r6, pc}
	...

08005250 <usbStartTransmitI>:
 * @param[in] n         transaction size
 *
 * @iclass
 */
void usbStartTransmitI(USBDriver *usbp, usbep_t ep,
                       const uint8_t *buf, size_t n) {
 8005250:	b570      	push	{r4, r5, r6, lr}
  osalDbgCheckClassI();
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
  //osalDbgAssert(!usbGetTransmitStatusI(usbp, ep), "already transmitting");

  /* Marking the endpoint as active.*/
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8005252:	2501      	movs	r5, #1
 8005254:	408d      	lsls	r5, r1
 8005256:	8904      	ldrh	r4, [r0, #8]
 8005258:	432c      	orrs	r4, r5
 800525a:	8104      	strh	r4, [r0, #8]

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  isp = usbp->epc[ep]->in_state;
 800525c:	1c8c      	adds	r4, r1, #2
 800525e:	00a4      	lsls	r4, r4, #2
 8005260:	1904      	adds	r4, r0, r4
 8005262:	6864      	ldr	r4, [r4, #4]
 8005264:	6964      	ldr	r4, [r4, #20]
  /*lint -restore*/
  isp->txbuf  = buf;
  isp->txsize = n;
 8005266:	6023      	str	r3, [r4, #0]
  isp->txcnt  = 0;
 8005268:	2300      	movs	r3, #0
  isp->txbuf  = buf;
 800526a:	60a2      	str	r2, [r4, #8]
  isp->txcnt  = 0;
 800526c:	6063      	str	r3, [r4, #4]
#if USB_USE_WAIT == TRUE
  isp->thread = NULL;
#endif

  /* Starting transfer.*/
  usb_lld_start_in(usbp, ep);
 800526e:	f001 fdbf 	bl	8006df0 <usb_lld_start_in>
}
 8005272:	bd70      	pop	{r4, r5, r6, pc}
	...

08005280 <_usb_reset>:
 */
void _usb_reset(USBDriver *usbp) {
  unsigned i;

  /* State transition.*/
  usbp->state         = USB_READY;
 8005280:	2302      	movs	r3, #2
void _usb_reset(USBDriver *usbp) {
 8005282:	b510      	push	{r4, lr}
#endif
    usbp->epc[i] = NULL;
  }

  /* EP0 state machine initialization.*/
  usbp->ep0state = USB_EP0_WAITING_SETUP;
 8005284:	2264      	movs	r2, #100	; 0x64
  usbp->state         = USB_READY;
 8005286:	7003      	strb	r3, [r0, #0]
  usbp->status        = 0;
 8005288:	2300      	movs	r3, #0
void _usb_reset(USBDriver *usbp) {
 800528a:	0004      	movs	r4, r0
  usbp->status        = 0;
 800528c:	67c3      	str	r3, [r0, #124]	; 0x7c
  usbp->transmitting  = 0;
 800528e:	6083      	str	r3, [r0, #8]
    usbp->epc[i] = NULL;
 8005290:	60c3      	str	r3, [r0, #12]
 8005292:	6103      	str	r3, [r0, #16]
 8005294:	6143      	str	r3, [r0, #20]
 8005296:	6183      	str	r3, [r0, #24]
 8005298:	61c3      	str	r3, [r0, #28]
 800529a:	6203      	str	r3, [r0, #32]
 800529c:	6243      	str	r3, [r0, #36]	; 0x24
 800529e:	6283      	str	r3, [r0, #40]	; 0x28
  usbp->ep0state = USB_EP0_WAITING_SETUP;
 80052a0:	5483      	strb	r3, [r0, r2]

  /* Low level reset.*/
  usb_lld_reset(usbp);
 80052a2:	f001 fd15 	bl	8006cd0 <usb_lld_reset>

  /* Notification of reset event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_RESET);
 80052a6:	6863      	ldr	r3, [r4, #4]
 80052a8:	681b      	ldr	r3, [r3, #0]
 80052aa:	2b00      	cmp	r3, #0
 80052ac:	d002      	beq.n	80052b4 <_usb_reset+0x34>
 80052ae:	2100      	movs	r1, #0
 80052b0:	0020      	movs	r0, r4
 80052b2:	4798      	blx	r3
}
 80052b4:	bd10      	pop	{r4, pc}
 80052b6:	46c0      	nop			; (mov r8, r8)
	...

080052c0 <_usb_suspend>:
 * @notapi
 */
void _usb_suspend(USBDriver *usbp) {

  /* State transition.*/
  usbp->state = USB_SUSPENDED;
 80052c0:	2305      	movs	r3, #5
 80052c2:	7003      	strb	r3, [r0, #0]

  /* Notification of suspend event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_SUSPEND);
 80052c4:	6843      	ldr	r3, [r0, #4]
void _usb_suspend(USBDriver *usbp) {
 80052c6:	b510      	push	{r4, lr}
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_SUSPEND);
 80052c8:	681b      	ldr	r3, [r3, #0]
 80052ca:	2b00      	cmp	r3, #0
 80052cc:	d001      	beq.n	80052d2 <_usb_suspend+0x12>
 80052ce:	2103      	movs	r1, #3
 80052d0:	4798      	blx	r3
        osalSysUnlockFromISR();
      }
    }
  }
#endif
}
 80052d2:	bd10      	pop	{r4, pc}
	...

080052e0 <_usb_wakeup>:
 * @notapi
 */
void _usb_wakeup(USBDriver *usbp) {

  /* State transition.*/
  usbp->state = USB_ACTIVE;
 80052e0:	2304      	movs	r3, #4
 80052e2:	7003      	strb	r3, [r0, #0]

  /* Notification of suspend event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_WAKEUP);
 80052e4:	6843      	ldr	r3, [r0, #4]
void _usb_wakeup(USBDriver *usbp) {
 80052e6:	b510      	push	{r4, lr}
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_WAKEUP);
 80052e8:	681b      	ldr	r3, [r3, #0]
 80052ea:	2b00      	cmp	r3, #0
 80052ec:	d001      	beq.n	80052f2 <_usb_wakeup+0x12>
 80052ee:	2104      	movs	r1, #4
 80052f0:	4798      	blx	r3
}
 80052f2:	bd10      	pop	{r4, pc}
	...

08005300 <_usb_ep0setup>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0setup(USBDriver *usbp, usbep_t ep) {
 8005300:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  size_t max;

  usbp->ep0state = USB_EP0_WAITING_SETUP;
 8005302:	2200      	movs	r2, #0
 8005304:	2364      	movs	r3, #100	; 0x64
 8005306:	54c2      	strb	r2, [r0, r3]
  usbReadSetup(usbp, ep, usbp->setup);
 8005308:	0002      	movs	r2, r0
void _usb_ep0setup(USBDriver *usbp, usbep_t ep) {
 800530a:	0004      	movs	r4, r0
  usbReadSetup(usbp, ep, usbp->setup);
 800530c:	3274      	adds	r2, #116	; 0x74
 800530e:	f001 fd27 	bl	8006d60 <usb_lld_read_setup>

  /* First verify if the application has an handler installed for this
     request.*/
  /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
  if ((usbp->config->requests_hook_cb == NULL) ||
 8005312:	6863      	ldr	r3, [r4, #4]
 8005314:	689b      	ldr	r3, [r3, #8]
 8005316:	2b00      	cmp	r3, #0
 8005318:	d02d      	beq.n	8005376 <_usb_ep0setup+0x76>
      !(usbp->config->requests_hook_cb(usbp))) {
 800531a:	0020      	movs	r0, r4
 800531c:	4798      	blx	r3
  if ((usbp->config->requests_hook_cb == NULL) ||
 800531e:	2800      	cmp	r0, #0
 8005320:	d029      	beq.n	8005376 <_usb_ep0setup+0x76>
 8005322:	2374      	movs	r3, #116	; 0x74
 8005324:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 8005326:	5ce3      	ldrb	r3, [r4, r3]
  hw |= (uint16_t)*p << 8U;
 8005328:	227b      	movs	r2, #123	; 0x7b
 800532a:	5ca1      	ldrb	r1, [r4, r2]
  hw  = (uint16_t)*p++;
 800532c:	3a01      	subs	r2, #1
  hw |= (uint16_t)*p << 8U;
 800532e:	5ca2      	ldrb	r2, [r4, r2]
 8005330:	0209      	lsls	r1, r1, #8
  }
#endif
  /* Transfer preparation. The request handler must have populated
     correctly the fields ep0next, ep0n and ep0endcb using the macro
     usbSetupTransfer().*/
  max = (size_t)get_hword(&usbp->setup[6]);
 8005332:	430a      	orrs	r2, r1
  /* The transfer size cannot exceed the specified amount.*/
  if (usbp->ep0n > max) {
 8005334:	4282      	cmp	r2, r0
 8005336:	d201      	bcs.n	800533c <_usb_ep0setup+0x3c>
    usbp->ep0n = max;
 8005338:	0010      	movs	r0, r2
 800533a:	66e2      	str	r2, [r4, #108]	; 0x6c
  }
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 800533c:	b25b      	sxtb	r3, r3
 800533e:	2b00      	cmp	r3, #0
 8005340:	da00      	bge.n	8005344 <_usb_ep0setup+0x44>
 8005342:	e099      	b.n	8005478 <_usb_ep0setup+0x178>
#endif
    }
  }
  else {
    /* OUT phase.*/
    if (usbp->ep0n != 0U) {
 8005344:	2800      	cmp	r0, #0
 8005346:	d100      	bne.n	800534a <_usb_ep0setup+0x4a>
 8005348:	e074      	b.n	8005434 <_usb_ep0setup+0x134>
      /* Starts the receive phase.*/
      usbp->ep0state = USB_EP0_RX;
 800534a:	2364      	movs	r3, #100	; 0x64
 800534c:	2204      	movs	r2, #4
 800534e:	54e2      	strb	r2, [r4, r3]
  __ASM volatile ("cpsid i" : : : "memory");
 8005350:	b672      	cpsid	i
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8005352:	2101      	movs	r1, #1
 8005354:	8963      	ldrh	r3, [r4, #10]
      osalSysLockFromISR();
      usbStartReceiveI(usbp, 0, usbp->ep0next, usbp->ep0n);
 8005356:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8005358:	430b      	orrs	r3, r1
 800535a:	8163      	strh	r3, [r4, #10]
  osp = usbp->epc[ep]->out_state;
 800535c:	68e3      	ldr	r3, [r4, #12]
  osp->rxbuf  = buf;
 800535e:	6ea1      	ldr	r1, [r4, #104]	; 0x68
  osp = usbp->epc[ep]->out_state;
 8005360:	699b      	ldr	r3, [r3, #24]
  osp->rxsize = n;
 8005362:	601a      	str	r2, [r3, #0]
  osp->rxcnt  = 0;
 8005364:	2200      	movs	r2, #0
  osp->rxbuf  = buf;
 8005366:	6099      	str	r1, [r3, #8]
  osp->rxcnt  = 0;
 8005368:	605a      	str	r2, [r3, #4]
  usb_lld_start_out(usbp, ep);
 800536a:	2100      	movs	r1, #0
 800536c:	0020      	movs	r0, r4
 800536e:	f001 fd17 	bl	8006da0 <usb_lld_start_out>
  __ASM volatile ("cpsie i" : : : "memory");
 8005372:	b662      	cpsie	i
 8005374:	e04e      	b.n	8005414 <_usb_ep0setup+0x114>
    if (((usbp->setup[0] & USB_RTYPE_TYPE_MASK) != USB_RTYPE_TYPE_STD) ||
 8005376:	2774      	movs	r7, #116	; 0x74
 8005378:	2660      	movs	r6, #96	; 0x60
 800537a:	5de3      	ldrb	r3, [r4, r7]
 800537c:	401e      	ands	r6, r3
 800537e:	d137      	bne.n	80053f0 <_usb_ep0setup+0xf0>
           ((uint32_t)usbp->setup[1] << 8U))) {
 8005380:	2275      	movs	r2, #117	; 0x75
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8005382:	217f      	movs	r1, #127	; 0x7f
           ((uint32_t)usbp->setup[1] << 8U))) {
 8005384:	5ca5      	ldrb	r5, [r4, r2]
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8005386:	000a      	movs	r2, r1
           ((uint32_t)usbp->setup[1] << 8U))) {
 8005388:	022d      	lsls	r5, r5, #8
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 800538a:	401a      	ands	r2, r3
                                        USB_RTYPE_TYPE_MASK)) |
 800538c:	4315      	orrs	r5, r2
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 800538e:	22c0      	movs	r2, #192	; 0xc0
 8005390:	0092      	lsls	r2, r2, #2
 8005392:	4295      	cmp	r5, r2
 8005394:	d100      	bne.n	8005398 <_usb_ep0setup+0x98>
 8005396:	e0cc      	b.n	8005532 <_usb_ep0setup+0x232>
 8005398:	d919      	bls.n	80053ce <_usb_ep0setup+0xce>
 800539a:	22c0      	movs	r2, #192	; 0xc0
 800539c:	00d2      	lsls	r2, r2, #3
 800539e:	4295      	cmp	r5, r2
 80053a0:	d100      	bne.n	80053a4 <_usb_ep0setup+0xa4>
 80053a2:	e0e6      	b.n	8005572 <_usb_ep0setup+0x272>
 80053a4:	d937      	bls.n	8005416 <_usb_ep0setup+0x116>
 80053a6:	2290      	movs	r2, #144	; 0x90
 80053a8:	0112      	lsls	r2, r2, #4
 80053aa:	4295      	cmp	r5, r2
 80053ac:	d100      	bne.n	80053b0 <_usb_ep0setup+0xb0>
 80053ae:	e0f8      	b.n	80055a2 <_usb_ep0setup+0x2a2>
 80053b0:	4a8e      	ldr	r2, [pc, #568]	; (80055ec <_usb_ep0setup+0x2ec>)
 80053b2:	4295      	cmp	r5, r2
 80053b4:	d058      	beq.n	8005468 <_usb_ep0setup+0x168>
 80053b6:	2280      	movs	r2, #128	; 0x80
 80053b8:	0112      	lsls	r2, r2, #4
 80053ba:	4295      	cmp	r5, r2
 80053bc:	d118      	bne.n	80053f0 <_usb_ep0setup+0xf0>
    usbSetupTransfer(usbp, &usbp->configuration, 1, NULL);
 80053be:	0022      	movs	r2, r4
 80053c0:	327f      	adds	r2, #127	; 0x7f
 80053c2:	66a2      	str	r2, [r4, #104]	; 0x68
 80053c4:	2201      	movs	r2, #1
 80053c6:	6726      	str	r6, [r4, #112]	; 0x70
 80053c8:	66e2      	str	r2, [r4, #108]	; 0x6c
 80053ca:	2001      	movs	r0, #1
 80053cc:	e7ac      	b.n	8005328 <_usb_ep0setup+0x28>
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 80053ce:	2d02      	cmp	r5, #2
 80053d0:	d100      	bne.n	80053d4 <_usb_ep0setup+0xd4>
 80053d2:	e08a      	b.n	80054ea <_usb_ep0setup+0x1ea>
 80053d4:	d93c      	bls.n	8005450 <_usb_ep0setup+0x150>
 80053d6:	2280      	movs	r2, #128	; 0x80
 80053d8:	0052      	lsls	r2, r2, #1
 80053da:	4295      	cmp	r5, r2
 80053dc:	d100      	bne.n	80053e0 <_usb_ep0setup+0xe0>
 80053de:	e09a      	b.n	8005516 <_usb_ep0setup+0x216>
 80053e0:	3202      	adds	r2, #2
 80053e2:	4295      	cmp	r5, r2
 80053e4:	d104      	bne.n	80053f0 <_usb_ep0setup+0xf0>
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
 80053e6:	2276      	movs	r2, #118	; 0x76
 80053e8:	5ca2      	ldrb	r2, [r4, r2]
 80053ea:	2a00      	cmp	r2, #0
 80053ec:	d100      	bne.n	80053f0 <_usb_ep0setup+0xf0>
 80053ee:	e069      	b.n	80054c4 <_usb_ep0setup+0x1c4>
      usb_lld_stall_in(usbp, 0);
 80053f0:	2100      	movs	r1, #0
 80053f2:	0020      	movs	r0, r4
 80053f4:	f001 fd5c 	bl	8006eb0 <usb_lld_stall_in>
      usb_lld_stall_out(usbp, 0);
 80053f8:	2100      	movs	r1, #0
 80053fa:	0020      	movs	r0, r4
 80053fc:	f001 fd40 	bl	8006e80 <usb_lld_stall_out>
      _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 8005400:	6863      	ldr	r3, [r4, #4]
 8005402:	681b      	ldr	r3, [r3, #0]
 8005404:	2b00      	cmp	r3, #0
 8005406:	d002      	beq.n	800540e <_usb_ep0setup+0x10e>
 8005408:	2105      	movs	r1, #5
 800540a:	0020      	movs	r0, r4
 800540c:	4798      	blx	r3
      usbp->ep0state = USB_EP0_ERROR;
 800540e:	2364      	movs	r3, #100	; 0x64
 8005410:	2206      	movs	r2, #6
 8005412:	54e2      	strb	r2, [r4, r3]
#else
      usb_lld_end_setup(usbp, ep);
#endif
    }
  }
}
 8005414:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8005416:	4a76      	ldr	r2, [pc, #472]	; (80055f0 <_usb_ep0setup+0x2f0>)
 8005418:	4295      	cmp	r5, r2
 800541a:	d100      	bne.n	800541e <_usb_ep0setup+0x11e>
 800541c:	e097      	b.n	800554e <_usb_ep0setup+0x24e>
 800541e:	32ff      	adds	r2, #255	; 0xff
 8005420:	32ff      	adds	r2, #255	; 0xff
 8005422:	4295      	cmp	r5, r2
 8005424:	d1e4      	bne.n	80053f0 <_usb_ep0setup+0xf0>
    usbSetupTransfer(usbp, NULL, 0, set_address);
 8005426:	4a73      	ldr	r2, [pc, #460]	; (80055f4 <_usb_ep0setup+0x2f4>)
 8005428:	66a6      	str	r6, [r4, #104]	; 0x68
 800542a:	66e6      	str	r6, [r4, #108]	; 0x6c
 800542c:	6722      	str	r2, [r4, #112]	; 0x70
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 800542e:	b25b      	sxtb	r3, r3
 8005430:	2b00      	cmp	r3, #0
 8005432:	db39      	blt.n	80054a8 <_usb_ep0setup+0x1a8>
      usbp->ep0state = USB_EP0_SENDING_STS;
 8005434:	2364      	movs	r3, #100	; 0x64
 8005436:	2205      	movs	r2, #5
 8005438:	54e2      	strb	r2, [r4, r3]
  __ASM volatile ("cpsid i" : : : "memory");
 800543a:	b672      	cpsid	i
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 800543c:	2201      	movs	r2, #1
 800543e:	8923      	ldrh	r3, [r4, #8]
 8005440:	4313      	orrs	r3, r2
  isp->txbuf  = buf;
 8005442:	2200      	movs	r2, #0
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8005444:	8123      	strh	r3, [r4, #8]
  isp = usbp->epc[ep]->in_state;
 8005446:	68e3      	ldr	r3, [r4, #12]
 8005448:	695b      	ldr	r3, [r3, #20]
  isp->txbuf  = buf;
 800544a:	609a      	str	r2, [r3, #8]
  isp->txsize = n;
 800544c:	601a      	str	r2, [r3, #0]
 800544e:	e024      	b.n	800549a <_usb_ep0setup+0x19a>
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8005450:	2d00      	cmp	r5, #0
 8005452:	d107      	bne.n	8005464 <_usb_ep0setup+0x164>
    usbSetupTransfer(usbp, (uint8_t *)&usbp->status, 2, NULL);
 8005454:	0022      	movs	r2, r4
 8005456:	327c      	adds	r2, #124	; 0x7c
 8005458:	66a2      	str	r2, [r4, #104]	; 0x68
 800545a:	2202      	movs	r2, #2
 800545c:	6725      	str	r5, [r4, #112]	; 0x70
 800545e:	66e2      	str	r2, [r4, #108]	; 0x6c
 8005460:	2002      	movs	r0, #2
 8005462:	e761      	b.n	8005328 <_usb_ep0setup+0x28>
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8005464:	2d01      	cmp	r5, #1
 8005466:	d1c3      	bne.n	80053f0 <_usb_ep0setup+0xf0>
    usbSetupTransfer(usbp, (uint8_t *)zero_status, 2, NULL);
 8005468:	4a63      	ldr	r2, [pc, #396]	; (80055f8 <_usb_ep0setup+0x2f8>)
 800546a:	2002      	movs	r0, #2
 800546c:	66a2      	str	r2, [r4, #104]	; 0x68
 800546e:	2202      	movs	r2, #2
 8005470:	66e2      	str	r2, [r4, #108]	; 0x6c
 8005472:	2200      	movs	r2, #0
 8005474:	6722      	str	r2, [r4, #112]	; 0x70
    return true;
 8005476:	e757      	b.n	8005328 <_usb_ep0setup+0x28>
    if (usbp->ep0n != 0U) {
 8005478:	2800      	cmp	r0, #0
 800547a:	d015      	beq.n	80054a8 <_usb_ep0setup+0x1a8>
      usbp->ep0state = USB_EP0_TX;
 800547c:	2364      	movs	r3, #100	; 0x64
 800547e:	2201      	movs	r2, #1
 8005480:	54e2      	strb	r2, [r4, r3]
 8005482:	b672      	cpsid	i
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8005484:	2101      	movs	r1, #1
 8005486:	8923      	ldrh	r3, [r4, #8]
      usbStartTransmitI(usbp, 0, usbp->ep0next, usbp->ep0n);
 8005488:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 800548a:	430b      	orrs	r3, r1
 800548c:	8123      	strh	r3, [r4, #8]
  isp = usbp->epc[ep]->in_state;
 800548e:	68e3      	ldr	r3, [r4, #12]
  isp->txbuf  = buf;
 8005490:	6ea1      	ldr	r1, [r4, #104]	; 0x68
  isp = usbp->epc[ep]->in_state;
 8005492:	695b      	ldr	r3, [r3, #20]
  isp->txsize = n;
 8005494:	601a      	str	r2, [r3, #0]
  isp->txcnt  = 0;
 8005496:	2200      	movs	r2, #0
  isp->txbuf  = buf;
 8005498:	6099      	str	r1, [r3, #8]
  isp->txcnt  = 0;
 800549a:	605a      	str	r2, [r3, #4]
  usb_lld_start_in(usbp, ep);
 800549c:	2100      	movs	r1, #0
 800549e:	0020      	movs	r0, r4
 80054a0:	f001 fca6 	bl	8006df0 <usb_lld_start_in>
  __ASM volatile ("cpsie i" : : : "memory");
 80054a4:	b662      	cpsie	i
 80054a6:	e7b5      	b.n	8005414 <_usb_ep0setup+0x114>
      usbp->ep0state = USB_EP0_WAITING_STS;
 80054a8:	2364      	movs	r3, #100	; 0x64
 80054aa:	2203      	movs	r2, #3
 80054ac:	54e2      	strb	r2, [r4, r3]
  __ASM volatile ("cpsid i" : : : "memory");
 80054ae:	b672      	cpsid	i
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 80054b0:	2201      	movs	r2, #1
 80054b2:	8963      	ldrh	r3, [r4, #10]
 80054b4:	4313      	orrs	r3, r2
  osp->rxbuf  = buf;
 80054b6:	2200      	movs	r2, #0
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 80054b8:	8163      	strh	r3, [r4, #10]
  osp = usbp->epc[ep]->out_state;
 80054ba:	68e3      	ldr	r3, [r4, #12]
 80054bc:	699b      	ldr	r3, [r3, #24]
  osp->rxbuf  = buf;
 80054be:	609a      	str	r2, [r3, #8]
  osp->rxsize = n;
 80054c0:	601a      	str	r2, [r3, #0]
  osp->rxcnt  = 0;
 80054c2:	e751      	b.n	8005368 <_usb_ep0setup+0x68>
    if ((usbp->setup[4] & 0x0FU) != 0U) {
 80054c4:	210f      	movs	r1, #15
 80054c6:	3278      	adds	r2, #120	; 0x78
 80054c8:	5ca2      	ldrb	r2, [r4, r2]
 80054ca:	4011      	ands	r1, r2
 80054cc:	d008      	beq.n	80054e0 <_usb_ep0setup+0x1e0>
      if ((usbp->setup[4] & 0x80U) != 0U) {
 80054ce:	b252      	sxtb	r2, r2
        usb_lld_clear_in(usbp, usbp->setup[4] & 0x0FU);
 80054d0:	0020      	movs	r0, r4
      if ((usbp->setup[4] & 0x80U) != 0U) {
 80054d2:	2a00      	cmp	r2, #0
 80054d4:	da00      	bge.n	80054d8 <_usb_ep0setup+0x1d8>
 80054d6:	e07f      	b.n	80055d8 <_usb_ep0setup+0x2d8>
        usb_lld_clear_out(usbp, usbp->setup[4] & 0x0FU);
 80054d8:	f001 fd02 	bl	8006ee0 <usb_lld_clear_out>
 80054dc:	2374      	movs	r3, #116	; 0x74
 80054de:	5ce3      	ldrb	r3, [r4, r3]
    usbSetupTransfer(usbp, NULL, 0, NULL);
 80054e0:	2200      	movs	r2, #0
 80054e2:	66a2      	str	r2, [r4, #104]	; 0x68
 80054e4:	66e2      	str	r2, [r4, #108]	; 0x6c
 80054e6:	6722      	str	r2, [r4, #112]	; 0x70
    return true;
 80054e8:	e7a1      	b.n	800542e <_usb_ep0setup+0x12e>
    if ((usbp->setup[4] & 0x80U) != 0U) {
 80054ea:	2378      	movs	r3, #120	; 0x78
 80054ec:	210f      	movs	r1, #15
 80054ee:	5ce3      	ldrb	r3, [r4, r3]
      switch (usb_lld_get_status_in(usbp, usbp->setup[4] & 0x0FU)) {
 80054f0:	0020      	movs	r0, r4
 80054f2:	4019      	ands	r1, r3
    if ((usbp->setup[4] & 0x80U) != 0U) {
 80054f4:	b25b      	sxtb	r3, r3
 80054f6:	2b00      	cmp	r3, #0
 80054f8:	db63      	blt.n	80055c2 <_usb_ep0setup+0x2c2>
      switch (usb_lld_get_status_out(usbp, usbp->setup[4] & 0x0FU)) {
 80054fa:	f001 fc09 	bl	8006d10 <usb_lld_get_status_out>
 80054fe:	2801      	cmp	r0, #1
 8005500:	d063      	beq.n	80055ca <_usb_ep0setup+0x2ca>
 8005502:	2802      	cmp	r0, #2
 8005504:	d000      	beq.n	8005508 <_usb_ep0setup+0x208>
 8005506:	e773      	b.n	80053f0 <_usb_ep0setup+0xf0>
        usbSetupTransfer(usbp, (uint8_t *)active_status, 2, NULL);
 8005508:	4b3c      	ldr	r3, [pc, #240]	; (80055fc <_usb_ep0setup+0x2fc>)
 800550a:	66e0      	str	r0, [r4, #108]	; 0x6c
 800550c:	66a3      	str	r3, [r4, #104]	; 0x68
 800550e:	6726      	str	r6, [r4, #112]	; 0x70
        return true;
 8005510:	5de3      	ldrb	r3, [r4, r7]
        usbSetupTransfer(usbp, (uint8_t *)active_status, 2, NULL);
 8005512:	2002      	movs	r0, #2
 8005514:	e708      	b.n	8005328 <_usb_ep0setup+0x28>
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 8005516:	2276      	movs	r2, #118	; 0x76
 8005518:	5ca2      	ldrb	r2, [r4, r2]
 800551a:	2a01      	cmp	r2, #1
 800551c:	d000      	beq.n	8005520 <_usb_ep0setup+0x220>
 800551e:	e767      	b.n	80053f0 <_usb_ep0setup+0xf0>
      usbp->status &= ~2U;
 8005520:	217c      	movs	r1, #124	; 0x7c
 8005522:	2002      	movs	r0, #2
 8005524:	5a62      	ldrh	r2, [r4, r1]
 8005526:	4382      	bics	r2, r0
 8005528:	5262      	strh	r2, [r4, r1]
      usbSetupTransfer(usbp, NULL, 0, NULL);
 800552a:	66a6      	str	r6, [r4, #104]	; 0x68
 800552c:	66e6      	str	r6, [r4, #108]	; 0x6c
 800552e:	6726      	str	r6, [r4, #112]	; 0x70
      return true;
 8005530:	e77d      	b.n	800542e <_usb_ep0setup+0x12e>
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 8005532:	2276      	movs	r2, #118	; 0x76
 8005534:	5ca2      	ldrb	r2, [r4, r2]
 8005536:	2a01      	cmp	r2, #1
 8005538:	d000      	beq.n	800553c <_usb_ep0setup+0x23c>
 800553a:	e759      	b.n	80053f0 <_usb_ep0setup+0xf0>
      usbp->status |= 2U;
 800553c:	217c      	movs	r1, #124	; 0x7c
 800553e:	2002      	movs	r0, #2
 8005540:	5a62      	ldrh	r2, [r4, r1]
 8005542:	4302      	orrs	r2, r0
 8005544:	5262      	strh	r2, [r4, r1]
      usbSetupTransfer(usbp, NULL, 0, NULL);
 8005546:	66a6      	str	r6, [r4, #104]	; 0x68
 8005548:	66e6      	str	r6, [r4, #108]	; 0x6c
 800554a:	6726      	str	r6, [r4, #112]	; 0x70
      return true;
 800554c:	e76f      	b.n	800542e <_usb_ep0setup+0x12e>
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
 800554e:	2276      	movs	r2, #118	; 0x76
 8005550:	5ca2      	ldrb	r2, [r4, r2]
 8005552:	2a00      	cmp	r2, #0
 8005554:	d000      	beq.n	8005558 <_usb_ep0setup+0x258>
 8005556:	e74b      	b.n	80053f0 <_usb_ep0setup+0xf0>
    if ((usbp->setup[4] & 0x0FU) != 0U) {
 8005558:	210f      	movs	r1, #15
 800555a:	3278      	adds	r2, #120	; 0x78
 800555c:	5ca2      	ldrb	r2, [r4, r2]
 800555e:	4011      	ands	r1, r2
 8005560:	d0be      	beq.n	80054e0 <_usb_ep0setup+0x1e0>
      if ((usbp->setup[4] & 0x80U) != 0U) {
 8005562:	b252      	sxtb	r2, r2
        usb_lld_stall_in(usbp, usbp->setup[4] & 0x0FU);
 8005564:	0020      	movs	r0, r4
      if ((usbp->setup[4] & 0x80U) != 0U) {
 8005566:	2a00      	cmp	r2, #0
 8005568:	db3b      	blt.n	80055e2 <_usb_ep0setup+0x2e2>
        usb_lld_stall_out(usbp, usbp->setup[4] & 0x0FU);
 800556a:	f001 fc89 	bl	8006e80 <usb_lld_stall_out>
 800556e:	5de3      	ldrb	r3, [r4, r7]
 8005570:	e7b6      	b.n	80054e0 <_usb_ep0setup+0x1e0>
  hw |= (uint16_t)*p << 8U;
 8005572:	2379      	movs	r3, #121	; 0x79
 8005574:	5ce2      	ldrb	r2, [r4, r3]
  hw  = (uint16_t)*p++;
 8005576:	3b01      	subs	r3, #1
  hw |= (uint16_t)*p << 8U;
 8005578:	5ce3      	ldrb	r3, [r4, r3]
 800557a:	0212      	lsls	r2, r2, #8
    dp = usbp->config->get_descriptor_cb(usbp, usbp->setup[3],
 800557c:	4313      	orrs	r3, r2
 800557e:	2177      	movs	r1, #119	; 0x77
 8005580:	2276      	movs	r2, #118	; 0x76
 8005582:	6860      	ldr	r0, [r4, #4]
 8005584:	5ca2      	ldrb	r2, [r4, r2]
 8005586:	6845      	ldr	r5, [r0, #4]
 8005588:	5c61      	ldrb	r1, [r4, r1]
 800558a:	0020      	movs	r0, r4
 800558c:	47a8      	blx	r5
    if (dp == NULL) {
 800558e:	2800      	cmp	r0, #0
 8005590:	d100      	bne.n	8005594 <_usb_ep0setup+0x294>
 8005592:	e72d      	b.n	80053f0 <_usb_ep0setup+0xf0>
    usbSetupTransfer(usbp, (uint8_t *)dp->ud_string, dp->ud_size, NULL);
 8005594:	6843      	ldr	r3, [r0, #4]
 8005596:	6800      	ldr	r0, [r0, #0]
 8005598:	66a3      	str	r3, [r4, #104]	; 0x68
 800559a:	66e0      	str	r0, [r4, #108]	; 0x6c
 800559c:	6726      	str	r6, [r4, #112]	; 0x70
    return true;
 800559e:	5de3      	ldrb	r3, [r4, r7]
 80055a0:	e6c2      	b.n	8005328 <_usb_ep0setup+0x28>
    usbp->configuration = usbp->setup[2];
 80055a2:	2276      	movs	r2, #118	; 0x76
 80055a4:	5ca2      	ldrb	r2, [r4, r2]
 80055a6:	5462      	strb	r2, [r4, r1]
      usbp->state = USB_ACTIVE;
 80055a8:	1e51      	subs	r1, r2, #1
 80055aa:	418a      	sbcs	r2, r1
 80055ac:	3203      	adds	r2, #3
 80055ae:	7022      	strb	r2, [r4, #0]
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_CONFIGURED);
 80055b0:	6862      	ldr	r2, [r4, #4]
 80055b2:	6812      	ldr	r2, [r2, #0]
 80055b4:	2a00      	cmp	r2, #0
 80055b6:	d093      	beq.n	80054e0 <_usb_ep0setup+0x1e0>
 80055b8:	2102      	movs	r1, #2
 80055ba:	0020      	movs	r0, r4
 80055bc:	4790      	blx	r2
 80055be:	5de3      	ldrb	r3, [r4, r7]
    usbSetupTransfer(usbp, NULL, 0, NULL);
 80055c0:	e78e      	b.n	80054e0 <_usb_ep0setup+0x1e0>
      switch (usb_lld_get_status_in(usbp, usbp->setup[4] & 0x0FU)) {
 80055c2:	f001 fbbd 	bl	8006d40 <usb_lld_get_status_in>
 80055c6:	2801      	cmp	r0, #1
 80055c8:	d19b      	bne.n	8005502 <_usb_ep0setup+0x202>
        usbSetupTransfer(usbp, (uint8_t *)halted_status, 2, NULL);
 80055ca:	4b0d      	ldr	r3, [pc, #52]	; (8005600 <_usb_ep0setup+0x300>)
 80055cc:	66e5      	str	r5, [r4, #108]	; 0x6c
 80055ce:	66a3      	str	r3, [r4, #104]	; 0x68
 80055d0:	6726      	str	r6, [r4, #112]	; 0x70
        return true;
 80055d2:	5de3      	ldrb	r3, [r4, r7]
        usbSetupTransfer(usbp, (uint8_t *)halted_status, 2, NULL);
 80055d4:	2002      	movs	r0, #2
 80055d6:	e6a7      	b.n	8005328 <_usb_ep0setup+0x28>
        usb_lld_clear_in(usbp, usbp->setup[4] & 0x0FU);
 80055d8:	f001 fc9a 	bl	8006f10 <usb_lld_clear_in>
 80055dc:	2374      	movs	r3, #116	; 0x74
 80055de:	5ce3      	ldrb	r3, [r4, r3]
 80055e0:	e77e      	b.n	80054e0 <_usb_ep0setup+0x1e0>
        usb_lld_stall_in(usbp, usbp->setup[4] & 0x0FU);
 80055e2:	f001 fc65 	bl	8006eb0 <usb_lld_stall_in>
 80055e6:	5de3      	ldrb	r3, [r4, r7]
 80055e8:	e77a      	b.n	80054e0 <_usb_ep0setup+0x1e0>
 80055ea:	46c0      	nop			; (mov r8, r8)
 80055ec:	00000c02 	.word	0x00000c02
 80055f0:	00000302 	.word	0x00000302
 80055f4:	08005151 	.word	0x08005151
 80055f8:	08013660 	.word	0x08013660
 80055fc:	08013658 	.word	0x08013658
 8005600:	0801365c 	.word	0x0801365c
	...

08005610 <_usb_ep0in>:
 */
void _usb_ep0in(USBDriver *usbp, usbep_t ep) {
  size_t max;

  (void)ep;
  switch (usbp->ep0state) {
 8005610:	2364      	movs	r3, #100	; 0x64
void _usb_ep0in(USBDriver *usbp, usbep_t ep) {
 8005612:	b510      	push	{r4, lr}
  switch (usbp->ep0state) {
 8005614:	5cc3      	ldrb	r3, [r0, r3]
void _usb_ep0in(USBDriver *usbp, usbep_t ep) {
 8005616:	0004      	movs	r4, r0
  switch (usbp->ep0state) {
 8005618:	2b06      	cmp	r3, #6
 800561a:	d814      	bhi.n	8005646 <_usb_ep0in+0x36>
 800561c:	4a29      	ldr	r2, [pc, #164]	; (80056c4 <_usb_ep0in+0xb4>)
 800561e:	009b      	lsls	r3, r3, #2
 8005620:	58d3      	ldr	r3, [r2, r3]
 8005622:	469f      	mov	pc, r3
    /* Falling through is intentional.*/
  case USB_EP0_ERROR:
    /* Error response, the state machine goes into an error state, the low
       level layer will have to reset it to USB_EP0_WAITING_SETUP after
       receiving a SETUP packet.*/
    usb_lld_stall_in(usbp, 0);
 8005624:	2100      	movs	r1, #0
 8005626:	f001 fc43 	bl	8006eb0 <usb_lld_stall_in>
    usb_lld_stall_out(usbp, 0);
 800562a:	2100      	movs	r1, #0
 800562c:	0020      	movs	r0, r4
 800562e:	f001 fc27 	bl	8006e80 <usb_lld_stall_out>
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 8005632:	6863      	ldr	r3, [r4, #4]
 8005634:	681b      	ldr	r3, [r3, #0]
 8005636:	2b00      	cmp	r3, #0
 8005638:	d002      	beq.n	8005640 <_usb_ep0in+0x30>
 800563a:	2105      	movs	r1, #5
 800563c:	0020      	movs	r0, r4
 800563e:	4798      	blx	r3
    usbp->ep0state = USB_EP0_ERROR;
 8005640:	2364      	movs	r3, #100	; 0x64
 8005642:	2206      	movs	r2, #6
 8005644:	54e2      	strb	r2, [r4, r3]
    return;
  default:
    osalDbgAssert(false, "EP0 state machine invalid state");
  }
}
 8005646:	bd10      	pop	{r4, pc}
  hw |= (uint16_t)*p << 8U;
 8005648:	237b      	movs	r3, #123	; 0x7b
 800564a:	5ce2      	ldrb	r2, [r4, r3]
  hw  = (uint16_t)*p++;
 800564c:	3b01      	subs	r3, #1
  hw |= (uint16_t)*p << 8U;
 800564e:	5ce3      	ldrb	r3, [r4, r3]
    if ((usbp->ep0n < max) &&
 8005650:	6ec0      	ldr	r0, [r0, #108]	; 0x6c
  hw |= (uint16_t)*p << 8U;
 8005652:	0212      	lsls	r2, r2, #8
    max = (size_t)get_hword(&usbp->setup[6]);
 8005654:	4313      	orrs	r3, r2
    if ((usbp->ep0n < max) &&
 8005656:	4298      	cmp	r0, r3
 8005658:	d205      	bcs.n	8005666 <_usb_ep0in+0x56>
        ((usbp->ep0n % usbp->epc[0]->in_maxsize) == 0U)) {
 800565a:	68e3      	ldr	r3, [r4, #12]
 800565c:	8a19      	ldrh	r1, [r3, #16]
 800565e:	f7fa fe3d 	bl	80002dc <__aeabi_uidivmod>
    if ((usbp->ep0n < max) &&
 8005662:	2900      	cmp	r1, #0
 8005664:	d01b      	beq.n	800569e <_usb_ep0in+0x8e>
    usbp->ep0state = USB_EP0_WAITING_STS;
 8005666:	2364      	movs	r3, #100	; 0x64
 8005668:	2203      	movs	r2, #3
 800566a:	54e2      	strb	r2, [r4, r3]
 800566c:	b672      	cpsid	i
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 800566e:	2201      	movs	r2, #1
 8005670:	8963      	ldrh	r3, [r4, #10]
  usb_lld_start_out(usbp, ep);
 8005672:	2100      	movs	r1, #0
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8005674:	4313      	orrs	r3, r2
  osp->rxbuf  = buf;
 8005676:	2200      	movs	r2, #0
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8005678:	8163      	strh	r3, [r4, #10]
  osp = usbp->epc[ep]->out_state;
 800567a:	68e3      	ldr	r3, [r4, #12]
  usb_lld_start_out(usbp, ep);
 800567c:	0020      	movs	r0, r4
  osp = usbp->epc[ep]->out_state;
 800567e:	699b      	ldr	r3, [r3, #24]
  osp->rxbuf  = buf;
 8005680:	609a      	str	r2, [r3, #8]
  osp->rxsize = n;
 8005682:	601a      	str	r2, [r3, #0]
  osp->rxcnt  = 0;
 8005684:	605a      	str	r2, [r3, #4]
  usb_lld_start_out(usbp, ep);
 8005686:	f001 fb8b 	bl	8006da0 <usb_lld_start_out>
  __ASM volatile ("cpsie i" : : : "memory");
 800568a:	b662      	cpsie	i
 800568c:	e7db      	b.n	8005646 <_usb_ep0in+0x36>
    if (usbp->ep0endcb != NULL) {
 800568e:	6f03      	ldr	r3, [r0, #112]	; 0x70
 8005690:	2b00      	cmp	r3, #0
 8005692:	d000      	beq.n	8005696 <_usb_ep0in+0x86>
      usbp->ep0endcb(usbp);
 8005694:	4798      	blx	r3
    usbp->ep0state = USB_EP0_WAITING_SETUP;
 8005696:	2364      	movs	r3, #100	; 0x64
 8005698:	2200      	movs	r2, #0
 800569a:	54e2      	strb	r2, [r4, r3]
    return;
 800569c:	e7d3      	b.n	8005646 <_usb_ep0in+0x36>
  __ASM volatile ("cpsid i" : : : "memory");
 800569e:	b672      	cpsid	i
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 80056a0:	2201      	movs	r2, #1
 80056a2:	8923      	ldrh	r3, [r4, #8]
  usb_lld_start_in(usbp, ep);
 80056a4:	0020      	movs	r0, r4
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 80056a6:	4313      	orrs	r3, r2
 80056a8:	8123      	strh	r3, [r4, #8]
  isp = usbp->epc[ep]->in_state;
 80056aa:	68e3      	ldr	r3, [r4, #12]
 80056ac:	695b      	ldr	r3, [r3, #20]
  isp->txbuf  = buf;
 80056ae:	6099      	str	r1, [r3, #8]
  isp->txsize = n;
 80056b0:	6019      	str	r1, [r3, #0]
  isp->txcnt  = 0;
 80056b2:	6059      	str	r1, [r3, #4]
  usb_lld_start_in(usbp, ep);
 80056b4:	f001 fb9c 	bl	8006df0 <usb_lld_start_in>
  __ASM volatile ("cpsie i" : : : "memory");
 80056b8:	b662      	cpsie	i
      usbp->ep0state = USB_EP0_WAITING_TX0;
 80056ba:	2364      	movs	r3, #100	; 0x64
 80056bc:	2202      	movs	r2, #2
 80056be:	54e2      	strb	r2, [r4, r3]
      return;
 80056c0:	e7c1      	b.n	8005646 <_usb_ep0in+0x36>
 80056c2:	46c0      	nop			; (mov r8, r8)
 80056c4:	0801363c 	.word	0x0801363c
	...

080056d0 <_usb_ep0out>:
 * @notapi
 */
void _usb_ep0out(USBDriver *usbp, usbep_t ep) {

  (void)ep;
  switch (usbp->ep0state) {
 80056d0:	2164      	movs	r1, #100	; 0x64
void _usb_ep0out(USBDriver *usbp, usbep_t ep) {
 80056d2:	b510      	push	{r4, lr}
  switch (usbp->ep0state) {
 80056d4:	5c42      	ldrb	r2, [r0, r1]
void _usb_ep0out(USBDriver *usbp, usbep_t ep) {
 80056d6:	0004      	movs	r4, r0
 80056d8:	2a06      	cmp	r2, #6
 80056da:	d813      	bhi.n	8005704 <_usb_ep0out+0x34>
 80056dc:	2301      	movs	r3, #1
 80056de:	4093      	lsls	r3, r2
 80056e0:	2267      	movs	r2, #103	; 0x67
 80056e2:	421a      	tst	r2, r3
 80056e4:	d122      	bne.n	800572c <_usb_ep0out+0x5c>
 80056e6:	3a5f      	subs	r2, #95	; 0x5f
 80056e8:	401a      	ands	r2, r3
 80056ea:	d00c      	beq.n	8005706 <_usb_ep0out+0x36>
    return;
  case USB_EP0_WAITING_STS:
    /* Status packet received, it must be zero sized, invoking the callback
       if defined.*/
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    if (usbGetReceiveTransactionSizeX(usbp, 0) != 0U) {
 80056ec:	68c3      	ldr	r3, [r0, #12]
 80056ee:	699b      	ldr	r3, [r3, #24]
 80056f0:	685b      	ldr	r3, [r3, #4]
 80056f2:	2b00      	cmp	r3, #0
 80056f4:	d106      	bne.n	8005704 <_usb_ep0out+0x34>
      break;
    }
#endif
    if (usbp->ep0endcb != NULL) {
 80056f6:	6f03      	ldr	r3, [r0, #112]	; 0x70
 80056f8:	2b00      	cmp	r3, #0
 80056fa:	d000      	beq.n	80056fe <_usb_ep0out+0x2e>
      usbp->ep0endcb(usbp);
 80056fc:	4798      	blx	r3
    }
    usbp->ep0state = USB_EP0_WAITING_SETUP;
 80056fe:	2364      	movs	r3, #100	; 0x64
 8005700:	2200      	movs	r2, #0
 8005702:	54e2      	strb	r2, [r4, r3]
    usbp->ep0state = USB_EP0_ERROR;
    return;
  default:
    osalDbgAssert(false, "EP0 state machine invalid state");
  }
}
 8005704:	bd10      	pop	{r4, pc}
 8005706:	06db      	lsls	r3, r3, #27
 8005708:	d5fc      	bpl.n	8005704 <_usb_ep0out+0x34>
    usbp->ep0state = USB_EP0_SENDING_STS;
 800570a:	2305      	movs	r3, #5
 800570c:	5443      	strb	r3, [r0, r1]
  __ASM volatile ("cpsid i" : : : "memory");
 800570e:	b672      	cpsid	i
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8005710:	2101      	movs	r1, #1
 8005712:	8903      	ldrh	r3, [r0, #8]
 8005714:	430b      	orrs	r3, r1
 8005716:	8103      	strh	r3, [r0, #8]
  isp = usbp->epc[ep]->in_state;
 8005718:	68c3      	ldr	r3, [r0, #12]
  usb_lld_start_in(usbp, ep);
 800571a:	2100      	movs	r1, #0
  isp = usbp->epc[ep]->in_state;
 800571c:	695b      	ldr	r3, [r3, #20]
  isp->txbuf  = buf;
 800571e:	609a      	str	r2, [r3, #8]
  isp->txsize = n;
 8005720:	601a      	str	r2, [r3, #0]
  isp->txcnt  = 0;
 8005722:	605a      	str	r2, [r3, #4]
  usb_lld_start_in(usbp, ep);
 8005724:	f001 fb64 	bl	8006df0 <usb_lld_start_in>
  __ASM volatile ("cpsie i" : : : "memory");
 8005728:	b662      	cpsie	i
 800572a:	e7eb      	b.n	8005704 <_usb_ep0out+0x34>
    usb_lld_stall_in(usbp, 0);
 800572c:	2100      	movs	r1, #0
 800572e:	f001 fbbf 	bl	8006eb0 <usb_lld_stall_in>
    usb_lld_stall_out(usbp, 0);
 8005732:	2100      	movs	r1, #0
 8005734:	0020      	movs	r0, r4
 8005736:	f001 fba3 	bl	8006e80 <usb_lld_stall_out>
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 800573a:	6863      	ldr	r3, [r4, #4]
 800573c:	681b      	ldr	r3, [r3, #0]
 800573e:	2b00      	cmp	r3, #0
 8005740:	d002      	beq.n	8005748 <_usb_ep0out+0x78>
 8005742:	2105      	movs	r1, #5
 8005744:	0020      	movs	r0, r4
 8005746:	4798      	blx	r3
    usbp->ep0state = USB_EP0_ERROR;
 8005748:	2364      	movs	r3, #100	; 0x64
 800574a:	2206      	movs	r2, #6
 800574c:	54e2      	strb	r2, [r4, r3]
    return;
 800574e:	e7d9      	b.n	8005704 <_usb_ep0out+0x34>

08005750 <nvicEnableVector>:
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
 8005750:	4a0f      	ldr	r2, [pc, #60]	; (8005790 <nvicEnableVector+0x40>)
void nvicEnableVector(uint32_t n, uint32_t prio) {
 8005752:	b570      	push	{r4, r5, r6, lr}
 8005754:	4694      	mov	ip, r2
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
 8005756:	2203      	movs	r2, #3
 8005758:	25ff      	movs	r5, #255	; 0xff
 800575a:	26c0      	movs	r6, #192	; 0xc0
 800575c:	4002      	ands	r2, r0
 800575e:	00d2      	lsls	r2, r2, #3
 8005760:	4095      	lsls	r5, r2
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
 8005762:	0189      	lsls	r1, r1, #6
 8005764:	4091      	lsls	r1, r2
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
 8005766:	0883      	lsrs	r3, r0, #2
 8005768:	009b      	lsls	r3, r3, #2
 800576a:	4463      	add	r3, ip
 800576c:	00b6      	lsls	r6, r6, #2
 800576e:	599c      	ldr	r4, [r3, r6]
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8005770:	221f      	movs	r2, #31
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
 8005772:	43ac      	bics	r4, r5
 8005774:	430c      	orrs	r4, r1
 8005776:	519c      	str	r4, [r3, r6]
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8005778:	2301      	movs	r3, #1
 800577a:	4002      	ands	r2, r0
 800577c:	4093      	lsls	r3, r2
 800577e:	22c0      	movs	r2, #192	; 0xc0
 8005780:	0940      	lsrs	r0, r0, #5
 8005782:	0080      	lsls	r0, r0, #2
 8005784:	4460      	add	r0, ip
 8005786:	0052      	lsls	r2, r2, #1
 8005788:	5083      	str	r3, [r0, r2]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 800578a:	6003      	str	r3, [r0, #0]
}
 800578c:	bd70      	pop	{r4, r5, r6, pc}
 800578e:	46c0      	nop			; (mov r8, r8)
 8005790:	e000e100 	.word	0xe000e100
	...

080057a0 <Vector68>:
OSAL_IRQ_HANDLER(STM32_DMA1_CH23_HANDLER) {

  OSAL_IRQ_PROLOGUE();

  /* Check on channel 2.*/
  dmaServeInterrupt(STM32_DMA1_STREAM2);
 80057a0:	2324      	movs	r3, #36	; 0x24
OSAL_IRQ_HANDLER(STM32_DMA1_CH23_HANDLER) {
 80057a2:	b570      	push	{r4, r5, r6, lr}
  dmaServeInterrupt(STM32_DMA1_STREAM2);
 80057a4:	4c18      	ldr	r4, [pc, #96]	; (8005808 <Vector68+0x68>)
  OSAL_IRQ_PROLOGUE();
 80057a6:	4675      	mov	r5, lr
  dmaServeInterrupt(STM32_DMA1_STREAM2);
 80057a8:	6962      	ldr	r2, [r4, #20]
 80057aa:	5ce0      	ldrb	r0, [r4, r3]
 80057ac:	6811      	ldr	r1, [r2, #0]
 80057ae:	000b      	movs	r3, r1
 80057b0:	210f      	movs	r1, #15
 80057b2:	40c3      	lsrs	r3, r0
 80057b4:	4019      	ands	r1, r3
 80057b6:	d00c      	beq.n	80057d2 <Vector68+0x32>
 80057b8:	000e      	movs	r6, r1
 80057ba:	2325      	movs	r3, #37	; 0x25
 80057bc:	4086      	lsls	r6, r0
 80057be:	5ce3      	ldrb	r3, [r4, r3]
 80057c0:	6056      	str	r6, [r2, #4]
 80057c2:	4a12      	ldr	r2, [pc, #72]	; (800580c <Vector68+0x6c>)
 80057c4:	00db      	lsls	r3, r3, #3
 80057c6:	589e      	ldr	r6, [r3, r2]
 80057c8:	2e00      	cmp	r6, #0
 80057ca:	d002      	beq.n	80057d2 <Vector68+0x32>
 80057cc:	18d3      	adds	r3, r2, r3
 80057ce:	6858      	ldr	r0, [r3, #4]
 80057d0:	47b0      	blx	r6

  /* Check on channel 3.*/
  dmaServeInterrupt(STM32_DMA1_STREAM3);
 80057d2:	2338      	movs	r3, #56	; 0x38
 80057d4:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 80057d6:	5ce0      	ldrb	r0, [r4, r3]
 80057d8:	6811      	ldr	r1, [r2, #0]
 80057da:	000b      	movs	r3, r1
 80057dc:	210f      	movs	r1, #15
 80057de:	40c3      	lsrs	r3, r0
 80057e0:	4019      	ands	r1, r3
 80057e2:	d00c      	beq.n	80057fe <Vector68+0x5e>
 80057e4:	2339      	movs	r3, #57	; 0x39
 80057e6:	5ce3      	ldrb	r3, [r4, r3]
 80057e8:	000c      	movs	r4, r1
 80057ea:	4084      	lsls	r4, r0
 80057ec:	6054      	str	r4, [r2, #4]
 80057ee:	4a07      	ldr	r2, [pc, #28]	; (800580c <Vector68+0x6c>)
 80057f0:	00db      	lsls	r3, r3, #3
 80057f2:	589c      	ldr	r4, [r3, r2]
 80057f4:	2c00      	cmp	r4, #0
 80057f6:	d002      	beq.n	80057fe <Vector68+0x5e>
 80057f8:	18d3      	adds	r3, r2, r3
 80057fa:	6858      	ldr	r0, [r3, #4]
 80057fc:	47a0      	blx	r4

  OSAL_IRQ_EPILOGUE();
 80057fe:	0028      	movs	r0, r5
 8005800:	f7fe fcde 	bl	80041c0 <_port_irq_epilogue>
}
 8005804:	bd70      	pop	{r4, r5, r6, pc}
 8005806:	46c0      	nop			; (mov r8, r8)
 8005808:	08013664 	.word	0x08013664
 800580c:	20001800 	.word	0x20001800

08005810 <Vector6C>:
OSAL_IRQ_HANDLER(STM32_DMA1_CH4567_HANDLER) {

  OSAL_IRQ_PROLOGUE();

  /* Check on channel 4.*/
  dmaServeInterrupt(STM32_DMA1_STREAM4);
 8005810:	234c      	movs	r3, #76	; 0x4c
OSAL_IRQ_HANDLER(STM32_DMA1_CH4567_HANDLER) {
 8005812:	b570      	push	{r4, r5, r6, lr}
  dmaServeInterrupt(STM32_DMA1_STREAM4);
 8005814:	4c2e      	ldr	r4, [pc, #184]	; (80058d0 <Vector6C+0xc0>)
  OSAL_IRQ_PROLOGUE();
 8005816:	4675      	mov	r5, lr
  dmaServeInterrupt(STM32_DMA1_STREAM4);
 8005818:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 800581a:	5ce0      	ldrb	r0, [r4, r3]
 800581c:	6811      	ldr	r1, [r2, #0]
 800581e:	000b      	movs	r3, r1
 8005820:	210f      	movs	r1, #15
 8005822:	40c3      	lsrs	r3, r0
 8005824:	4019      	ands	r1, r3
 8005826:	d00c      	beq.n	8005842 <Vector6C+0x32>
 8005828:	000e      	movs	r6, r1
 800582a:	234d      	movs	r3, #77	; 0x4d
 800582c:	4086      	lsls	r6, r0
 800582e:	5ce3      	ldrb	r3, [r4, r3]
 8005830:	6056      	str	r6, [r2, #4]
 8005832:	4a28      	ldr	r2, [pc, #160]	; (80058d4 <Vector6C+0xc4>)
 8005834:	00db      	lsls	r3, r3, #3
 8005836:	589e      	ldr	r6, [r3, r2]
 8005838:	2e00      	cmp	r6, #0
 800583a:	d002      	beq.n	8005842 <Vector6C+0x32>
 800583c:	18d3      	adds	r3, r2, r3
 800583e:	6858      	ldr	r0, [r3, #4]
 8005840:	47b0      	blx	r6

  /* Check on channel 5.*/
  dmaServeInterrupt(STM32_DMA1_STREAM5);
 8005842:	2360      	movs	r3, #96	; 0x60
 8005844:	6d22      	ldr	r2, [r4, #80]	; 0x50
 8005846:	5ce0      	ldrb	r0, [r4, r3]
 8005848:	6811      	ldr	r1, [r2, #0]
 800584a:	000b      	movs	r3, r1
 800584c:	210f      	movs	r1, #15
 800584e:	40c3      	lsrs	r3, r0
 8005850:	4019      	ands	r1, r3
 8005852:	d00c      	beq.n	800586e <Vector6C+0x5e>
 8005854:	000e      	movs	r6, r1
 8005856:	2361      	movs	r3, #97	; 0x61
 8005858:	4086      	lsls	r6, r0
 800585a:	5ce3      	ldrb	r3, [r4, r3]
 800585c:	6056      	str	r6, [r2, #4]
 800585e:	4a1d      	ldr	r2, [pc, #116]	; (80058d4 <Vector6C+0xc4>)
 8005860:	00db      	lsls	r3, r3, #3
 8005862:	589e      	ldr	r6, [r3, r2]
 8005864:	2e00      	cmp	r6, #0
 8005866:	d002      	beq.n	800586e <Vector6C+0x5e>
 8005868:	18d3      	adds	r3, r2, r3
 800586a:	6858      	ldr	r0, [r3, #4]
 800586c:	47b0      	blx	r6

#if STM32_DMA1_NUM_CHANNELS > 5
  /* Check on channel 6.*/
  dmaServeInterrupt(STM32_DMA1_STREAM6);
 800586e:	2374      	movs	r3, #116	; 0x74
 8005870:	6e62      	ldr	r2, [r4, #100]	; 0x64
 8005872:	5ce0      	ldrb	r0, [r4, r3]
 8005874:	6811      	ldr	r1, [r2, #0]
 8005876:	000b      	movs	r3, r1
 8005878:	210f      	movs	r1, #15
 800587a:	40c3      	lsrs	r3, r0
 800587c:	4019      	ands	r1, r3
 800587e:	d00c      	beq.n	800589a <Vector6C+0x8a>
 8005880:	000e      	movs	r6, r1
 8005882:	2375      	movs	r3, #117	; 0x75
 8005884:	4086      	lsls	r6, r0
 8005886:	5ce3      	ldrb	r3, [r4, r3]
 8005888:	6056      	str	r6, [r2, #4]
 800588a:	4a12      	ldr	r2, [pc, #72]	; (80058d4 <Vector6C+0xc4>)
 800588c:	00db      	lsls	r3, r3, #3
 800588e:	589e      	ldr	r6, [r3, r2]
 8005890:	2e00      	cmp	r6, #0
 8005892:	d002      	beq.n	800589a <Vector6C+0x8a>
 8005894:	18d3      	adds	r3, r2, r3
 8005896:	6858      	ldr	r0, [r3, #4]
 8005898:	47b0      	blx	r6
#endif

#if STM32_DMA1_NUM_CHANNELS > 6
  /* Check on channel 7.*/
  dmaServeInterrupt(STM32_DMA1_STREAM7);
 800589a:	2388      	movs	r3, #136	; 0x88
 800589c:	6fa2      	ldr	r2, [r4, #120]	; 0x78
 800589e:	5ce0      	ldrb	r0, [r4, r3]
 80058a0:	6811      	ldr	r1, [r2, #0]
 80058a2:	000b      	movs	r3, r1
 80058a4:	210f      	movs	r1, #15
 80058a6:	40c3      	lsrs	r3, r0
 80058a8:	4019      	ands	r1, r3
 80058aa:	d00c      	beq.n	80058c6 <Vector6C+0xb6>
 80058ac:	2389      	movs	r3, #137	; 0x89
 80058ae:	5ce3      	ldrb	r3, [r4, r3]
 80058b0:	000c      	movs	r4, r1
 80058b2:	4084      	lsls	r4, r0
 80058b4:	6054      	str	r4, [r2, #4]
 80058b6:	4a07      	ldr	r2, [pc, #28]	; (80058d4 <Vector6C+0xc4>)
 80058b8:	00db      	lsls	r3, r3, #3
 80058ba:	589c      	ldr	r4, [r3, r2]
 80058bc:	2c00      	cmp	r4, #0
 80058be:	d002      	beq.n	80058c6 <Vector6C+0xb6>
 80058c0:	18d3      	adds	r3, r2, r3
 80058c2:	6858      	ldr	r0, [r3, #4]
 80058c4:	47a0      	blx	r4
#endif

  OSAL_IRQ_EPILOGUE();
 80058c6:	0028      	movs	r0, r5
 80058c8:	f7fe fc7a 	bl	80041c0 <_port_irq_epilogue>
}
 80058cc:	bd70      	pop	{r4, r5, r6, pc}
 80058ce:	46c0      	nop			; (mov r8, r8)
 80058d0:	08013664 	.word	0x08013664
 80058d4:	20001800 	.word	0x20001800
	...

080058e0 <hal_lld_init>:
 * @notapi
 */
void hal_lld_init(void) {

  /* Reset of all peripherals.*/
  rccResetAHB(0xFFFFFFFF);
 80058e0:	4b1b      	ldr	r3, [pc, #108]	; (8005950 <hal_lld_init+0x70>)
 80058e2:	2101      	movs	r1, #1
 80058e4:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 80058e6:	2200      	movs	r2, #0
 80058e8:	4249      	negs	r1, r1
void hal_lld_init(void) {
 80058ea:	b510      	push	{r4, lr}
  rccResetAHB(0xFFFFFFFF);
 80058ec:	6299      	str	r1, [r3, #40]	; 0x28
 80058ee:	629a      	str	r2, [r3, #40]	; 0x28
  rccResetAPB1(0xFFFFFFFF);
 80058f0:	6918      	ldr	r0, [r3, #16]
 80058f2:	6119      	str	r1, [r3, #16]
 80058f4:	611a      	str	r2, [r3, #16]
  rccResetAPB2(~RCC_APB2RSTR_DBGMCURST);
 80058f6:	68d8      	ldr	r0, [r3, #12]
 80058f8:	4916      	ldr	r1, [pc, #88]	; (8005954 <hal_lld_init+0x74>)
 80058fa:	4301      	orrs	r1, r0
 80058fc:	60d9      	str	r1, [r3, #12]

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 80058fe:	2180      	movs	r1, #128	; 0x80
  rccResetAPB2(~RCC_APB2RSTR_DBGMCURST);
 8005900:	60da      	str	r2, [r3, #12]
  rccEnablePWRInterface(FALSE);
 8005902:	69d8      	ldr	r0, [r3, #28]
 8005904:	0549      	lsls	r1, r1, #21
 8005906:	4301      	orrs	r1, r0
 8005908:	61d9      	str	r1, [r3, #28]
  PWR->CR |= PWR_CR_DBP;
 800590a:	2180      	movs	r1, #128	; 0x80
 800590c:	4812      	ldr	r0, [pc, #72]	; (8005958 <hal_lld_init+0x78>)
 800590e:	0049      	lsls	r1, r1, #1
 8005910:	6804      	ldr	r4, [r0, #0]
 8005912:	4321      	orrs	r1, r4
 8005914:	6001      	str	r1, [r0, #0]
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL){
 8005916:	20c0      	movs	r0, #192	; 0xc0
 8005918:	6a19      	ldr	r1, [r3, #32]
 800591a:	0080      	lsls	r0, r0, #2
 800591c:	4001      	ands	r1, r0
 800591e:	3801      	subs	r0, #1
 8005920:	38ff      	subs	r0, #255	; 0xff
 8005922:	4281      	cmp	r1, r0
 8005924:	d003      	beq.n	800592e <hal_lld_init+0x4e>
    RCC->BDCR = RCC_BDCR_BDRST;
 8005926:	2180      	movs	r1, #128	; 0x80
 8005928:	0249      	lsls	r1, r1, #9
 800592a:	6219      	str	r1, [r3, #32]
    RCC->BDCR = 0;
 800592c:	621a      	str	r2, [r3, #32]
  if ((RCC->BDCR & RCC_BDCR_RTCEN) == 0) {
 800592e:	2280      	movs	r2, #128	; 0x80
 8005930:	4b07      	ldr	r3, [pc, #28]	; (8005950 <hal_lld_init+0x70>)
 8005932:	0212      	lsls	r2, r2, #8
 8005934:	6a19      	ldr	r1, [r3, #32]
 8005936:	4211      	tst	r1, r2
 8005938:	d107      	bne.n	800594a <hal_lld_init+0x6a>
    RCC->BDCR |= STM32_RTCSEL;
 800593a:	2180      	movs	r1, #128	; 0x80
 800593c:	6a18      	ldr	r0, [r3, #32]
 800593e:	0089      	lsls	r1, r1, #2
 8005940:	4301      	orrs	r1, r0
 8005942:	6219      	str	r1, [r3, #32]
    RCC->BDCR |= RCC_BDCR_RTCEN;
 8005944:	6a19      	ldr	r1, [r3, #32]
 8005946:	430a      	orrs	r2, r1
 8005948:	621a      	str	r2, [r3, #32]

  /* Initializes the backup domain.*/
  hal_lld_backup_domain_init();

#if defined(STM32_DMA_REQUIRED)
  dmaInit();
 800594a:	f000 f881 	bl	8005a50 <dmaInit>

  /* Programmable voltage detector enable.*/
#if STM32_PVD_ENABLE
  PWR->CR |= PWR_CR_PVDE | (STM32_PLS & STM32_PLS_MASK);
#endif /* STM32_PVD_ENABLE */
}
 800594e:	bd10      	pop	{r4, pc}
 8005950:	40021000 	.word	0x40021000
 8005954:	ffbfffff 	.word	0xffbfffff
 8005958:	40007000 	.word	0x40007000
 800595c:	00000000 	.word	0x00000000

08005960 <stm32_clock_init>:
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 8005960:	2101      	movs	r1, #1
 8005962:	4a2c      	ldr	r2, [pc, #176]	; (8005a14 <stm32_clock_init+0xb4>)
 8005964:	6813      	ldr	r3, [r2, #0]
 8005966:	430b      	orrs	r3, r1
 8005968:	6013      	str	r3, [r2, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 800596a:	3101      	adds	r1, #1
 800596c:	6813      	ldr	r3, [r2, #0]
 800596e:	4219      	tst	r1, r3
 8005970:	d0fc      	beq.n	800596c <stm32_clock_init+0xc>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
 8005972:	2103      	movs	r1, #3
 8005974:	6853      	ldr	r3, [r2, #4]
 8005976:	438b      	bics	r3, r1
 8005978:	6053      	str	r3, [r2, #4]
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
 800597a:	6853      	ldr	r3, [r2, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 800597c:	3109      	adds	r1, #9
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
 800597e:	6053      	str	r3, [r2, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 8005980:	4a24      	ldr	r2, [pc, #144]	; (8005a14 <stm32_clock_init+0xb4>)
 8005982:	6853      	ldr	r3, [r2, #4]
 8005984:	400b      	ands	r3, r1
 8005986:	d1fc      	bne.n	8005982 <stm32_clock_init+0x22>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 8005988:	21f9      	movs	r1, #249	; 0xf9
 800598a:	6810      	ldr	r0, [r2, #0]
 800598c:	4001      	ands	r1, r0
 800598e:	6011      	str	r1, [r2, #0]
    ;                                       /* Waits until HSE is stable.   */
#endif

#if STM32_HSI14_ENABLED
  /* HSI14 activation.*/
  RCC->CR2 |= RCC_CR2_HSI14ON;
 8005990:	2101      	movs	r1, #1
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 8005992:	6053      	str	r3, [r2, #4]
  RCC->CR2 |= RCC_CR2_HSI14ON;
 8005994:	6b53      	ldr	r3, [r2, #52]	; 0x34
 8005996:	430b      	orrs	r3, r1
 8005998:	6353      	str	r3, [r2, #52]	; 0x34
  while (!(RCC->CR2 & RCC_CR2_HSI14RDY))
 800599a:	4a1e      	ldr	r2, [pc, #120]	; (8005a14 <stm32_clock_init+0xb4>)
 800599c:	3101      	adds	r1, #1
 800599e:	6b53      	ldr	r3, [r2, #52]	; 0x34
 80059a0:	4219      	tst	r1, r3
 80059a2:	d0fc      	beq.n	800599e <stm32_clock_init+0x3e>
    ;                                       /* Waits until HSI14 is stable. */
#endif

#if STM32_HSI48_ENABLED
  /* HSI48 activation.*/
  RCC->CR2 |= RCC_CR2_HSI48ON;
 80059a4:	2380      	movs	r3, #128	; 0x80
 80059a6:	6b51      	ldr	r1, [r2, #52]	; 0x34
 80059a8:	025b      	lsls	r3, r3, #9
 80059aa:	430b      	orrs	r3, r1
  while (!(RCC->CR2 & RCC_CR2_HSI48RDY))
 80059ac:	2180      	movs	r1, #128	; 0x80
  RCC->CR2 |= RCC_CR2_HSI48ON;
 80059ae:	6353      	str	r3, [r2, #52]	; 0x34
  while (!(RCC->CR2 & RCC_CR2_HSI48RDY))
 80059b0:	4a18      	ldr	r2, [pc, #96]	; (8005a14 <stm32_clock_init+0xb4>)
 80059b2:	0289      	lsls	r1, r1, #10
 80059b4:	6b53      	ldr	r3, [r2, #52]	; 0x34
 80059b6:	420b      	tst	r3, r1
 80059b8:	d0fc      	beq.n	80059b4 <stm32_clock_init+0x54>
    ;                                       /* Waits until HSI48 is stable. */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 80059ba:	2101      	movs	r1, #1
 80059bc:	6a53      	ldr	r3, [r2, #36]	; 0x24
 80059be:	430b      	orrs	r3, r1
 80059c0:	6253      	str	r3, [r2, #36]	; 0x24
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 80059c2:	4a14      	ldr	r2, [pc, #80]	; (8005a14 <stm32_clock_init+0xb4>)
 80059c4:	3101      	adds	r1, #1
 80059c6:	6a53      	ldr	r3, [r2, #36]	; 0x24
 80059c8:	4219      	tst	r1, r3
 80059ca:	d0fc      	beq.n	80059c6 <stm32_clock_init+0x66>
    ;                                       /* Waits until LSI is stable.   */
#endif

  /* Clock settings.*/
  RCC->CFGR  = STM32_PLLNODIV | STM32_MCOPRE | STM32_MCOSEL | STM32_PLLMUL |
 80059cc:	23e5      	movs	r3, #229	; 0xe5
 80059ce:	04db      	lsls	r3, r3, #19
 80059d0:	6053      	str	r3, [r2, #4]
               STM32_PLLSRC   | STM32_PPRE   | STM32_HPRE;
  RCC->CFGR2 = STM32_PREDIV;
 80059d2:	2300      	movs	r3, #0
 80059d4:	62d3      	str	r3, [r2, #44]	; 0x2c
#if STM32_CECSW == STM32_CECSW_OFF
  RCC->CFGR3 = STM32_USBSW  | STM32_I2C1SW | STM32_USART1SW;
#else
  RCC->CFGR3 = STM32_USBSW  | STM32_CECSW  | STM32_I2C1SW | STM32_USART1SW;
 80059d6:	6313      	str	r3, [r2, #48]	; 0x30
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->CR   |= RCC_CR_PLLON;
 80059d8:	2380      	movs	r3, #128	; 0x80
 80059da:	6811      	ldr	r1, [r2, #0]
 80059dc:	045b      	lsls	r3, r3, #17
 80059de:	430b      	orrs	r3, r1
  while (!(RCC->CR & RCC_CR_PLLRDY))
 80059e0:	2180      	movs	r1, #128	; 0x80
  RCC->CR   |= RCC_CR_PLLON;
 80059e2:	6013      	str	r3, [r2, #0]
  while (!(RCC->CR & RCC_CR_PLLRDY))
 80059e4:	4a0b      	ldr	r2, [pc, #44]	; (8005a14 <stm32_clock_init+0xb4>)
 80059e6:	0489      	lsls	r1, r1, #18
 80059e8:	6813      	ldr	r3, [r2, #0]
 80059ea:	420b      	tst	r3, r1
 80059ec:	d0fc      	beq.n	80059e8 <stm32_clock_init+0x88>
    ;                                       /* Waits until PLL is stable.   */
#endif

  /* Flash setup and final clock selection.   */
  FLASH->ACR = STM32_FLASHBITS;
 80059ee:	2111      	movs	r1, #17
 80059f0:	4b09      	ldr	r3, [pc, #36]	; (8005a18 <stm32_clock_init+0xb8>)
 80059f2:	6019      	str	r1, [r3, #0]

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  /* Switches clock source.*/
  RCC->CFGR |= STM32_SW;
 80059f4:	6853      	ldr	r3, [r2, #4]
 80059f6:	390f      	subs	r1, #15
 80059f8:	430b      	orrs	r3, r1
 80059fa:	6053      	str	r3, [r2, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 80059fc:	4a05      	ldr	r2, [pc, #20]	; (8005a14 <stm32_clock_init+0xb4>)
 80059fe:	310a      	adds	r1, #10
 8005a00:	6853      	ldr	r3, [r2, #4]
 8005a02:	400b      	ands	r3, r1
 8005a04:	2b08      	cmp	r3, #8
 8005a06:	d1fb      	bne.n	8005a00 <stm32_clock_init+0xa0>
    ;                                       /* Waits selection complete.    */
#endif

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
 8005a08:	2101      	movs	r1, #1
 8005a0a:	6993      	ldr	r3, [r2, #24]
 8005a0c:	430b      	orrs	r3, r1
 8005a0e:	6193      	str	r3, [r2, #24]
#endif /* !STM32_NO_INIT */
}
 8005a10:	4770      	bx	lr
 8005a12:	46c0      	nop			; (mov r8, r8)
 8005a14:	40021000 	.word	0x40021000
 8005a18:	40022000 	.word	0x40022000
 8005a1c:	00000000 	.word	0x00000000

08005a20 <Vector64>:
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM1);
 8005a20:	210f      	movs	r1, #15
 8005a22:	4b08      	ldr	r3, [pc, #32]	; (8005a44 <Vector64+0x24>)
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
 8005a24:	b510      	push	{r4, lr}
  dmaServeInterrupt(STM32_DMA1_STREAM1);
 8005a26:	681a      	ldr	r2, [r3, #0]
  OSAL_IRQ_PROLOGUE();
 8005a28:	4674      	mov	r4, lr
  dmaServeInterrupt(STM32_DMA1_STREAM1);
 8005a2a:	4011      	ands	r1, r2
 8005a2c:	d006      	beq.n	8005a3c <Vector64+0x1c>
 8005a2e:	4a06      	ldr	r2, [pc, #24]	; (8005a48 <Vector64+0x28>)
 8005a30:	6059      	str	r1, [r3, #4]
 8005a32:	6813      	ldr	r3, [r2, #0]
 8005a34:	2b00      	cmp	r3, #0
 8005a36:	d001      	beq.n	8005a3c <Vector64+0x1c>
 8005a38:	6850      	ldr	r0, [r2, #4]
 8005a3a:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8005a3c:	0020      	movs	r0, r4
 8005a3e:	f7fe fbbf 	bl	80041c0 <_port_irq_epilogue>
}
 8005a42:	bd10      	pop	{r4, pc}
 8005a44:	40020000 	.word	0x40020000
 8005a48:	20001800 	.word	0x20001800
 8005a4c:	00000000 	.word	0x00000000

08005a50 <dmaInit>:
 * @init
 */
void dmaInit(void) {
  int i;

  dma_streams_mask = 0U;
 8005a50:	2200      	movs	r2, #0
 8005a52:	4b0b      	ldr	r3, [pc, #44]	; (8005a80 <dmaInit+0x30>)
void dmaInit(void) {
 8005a54:	b510      	push	{r4, lr}
  dma_streams_mask = 0U;
 8005a56:	601a      	str	r2, [r3, #0]
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 8005a58:	4b0a      	ldr	r3, [pc, #40]	; (8005a84 <dmaInit+0x34>)
 8005a5a:	4a0b      	ldr	r2, [pc, #44]	; (8005a88 <dmaInit+0x38>)
 8005a5c:	001c      	movs	r4, r3
  dma_streams_mask = 0U;
 8005a5e:	480b      	ldr	r0, [pc, #44]	; (8005a8c <dmaInit+0x3c>)
 8005a60:	348c      	adds	r4, #140	; 0x8c
    _stm32_dma_streams[i].channel->CCR = 0U;
 8005a62:	2100      	movs	r1, #0
 8005a64:	e000      	b.n	8005a68 <dmaInit+0x18>
 8005a66:	6858      	ldr	r0, [r3, #4]
 8005a68:	3314      	adds	r3, #20
 8005a6a:	6001      	str	r1, [r0, #0]
    _stm32_dma_isr_redir[i].dma_func = NULL;
 8005a6c:	6011      	str	r1, [r2, #0]
 8005a6e:	3208      	adds	r2, #8
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 8005a70:	42a3      	cmp	r3, r4
 8005a72:	d1f8      	bne.n	8005a66 <dmaInit+0x16>
  }
  DMA1->IFCR = 0xFFFFFFFFU;
 8005a74:	2201      	movs	r2, #1
 8005a76:	4b06      	ldr	r3, [pc, #24]	; (8005a90 <dmaInit+0x40>)
 8005a78:	4252      	negs	r2, r2
 8005a7a:	605a      	str	r2, [r3, #4]
#if STM32_DMA2_NUM_CHANNELS > 0
  DMA2->IFCR = 0xFFFFFFFFU;
#endif
}
 8005a7c:	bd10      	pop	{r4, pc}
 8005a7e:	46c0      	nop			; (mov r8, r8)
 8005a80:	20001838 	.word	0x20001838
 8005a84:	08013664 	.word	0x08013664
 8005a88:	20001800 	.word	0x20001800
 8005a8c:	40020008 	.word	0x40020008
 8005a90:	40020000 	.word	0x40020000
	...

08005aa0 <dmaStreamAllocate>:
 * @special
 */
bool dmaStreamAllocate(const stm32_dma_stream_t *dmastp,
                       uint32_t priority,
                       stm32_dmaisr_t func,
                       void *param) {
 8005aa0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8005aa2:	4647      	mov	r7, r8
 8005aa4:	4698      	mov	r8, r3

  osalDbgCheck(dmastp != NULL);

  /* Checks if the stream is already taken.*/
  if ((dma_streams_mask & (1U << dmastp->selfindex)) != 0U)
 8005aa6:	2301      	movs	r3, #1
                       void *param) {
 8005aa8:	46ce      	mov	lr, r9
  if ((dma_streams_mask & (1U << dmastp->selfindex)) != 0U)
 8005aaa:	001d      	movs	r5, r3
                       void *param) {
 8005aac:	b580      	push	{r7, lr}
 8005aae:	0004      	movs	r4, r0
  if ((dma_streams_mask & (1U << dmastp->selfindex)) != 0U)
 8005ab0:	7c40      	ldrb	r0, [r0, #17]
 8005ab2:	4f1c      	ldr	r7, [pc, #112]	; (8005b24 <dmaStreamAllocate+0x84>)
 8005ab4:	4085      	lsls	r5, r0
 8005ab6:	683e      	ldr	r6, [r7, #0]
                       void *param) {
 8005ab8:	4689      	mov	r9, r1
  if ((dma_streams_mask & (1U << dmastp->selfindex)) != 0U)
 8005aba:	422e      	tst	r6, r5
 8005abc:	d12f      	bne.n	8005b1e <dmaStreamAllocate+0x7e>
    return true;

  /* Installs the DMA handler.*/
  _stm32_dma_isr_redir[dmastp->selfindex].dma_func  = func;
 8005abe:	491a      	ldr	r1, [pc, #104]	; (8005b28 <dmaStreamAllocate+0x88>)
 8005ac0:	00c0      	lsls	r0, r0, #3
 8005ac2:	468c      	mov	ip, r1
 8005ac4:	5042      	str	r2, [r0, r1]
  _stm32_dma_isr_redir[dmastp->selfindex].dma_param = param;
 8005ac6:	4641      	mov	r1, r8
 8005ac8:	4460      	add	r0, ip
 8005aca:	6041      	str	r1, [r0, #4]

  /* Enabling DMA clocks required by the current streams set.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) == 0U) {
 8005acc:	0671      	lsls	r1, r6, #25
 8005ace:	d103      	bne.n	8005ad8 <dmaStreamAllocate+0x38>
    rccEnableDMA1(false);
 8005ad0:	4916      	ldr	r1, [pc, #88]	; (8005b2c <dmaStreamAllocate+0x8c>)
 8005ad2:	6948      	ldr	r0, [r1, #20]
 8005ad4:	4303      	orrs	r3, r0
 8005ad6:	614b      	str	r3, [r1, #20]
    rccEnableDMA2(false);
  }
#endif

  /* Putting the stream in a safe state.*/
  dmaStreamDisable(dmastp);
 8005ad8:	6863      	ldr	r3, [r4, #4]
 8005ada:	469c      	mov	ip, r3
 8005adc:	6818      	ldr	r0, [r3, #0]
 8005ade:	230f      	movs	r3, #15
 8005ae0:	4661      	mov	r1, ip
 8005ae2:	4398      	bics	r0, r3
 8005ae4:	6008      	str	r0, [r1, #0]
 8005ae6:	7c20      	ldrb	r0, [r4, #16]
 8005ae8:	6821      	ldr	r1, [r4, #0]
 8005aea:	4083      	lsls	r3, r0
 8005aec:	604b      	str	r3, [r1, #4]
  dmastp->channel->CCR = STM32_DMA_CCR_RESET_VALUE;
 8005aee:	2300      	movs	r3, #0
 8005af0:	4661      	mov	r1, ip
 8005af2:	600b      	str	r3, [r1, #0]

  /* Enables the associated IRQ vector if not alread enabled and if a
     callback is defined.*/
  if (((dma_streams_mask & dmastp->cmask) == 0U) &&
 8005af4:	68a3      	ldr	r3, [r4, #8]
 8005af6:	4233      	tst	r3, r6
 8005af8:	d006      	beq.n	8005b08 <dmaStreamAllocate+0x68>
  }

  /* Marks the stream as allocated.*/
  dma_streams_mask |= (1U << dmastp->selfindex);

  return false;
 8005afa:	2000      	movs	r0, #0
  dma_streams_mask |= (1U << dmastp->selfindex);
 8005afc:	4335      	orrs	r5, r6
 8005afe:	603d      	str	r5, [r7, #0]
}
 8005b00:	bc0c      	pop	{r2, r3}
 8005b02:	4690      	mov	r8, r2
 8005b04:	4699      	mov	r9, r3
 8005b06:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if (((dma_streams_mask & dmastp->cmask) == 0U) &&
 8005b08:	2a00      	cmp	r2, #0
 8005b0a:	d0f6      	beq.n	8005afa <dmaStreamAllocate+0x5a>
    nvicEnableVector(dmastp->vector, priority);
 8005b0c:	2501      	movs	r5, #1
 8005b0e:	7ca0      	ldrb	r0, [r4, #18]
 8005b10:	4649      	mov	r1, r9
 8005b12:	f7ff fe1d 	bl	8005750 <nvicEnableVector>
 8005b16:	7c63      	ldrb	r3, [r4, #17]
 8005b18:	683e      	ldr	r6, [r7, #0]
 8005b1a:	409d      	lsls	r5, r3
 8005b1c:	e7ed      	b.n	8005afa <dmaStreamAllocate+0x5a>
    return true;
 8005b1e:	2001      	movs	r0, #1
 8005b20:	e7ee      	b.n	8005b00 <dmaStreamAllocate+0x60>
 8005b22:	46c0      	nop			; (mov r8, r8)
 8005b24:	20001838 	.word	0x20001838
 8005b28:	20001800 	.word	0x20001800
 8005b2c:	40021000 	.word	0x40021000

08005b30 <Vector7C>:
  OSAL_IRQ_PROLOGUE();

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 8005b30:	2380      	movs	r3, #128	; 0x80
 8005b32:	05db      	lsls	r3, r3, #23
 8005b34:	691a      	ldr	r2, [r3, #16]
OSAL_IRQ_HANDLER(ST_HANDLER) {
 8005b36:	b510      	push	{r4, lr}
  OSAL_IRQ_PROLOGUE();
 8005b38:	4674      	mov	r4, lr
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 8005b3a:	0792      	lsls	r2, r2, #30
 8005b3c:	d403      	bmi.n	8005b46 <Vector7C+0x16>
    osalSysLockFromISR();
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
 8005b3e:	0020      	movs	r0, r4
 8005b40:	f7fe fb3e 	bl	80041c0 <_port_irq_epilogue>
}
 8005b44:	bd10      	pop	{r4, pc}
    STM32_ST_TIM->SR = 0U;
 8005b46:	2200      	movs	r2, #0
 8005b48:	611a      	str	r2, [r3, #16]
  __ASM volatile ("cpsid i" : : : "memory");
 8005b4a:	b672      	cpsid	i
  chSysTimerHandlerI();
 8005b4c:	f7fd fee0 	bl	8003910 <chSysTimerHandlerI>
  __ASM volatile ("cpsie i" : : : "memory");
 8005b50:	b662      	cpsie	i
 8005b52:	e7f4      	b.n	8005b3e <Vector7C+0xe>
	...

08005b60 <st_lld_init>:

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 8005b60:	2201      	movs	r2, #1
 8005b62:	490e      	ldr	r1, [pc, #56]	; (8005b9c <st_lld_init+0x3c>)
void st_lld_init(void) {
 8005b64:	b510      	push	{r4, lr}
  ST_ENABLE_CLOCK();
 8005b66:	69cb      	ldr	r3, [r1, #28]
  STM32_ST_TIM->CR2    = 0;
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;

  /* IRQ enabled.*/
  nvicEnableVector(ST_NUMBER, STM32_ST_IRQ_PRIORITY);
 8005b68:	200f      	movs	r0, #15
  ST_ENABLE_CLOCK();
 8005b6a:	4313      	orrs	r3, r2
 8005b6c:	61cb      	str	r3, [r1, #28]
  ST_ENABLE_STOP();
 8005b6e:	490c      	ldr	r1, [pc, #48]	; (8005ba0 <st_lld_init+0x40>)
 8005b70:	688b      	ldr	r3, [r1, #8]
 8005b72:	4313      	orrs	r3, r2
 8005b74:	608b      	str	r3, [r1, #8]
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8005b76:	2380      	movs	r3, #128	; 0x80
 8005b78:	490a      	ldr	r1, [pc, #40]	; (8005ba4 <st_lld_init+0x44>)
 8005b7a:	05db      	lsls	r3, r3, #23
 8005b7c:	6299      	str	r1, [r3, #40]	; 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 8005b7e:	2101      	movs	r1, #1
 8005b80:	4249      	negs	r1, r1
 8005b82:	62d9      	str	r1, [r3, #44]	; 0x2c
  STM32_ST_TIM->CCMR1  = 0;
 8005b84:	2100      	movs	r1, #0
 8005b86:	6199      	str	r1, [r3, #24]
  STM32_ST_TIM->CCR[0] = 0;
 8005b88:	6359      	str	r1, [r3, #52]	; 0x34
  STM32_ST_TIM->DIER   = 0;
 8005b8a:	60d9      	str	r1, [r3, #12]
  STM32_ST_TIM->CR2    = 0;
 8005b8c:	6059      	str	r1, [r3, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 8005b8e:	615a      	str	r2, [r3, #20]
  nvicEnableVector(ST_NUMBER, STM32_ST_IRQ_PRIORITY);
 8005b90:	3102      	adds	r1, #2
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 8005b92:	601a      	str	r2, [r3, #0]
  nvicEnableVector(ST_NUMBER, STM32_ST_IRQ_PRIORITY);
 8005b94:	f7ff fddc 	bl	8005750 <nvicEnableVector>
                  SysTick_CTRL_TICKINT_Msk;

  /* IRQ enabled.*/
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK, STM32_ST_IRQ_PRIORITY);
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
 8005b98:	bd10      	pop	{r4, pc}
 8005b9a:	46c0      	nop			; (mov r8, r8)
 8005b9c:	40021000 	.word	0x40021000
 8005ba0:	40015800 	.word	0x40015800
 8005ba4:	000012bf 	.word	0x000012bf
	...

08005bb0 <ext_lld_init>:
/**
 * @brief   Low level EXT driver initialization.
 *
 * @notapi
 */
void ext_lld_init(void) {
 8005bb0:	b510      	push	{r4, lr}

  /* Driver initialization.*/
  extObjectInit(&EXTD1);
 8005bb2:	4802      	ldr	r0, [pc, #8]	; (8005bbc <ext_lld_init+0xc>)
 8005bb4:	f7fe ff1c 	bl	80049f0 <extObjectInit>
}
 8005bb8:	bd10      	pop	{r4, pc}
 8005bba:	46c0      	nop			; (mov r8, r8)
 8005bbc:	2000183c 	.word	0x2000183c

08005bc0 <ext_lld_channel_enable>:
 * @param[in] channel   channel to be enabled
 *
 * @notapi
 */
void ext_lld_channel_enable(EXTDriver *extp, expchannel_t channel) {
  uint32_t cmask = (1 << (channel & 0x1F));
 8005bc0:	221f      	movs	r2, #31
 8005bc2:	2301      	movs	r3, #1
 8005bc4:	400a      	ands	r2, r1
void ext_lld_channel_enable(EXTDriver *extp, expchannel_t channel) {
 8005bc6:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t cmask = (1 << (channel & 0x1F));
 8005bc8:	4093      	lsls	r3, r2

  /* Setting the associated GPIO for external channels.*/
  if (channel < 16) {
 8005bca:	290f      	cmp	r1, #15
 8005bcc:	d813      	bhi.n	8005bf6 <ext_lld_channel_enable+0x36>
    uint32_t n = channel >> 2;
    uint32_t mask = ~(0xF << ((channel & 3) * 4));
 8005bce:	4a23      	ldr	r2, [pc, #140]	; (8005c5c <ext_lld_channel_enable+0x9c>)
    uint32_t port = ((extp->config->channels[channel].mode &
                      EXT_MODE_GPIO_MASK) >>
 8005bd0:	6846      	ldr	r6, [r0, #4]
    uint32_t mask = ~(0xF << ((channel & 3) * 4));
 8005bd2:	2503      	movs	r5, #3
 8005bd4:	4694      	mov	ip, r2
    uint32_t port = ((extp->config->channels[channel].mode &
 8005bd6:	00ca      	lsls	r2, r1, #3
                      EXT_MODE_GPIO_MASK) >>
 8005bd8:	5992      	ldr	r2, [r2, r6]
 8005bda:	260f      	movs	r6, #15
    uint32_t mask = ~(0xF << ((channel & 3) * 4));
 8005bdc:	400d      	ands	r5, r1
 8005bde:	00ad      	lsls	r5, r5, #2
                      EXT_MODE_GPIO_MASK) >>
 8005be0:	0912      	lsrs	r2, r2, #4
 8005be2:	4032      	ands	r2, r6
    uint32_t mask = ~(0xF << ((channel & 3) * 4));
 8005be4:	40ae      	lsls	r6, r5
    uint32_t port = ((extp->config->channels[channel].mode &
 8005be6:	40aa      	lsls	r2, r5
    uint32_t n = channel >> 2;
 8005be8:	088c      	lsrs	r4, r1, #2
 8005bea:	00a4      	lsls	r4, r4, #2
 8005bec:	4464      	add	r4, ip
                     EXT_MODE_GPIO_OFF) << ((channel & 3) * 4);

#if defined(STM32F1XX)
    AFIO->EXTICR[n] = (AFIO->EXTICR[n] & mask) | port;
#else /* !defined(STM32F1XX) */
    SYSCFG->EXTICR[n] = (SYSCFG->EXTICR[n] & mask) | port;
 8005bee:	68a7      	ldr	r7, [r4, #8]
 8005bf0:	43b7      	bics	r7, r6
 8005bf2:	433a      	orrs	r2, r7
 8005bf4:	60a2      	str	r2, [r4, #8]

#if STM32_EXTI_NUM_LINES > 32
  if (channel < 32) {
#endif
    /* Masked out lines must not be touched by this driver.*/
    if ((cmask & STM32_EXTI_IMR_MASK) != 0U) {
 8005bf6:	4a1a      	ldr	r2, [pc, #104]	; (8005c60 <ext_lld_channel_enable+0xa0>)
 8005bf8:	4213      	tst	r3, r2
 8005bfa:	d11a      	bne.n	8005c32 <ext_lld_channel_enable+0x72>
      return;
    }

    /* Programming edge registers.*/
    if (extp->config->channels[channel].mode & EXT_CH_MODE_RISING_EDGE)
 8005bfc:	6842      	ldr	r2, [r0, #4]
 8005bfe:	00c9      	lsls	r1, r1, #3
 8005c00:	1851      	adds	r1, r2, r1
 8005c02:	680a      	ldr	r2, [r1, #0]
 8005c04:	43d8      	mvns	r0, r3
      EXTI->RTSR |= cmask;
 8005c06:	4d17      	ldr	r5, [pc, #92]	; (8005c64 <ext_lld_channel_enable+0xa4>)
    if (extp->config->channels[channel].mode & EXT_CH_MODE_RISING_EDGE)
 8005c08:	07d4      	lsls	r4, r2, #31
 8005c0a:	d413      	bmi.n	8005c34 <ext_lld_channel_enable+0x74>
    else
      EXTI->RTSR &= ~cmask;
 8005c0c:	68ac      	ldr	r4, [r5, #8]
 8005c0e:	4004      	ands	r4, r0
 8005c10:	60ac      	str	r4, [r5, #8]
    if (extp->config->channels[channel].mode & EXT_CH_MODE_FALLING_EDGE)
      EXTI->FTSR |= cmask;
 8005c12:	4c14      	ldr	r4, [pc, #80]	; (8005c64 <ext_lld_channel_enable+0xa4>)
    if (extp->config->channels[channel].mode & EXT_CH_MODE_FALLING_EDGE)
 8005c14:	0792      	lsls	r2, r2, #30
 8005c16:	d513      	bpl.n	8005c40 <ext_lld_channel_enable+0x80>
      EXTI->FTSR |= cmask;
 8005c18:	68e2      	ldr	r2, [r4, #12]
 8005c1a:	431a      	orrs	r2, r3
 8005c1c:	60e2      	str	r2, [r4, #12]
    else
      EXTI->FTSR &= ~cmask;

    /* Programming interrupt and event registers.*/
    if (extp->config->channels[channel].cb != NULL) {
 8005c1e:	684a      	ldr	r2, [r1, #4]
 8005c20:	2a00      	cmp	r2, #0
 8005c22:	d013      	beq.n	8005c4c <ext_lld_channel_enable+0x8c>
      EXTI->IMR |= cmask;
 8005c24:	4a0f      	ldr	r2, [pc, #60]	; (8005c64 <ext_lld_channel_enable+0xa4>)
 8005c26:	6811      	ldr	r1, [r2, #0]
 8005c28:	430b      	orrs	r3, r1
 8005c2a:	6013      	str	r3, [r2, #0]
      EXTI->EMR &= ~cmask;
 8005c2c:	6853      	ldr	r3, [r2, #4]
 8005c2e:	4003      	ands	r3, r0
 8005c30:	6053      	str	r3, [r2, #4]
      EXTI->EMR2 |= cmask;
      EXTI->IMR2 &= ~cmask;
    }
  }
#endif
}
 8005c32:	bdf0      	pop	{r4, r5, r6, r7, pc}
      EXTI->RTSR |= cmask;
 8005c34:	68ac      	ldr	r4, [r5, #8]
 8005c36:	431c      	orrs	r4, r3
 8005c38:	60ac      	str	r4, [r5, #8]
      EXTI->FTSR |= cmask;
 8005c3a:	4c0a      	ldr	r4, [pc, #40]	; (8005c64 <ext_lld_channel_enable+0xa4>)
    if (extp->config->channels[channel].mode & EXT_CH_MODE_FALLING_EDGE)
 8005c3c:	0792      	lsls	r2, r2, #30
 8005c3e:	d4eb      	bmi.n	8005c18 <ext_lld_channel_enable+0x58>
      EXTI->FTSR &= ~cmask;
 8005c40:	68e2      	ldr	r2, [r4, #12]
 8005c42:	4002      	ands	r2, r0
 8005c44:	60e2      	str	r2, [r4, #12]
    if (extp->config->channels[channel].cb != NULL) {
 8005c46:	684a      	ldr	r2, [r1, #4]
 8005c48:	2a00      	cmp	r2, #0
 8005c4a:	d1eb      	bne.n	8005c24 <ext_lld_channel_enable+0x64>
      EXTI->EMR |= cmask;
 8005c4c:	4a05      	ldr	r2, [pc, #20]	; (8005c64 <ext_lld_channel_enable+0xa4>)
 8005c4e:	6851      	ldr	r1, [r2, #4]
 8005c50:	430b      	orrs	r3, r1
 8005c52:	6053      	str	r3, [r2, #4]
      EXTI->IMR &= ~cmask;
 8005c54:	6813      	ldr	r3, [r2, #0]
 8005c56:	4003      	ands	r3, r0
 8005c58:	6013      	str	r3, [r2, #0]
 8005c5a:	e7ea      	b.n	8005c32 <ext_lld_channel_enable+0x72>
 8005c5c:	40010000 	.word	0x40010000
 8005c60:	7f840000 	.word	0x7f840000
 8005c64:	40010400 	.word	0x40010400
	...

08005c70 <ext_lld_start>:
void ext_lld_start(EXTDriver *extp) {
 8005c70:	b5f0      	push	{r4, r5, r6, r7, lr}
 8005c72:	46c6      	mov	lr, r8
  if (extp->state == EXT_STOP)
 8005c74:	7803      	ldrb	r3, [r0, #0]
void ext_lld_start(EXTDriver *extp) {
 8005c76:	b500      	push	{lr}
 8005c78:	0006      	movs	r6, r0
  if (extp->state == EXT_STOP)
 8005c7a:	2b01      	cmp	r3, #1
 8005c7c:	d027      	beq.n	8005cce <ext_lld_start+0x5e>
 * @param[in] channel   channel to be disabled
 *
 * @notapi
 */
void ext_lld_channel_disable(EXTDriver *extp, expchannel_t channel) {
  uint32_t cmask = (1 << (channel & 0x1F));
 8005c7e:	2301      	movs	r3, #1
void ext_lld_start(EXTDriver *extp) {
 8005c80:	2500      	movs	r5, #0
    if (extp->config->channels[line].mode & EXT_CH_MODE_AUTOSTART)
 8005c82:	2704      	movs	r7, #4
  uint32_t cmask = (1 << (channel & 0x1F));
 8005c84:	4698      	mov	r8, r3
  (void)extp;

#if STM32_EXTI_NUM_LINES > 32
  if (channel < 32) {
#endif
    EXTI->IMR  &= ~cmask;
 8005c86:	4c13      	ldr	r4, [pc, #76]	; (8005cd4 <ext_lld_start+0x64>)
 8005c88:	e012      	b.n	8005cb0 <ext_lld_start+0x40>
 8005c8a:	4643      	mov	r3, r8
 8005c8c:	40ab      	lsls	r3, r5
 8005c8e:	43da      	mvns	r2, r3
 8005c90:	6821      	ldr	r1, [r4, #0]
  for (line = 0; line < EXT_MAX_CHANNELS; line++)
 8005c92:	3501      	adds	r5, #1
    EXTI->IMR  &= ~cmask;
 8005c94:	4011      	ands	r1, r2
 8005c96:	6021      	str	r1, [r4, #0]
    EXTI->EMR  &= ~cmask;
 8005c98:	6861      	ldr	r1, [r4, #4]
 8005c9a:	4011      	ands	r1, r2
 8005c9c:	6061      	str	r1, [r4, #4]
    EXTI->RTSR &= ~cmask;
 8005c9e:	68a1      	ldr	r1, [r4, #8]
 8005ca0:	4011      	ands	r1, r2
 8005ca2:	60a1      	str	r1, [r4, #8]
    EXTI->FTSR &= ~cmask;
 8005ca4:	68e1      	ldr	r1, [r4, #12]
 8005ca6:	400a      	ands	r2, r1
 8005ca8:	60e2      	str	r2, [r4, #12]
    EXTI->PR    =  cmask;
 8005caa:	6163      	str	r3, [r4, #20]
  for (line = 0; line < EXT_MAX_CHANNELS; line++)
 8005cac:	2d20      	cmp	r5, #32
 8005cae:	d00b      	beq.n	8005cc8 <ext_lld_start+0x58>
    if (extp->config->channels[line].mode & EXT_CH_MODE_AUTOSTART)
 8005cb0:	6872      	ldr	r2, [r6, #4]
 8005cb2:	00eb      	lsls	r3, r5, #3
 8005cb4:	589b      	ldr	r3, [r3, r2]
 8005cb6:	423b      	tst	r3, r7
 8005cb8:	d0e7      	beq.n	8005c8a <ext_lld_start+0x1a>
      ext_lld_channel_enable(extp, line);
 8005cba:	0029      	movs	r1, r5
 8005cbc:	0030      	movs	r0, r6
  for (line = 0; line < EXT_MAX_CHANNELS; line++)
 8005cbe:	3501      	adds	r5, #1
      ext_lld_channel_enable(extp, line);
 8005cc0:	f7ff ff7e 	bl	8005bc0 <ext_lld_channel_enable>
  for (line = 0; line < EXT_MAX_CHANNELS; line++)
 8005cc4:	2d20      	cmp	r5, #32
 8005cc6:	d1f3      	bne.n	8005cb0 <ext_lld_start+0x40>
}
 8005cc8:	bc04      	pop	{r2}
 8005cca:	4690      	mov	r8, r2
 8005ccc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    ext_lld_exti_irq_enable();
 8005cce:	f000 f8ff 	bl	8005ed0 <ext_lld_exti_irq_enable>
 8005cd2:	e7d4      	b.n	8005c7e <ext_lld_start+0xe>
 8005cd4:	40010400 	.word	0x40010400
	...

08005ce0 <Vector54>:
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  pr = EXTI->PR;
  pr &= ((1U << 0) | (1U << 1));
 8005ce0:	2303      	movs	r3, #3
  pr = EXTI->PR;
 8005ce2:	4a0c      	ldr	r2, [pc, #48]	; (8005d14 <Vector54+0x34>)
OSAL_IRQ_HANDLER(Vector54) {
 8005ce4:	b570      	push	{r4, r5, r6, lr}
  pr = EXTI->PR;
 8005ce6:	6954      	ldr	r4, [r2, #20]
  OSAL_IRQ_PROLOGUE();
 8005ce8:	4675      	mov	r5, lr
  pr &= ((1U << 0) | (1U << 1));
 8005cea:	4023      	ands	r3, r4
  EXTI->PR = pr;
 8005cec:	6153      	str	r3, [r2, #20]
  if (pr & (1U << 0))
 8005cee:	07e3      	lsls	r3, r4, #31
 8005cf0:	d504      	bpl.n	8005cfc <Vector54+0x1c>
    EXTD1.config->channels[0].cb(&EXTD1, 0);
 8005cf2:	4809      	ldr	r0, [pc, #36]	; (8005d18 <Vector54+0x38>)
 8005cf4:	2100      	movs	r1, #0
 8005cf6:	6843      	ldr	r3, [r0, #4]
 8005cf8:	685b      	ldr	r3, [r3, #4]
 8005cfa:	4798      	blx	r3
  if (pr & (1U << 1))
 8005cfc:	07a3      	lsls	r3, r4, #30
 8005cfe:	d504      	bpl.n	8005d0a <Vector54+0x2a>
    EXTD1.config->channels[1].cb(&EXTD1, 1);
 8005d00:	4805      	ldr	r0, [pc, #20]	; (8005d18 <Vector54+0x38>)
 8005d02:	2101      	movs	r1, #1
 8005d04:	6843      	ldr	r3, [r0, #4]
 8005d06:	68db      	ldr	r3, [r3, #12]
 8005d08:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8005d0a:	0028      	movs	r0, r5
 8005d0c:	f7fe fa58 	bl	80041c0 <_port_irq_epilogue>
}
 8005d10:	bd70      	pop	{r4, r5, r6, pc}
 8005d12:	46c0      	nop			; (mov r8, r8)
 8005d14:	40010400 	.word	0x40010400
 8005d18:	2000183c 	.word	0x2000183c
 8005d1c:	00000000 	.word	0x00000000

08005d20 <Vector58>:
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  pr = EXTI->PR;
  pr &= ((1U << 2) | (1U << 3));
 8005d20:	230c      	movs	r3, #12
  pr = EXTI->PR;
 8005d22:	4a0c      	ldr	r2, [pc, #48]	; (8005d54 <Vector58+0x34>)
OSAL_IRQ_HANDLER(Vector58) {
 8005d24:	b570      	push	{r4, r5, r6, lr}
  pr = EXTI->PR;
 8005d26:	6954      	ldr	r4, [r2, #20]
  OSAL_IRQ_PROLOGUE();
 8005d28:	4675      	mov	r5, lr
  pr &= ((1U << 2) | (1U << 3));
 8005d2a:	4023      	ands	r3, r4
  EXTI->PR = pr;
 8005d2c:	6153      	str	r3, [r2, #20]
  if (pr & (1U << 2))
 8005d2e:	0763      	lsls	r3, r4, #29
 8005d30:	d504      	bpl.n	8005d3c <Vector58+0x1c>
    EXTD1.config->channels[2].cb(&EXTD1, 2);
 8005d32:	4809      	ldr	r0, [pc, #36]	; (8005d58 <Vector58+0x38>)
 8005d34:	2102      	movs	r1, #2
 8005d36:	6843      	ldr	r3, [r0, #4]
 8005d38:	695b      	ldr	r3, [r3, #20]
 8005d3a:	4798      	blx	r3
  if (pr & (1U << 3))
 8005d3c:	0723      	lsls	r3, r4, #28
 8005d3e:	d504      	bpl.n	8005d4a <Vector58+0x2a>
    EXTD1.config->channels[3].cb(&EXTD1, 3);
 8005d40:	4805      	ldr	r0, [pc, #20]	; (8005d58 <Vector58+0x38>)
 8005d42:	2103      	movs	r1, #3
 8005d44:	6843      	ldr	r3, [r0, #4]
 8005d46:	69db      	ldr	r3, [r3, #28]
 8005d48:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8005d4a:	0028      	movs	r0, r5
 8005d4c:	f7fe fa38 	bl	80041c0 <_port_irq_epilogue>
}
 8005d50:	bd70      	pop	{r4, r5, r6, pc}
 8005d52:	46c0      	nop			; (mov r8, r8)
 8005d54:	40010400 	.word	0x40010400
 8005d58:	2000183c 	.word	0x2000183c
 8005d5c:	00000000 	.word	0x00000000

08005d60 <Vector5C>:
OSAL_IRQ_HANDLER(Vector5C) {
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  pr = EXTI->PR;
 8005d60:	4a2f      	ldr	r2, [pc, #188]	; (8005e20 <Vector5C+0xc0>)
OSAL_IRQ_HANDLER(Vector5C) {
 8005d62:	b570      	push	{r4, r5, r6, lr}
  pr &= ((1U << 4)  | (1U << 5)  | (1U << 6)  | (1U << 7)  | (1U << 8)  |
 8005d64:	4b2f      	ldr	r3, [pc, #188]	; (8005e24 <Vector5C+0xc4>)
  pr = EXTI->PR;
 8005d66:	6954      	ldr	r4, [r2, #20]
  OSAL_IRQ_PROLOGUE();
 8005d68:	4675      	mov	r5, lr
  pr &= ((1U << 4)  | (1U << 5)  | (1U << 6)  | (1U << 7)  | (1U << 8)  |
 8005d6a:	4023      	ands	r3, r4
         (1U << 9)  | (1U << 10) | (1U << 11) | (1U << 12) | (1U << 13) |
         (1U << 14) | (1U << 15));
  EXTI->PR = pr;
 8005d6c:	6153      	str	r3, [r2, #20]
  if (pr & (1U << 4))
 8005d6e:	06e3      	lsls	r3, r4, #27
 8005d70:	d504      	bpl.n	8005d7c <Vector5C+0x1c>
    EXTD1.config->channels[4].cb(&EXTD1, 4);
 8005d72:	482d      	ldr	r0, [pc, #180]	; (8005e28 <Vector5C+0xc8>)
 8005d74:	2104      	movs	r1, #4
 8005d76:	6843      	ldr	r3, [r0, #4]
 8005d78:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8005d7a:	4798      	blx	r3
  if (pr & (1U << 5))
 8005d7c:	06a3      	lsls	r3, r4, #26
 8005d7e:	d504      	bpl.n	8005d8a <Vector5C+0x2a>
    EXTD1.config->channels[5].cb(&EXTD1, 5);
 8005d80:	4829      	ldr	r0, [pc, #164]	; (8005e28 <Vector5C+0xc8>)
 8005d82:	2105      	movs	r1, #5
 8005d84:	6843      	ldr	r3, [r0, #4]
 8005d86:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8005d88:	4798      	blx	r3
  if (pr & (1U << 6))
 8005d8a:	0663      	lsls	r3, r4, #25
 8005d8c:	d504      	bpl.n	8005d98 <Vector5C+0x38>
    EXTD1.config->channels[6].cb(&EXTD1, 6);
 8005d8e:	4826      	ldr	r0, [pc, #152]	; (8005e28 <Vector5C+0xc8>)
 8005d90:	2106      	movs	r1, #6
 8005d92:	6843      	ldr	r3, [r0, #4]
 8005d94:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8005d96:	4798      	blx	r3
  if (pr & (1U << 7))
 8005d98:	0623      	lsls	r3, r4, #24
 8005d9a:	d504      	bpl.n	8005da6 <Vector5C+0x46>
    EXTD1.config->channels[7].cb(&EXTD1, 7);
 8005d9c:	4822      	ldr	r0, [pc, #136]	; (8005e28 <Vector5C+0xc8>)
 8005d9e:	2107      	movs	r1, #7
 8005da0:	6843      	ldr	r3, [r0, #4]
 8005da2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8005da4:	4798      	blx	r3
  if (pr & (1U << 8))
 8005da6:	05e3      	lsls	r3, r4, #23
 8005da8:	d504      	bpl.n	8005db4 <Vector5C+0x54>
    EXTD1.config->channels[8].cb(&EXTD1, 8);
 8005daa:	481f      	ldr	r0, [pc, #124]	; (8005e28 <Vector5C+0xc8>)
 8005dac:	2108      	movs	r1, #8
 8005dae:	6843      	ldr	r3, [r0, #4]
 8005db0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8005db2:	4798      	blx	r3
  if (pr & (1U << 9))
 8005db4:	05a3      	lsls	r3, r4, #22
 8005db6:	d504      	bpl.n	8005dc2 <Vector5C+0x62>
    EXTD1.config->channels[9].cb(&EXTD1, 9);
 8005db8:	481b      	ldr	r0, [pc, #108]	; (8005e28 <Vector5C+0xc8>)
 8005dba:	2109      	movs	r1, #9
 8005dbc:	6843      	ldr	r3, [r0, #4]
 8005dbe:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8005dc0:	4798      	blx	r3
  if (pr & (1U << 10))
 8005dc2:	0563      	lsls	r3, r4, #21
 8005dc4:	d504      	bpl.n	8005dd0 <Vector5C+0x70>
    EXTD1.config->channels[10].cb(&EXTD1, 10);
 8005dc6:	4818      	ldr	r0, [pc, #96]	; (8005e28 <Vector5C+0xc8>)
 8005dc8:	210a      	movs	r1, #10
 8005dca:	6843      	ldr	r3, [r0, #4]
 8005dcc:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8005dce:	4798      	blx	r3
  if (pr & (1U << 11))
 8005dd0:	0523      	lsls	r3, r4, #20
 8005dd2:	d504      	bpl.n	8005dde <Vector5C+0x7e>
    EXTD1.config->channels[11].cb(&EXTD1, 11);
 8005dd4:	4814      	ldr	r0, [pc, #80]	; (8005e28 <Vector5C+0xc8>)
 8005dd6:	210b      	movs	r1, #11
 8005dd8:	6843      	ldr	r3, [r0, #4]
 8005dda:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8005ddc:	4798      	blx	r3
  if (pr & (1U << 12))
 8005dde:	04e3      	lsls	r3, r4, #19
 8005de0:	d504      	bpl.n	8005dec <Vector5C+0x8c>
    EXTD1.config->channels[12].cb(&EXTD1, 12);
 8005de2:	4811      	ldr	r0, [pc, #68]	; (8005e28 <Vector5C+0xc8>)
 8005de4:	210c      	movs	r1, #12
 8005de6:	6843      	ldr	r3, [r0, #4]
 8005de8:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8005dea:	4798      	blx	r3
  if (pr & (1U << 13))
 8005dec:	04a3      	lsls	r3, r4, #18
 8005dee:	d504      	bpl.n	8005dfa <Vector5C+0x9a>
    EXTD1.config->channels[13].cb(&EXTD1, 13);
 8005df0:	480d      	ldr	r0, [pc, #52]	; (8005e28 <Vector5C+0xc8>)
 8005df2:	210d      	movs	r1, #13
 8005df4:	6843      	ldr	r3, [r0, #4]
 8005df6:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8005df8:	4798      	blx	r3
  if (pr & (1U << 14))
 8005dfa:	0463      	lsls	r3, r4, #17
 8005dfc:	d504      	bpl.n	8005e08 <Vector5C+0xa8>
    EXTD1.config->channels[14].cb(&EXTD1, 14);
 8005dfe:	480a      	ldr	r0, [pc, #40]	; (8005e28 <Vector5C+0xc8>)
 8005e00:	210e      	movs	r1, #14
 8005e02:	6843      	ldr	r3, [r0, #4]
 8005e04:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8005e06:	4798      	blx	r3
  if (pr & (1U << 15))
 8005e08:	0423      	lsls	r3, r4, #16
 8005e0a:	d504      	bpl.n	8005e16 <Vector5C+0xb6>
    EXTD1.config->channels[15].cb(&EXTD1, 15);
 8005e0c:	4806      	ldr	r0, [pc, #24]	; (8005e28 <Vector5C+0xc8>)
 8005e0e:	210f      	movs	r1, #15
 8005e10:	6843      	ldr	r3, [r0, #4]
 8005e12:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8005e14:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8005e16:	0028      	movs	r0, r5
 8005e18:	f7fe f9d2 	bl	80041c0 <_port_irq_epilogue>
}
 8005e1c:	bd70      	pop	{r4, r5, r6, pc}
 8005e1e:	46c0      	nop			; (mov r8, r8)
 8005e20:	40010400 	.word	0x40010400
 8005e24:	0000fff0 	.word	0x0000fff0
 8005e28:	2000183c 	.word	0x2000183c
 8005e2c:	00000000 	.word	0x00000000

08005e30 <Vector44>:
OSAL_IRQ_HANDLER(Vector44) {
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  pr = EXTI->PR;
 8005e30:	4a0a      	ldr	r2, [pc, #40]	; (8005e5c <Vector44+0x2c>)
OSAL_IRQ_HANDLER(Vector44) {
 8005e32:	b510      	push	{r4, lr}
  pr = EXTI->PR;
 8005e34:	6953      	ldr	r3, [r2, #20]
  pr &= EXTI->IMR & (1U << 16);
 8005e36:	6811      	ldr	r1, [r2, #0]
  OSAL_IRQ_PROLOGUE();
 8005e38:	4674      	mov	r4, lr
  pr &= EXTI->IMR & (1U << 16);
 8005e3a:	400b      	ands	r3, r1
 8005e3c:	2180      	movs	r1, #128	; 0x80
 8005e3e:	0249      	lsls	r1, r1, #9
 8005e40:	400b      	ands	r3, r1
  EXTI->PR = pr;
 8005e42:	6153      	str	r3, [r2, #20]
  if (pr & (1U << 16))
 8005e44:	d005      	beq.n	8005e52 <Vector44+0x22>
    EXTD1.config->channels[16].cb(&EXTD1, 16);
 8005e46:	2384      	movs	r3, #132	; 0x84
 8005e48:	4805      	ldr	r0, [pc, #20]	; (8005e60 <Vector44+0x30>)
 8005e4a:	2110      	movs	r1, #16
 8005e4c:	6842      	ldr	r2, [r0, #4]
 8005e4e:	58d3      	ldr	r3, [r2, r3]
 8005e50:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8005e52:	0020      	movs	r0, r4
 8005e54:	f7fe f9b4 	bl	80041c0 <_port_irq_epilogue>
}
 8005e58:	bd10      	pop	{r4, pc}
 8005e5a:	46c0      	nop			; (mov r8, r8)
 8005e5c:	40010400 	.word	0x40010400
 8005e60:	2000183c 	.word	0x2000183c
	...

08005e70 <Vector48>:
OSAL_IRQ_HANDLER(Vector48) {
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  pr = EXTI->PR;
 8005e70:	4b12      	ldr	r3, [pc, #72]	; (8005ebc <Vector48+0x4c>)
OSAL_IRQ_HANDLER(Vector48) {
 8005e72:	b570      	push	{r4, r5, r6, lr}
  pr = EXTI->PR;
 8005e74:	695c      	ldr	r4, [r3, #20]
  pr &= EXTI->IMR & ((1U << 17) | (1U << 19) | (1U << 20));
 8005e76:	681a      	ldr	r2, [r3, #0]
  OSAL_IRQ_PROLOGUE();
 8005e78:	4675      	mov	r5, lr
  pr &= EXTI->IMR & ((1U << 17) | (1U << 19) | (1U << 20));
 8005e7a:	4014      	ands	r4, r2
 8005e7c:	22d0      	movs	r2, #208	; 0xd0
 8005e7e:	0352      	lsls	r2, r2, #13
 8005e80:	4022      	ands	r2, r4
  EXTI->PR = pr;
 8005e82:	615a      	str	r2, [r3, #20]
  if (pr & (1U << 17))
 8005e84:	03a3      	lsls	r3, r4, #14
 8005e86:	d505      	bpl.n	8005e94 <Vector48+0x24>
    EXTD1.config->channels[17].cb(&EXTD1, 17);
 8005e88:	238c      	movs	r3, #140	; 0x8c
 8005e8a:	480d      	ldr	r0, [pc, #52]	; (8005ec0 <Vector48+0x50>)
 8005e8c:	2111      	movs	r1, #17
 8005e8e:	6842      	ldr	r2, [r0, #4]
 8005e90:	58d3      	ldr	r3, [r2, r3]
 8005e92:	4798      	blx	r3
  if (pr & (1U << 19))
 8005e94:	0323      	lsls	r3, r4, #12
 8005e96:	d505      	bpl.n	8005ea4 <Vector48+0x34>
    EXTD1.config->channels[19].cb(&EXTD1, 19);
 8005e98:	239c      	movs	r3, #156	; 0x9c
 8005e9a:	4809      	ldr	r0, [pc, #36]	; (8005ec0 <Vector48+0x50>)
 8005e9c:	2113      	movs	r1, #19
 8005e9e:	6842      	ldr	r2, [r0, #4]
 8005ea0:	58d3      	ldr	r3, [r2, r3]
 8005ea2:	4798      	blx	r3
  if (pr & (1U << 20))
 8005ea4:	02e3      	lsls	r3, r4, #11
 8005ea6:	d505      	bpl.n	8005eb4 <Vector48+0x44>
    EXTD1.config->channels[20].cb(&EXTD1, 20);
 8005ea8:	23a4      	movs	r3, #164	; 0xa4
 8005eaa:	4805      	ldr	r0, [pc, #20]	; (8005ec0 <Vector48+0x50>)
 8005eac:	2114      	movs	r1, #20
 8005eae:	6842      	ldr	r2, [r0, #4]
 8005eb0:	58d3      	ldr	r3, [r2, r3]
 8005eb2:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8005eb4:	0028      	movs	r0, r5
 8005eb6:	f7fe f983 	bl	80041c0 <_port_irq_epilogue>
}
 8005eba:	bd70      	pop	{r4, r5, r6, pc}
 8005ebc:	40010400 	.word	0x40010400
 8005ec0:	2000183c 	.word	0x2000183c
	...

08005ed0 <ext_lld_exti_irq_enable>:
/**
 * @brief   Enables EXTI IRQ sources.
 *
 * @notapi
 */
void ext_lld_exti_irq_enable(void) {
 8005ed0:	b510      	push	{r4, lr}

  nvicEnableVector(EXTI0_1_IRQn, STM32_EXT_EXTI0_1_IRQ_PRIORITY);
 8005ed2:	2103      	movs	r1, #3
 8005ed4:	2005      	movs	r0, #5
 8005ed6:	f7ff fc3b 	bl	8005750 <nvicEnableVector>
  nvicEnableVector(EXTI2_3_IRQn, STM32_EXT_EXTI2_3_IRQ_PRIORITY);
 8005eda:	2103      	movs	r1, #3
 8005edc:	2006      	movs	r0, #6
 8005ede:	f7ff fc37 	bl	8005750 <nvicEnableVector>
  nvicEnableVector(EXTI4_15_IRQn, STM32_EXT_EXTI4_15_IRQ_PRIORITY);
 8005ee2:	2103      	movs	r1, #3
 8005ee4:	2007      	movs	r0, #7
 8005ee6:	f7ff fc33 	bl	8005750 <nvicEnableVector>
#if !defined(STM32F030) && !defined(STM32F070)
  nvicEnableVector(PVD_IRQn, STM32_EXT_EXTI16_IRQ_PRIORITY);
 8005eea:	2103      	movs	r1, #3
 8005eec:	2001      	movs	r0, #1
 8005eee:	f7ff fc2f 	bl	8005750 <nvicEnableVector>
  nvicEnableVector(ADC1_COMP_IRQn, STM32_EXT_EXTI21_22_IRQ_PRIORITY);
 8005ef2:	2103      	movs	r1, #3
 8005ef4:	200c      	movs	r0, #12
 8005ef6:	f7ff fc2b 	bl	8005750 <nvicEnableVector>
#endif
  nvicEnableVector(RTC_IRQn, STM32_EXT_EXTI17_20_IRQ_PRIORITY);
 8005efa:	2103      	movs	r1, #3
 8005efc:	2002      	movs	r0, #2
 8005efe:	f7ff fc27 	bl	8005750 <nvicEnableVector>
}
 8005f02:	bd10      	pop	{r4, pc}
	...

08005f10 <_pal_lld_init>:
  RCC->IOPSMENR |= AHB_LPEN_MASK;
#elif defined(STM32L1XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
  RCC->AHBLPENR |= AHB_LPEN_MASK;
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
 8005f10:	23fc      	movs	r3, #252	; 0xfc
 8005f12:	4a33      	ldr	r2, [pc, #204]	; (8005fe0 <_pal_lld_init+0xd0>)
 8005f14:	03db      	lsls	r3, r3, #15
 8005f16:	6951      	ldr	r1, [r2, #20]
 8005f18:	430b      	orrs	r3, r1
 8005f1a:	6153      	str	r3, [r2, #20]
  gpiop->OTYPER  = config->otyper;
 8005f1c:	2390      	movs	r3, #144	; 0x90
 8005f1e:	6842      	ldr	r2, [r0, #4]
 8005f20:	05db      	lsls	r3, r3, #23
 8005f22:	605a      	str	r2, [r3, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8005f24:	6882      	ldr	r2, [r0, #8]
 8005f26:	609a      	str	r2, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
 8005f28:	68c2      	ldr	r2, [r0, #12]
 8005f2a:	60da      	str	r2, [r3, #12]
  gpiop->ODR     = config->odr;
 8005f2c:	6902      	ldr	r2, [r0, #16]
 8005f2e:	615a      	str	r2, [r3, #20]
  gpiop->AFRL    = config->afrl;
 8005f30:	6942      	ldr	r2, [r0, #20]
 8005f32:	621a      	str	r2, [r3, #32]
  gpiop->AFRH    = config->afrh;
 8005f34:	6982      	ldr	r2, [r0, #24]
 8005f36:	625a      	str	r2, [r3, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8005f38:	6802      	ldr	r2, [r0, #0]
 8005f3a:	601a      	str	r2, [r3, #0]
  gpiop->OTYPER  = config->otyper;
 8005f3c:	6a02      	ldr	r2, [r0, #32]
 8005f3e:	4b29      	ldr	r3, [pc, #164]	; (8005fe4 <_pal_lld_init+0xd4>)
 8005f40:	605a      	str	r2, [r3, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8005f42:	6a42      	ldr	r2, [r0, #36]	; 0x24
 8005f44:	609a      	str	r2, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
 8005f46:	6a82      	ldr	r2, [r0, #40]	; 0x28
 8005f48:	60da      	str	r2, [r3, #12]
  gpiop->ODR     = config->odr;
 8005f4a:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 8005f4c:	615a      	str	r2, [r3, #20]
  gpiop->AFRL    = config->afrl;
 8005f4e:	6b02      	ldr	r2, [r0, #48]	; 0x30
 8005f50:	621a      	str	r2, [r3, #32]
  gpiop->AFRH    = config->afrh;
 8005f52:	6b42      	ldr	r2, [r0, #52]	; 0x34
 8005f54:	625a      	str	r2, [r3, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8005f56:	69c2      	ldr	r2, [r0, #28]
 8005f58:	601a      	str	r2, [r3, #0]
  gpiop->OTYPER  = config->otyper;
 8005f5a:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
 8005f5c:	4b22      	ldr	r3, [pc, #136]	; (8005fe8 <_pal_lld_init+0xd8>)
 8005f5e:	605a      	str	r2, [r3, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8005f60:	6c02      	ldr	r2, [r0, #64]	; 0x40
 8005f62:	609a      	str	r2, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
 8005f64:	6c42      	ldr	r2, [r0, #68]	; 0x44
 8005f66:	60da      	str	r2, [r3, #12]
  gpiop->ODR     = config->odr;
 8005f68:	6c82      	ldr	r2, [r0, #72]	; 0x48
 8005f6a:	615a      	str	r2, [r3, #20]
  gpiop->AFRL    = config->afrl;
 8005f6c:	6cc2      	ldr	r2, [r0, #76]	; 0x4c
 8005f6e:	621a      	str	r2, [r3, #32]
  gpiop->AFRH    = config->afrh;
 8005f70:	6d02      	ldr	r2, [r0, #80]	; 0x50
 8005f72:	625a      	str	r2, [r3, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8005f74:	6b82      	ldr	r2, [r0, #56]	; 0x38
 8005f76:	601a      	str	r2, [r3, #0]
  gpiop->OTYPER  = config->otyper;
 8005f78:	6d82      	ldr	r2, [r0, #88]	; 0x58
 8005f7a:	4b1c      	ldr	r3, [pc, #112]	; (8005fec <_pal_lld_init+0xdc>)
 8005f7c:	605a      	str	r2, [r3, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8005f7e:	6dc2      	ldr	r2, [r0, #92]	; 0x5c
 8005f80:	609a      	str	r2, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
 8005f82:	6e02      	ldr	r2, [r0, #96]	; 0x60
 8005f84:	60da      	str	r2, [r3, #12]
  gpiop->ODR     = config->odr;
 8005f86:	6e42      	ldr	r2, [r0, #100]	; 0x64
 8005f88:	615a      	str	r2, [r3, #20]
  gpiop->AFRL    = config->afrl;
 8005f8a:	6e82      	ldr	r2, [r0, #104]	; 0x68
 8005f8c:	621a      	str	r2, [r3, #32]
  gpiop->AFRH    = config->afrh;
 8005f8e:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
 8005f90:	625a      	str	r2, [r3, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8005f92:	6d42      	ldr	r2, [r0, #84]	; 0x54
 8005f94:	601a      	str	r2, [r3, #0]
  gpiop->OTYPER  = config->otyper;
 8005f96:	6f42      	ldr	r2, [r0, #116]	; 0x74
 8005f98:	4b15      	ldr	r3, [pc, #84]	; (8005ff0 <_pal_lld_init+0xe0>)
 8005f9a:	605a      	str	r2, [r3, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8005f9c:	6f82      	ldr	r2, [r0, #120]	; 0x78
 8005f9e:	609a      	str	r2, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
 8005fa0:	6fc2      	ldr	r2, [r0, #124]	; 0x7c
 8005fa2:	60da      	str	r2, [r3, #12]
  gpiop->ODR     = config->odr;
 8005fa4:	2280      	movs	r2, #128	; 0x80
 8005fa6:	5882      	ldr	r2, [r0, r2]
 8005fa8:	615a      	str	r2, [r3, #20]
  gpiop->AFRL    = config->afrl;
 8005faa:	2284      	movs	r2, #132	; 0x84
 8005fac:	5882      	ldr	r2, [r0, r2]
 8005fae:	621a      	str	r2, [r3, #32]
  gpiop->AFRH    = config->afrh;
 8005fb0:	2288      	movs	r2, #136	; 0x88
 8005fb2:	5882      	ldr	r2, [r0, r2]
 8005fb4:	625a      	str	r2, [r3, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8005fb6:	6f02      	ldr	r2, [r0, #112]	; 0x70
 8005fb8:	601a      	str	r2, [r3, #0]
  gpiop->OTYPER  = config->otyper;
 8005fba:	0002      	movs	r2, r0
 8005fbc:	328c      	adds	r2, #140	; 0x8c
 8005fbe:	6851      	ldr	r1, [r2, #4]
 8005fc0:	4b0c      	ldr	r3, [pc, #48]	; (8005ff4 <_pal_lld_init+0xe4>)
 8005fc2:	6059      	str	r1, [r3, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8005fc4:	6891      	ldr	r1, [r2, #8]
 8005fc6:	6099      	str	r1, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
 8005fc8:	68d1      	ldr	r1, [r2, #12]
 8005fca:	60d9      	str	r1, [r3, #12]
  gpiop->ODR     = config->odr;
 8005fcc:	6911      	ldr	r1, [r2, #16]
 8005fce:	6159      	str	r1, [r3, #20]
  gpiop->AFRL    = config->afrl;
 8005fd0:	6951      	ldr	r1, [r2, #20]
 8005fd2:	6219      	str	r1, [r3, #32]
  gpiop->AFRH    = config->afrh;
 8005fd4:	6992      	ldr	r2, [r2, #24]
 8005fd6:	625a      	str	r2, [r3, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8005fd8:	228c      	movs	r2, #140	; 0x8c
 8005fda:	5882      	ldr	r2, [r0, r2]
 8005fdc:	601a      	str	r2, [r3, #0]
  initgpio(GPIOJ, &config->PJData);
#endif
#if STM32_HAS_GPIOK
  initgpio(GPIOK, &config->PKData);
#endif
}
 8005fde:	4770      	bx	lr
 8005fe0:	40021000 	.word	0x40021000
 8005fe4:	48000400 	.word	0x48000400
 8005fe8:	48000800 	.word	0x48000800
 8005fec:	48000c00 	.word	0x48000c00
 8005ff0:	48001000 	.word	0x48001000
 8005ff4:	48001400 	.word	0x48001400
	...

08006000 <_pal_lld_setgroupmode>:
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
 8006000:	b5f0      	push	{r4, r5, r6, r7, lr}
 8006002:	4657      	mov	r7, sl
 8006004:	464e      	mov	r6, r9
 8006006:	4645      	mov	r5, r8
 8006008:	46de      	mov	lr, fp
 800600a:	b5e0      	push	{r5, r6, r7, lr}

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 800600c:	2603      	movs	r6, #3
 800600e:	0037      	movs	r7, r6
                           iomode_t mode) {
 8006010:	0013      	movs	r3, r2
  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 8006012:	4017      	ands	r7, r2
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
 8006014:	0752      	lsls	r2, r2, #29
 8006016:	0fd2      	lsrs	r2, r2, #31
 8006018:	4694      	mov	ip, r2
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
 800601a:	095c      	lsrs	r4, r3, #5
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
 800601c:	08da      	lsrs	r2, r3, #3
 800601e:	4032      	ands	r2, r6
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
 8006020:	4026      	ands	r6, r4
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
  uint32_t bit     = 0;
  while (true) {
    if ((mask & 1) != 0) {
 8006022:	2401      	movs	r4, #1
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
 8006024:	055b      	lsls	r3, r3, #21
 8006026:	0f1b      	lsrs	r3, r3, #28
 8006028:	469a      	mov	sl, r3
           before switching mode in order to avoid glitches.*/
        if (bit < 8)
          port->AFRL = (port->AFRL & ~m4) | altrmask;
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
        port->MODER   = (port->MODER & ~m2) | moder;
 800602a:	46b0      	mov	r8, r6
                           iomode_t mode) {
 800602c:	b083      	sub	sp, #12
        port->MODER   = (port->MODER & ~m2) | moder;
 800602e:	4666      	mov	r6, ip
  uint32_t bit     = 0;
 8006030:	2300      	movs	r3, #0
    if ((mask & 1) != 0) {
 8006032:	46a1      	mov	r9, r4
        port->MODER   = (port->MODER & ~m2) | moder;
 8006034:	4694      	mov	ip, r2
 8006036:	e015      	b.n	8006064 <_pal_lld_setgroupmode+0x64>
      }
      else {
        /* If going into a non-alternate mode then the mode is switched
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
 8006038:	6805      	ldr	r5, [r0, #0]
 800603a:	402c      	ands	r4, r5
 800603c:	433c      	orrs	r4, r7
 800603e:	6004      	str	r4, [r0, #0]
        if (bit < 8)
 8006040:	2b07      	cmp	r3, #7
 8006042:	d849      	bhi.n	80060d8 <_pal_lld_setgroupmode+0xd8>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 8006044:	6a04      	ldr	r4, [r0, #32]
 8006046:	4022      	ands	r2, r4
 8006048:	465c      	mov	r4, fp
 800604a:	4322      	orrs	r2, r4
 800604c:	6202      	str	r2, [r0, #32]
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
      }
    }
    mask >>= 1;
 800604e:	0849      	lsrs	r1, r1, #1
    if (!mask)
 8006050:	d03b      	beq.n	80060ca <_pal_lld_setgroupmode+0xca>
      return;
    otyper <<= 1;
    ospeedr <<= 2;
 8006052:	4662      	mov	r2, ip
 8006054:	0092      	lsls	r2, r2, #2
 8006056:	4694      	mov	ip, r2
    pupdr <<= 2;
 8006058:	4642      	mov	r2, r8
 800605a:	0092      	lsls	r2, r2, #2
 800605c:	4690      	mov	r8, r2
    otyper <<= 1;
 800605e:	0076      	lsls	r6, r6, #1
    moder <<= 2;
 8006060:	00bf      	lsls	r7, r7, #2
    bit++;
 8006062:	3301      	adds	r3, #1
    if ((mask & 1) != 0) {
 8006064:	464a      	mov	r2, r9
 8006066:	420a      	tst	r2, r1
 8006068:	d0f1      	beq.n	800604e <_pal_lld_setgroupmode+0x4e>
      altrmask = altr << ((bit & 7) * 4);
 800606a:	2207      	movs	r2, #7
 800606c:	4654      	mov	r4, sl
 800606e:	401a      	ands	r2, r3
 8006070:	0095      	lsls	r5, r2, #2
 8006072:	40ac      	lsls	r4, r5
 8006074:	9501      	str	r5, [sp, #4]
      m1 = 1 << bit;
 8006076:	464d      	mov	r5, r9
 8006078:	409d      	lsls	r5, r3
      m2 = 3 << (bit * 2);
 800607a:	2203      	movs	r2, #3
      altrmask = altr << ((bit & 7) * 4);
 800607c:	46a3      	mov	fp, r4
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 800607e:	6844      	ldr	r4, [r0, #4]
 8006080:	43ac      	bics	r4, r5
 8006082:	4334      	orrs	r4, r6
 8006084:	6044      	str	r4, [r0, #4]
      m2 = 3 << (bit * 2);
 8006086:	005c      	lsls	r4, r3, #1
 8006088:	40a2      	lsls	r2, r4
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 800608a:	43d4      	mvns	r4, r2
 800608c:	4662      	mov	r2, ip
 800608e:	6885      	ldr	r5, [r0, #8]
 8006090:	4025      	ands	r5, r4
 8006092:	4315      	orrs	r5, r2
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 8006094:	4642      	mov	r2, r8
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 8006096:	6085      	str	r5, [r0, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 8006098:	68c5      	ldr	r5, [r0, #12]
 800609a:	4025      	ands	r5, r4
 800609c:	4315      	orrs	r5, r2
      m4 = 15 << ((bit & 7) * 4);
 800609e:	220f      	movs	r2, #15
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 80060a0:	60c5      	str	r5, [r0, #12]
      m4 = 15 << ((bit & 7) * 4);
 80060a2:	9d01      	ldr	r5, [sp, #4]
 80060a4:	40aa      	lsls	r2, r5
 80060a6:	43d2      	mvns	r2, r2
      if (moder == PAL_STM32_MODE_ALTERNATE) {
 80060a8:	2f02      	cmp	r7, #2
 80060aa:	d1c5      	bne.n	8006038 <_pal_lld_setgroupmode+0x38>
        if (bit < 8)
 80060ac:	2b07      	cmp	r3, #7
 80060ae:	d819      	bhi.n	80060e4 <_pal_lld_setgroupmode+0xe4>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 80060b0:	6a05      	ldr	r5, [r0, #32]
 80060b2:	402a      	ands	r2, r5
 80060b4:	465d      	mov	r5, fp
 80060b6:	432a      	orrs	r2, r5
 80060b8:	6202      	str	r2, [r0, #32]
        port->MODER   = (port->MODER & ~m2) | moder;
 80060ba:	6802      	ldr	r2, [r0, #0]
    mask >>= 1;
 80060bc:	0849      	lsrs	r1, r1, #1
        port->MODER   = (port->MODER & ~m2) | moder;
 80060be:	4014      	ands	r4, r2
 80060c0:	2202      	movs	r2, #2
 80060c2:	4314      	orrs	r4, r2
 80060c4:	6004      	str	r4, [r0, #0]
    if (!mask)
 80060c6:	2900      	cmp	r1, #0
 80060c8:	d1c3      	bne.n	8006052 <_pal_lld_setgroupmode+0x52>
  }
}
 80060ca:	b003      	add	sp, #12
 80060cc:	bc3c      	pop	{r2, r3, r4, r5}
 80060ce:	4690      	mov	r8, r2
 80060d0:	4699      	mov	r9, r3
 80060d2:	46a2      	mov	sl, r4
 80060d4:	46ab      	mov	fp, r5
 80060d6:	bdf0      	pop	{r4, r5, r6, r7, pc}
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 80060d8:	6a44      	ldr	r4, [r0, #36]	; 0x24
 80060da:	4022      	ands	r2, r4
 80060dc:	465c      	mov	r4, fp
 80060de:	4322      	orrs	r2, r4
 80060e0:	6242      	str	r2, [r0, #36]	; 0x24
 80060e2:	e7b4      	b.n	800604e <_pal_lld_setgroupmode+0x4e>
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 80060e4:	6a45      	ldr	r5, [r0, #36]	; 0x24
 80060e6:	402a      	ands	r2, r5
 80060e8:	465d      	mov	r5, fp
 80060ea:	432a      	orrs	r2, r5
 80060ec:	6242      	str	r2, [r0, #36]	; 0x24
 80060ee:	e7e4      	b.n	80060ba <_pal_lld_setgroupmode+0xba>

080060f0 <Vector9C>:
  OSAL_IRQ_PROLOGUE();

  /* Clearing IRQ bits.*/
  I2CD1.i2c->ICR = isr;

  if (isr & I2C_ERROR_MASK)
 80060f0:	21fc      	movs	r1, #252	; 0xfc
  uint32_t isr = I2CD1.i2c->ISR;
 80060f2:	4879      	ldr	r0, [pc, #484]	; (80062d8 <Vector9C+0x1e8>)
OSAL_IRQ_HANDLER(STM32_I2C1_GLOBAL_HANDLER) {
 80060f4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t isr = I2CD1.i2c->ISR;
 80060f6:	6b42      	ldr	r2, [r0, #52]	; 0x34
  if (isr & I2C_ERROR_MASK)
 80060f8:	0189      	lsls	r1, r1, #6
  uint32_t isr = I2CD1.i2c->ISR;
 80060fa:	6993      	ldr	r3, [r2, #24]
  OSAL_IRQ_PROLOGUE();
 80060fc:	4674      	mov	r4, lr
  I2CD1.i2c->ICR = isr;
 80060fe:	0015      	movs	r5, r2
 8006100:	61d3      	str	r3, [r2, #28]
  if (isr & I2C_ERROR_MASK)
 8006102:	420b      	tst	r3, r1
 8006104:	d129      	bne.n	800615a <Vector9C+0x6a>
    i2c_lld_serve_error_interrupt(&I2CD1, isr);
  else if (isr & I2C_INT_MASK)
 8006106:	21fe      	movs	r1, #254	; 0xfe
 8006108:	4219      	tst	r1, r3
 800610a:	d103      	bne.n	8006114 <Vector9C+0x24>
    i2c_lld_serve_interrupt(&I2CD1, isr);

  OSAL_IRQ_EPILOGUE();
 800610c:	0020      	movs	r0, r4
 800610e:	f7fe f857 	bl	80041c0 <_port_irq_epilogue>
}
 8006112:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if ((isr & I2C_ISR_NACKF) != 0U) {
 8006114:	06d9      	lsls	r1, r3, #27
 8006116:	d500      	bpl.n	800611a <Vector9C+0x2a>
 8006118:	e086      	b.n	8006228 <Vector9C+0x138>
    if (i2cp->state == I2C_ACTIVE_TX) {
 800611a:	7806      	ldrb	r6, [r0, #0]
    uint32_t cr1 = dp->CR1;
 800611c:	6811      	ldr	r1, [r2, #0]
    if (i2cp->state == I2C_ACTIVE_TX) {
 800611e:	2e03      	cmp	r6, #3
 8006120:	d049      	beq.n	80061b6 <Vector9C+0xc6>
      if (((cr1 & I2C_CR1_RXIE) != 0U) && ((isr & I2C_ISR_RXNE) != 0U)) {
 8006122:	2604      	movs	r6, #4
 8006124:	420e      	tst	r6, r1
 8006126:	d041      	beq.n	80061ac <Vector9C+0xbc>
 8006128:	421e      	tst	r6, r3
 800612a:	d03f      	beq.n	80061ac <Vector9C+0xbc>
        *i2cp->rxptr = (uint8_t)dp->RXDR;
 800612c:	6a51      	ldr	r1, [r2, #36]	; 0x24
 800612e:	6ac5      	ldr	r5, [r0, #44]	; 0x2c
 8006130:	7029      	strb	r1, [r5, #0]
        i2cp->rxptr++;
 8006132:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
 8006134:	3101      	adds	r1, #1
 8006136:	62c1      	str	r1, [r0, #44]	; 0x2c
        i2cp->rxbytes--;
 8006138:	6b01      	ldr	r1, [r0, #48]	; 0x30
 800613a:	3901      	subs	r1, #1
 800613c:	6301      	str	r1, [r0, #48]	; 0x30
        if (i2cp->rxbytes == 0U) {
 800613e:	2900      	cmp	r1, #0
 8006140:	d102      	bne.n	8006148 <Vector9C+0x58>
          dp->CR1 &= ~I2C_CR1_RXIE;
 8006142:	6815      	ldr	r5, [r2, #0]
 8006144:	43b5      	bics	r5, r6
 8006146:	6015      	str	r5, [r2, #0]
  if ((isr & I2C_ISR_TCR) != 0U) {
 8006148:	061d      	lsls	r5, r3, #24
 800614a:	d500      	bpl.n	800614e <Vector9C+0x5e>
 800614c:	e080      	b.n	8006250 <Vector9C+0x160>
  if ((isr & I2C_ISR_TC) != 0U) {
 800614e:	065b      	lsls	r3, r3, #25
 8006150:	d5dc      	bpl.n	800610c <Vector9C+0x1c>
    if (i2cp->state == I2C_ACTIVE_TX) {
 8006152:	7803      	ldrb	r3, [r0, #0]
 8006154:	2b03      	cmp	r3, #3
 8006156:	d054      	beq.n	8006202 <Vector9C+0x112>
 8006158:	e056      	b.n	8006208 <Vector9C+0x118>
  i2cp->i2c->CR1 &= ~(I2C_CR1_TXIE | I2C_CR1_RXIE);
 800615a:	2506      	movs	r5, #6
 800615c:	6811      	ldr	r1, [r2, #0]
 800615e:	43a9      	bics	r1, r5
 8006160:	6011      	str	r1, [r2, #0]
  if (isr & I2C_ISR_BERR)
 8006162:	6882      	ldr	r2, [r0, #8]
 8006164:	05d9      	lsls	r1, r3, #23
 8006166:	d502      	bpl.n	800616e <Vector9C+0x7e>
    i2cp->errors |= I2C_BUS_ERROR;
 8006168:	2101      	movs	r1, #1
 800616a:	430a      	orrs	r2, r1
 800616c:	6082      	str	r2, [r0, #8]
  if (isr & I2C_ISR_ARLO)
 800616e:	0599      	lsls	r1, r3, #22
 8006170:	d502      	bpl.n	8006178 <Vector9C+0x88>
    i2cp->errors |= I2C_ARBITRATION_LOST;
 8006172:	2102      	movs	r1, #2
 8006174:	430a      	orrs	r2, r1
 8006176:	6082      	str	r2, [r0, #8]
  if (isr & I2C_ISR_OVR)
 8006178:	2180      	movs	r1, #128	; 0x80
 800617a:	0149      	lsls	r1, r1, #5
 800617c:	4019      	ands	r1, r3
 800617e:	055b      	lsls	r3, r3, #21
 8006180:	d50f      	bpl.n	80061a2 <Vector9C+0xb2>
    i2cp->errors |= I2C_OVERRUN;
 8006182:	2308      	movs	r3, #8
 8006184:	431a      	orrs	r2, r3
 8006186:	6082      	str	r2, [r0, #8]
  if (isr & I2C_ISR_TIMEOUT)
 8006188:	2900      	cmp	r1, #0
 800618a:	d002      	beq.n	8006192 <Vector9C+0xa2>
    i2cp->errors |= I2C_TIMEOUT;
 800618c:	2320      	movs	r3, #32
 800618e:	431a      	orrs	r2, r3
 8006190:	6082      	str	r2, [r0, #8]
  __ASM volatile ("cpsid i" : : : "memory");
 8006192:	b672      	cpsid	i
  chThdResumeI(trp, msg);
 8006194:	2102      	movs	r1, #2
 8006196:	3020      	adds	r0, #32
 8006198:	4249      	negs	r1, r1
 800619a:	f7fd fed1 	bl	8003f40 <chThdResumeI>
  __ASM volatile ("cpsie i" : : : "memory");
 800619e:	b662      	cpsie	i
 80061a0:	e7b4      	b.n	800610c <Vector9C+0x1c>
  if (isr & I2C_ISR_TIMEOUT)
 80061a2:	2900      	cmp	r1, #0
 80061a4:	d1f2      	bne.n	800618c <Vector9C+0x9c>
  if (i2cp->errors != I2C_NO_ERROR)
 80061a6:	2a00      	cmp	r2, #0
 80061a8:	d0b0      	beq.n	800610c <Vector9C+0x1c>
 80061aa:	e7f2      	b.n	8006192 <Vector9C+0xa2>
  if ((isr & I2C_ISR_TCR) != 0U) {
 80061ac:	0619      	lsls	r1, r3, #24
 80061ae:	d45b      	bmi.n	8006268 <Vector9C+0x178>
  if ((isr & I2C_ISR_TC) != 0U) {
 80061b0:	065b      	lsls	r3, r3, #25
 80061b2:	d5ab      	bpl.n	800610c <Vector9C+0x1c>
 80061b4:	e028      	b.n	8006208 <Vector9C+0x118>
      if (((cr1 &I2C_CR1_TXIE) != 0U) && ((isr & I2C_ISR_TXIS) != 0U)) {
 80061b6:	3e01      	subs	r6, #1
 80061b8:	420e      	tst	r6, r1
 80061ba:	d01d      	beq.n	80061f8 <Vector9C+0x108>
 80061bc:	421e      	tst	r6, r3
 80061be:	d01b      	beq.n	80061f8 <Vector9C+0x108>
        dp->TXDR = (uint32_t)*i2cp->txptr;
 80061c0:	6a41      	ldr	r1, [r0, #36]	; 0x24
 80061c2:	780f      	ldrb	r7, [r1, #0]
        i2cp->txptr++;
 80061c4:	3101      	adds	r1, #1
 80061c6:	6241      	str	r1, [r0, #36]	; 0x24
        i2cp->txbytes--;
 80061c8:	6a81      	ldr	r1, [r0, #40]	; 0x28
        dp->TXDR = (uint32_t)*i2cp->txptr;
 80061ca:	6297      	str	r7, [r2, #40]	; 0x28
        i2cp->txbytes--;
 80061cc:	3901      	subs	r1, #1
 80061ce:	6281      	str	r1, [r0, #40]	; 0x28
        if (i2cp->txbytes == 0U) {
 80061d0:	2900      	cmp	r1, #0
 80061d2:	d111      	bne.n	80061f8 <Vector9C+0x108>
          dp->CR1 &= ~I2C_CR1_TXIE;
 80061d4:	6811      	ldr	r1, [r2, #0]
 80061d6:	43b1      	bics	r1, r6
 80061d8:	6011      	str	r1, [r2, #0]
  if ((isr & I2C_ISR_TCR) != 0U) {
 80061da:	0619      	lsls	r1, r3, #24
 80061dc:	d50e      	bpl.n	80061fc <Vector9C+0x10c>
  n = i2c_lld_get_txbytes(i2cp);
 80061de:	6a82      	ldr	r2, [r0, #40]	; 0x28
    reload = 0U;
 80061e0:	2100      	movs	r1, #0
 80061e2:	0412      	lsls	r2, r2, #16
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
 80061e4:	6840      	ldr	r0, [r0, #4]
 80061e6:	686b      	ldr	r3, [r5, #4]
 80061e8:	4e3c      	ldr	r6, [pc, #240]	; (80062dc <Vector9C+0x1ec>)
 80061ea:	6880      	ldr	r0, [r0, #8]
 80061ec:	4033      	ands	r3, r6
 80061ee:	4303      	orrs	r3, r0
            (n << 16U) | reload;
 80061f0:	430b      	orrs	r3, r1
 80061f2:	4313      	orrs	r3, r2
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
 80061f4:	606b      	str	r3, [r5, #4]
 80061f6:	e789      	b.n	800610c <Vector9C+0x1c>
  if ((isr & I2C_ISR_TCR) != 0U) {
 80061f8:	0619      	lsls	r1, r3, #24
 80061fa:	d42d      	bmi.n	8006258 <Vector9C+0x168>
  if ((isr & I2C_ISR_TC) != 0U) {
 80061fc:	065b      	lsls	r3, r3, #25
 80061fe:	d400      	bmi.n	8006202 <Vector9C+0x112>
 8006200:	e784      	b.n	800610c <Vector9C+0x1c>
      if (i2c_lld_get_rxbytes(i2cp) > 0U) {
 8006202:	6b03      	ldr	r3, [r0, #48]	; 0x30
 8006204:	2b00      	cmp	r3, #0
 8006206:	d146      	bne.n	8006296 <Vector9C+0x1a6>
    dp->CR2 |= I2C_CR2_STOP;
 8006208:	2380      	movs	r3, #128	; 0x80
 800620a:	6851      	ldr	r1, [r2, #4]
 800620c:	01db      	lsls	r3, r3, #7
 800620e:	430b      	orrs	r3, r1
    dp->CR1 &= ~I2C_CR1_TCIE;
 8006210:	2140      	movs	r1, #64	; 0x40
    dp->CR2 |= I2C_CR2_STOP;
 8006212:	6053      	str	r3, [r2, #4]
    dp->CR1 &= ~I2C_CR1_TCIE;
 8006214:	6813      	ldr	r3, [r2, #0]
 8006216:	438b      	bics	r3, r1
 8006218:	6013      	str	r3, [r2, #0]
  __ASM volatile ("cpsid i" : : : "memory");
 800621a:	b672      	cpsid	i
 800621c:	2100      	movs	r1, #0
 800621e:	3020      	adds	r0, #32
 8006220:	f7fd fe8e 	bl	8003f40 <chThdResumeI>
  __ASM volatile ("cpsie i" : : : "memory");
 8006224:	b662      	cpsie	i
 8006226:	e771      	b.n	800610c <Vector9C+0x1c>
    i2cp->errors |= I2C_ACK_FAILURE;
 8006228:	2304      	movs	r3, #4
 800622a:	6881      	ldr	r1, [r0, #8]
 800622c:	430b      	orrs	r3, r1
 800622e:	6083      	str	r3, [r0, #8]
    dp->CR2 |= I2C_CR2_STOP;
 8006230:	2380      	movs	r3, #128	; 0x80
 8006232:	6851      	ldr	r1, [r2, #4]
 8006234:	01db      	lsls	r3, r3, #7
 8006236:	430b      	orrs	r3, r1
    dp->CR1 &= ~(I2C_CR1_TCIE | I2C_CR1_TXIE | I2C_CR1_RXIE);
 8006238:	2146      	movs	r1, #70	; 0x46
    dp->CR2 |= I2C_CR2_STOP;
 800623a:	6053      	str	r3, [r2, #4]
    dp->CR1 &= ~(I2C_CR1_TCIE | I2C_CR1_TXIE | I2C_CR1_RXIE);
 800623c:	6813      	ldr	r3, [r2, #0]
 800623e:	438b      	bics	r3, r1
 8006240:	6013      	str	r3, [r2, #0]
  __ASM volatile ("cpsid i" : : : "memory");
 8006242:	b672      	cpsid	i
 8006244:	3020      	adds	r0, #32
 8006246:	3948      	subs	r1, #72	; 0x48
 8006248:	f7fd fe7a 	bl	8003f40 <chThdResumeI>
  __ASM volatile ("cpsie i" : : : "memory");
 800624c:	b662      	cpsie	i
    return;
 800624e:	e75d      	b.n	800610c <Vector9C+0x1c>
    if (i2cp->state == I2C_ACTIVE_TX) {
 8006250:	7803      	ldrb	r3, [r0, #0]
 8006252:	6b45      	ldr	r5, [r0, #52]	; 0x34
 8006254:	2b03      	cmp	r3, #3
 8006256:	d108      	bne.n	800626a <Vector9C+0x17a>
  n = i2c_lld_get_txbytes(i2cp);
 8006258:	6a82      	ldr	r2, [r0, #40]	; 0x28
  if (n > 255U) {
 800625a:	2aff      	cmp	r2, #255	; 0xff
 800625c:	d9c0      	bls.n	80061e0 <Vector9C+0xf0>
 800625e:	22ff      	movs	r2, #255	; 0xff
    reload = I2C_CR2_RELOAD;
 8006260:	2180      	movs	r1, #128	; 0x80
  if (n > 255U) {
 8006262:	0412      	lsls	r2, r2, #16
    reload = I2C_CR2_RELOAD;
 8006264:	0449      	lsls	r1, r1, #17
 8006266:	e7bd      	b.n	80061e4 <Vector9C+0xf4>
 8006268:	6b01      	ldr	r1, [r0, #48]	; 0x30
  if (n > 255U) {
 800626a:	29ff      	cmp	r1, #255	; 0xff
 800626c:	d80e      	bhi.n	800628c <Vector9C+0x19c>
    reload = 0U;
 800626e:	2600      	movs	r6, #0
 8006270:	0409      	lsls	r1, r1, #16
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
 8006272:	6842      	ldr	r2, [r0, #4]
 8006274:	686b      	ldr	r3, [r5, #4]
            I2C_CR2_RD_WRN | (n << 16U) | reload;
 8006276:	6892      	ldr	r2, [r2, #8]
 8006278:	4311      	orrs	r1, r2
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
 800627a:	4a18      	ldr	r2, [pc, #96]	; (80062dc <Vector9C+0x1ec>)
 800627c:	4013      	ands	r3, r2
            I2C_CR2_RD_WRN | (n << 16U) | reload;
 800627e:	4319      	orrs	r1, r3
 8006280:	2380      	movs	r3, #128	; 0x80
 8006282:	4331      	orrs	r1, r6
 8006284:	00db      	lsls	r3, r3, #3
 8006286:	4319      	orrs	r1, r3
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
 8006288:	6069      	str	r1, [r5, #4]
 800628a:	e73f      	b.n	800610c <Vector9C+0x1c>
  if (n > 255U) {
 800628c:	21ff      	movs	r1, #255	; 0xff
    reload = I2C_CR2_RELOAD;
 800628e:	2680      	movs	r6, #128	; 0x80
  if (n > 255U) {
 8006290:	0409      	lsls	r1, r1, #16
    reload = I2C_CR2_RELOAD;
 8006292:	0476      	lsls	r6, r6, #17
 8006294:	e7ed      	b.n	8006272 <Vector9C+0x182>
  I2C_TypeDef *dp = i2cp->i2c;
 8006296:	6b46      	ldr	r6, [r0, #52]	; 0x34
  if (n > 255U) {
 8006298:	2bff      	cmp	r3, #255	; 0xff
 800629a:	d818      	bhi.n	80062ce <Vector9C+0x1de>
    reload = 0U;
 800629c:	2100      	movs	r1, #0
 800629e:	041b      	lsls	r3, r3, #16
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
 80062a0:	6847      	ldr	r7, [r0, #4]
 80062a2:	6875      	ldr	r5, [r6, #4]
            I2C_CR2_RD_WRN | (n << 16U) | reload;
 80062a4:	68bf      	ldr	r7, [r7, #8]
 80062a6:	4339      	orrs	r1, r7
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
 80062a8:	4f0c      	ldr	r7, [pc, #48]	; (80062dc <Vector9C+0x1ec>)
 80062aa:	403d      	ands	r5, r7
            I2C_CR2_RD_WRN | (n << 16U) | reload;
 80062ac:	4329      	orrs	r1, r5
 80062ae:	430b      	orrs	r3, r1
 80062b0:	2180      	movs	r1, #128	; 0x80
 80062b2:	00c9      	lsls	r1, r1, #3
 80062b4:	430b      	orrs	r3, r1
        dp->CR1 |= I2C_CR1_RXIE;
 80062b6:	2104      	movs	r1, #4
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
 80062b8:	6073      	str	r3, [r6, #4]
        dp->CR1 |= I2C_CR1_RXIE;
 80062ba:	6813      	ldr	r3, [r2, #0]
 80062bc:	430b      	orrs	r3, r1
 80062be:	6013      	str	r3, [r2, #0]
        dp->CR2 |= I2C_CR2_START;
 80062c0:	2380      	movs	r3, #128	; 0x80
 80062c2:	6855      	ldr	r5, [r2, #4]
 80062c4:	019b      	lsls	r3, r3, #6
 80062c6:	432b      	orrs	r3, r5
 80062c8:	6053      	str	r3, [r2, #4]
        i2cp->state = I2C_ACTIVE_RX;
 80062ca:	7001      	strb	r1, [r0, #0]
        return;
 80062cc:	e71e      	b.n	800610c <Vector9C+0x1c>
  if (n > 255U) {
 80062ce:	23ff      	movs	r3, #255	; 0xff
    reload = I2C_CR2_RELOAD;
 80062d0:	2180      	movs	r1, #128	; 0x80
  if (n > 255U) {
 80062d2:	041b      	lsls	r3, r3, #16
    reload = I2C_CR2_RELOAD;
 80062d4:	0449      	lsls	r1, r1, #17
 80062d6:	e7e3      	b.n	80062a0 <Vector9C+0x1b0>
 80062d8:	20001844 	.word	0x20001844
 80062dc:	fe00ffff 	.word	0xfe00ffff

080062e0 <i2c_lld_init>:
/**
 * @brief   Low level I2C driver initialization.
 *
 * @notapi
 */
void i2c_lld_init(void) {
 80062e0:	b510      	push	{r4, lr}

#if STM32_I2C_USE_I2C1
  i2cObjectInit(&I2CD1);
 80062e2:	4c04      	ldr	r4, [pc, #16]	; (80062f4 <i2c_lld_init+0x14>)
 80062e4:	0020      	movs	r0, r4
 80062e6:	f7fe fbdb 	bl	8004aa0 <i2cObjectInit>
  I2CD1.thread = NULL;
 80062ea:	2300      	movs	r3, #0
 80062ec:	6223      	str	r3, [r4, #32]
  I2CD1.i2c    = I2C1;
 80062ee:	4b02      	ldr	r3, [pc, #8]	; (80062f8 <i2c_lld_init+0x18>)
 80062f0:	6363      	str	r3, [r4, #52]	; 0x34
#if STM32_I2C_USE_DMA == TRUE
  I2CD4.dmarx  = STM32_DMA_STREAM(STM32_I2C_I2C4_RX_DMA_STREAM);
  I2CD4.dmatx  = STM32_DMA_STREAM(STM32_I2C_I2C4_TX_DMA_STREAM);
#endif
#endif /* STM32_I2C_USE_I2C4 */
}
 80062f2:	bd10      	pop	{r4, pc}
 80062f4:	20001844 	.word	0x20001844
 80062f8:	40005400 	.word	0x40005400
 80062fc:	00000000 	.word	0x00000000

08006300 <i2c_lld_start>:
  i2cp->txdmamode = DMAMODE_COMMON | STM32_DMA_CR_DIR_M2P;
  i2cp->rxdmamode = DMAMODE_COMMON | STM32_DMA_CR_DIR_P2M;
#endif

  /* Make sure I2C peripheral is disabled */
  dp->CR1 &= ~I2C_CR1_PE;
 8006300:	2201      	movs	r2, #1
void i2c_lld_start(I2CDriver *i2cp) {
 8006302:	b570      	push	{r4, r5, r6, lr}
  I2C_TypeDef *dp = i2cp->i2c;
 8006304:	6b44      	ldr	r4, [r0, #52]	; 0x34
void i2c_lld_start(I2CDriver *i2cp) {
 8006306:	0005      	movs	r5, r0
  dp->CR1 &= ~I2C_CR1_PE;
 8006308:	6823      	ldr	r3, [r4, #0]
 800630a:	4393      	bics	r3, r2
 800630c:	6023      	str	r3, [r4, #0]

  /* If in stopped state then enables the I2C and DMA clocks.*/
  if (i2cp->state == I2C_STOP) {
 800630e:	7803      	ldrb	r3, [r0, #0]
 8006310:	2b01      	cmp	r3, #1
 8006312:	d00b      	beq.n	800632c <i2c_lld_start+0x2c>
  /* Reset i2c peripheral, the TCIE bit will be handled separately.*/
  dp->CR1 = i2cp->config->cr1 |
#if STM32_I2C_USE_DMA == TRUE
            I2C_CR1_TXDMAEN | I2C_CR1_RXDMAEN | /* Enable only if using DMA */
#endif
            I2C_CR1_ERRIE | I2C_CR1_NACKIE;
 8006314:	2390      	movs	r3, #144	; 0x90
  dp->CR1 = i2cp->config->cr1 |
 8006316:	686a      	ldr	r2, [r5, #4]
            I2C_CR1_ERRIE | I2C_CR1_NACKIE;
 8006318:	6851      	ldr	r1, [r2, #4]
 800631a:	430b      	orrs	r3, r1
  dp->CR1 = i2cp->config->cr1 |
 800631c:	6023      	str	r3, [r4, #0]

  /* Setup I2C parameters.*/
  dp->TIMINGR = i2cp->config->timingr;
 800631e:	6813      	ldr	r3, [r2, #0]

  /* Ready to go.*/
  dp->CR1 |= I2C_CR1_PE;
 8006320:	2201      	movs	r2, #1
  dp->TIMINGR = i2cp->config->timingr;
 8006322:	6123      	str	r3, [r4, #16]
  dp->CR1 |= I2C_CR1_PE;
 8006324:	6823      	ldr	r3, [r4, #0]
 8006326:	4313      	orrs	r3, r2
 8006328:	6023      	str	r3, [r4, #0]
}
 800632a:	bd70      	pop	{r4, r5, r6, pc}
    if (&I2CD1 == i2cp) {
 800632c:	4b09      	ldr	r3, [pc, #36]	; (8006354 <i2c_lld_start+0x54>)
 800632e:	4298      	cmp	r0, r3
 8006330:	d1f0      	bne.n	8006314 <i2c_lld_start+0x14>
      rccResetI2C1();
 8006332:	2280      	movs	r2, #128	; 0x80
 8006334:	4b08      	ldr	r3, [pc, #32]	; (8006358 <i2c_lld_start+0x58>)
 8006336:	0392      	lsls	r2, r2, #14
 8006338:	6919      	ldr	r1, [r3, #16]
      nvicEnableVector(STM32_I2C1_GLOBAL_NUMBER, STM32_I2C_I2C1_IRQ_PRIORITY);
 800633a:	2017      	movs	r0, #23
      rccResetI2C1();
 800633c:	4311      	orrs	r1, r2
 800633e:	6119      	str	r1, [r3, #16]
 8006340:	2100      	movs	r1, #0
 8006342:	6119      	str	r1, [r3, #16]
      rccEnableI2C1(FALSE);
 8006344:	69d9      	ldr	r1, [r3, #28]
 8006346:	430a      	orrs	r2, r1
 8006348:	61da      	str	r2, [r3, #28]
      nvicEnableVector(STM32_I2C1_GLOBAL_NUMBER, STM32_I2C_I2C1_IRQ_PRIORITY);
 800634a:	2103      	movs	r1, #3
 800634c:	f7ff fa00 	bl	8005750 <nvicEnableVector>
 8006350:	e7e0      	b.n	8006314 <i2c_lld_start+0x14>
 8006352:	46c0      	nop			; (mov r8, r8)
 8006354:	20001844 	.word	0x20001844
 8006358:	40021000 	.word	0x40021000
 800635c:	00000000 	.word	0x00000000

08006360 <i2c_lld_master_transmit_timeout>:
 * @notapi
 */
msg_t i2c_lld_master_transmit_timeout(I2CDriver *i2cp, i2caddr_t addr,
                                      const uint8_t *txbuf, size_t txbytes,
                                      uint8_t *rxbuf, size_t rxbytes,
                                      systime_t timeout) {
 8006360:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  msg_t msg;
  I2C_TypeDef *dp = i2cp->i2c;
  systime_t start, end;

  /* Resetting error flags for this transfer.*/
  i2cp->errors = I2C_NO_ERROR;
 8006362:	2500      	movs	r5, #0
  I2C_TypeDef *dp = i2cp->i2c;
 8006364:	6b44      	ldr	r4, [r0, #52]	; 0x34
  i2cp->errors = I2C_NO_ERROR;
 8006366:	6085      	str	r5, [r0, #8]
 8006368:	b662      	cpsie	i
  /* RX DMA setup, note, rxbytes can be zero but we write the value anyway.*/
  dmaStreamSetMode(i2cp->dmarx, i2cp->rxdmamode);
  dmaStreamSetMemory0(i2cp->dmarx, rxbuf);
  dmaStreamSetTransactionSize(i2cp->dmarx, rxbytes);
#else
  i2cp->txptr   = txbuf;
 800636a:	6242      	str	r2, [r0, #36]	; 0x24
 800636c:	2280      	movs	r2, #128	; 0x80
  i2cp->txbytes = txbytes;
 800636e:	6283      	str	r3, [r0, #40]	; 0x28
  i2cp->rxptr   = rxbuf;
 8006370:	9b06      	ldr	r3, [sp, #24]
 8006372:	05d2      	lsls	r2, r2, #23
 8006374:	62c3      	str	r3, [r0, #44]	; 0x2c
  i2cp->rxbytes = rxbytes;
 8006376:	9b07      	ldr	r3, [sp, #28]
 8006378:	6a57      	ldr	r7, [r2, #36]	; 0x24
 800637a:	6303      	str	r3, [r0, #48]	; 0x30
  __ASM volatile ("cpsid i" : : : "memory");
 800637c:	b672      	cpsid	i
  while (true) {
    osalSysLock();

    /* If the bus is not busy then the operation can continue, note, the
       loop is exited in the locked state.*/
    if ((dp->ISR & I2C_ISR_BUSY) == 0)
 800637e:	2580      	movs	r5, #128	; 0x80
 8006380:	69a3      	ldr	r3, [r4, #24]
 8006382:	022d      	lsls	r5, r5, #8
 8006384:	422b      	tst	r3, r5
 8006386:	d00f      	beq.n	80063a8 <i2c_lld_master_transmit_timeout+0x48>
      break;

    /* If the system time went outside the allowed window then a timeout
       condition is returned.*/
    if (!osalOsIsTimeWithinX(osalOsGetSystemTimeX(), start, end)) {
 8006388:	26f4      	movs	r6, #244	; 0xf4
 800638a:	6a53      	ldr	r3, [r2, #36]	; 0x24
 800638c:	36ff      	adds	r6, #255	; 0xff
  return (bool)((systime_t)(time - start) < (systime_t)(end - start));
 800638e:	1bdb      	subs	r3, r3, r7
 8006390:	42b3      	cmp	r3, r6
 8006392:	d904      	bls.n	800639e <i2c_lld_master_transmit_timeout+0x3e>
 8006394:	e039      	b.n	800640a <i2c_lld_master_transmit_timeout+0xaa>
 8006396:	6a53      	ldr	r3, [r2, #36]	; 0x24
 8006398:	1bdb      	subs	r3, r3, r7
 800639a:	42b3      	cmp	r3, r6
 800639c:	d835      	bhi.n	800640a <i2c_lld_master_transmit_timeout+0xaa>
  __ASM volatile ("cpsie i" : : : "memory");
 800639e:	b662      	cpsie	i
  __ASM volatile ("cpsid i" : : : "memory");
 80063a0:	b672      	cpsid	i
    if ((dp->ISR & I2C_ISR_BUSY) == 0)
 80063a2:	69a3      	ldr	r3, [r4, #24]
 80063a4:	422b      	tst	r3, r5
 80063a6:	d1f6      	bne.n	8006396 <i2c_lld_master_transmit_timeout+0x36>
  if ((i2cp->config->cr2 & I2C_CR2_ADD10) == 0U)
 80063a8:	6843      	ldr	r3, [r0, #4]

    osalSysUnlock();
  }

  /* Setting up the slave address.*/
  i2c_lld_set_address(i2cp, addr);
 80063aa:	6b45      	ldr	r5, [r0, #52]	; 0x34
  if ((i2cp->config->cr2 & I2C_CR2_ADD10) == 0U)
 80063ac:	689e      	ldr	r6, [r3, #8]
 80063ae:	0533      	lsls	r3, r6, #20
 80063b0:	d521      	bpl.n	80063f6 <i2c_lld_master_transmit_timeout+0x96>
  n = i2c_lld_get_txbytes(i2cp);
 80063b2:	6a82      	ldr	r2, [r0, #40]	; 0x28
    dp->CR2 = (uint32_t)addr;
 80063b4:	6069      	str	r1, [r5, #4]
  if (n > 255U) {
 80063b6:	2aff      	cmp	r2, #255	; 0xff
 80063b8:	d822      	bhi.n	8006400 <i2c_lld_master_transmit_timeout+0xa0>
    reload = 0U;
 80063ba:	2700      	movs	r7, #0
 80063bc:	0412      	lsls	r2, r2, #16
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
 80063be:	686b      	ldr	r3, [r5, #4]
 80063c0:	4913      	ldr	r1, [pc, #76]	; (8006410 <i2c_lld_master_transmit_timeout+0xb0>)

  /* Starts the operation.*/
  dp->CR2 |= I2C_CR2_START;

  /* Waits for the operation completion or a timeout.*/
  msg = osalThreadSuspendTimeoutS(&i2cp->thread, timeout);
 80063c2:	3020      	adds	r0, #32
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
 80063c4:	400b      	ands	r3, r1
 80063c6:	4333      	orrs	r3, r6
            (n << 16U) | reload;
 80063c8:	433b      	orrs	r3, r7
 80063ca:	4313      	orrs	r3, r2
  dp->CR1 |= I2C_CR1_TCIE | I2C_CR1_TXIE;
 80063cc:	2242      	movs	r2, #66	; 0x42
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
 80063ce:	606b      	str	r3, [r5, #4]
  dp->CR1 |= I2C_CR1_TCIE | I2C_CR1_TXIE;
 80063d0:	6823      	ldr	r3, [r4, #0]
  return chThdSuspendTimeoutS(trp, timeout);
 80063d2:	9908      	ldr	r1, [sp, #32]
 80063d4:	4313      	orrs	r3, r2
 80063d6:	6023      	str	r3, [r4, #0]
  dp->CR2 |= I2C_CR2_START;
 80063d8:	2380      	movs	r3, #128	; 0x80
 80063da:	6862      	ldr	r2, [r4, #4]
 80063dc:	019b      	lsls	r3, r3, #6
 80063de:	4313      	orrs	r3, r2
 80063e0:	6063      	str	r3, [r4, #4]
 80063e2:	f7fd fd9d 	bl	8003f20 <chThdSuspendTimeoutS>

  /* In case of a software timeout a STOP is sent as an extreme attempt
     to release the bus.*/
  if (msg == MSG_TIMEOUT) {
 80063e6:	1c43      	adds	r3, r0, #1
 80063e8:	d104      	bne.n	80063f4 <i2c_lld_master_transmit_timeout+0x94>
    dp->CR2 |= I2C_CR2_STOP;
 80063ea:	2380      	movs	r3, #128	; 0x80
 80063ec:	6862      	ldr	r2, [r4, #4]
 80063ee:	01db      	lsls	r3, r3, #7
 80063f0:	4313      	orrs	r3, r2
 80063f2:	6063      	str	r3, [r4, #4]
  }

  return msg;
}
 80063f4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  n = i2c_lld_get_txbytes(i2cp);
 80063f6:	6a82      	ldr	r2, [r0, #40]	; 0x28
    dp->CR2 = (uint32_t)addr << 1U;
 80063f8:	0049      	lsls	r1, r1, #1
 80063fa:	6069      	str	r1, [r5, #4]
  if (n > 255U) {
 80063fc:	2aff      	cmp	r2, #255	; 0xff
 80063fe:	d9dc      	bls.n	80063ba <i2c_lld_master_transmit_timeout+0x5a>
 8006400:	22ff      	movs	r2, #255	; 0xff
    reload = I2C_CR2_RELOAD;
 8006402:	2780      	movs	r7, #128	; 0x80
  if (n > 255U) {
 8006404:	0412      	lsls	r2, r2, #16
    reload = I2C_CR2_RELOAD;
 8006406:	047f      	lsls	r7, r7, #17
 8006408:	e7d9      	b.n	80063be <i2c_lld_master_transmit_timeout+0x5e>
      return MSG_TIMEOUT;
 800640a:	2001      	movs	r0, #1
 800640c:	4240      	negs	r0, r0
 800640e:	e7f1      	b.n	80063f4 <i2c_lld_master_transmit_timeout+0x94>
 8006410:	fe00ffff 	.word	0xfe00ffff
	...

08006420 <rtc_lld_init>:
/**
 * @brief   Enable access to registers.
 *
 * @notapi
 */
void rtc_lld_init(void) {
 8006420:	b510      	push	{r4, lr}

  /* RTC object initialization.*/
  rtcObjectInit(&RTCD1);
 8006422:	4c12      	ldr	r4, [pc, #72]	; (800646c <rtc_lld_init+0x4c>)
 8006424:	0020      	movs	r0, r4
 8006426:	f7fe fbc3 	bl	8004bb0 <rtcObjectInit>

  /* RTC pointer initialization.*/
  RTCD1.rtc = RTC;

  /* Disable write protection. */
  RTCD1.rtc->WPR = 0xCA;
 800642a:	22ca      	movs	r2, #202	; 0xca
  RTCD1.rtc = RTC;
 800642c:	4b10      	ldr	r3, [pc, #64]	; (8006470 <rtc_lld_init+0x50>)
 800642e:	6023      	str	r3, [r4, #0]
  RTCD1.rtc->WPR = 0xCA;
 8006430:	625a      	str	r2, [r3, #36]	; 0x24
  RTCD1.rtc->WPR = 0x53;
 8006432:	3a77      	subs	r2, #119	; 0x77
 8006434:	625a      	str	r2, [r3, #36]	; 0x24

  /* If calendar has not been initialized yet then proceed with the
     initial setup.*/
  if (!(RTCD1.rtc->ISR & RTC_ISR_INITS)) {
 8006436:	68da      	ldr	r2, [r3, #12]
 8006438:	06d2      	lsls	r2, r2, #27
 800643a:	d412      	bmi.n	8006462 <rtc_lld_init+0x42>
  RTCD1.rtc->ISR |= RTC_ISR_INIT;
 800643c:	2180      	movs	r1, #128	; 0x80
 800643e:	68da      	ldr	r2, [r3, #12]
 8006440:	430a      	orrs	r2, r1
 8006442:	60da      	str	r2, [r3, #12]
  while ((RTCD1.rtc->ISR & RTC_ISR_INITF) == 0)
 8006444:	3940      	subs	r1, #64	; 0x40
 8006446:	68da      	ldr	r2, [r3, #12]
 8006448:	4211      	tst	r1, r2
 800644a:	d0fc      	beq.n	8006446 <rtc_lld_init+0x26>

    rtc_enter_init();

    RTCD1.rtc->CR   = 0;
 800644c:	2200      	movs	r2, #0
    RTCD1.rtc->ISR  = RTC_ISR_INIT;     /* Clearing all but RTC_ISR_INIT.   */
 800644e:	2180      	movs	r1, #128	; 0x80
    RTCD1.rtc->CR   = 0;
 8006450:	609a      	str	r2, [r3, #8]
    RTCD1.rtc->PRER = STM32_RTC_PRER_BITS;
 8006452:	4a08      	ldr	r2, [pc, #32]	; (8006474 <rtc_lld_init+0x54>)
    RTCD1.rtc->ISR  = RTC_ISR_INIT;     /* Clearing all but RTC_ISR_INIT.   */
 8006454:	60d9      	str	r1, [r3, #12]
    RTCD1.rtc->PRER = STM32_RTC_PRER_BITS;
 8006456:	611a      	str	r2, [r3, #16]
    RTCD1.rtc->PRER = STM32_RTC_PRER_BITS;
 8006458:	611a      	str	r2, [r3, #16]
  RTCD1.rtc->ISR &= ~RTC_ISR_INIT;
 800645a:	68da      	ldr	r2, [r3, #12]
 800645c:	438a      	bics	r2, r1
 800645e:	60da      	str	r2, [r3, #12]

    rtc_exit_init();
  }
  else
    RTCD1.rtc->ISR &= ~RTC_ISR_RSF;
}
 8006460:	bd10      	pop	{r4, pc}
    RTCD1.rtc->ISR &= ~RTC_ISR_RSF;
 8006462:	2120      	movs	r1, #32
 8006464:	68da      	ldr	r2, [r3, #12]
 8006466:	438a      	bics	r2, r1
 8006468:	60da      	str	r2, [r3, #12]
}
 800646a:	e7f9      	b.n	8006460 <rtc_lld_init+0x40>
 800646c:	2000187c 	.word	0x2000187c
 8006470:	40002800 	.word	0x40002800
 8006474:	001f03ff 	.word	0x001f03ff
	...

08006480 <i2s_lld_serve_rx_interrupt>:
 * @brief   Shared end-of-rx service routine.
 *
 * @param[in] i2sp      pointer to the @p I2SDriver object
 * @param[in] flags     pre-shifted content of the ISR register
 */
static void i2s_lld_serve_rx_interrupt(I2SDriver *i2sp, uint32_t flags) {
 8006480:	b570      	push	{r4, r5, r6, lr}
 8006482:	0005      	movs	r5, r0
 8006484:	000c      	movs	r4, r1

  (void)i2sp;

  /* DMA errors handling.*/
#if defined(STM32_I2S_DMA_ERROR_HOOK)
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8006486:	070b      	lsls	r3, r1, #28
 8006488:	d41f      	bmi.n	80064ca <i2s_lld_serve_rx_interrupt+0x4a>
  }
#endif

  /* Callbacks handling, note it is portable code defined in the high
     level driver.*/
  if ((flags & STM32_DMA_ISR_TCIF) != 0) {
 800648a:	07a3      	lsls	r3, r4, #30
 800648c:	d511      	bpl.n	80064b2 <i2s_lld_serve_rx_interrupt+0x32>
    /* Transfer complete processing.*/
    _i2s_isr_full_code_rx(i2sp);
 800648e:	686a      	ldr	r2, [r5, #4]
 8006490:	6913      	ldr	r3, [r2, #16]
 8006492:	2b00      	cmp	r3, #0
 8006494:	d00a      	beq.n	80064ac <i2s_lld_serve_rx_interrupt+0x2c>
 8006496:	2104      	movs	r1, #4
 8006498:	7029      	strb	r1, [r5, #0]
 800649a:	6891      	ldr	r1, [r2, #8]
 800649c:	0028      	movs	r0, r5
 800649e:	0849      	lsrs	r1, r1, #1
 80064a0:	000a      	movs	r2, r1
 80064a2:	4798      	blx	r3
 80064a4:	782b      	ldrb	r3, [r5, #0]
 80064a6:	2b04      	cmp	r3, #4
 80064a8:	d000      	beq.n	80064ac <i2s_lld_serve_rx_interrupt+0x2c>
  }
  else if ((flags & STM32_DMA_ISR_HTIF) != 0) {
    /* Half transfer processing.*/
    _i2s_isr_half_code_rx(i2sp);
  }
}
 80064aa:	bd70      	pop	{r4, r5, r6, pc}
    _i2s_isr_full_code_rx(i2sp);
 80064ac:	2302      	movs	r3, #2
 80064ae:	702b      	strb	r3, [r5, #0]
 80064b0:	e7fb      	b.n	80064aa <i2s_lld_serve_rx_interrupt+0x2a>
  else if ((flags & STM32_DMA_ISR_HTIF) != 0) {
 80064b2:	0763      	lsls	r3, r4, #29
 80064b4:	d5f9      	bpl.n	80064aa <i2s_lld_serve_rx_interrupt+0x2a>
    _i2s_isr_half_code_rx(i2sp);
 80064b6:	686a      	ldr	r2, [r5, #4]
 80064b8:	6913      	ldr	r3, [r2, #16]
 80064ba:	2b00      	cmp	r3, #0
 80064bc:	d0f5      	beq.n	80064aa <i2s_lld_serve_rx_interrupt+0x2a>
 80064be:	6892      	ldr	r2, [r2, #8]
 80064c0:	2100      	movs	r1, #0
 80064c2:	0852      	lsrs	r2, r2, #1
 80064c4:	0028      	movs	r0, r5
 80064c6:	4798      	blx	r3
}
 80064c8:	e7ef      	b.n	80064aa <i2s_lld_serve_rx_interrupt+0x2a>
  chSysHalt(reason);
 80064ca:	4802      	ldr	r0, [pc, #8]	; (80064d4 <i2s_lld_serve_rx_interrupt+0x54>)
 80064cc:	f7fd fa18 	bl	8003900 <chSysHalt>
 80064d0:	e7db      	b.n	800648a <i2s_lld_serve_rx_interrupt+0xa>
 80064d2:	46c0      	nop			; (mov r8, r8)
 80064d4:	080136f0 	.word	0x080136f0
	...

080064e0 <i2s_lld_init>:
/**
 * @brief   Low level I2S driver initialization.
 *
 * @notapi
 */
void i2s_lld_init(void) {
 80064e0:	b510      	push	{r4, lr}
  I2SD1.txdmamode = 0;
#endif
#endif

#if STM32_I2S_USE_SPI2
  i2sObjectInit(&I2SD2);
 80064e2:	4c09      	ldr	r4, [pc, #36]	; (8006508 <i2s_lld_init+0x28>)
 80064e4:	0020      	movs	r0, r4
 80064e6:	f7fe fb33 	bl	8004b50 <i2sObjectInit>
  I2SD2.spi       = SPI2;
  I2SD2.cfg       = STM32_I2S2_CFGR_CFG;
 80064ea:	2280      	movs	r2, #128	; 0x80
  I2SD2.spi       = SPI2;
 80064ec:	4b07      	ldr	r3, [pc, #28]	; (800650c <i2s_lld_init+0x2c>)
  I2SD2.cfg       = STM32_I2S2_CFGR_CFG;
 80064ee:	0052      	lsls	r2, r2, #1
  I2SD2.spi       = SPI2;
 80064f0:	60a3      	str	r3, [r4, #8]
#if STM32_I2S_FULLDUPLEX_ENABLED(STM32_I2S_SPI2_MODE)
  I2SD2.i2sext    = I2S2ext;
  I2SD2.extcfg    = STM32_I2S2EXT_CFGR_CFG;
#else
  I2SD2.i2sext    = NULL;
 80064f2:	2300      	movs	r3, #0
  I2SD2.cfg       = STM32_I2S2_CFGR_CFG;
 80064f4:	6122      	str	r2, [r4, #16]
  I2SD2.extcfg    = 0;
#endif
#if STM32_I2S_RX_ENABLED(STM32_I2S_SPI2_MODE) || STM32_I2S_FULLDUPLEX_ENABLED(STM32_I2S_SPI2_MODE)
  I2SD2.dmarx     = STM32_DMA_STREAM(STM32_I2S_SPI2_RX_DMA_STREAM);
 80064f6:	4a06      	ldr	r2, [pc, #24]	; (8006510 <i2s_lld_init+0x30>)
  I2SD2.i2sext    = NULL;
 80064f8:	60e3      	str	r3, [r4, #12]
  I2SD2.dmarx     = STM32_DMA_STREAM(STM32_I2S_SPI2_RX_DMA_STREAM);
 80064fa:	6162      	str	r2, [r4, #20]
  I2SD2.rxdmamode = STM32_DMA_CR_CHSEL(I2S2_RX_DMA_CHANNEL) |
 80064fc:	4a05      	ldr	r2, [pc, #20]	; (8006514 <i2s_lld_init+0x34>)
                    STM32_DMA_CR_HTIE |
                    STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE;
#else
  I2SD2.dmatx     = NULL;
 80064fe:	61a3      	str	r3, [r4, #24]
  I2SD2.rxdmamode = STM32_DMA_CR_CHSEL(I2S2_RX_DMA_CHANNEL) |
 8006500:	61e2      	str	r2, [r4, #28]
  I2SD2.txdmamode = 0;
 8006502:	6223      	str	r3, [r4, #32]
#else
  I2SD3.dmatx     = NULL;
  I2SD3.txdmamode = 0;
#endif
#endif
}
 8006504:	bd10      	pop	{r4, pc}
 8006506:	46c0      	nop			; (mov r8, r8)
 8006508:	20001880 	.word	0x20001880
 800650c:	40003800 	.word	0x40003800
 8006510:	080136a0 	.word	0x080136a0
 8006514:	000015ae 	.word	0x000015ae
	...

08006520 <i2s_lld_start>:
 *
 * @param[in] i2sp      pointer to the @p I2SDriver object
 *
 * @notapi
 */
void i2s_lld_start(I2SDriver *i2sp) {
 8006520:	b570      	push	{r4, r5, r6, lr}

  /* If in stopped state then enables the SPI and DMA clocks.*/
  if (i2sp->state == I2S_STOP) {
 8006522:	7805      	ldrb	r5, [r0, #0]
void i2s_lld_start(I2SDriver *i2sp) {
 8006524:	0004      	movs	r4, r0
  if (i2sp->state == I2S_STOP) {
 8006526:	2d01      	cmp	r5, #1
 8006528:	d015      	beq.n	8006556 <i2s_lld_start+0x36>
    }
#endif
  }

  /* I2S (re)configuration.*/
  i2sp->spi->I2SPR   = i2sp->config->i2spr;
 800652a:	6863      	ldr	r3, [r4, #4]
 800652c:	68a1      	ldr	r1, [r4, #8]
 800652e:	2216      	movs	r2, #22
 8006530:	5e9d      	ldrsh	r5, [r3, r2]
  i2sp->spi->I2SCFGR = i2sp->config->i2scfgr | i2sp->cfg | SPI_I2SCFGR_I2SMOD;
 8006532:	2280      	movs	r2, #128	; 0x80
  i2sp->spi->I2SPR   = i2sp->config->i2spr;
 8006534:	620d      	str	r5, [r1, #32]
  i2sp->spi->I2SCFGR = i2sp->config->i2scfgr | i2sp->cfg | SPI_I2SCFGR_I2SMOD;
 8006536:	2014      	movs	r0, #20
 8006538:	5e18      	ldrsh	r0, [r3, r0]
 800653a:	8a23      	ldrh	r3, [r4, #16]
 800653c:	0112      	lsls	r2, r2, #4
 800653e:	4303      	orrs	r3, r0
 8006540:	4313      	orrs	r3, r2
 8006542:	61cb      	str	r3, [r1, #28]

  if (i2sp->i2sext) {
 8006544:	68e3      	ldr	r3, [r4, #12]
 8006546:	2b00      	cmp	r3, #0
 8006548:	d004      	beq.n	8006554 <i2s_lld_start+0x34>
    i2sp->i2sext->I2SPR   = i2sp->config->i2spr;
 800654a:	621d      	str	r5, [r3, #32]
    i2sp->i2sext->I2SCFGR = i2sp->config->i2scfgr | i2sp->extcfg | SPI_I2SCFGR_I2SMOD;
 800654c:	8a61      	ldrh	r1, [r4, #18]
 800654e:	4301      	orrs	r1, r0
 8006550:	430a      	orrs	r2, r1
 8006552:	61da      	str	r2, [r3, #28]
  }
}
 8006554:	bd70      	pop	{r4, r5, r6, pc}
    if (&I2SD2 == i2sp) {
 8006556:	4b0b      	ldr	r3, [pc, #44]	; (8006584 <i2s_lld_start+0x64>)
 8006558:	4298      	cmp	r0, r3
 800655a:	d1e6      	bne.n	800652a <i2s_lld_start+0xa>
      rccEnableSPI2(FALSE);
 800655c:	2380      	movs	r3, #128	; 0x80
 800655e:	4a0a      	ldr	r2, [pc, #40]	; (8006588 <i2s_lld_start+0x68>)
 8006560:	01db      	lsls	r3, r3, #7
 8006562:	69d1      	ldr	r1, [r2, #28]
 8006564:	430b      	orrs	r3, r1
 8006566:	61d3      	str	r3, [r2, #28]
      b = dmaStreamAllocate(i2sp->dmarx,
 8006568:	2102      	movs	r1, #2
 800656a:	0003      	movs	r3, r0
 800656c:	4a07      	ldr	r2, [pc, #28]	; (800658c <i2s_lld_start+0x6c>)
 800656e:	6940      	ldr	r0, [r0, #20]
 8006570:	f7ff fa96 	bl	8005aa0 <dmaStreamAllocate>
      i2sp->spi->CR1 = 0;
 8006574:	2200      	movs	r2, #0
 8006576:	68a3      	ldr	r3, [r4, #8]
 8006578:	601a      	str	r2, [r3, #0]
      i2sp->spi->CR2 = SPI_CR2_RXDMAEN;
 800657a:	605d      	str	r5, [r3, #4]
      i2sp->rx_dr = &i2sp->spi->DR;
 800657c:	330c      	adds	r3, #12
 800657e:	6263      	str	r3, [r4, #36]	; 0x24
 8006580:	e7d3      	b.n	800652a <i2s_lld_start+0xa>
 8006582:	46c0      	nop			; (mov r8, r8)
 8006584:	20001880 	.word	0x20001880
 8006588:	40021000 	.word	0x40021000
 800658c:	08006481 	.word	0x08006481

08006590 <i2s_lld_start_exchange>:
 *
 * @param[in] i2sp      pointer to the @p I2SDriver object
 *
 * @notapi
 */
void i2s_lld_start_exchange(I2SDriver *i2sp) {
 8006590:	b530      	push	{r4, r5, lr}
     00 (16)  1 (32)  16
     01 (24)  X       32
     10 (32)  X       32
     11 (NA)  X       NA
     */
  if ((i2sp->config->i2scfgr & SPI_I2SCFGR_DATLEN) != 0)
 8006592:	2406      	movs	r4, #6
  size_t size = i2sp->config->size;
 8006594:	6842      	ldr	r2, [r0, #4]
  if ((i2sp->config->i2scfgr & SPI_I2SCFGR_DATLEN) != 0)
 8006596:	8a93      	ldrh	r3, [r2, #20]
  size_t size = i2sp->config->size;
 8006598:	6891      	ldr	r1, [r2, #8]
  if ((i2sp->config->i2scfgr & SPI_I2SCFGR_DATLEN) != 0)
 800659a:	421c      	tst	r4, r3
 800659c:	d000      	beq.n	80065a0 <i2s_lld_start_exchange+0x10>
    size *= 2;
 800659e:	0049      	lsls	r1, r1, #1

  /* RX DMA setup.*/
  if (NULL != i2sp->dmarx) {
 80065a0:	6943      	ldr	r3, [r0, #20]
 80065a2:	2b00      	cmp	r3, #0
 80065a4:	d00b      	beq.n	80065be <i2s_lld_start_exchange+0x2e>
    dmaStreamSetMode(i2sp->dmarx, i2sp->rxdmamode);
    dmaStreamSetPeripheral(i2sp->dmarx, i2sp->rx_dr);
    dmaStreamSetMemory0(i2sp->dmarx, i2sp->config->rx_buffer);
    dmaStreamSetTransactionSize(i2sp->dmarx, size);
    dmaStreamEnable(i2sp->dmarx);
 80065a6:	2501      	movs	r5, #1
    dmaStreamSetMode(i2sp->dmarx, i2sp->rxdmamode);
 80065a8:	685b      	ldr	r3, [r3, #4]
 80065aa:	69c4      	ldr	r4, [r0, #28]
 80065ac:	601c      	str	r4, [r3, #0]
    dmaStreamSetPeripheral(i2sp->dmarx, i2sp->rx_dr);
 80065ae:	6a44      	ldr	r4, [r0, #36]	; 0x24
 80065b0:	609c      	str	r4, [r3, #8]
    dmaStreamSetMemory0(i2sp->dmarx, i2sp->config->rx_buffer);
 80065b2:	6854      	ldr	r4, [r2, #4]
 80065b4:	60dc      	str	r4, [r3, #12]
    dmaStreamSetTransactionSize(i2sp->dmarx, size);
 80065b6:	6059      	str	r1, [r3, #4]
    dmaStreamEnable(i2sp->dmarx);
 80065b8:	681c      	ldr	r4, [r3, #0]
 80065ba:	432c      	orrs	r4, r5
 80065bc:	601c      	str	r4, [r3, #0]
  }

  /* TX DMA setup.*/
  if (NULL != i2sp->dmatx) {
 80065be:	6983      	ldr	r3, [r0, #24]
 80065c0:	2b00      	cmp	r3, #0
 80065c2:	d00b      	beq.n	80065dc <i2s_lld_start_exchange+0x4c>
    dmaStreamSetMode(i2sp->dmatx, i2sp->txdmamode);
 80065c4:	685b      	ldr	r3, [r3, #4]
 80065c6:	6a04      	ldr	r4, [r0, #32]
    dmaStreamSetPeripheral(i2sp->dmatx, i2sp->tx_dr);
    dmaStreamSetMemory0(i2sp->dmatx, i2sp->config->tx_buffer);
 80065c8:	6812      	ldr	r2, [r2, #0]
    dmaStreamSetMode(i2sp->dmatx, i2sp->txdmamode);
 80065ca:	601c      	str	r4, [r3, #0]
    dmaStreamSetPeripheral(i2sp->dmatx, i2sp->tx_dr);
 80065cc:	6a84      	ldr	r4, [r0, #40]	; 0x28
 80065ce:	609c      	str	r4, [r3, #8]
    dmaStreamSetMemory0(i2sp->dmatx, i2sp->config->tx_buffer);
 80065d0:	60da      	str	r2, [r3, #12]
    dmaStreamSetTransactionSize(i2sp->dmatx, size);
 80065d2:	6059      	str	r1, [r3, #4]
    dmaStreamEnable(i2sp->dmatx);
 80065d4:	2101      	movs	r1, #1
 80065d6:	681a      	ldr	r2, [r3, #0]
 80065d8:	430a      	orrs	r2, r1
 80065da:	601a      	str	r2, [r3, #0]
  }

  /* Starting transfer.*/
  i2sp->spi->I2SCFGR |= SPI_I2SCFGR_I2SE;
 80065dc:	2380      	movs	r3, #128	; 0x80
 80065de:	6881      	ldr	r1, [r0, #8]
 80065e0:	00db      	lsls	r3, r3, #3
 80065e2:	69ca      	ldr	r2, [r1, #28]
 80065e4:	431a      	orrs	r2, r3
 80065e6:	61ca      	str	r2, [r1, #28]
  if (i2sp->i2sext)
 80065e8:	68c2      	ldr	r2, [r0, #12]
 80065ea:	2a00      	cmp	r2, #0
 80065ec:	d002      	beq.n	80065f4 <i2s_lld_start_exchange+0x64>
    i2sp->i2sext->I2SCFGR |= SPI_I2SCFGR_I2SE;
 80065ee:	69d1      	ldr	r1, [r2, #28]
 80065f0:	430b      	orrs	r3, r1
 80065f2:	61d3      	str	r3, [r2, #28]
}
 80065f4:	bd30      	pop	{r4, r5, pc}
 80065f6:	46c0      	nop			; (mov r8, r8)
	...

08006600 <spi_lld_init>:
/**
 * @brief   Low level SPI driver initialization.
 *
 * @notapi
 */
void spi_lld_init(void) {
 8006600:	b510      	push	{r4, lr}

#if STM32_SPI_USE_SPI1
  spiObjectInit(&SPID1);
 8006602:	4c07      	ldr	r4, [pc, #28]	; (8006620 <spi_lld_init+0x20>)
 8006604:	0020      	movs	r0, r4
 8006606:	f7fe fd93 	bl	8005130 <spiObjectInit>
  SPID1.spi       = SPI1;
 800660a:	4b06      	ldr	r3, [pc, #24]	; (8006624 <spi_lld_init+0x24>)
 800660c:	6223      	str	r3, [r4, #32]
  SPID1.dmarx     = STM32_DMA_STREAM(STM32_SPI_SPI1_RX_DMA_STREAM);
 800660e:	4b06      	ldr	r3, [pc, #24]	; (8006628 <spi_lld_init+0x28>)
 8006610:	6263      	str	r3, [r4, #36]	; 0x24
  SPID1.dmatx     = STM32_DMA_STREAM(STM32_SPI_SPI1_TX_DMA_STREAM);
 8006612:	3314      	adds	r3, #20
 8006614:	62a3      	str	r3, [r4, #40]	; 0x28
  SPID1.rxdmamode = STM32_DMA_CR_CHSEL(SPI1_RX_DMA_CHANNEL) |
 8006616:	4b05      	ldr	r3, [pc, #20]	; (800662c <spi_lld_init+0x2c>)
 8006618:	62e3      	str	r3, [r4, #44]	; 0x2c
                    STM32_DMA_CR_PL(STM32_SPI_SPI1_DMA_PRIORITY) |
                    STM32_DMA_CR_DIR_P2M |
                    STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE;
  SPID1.txdmamode = STM32_DMA_CR_CHSEL(SPI1_TX_DMA_CHANNEL) |
 800661a:	4b05      	ldr	r3, [pc, #20]	; (8006630 <spi_lld_init+0x30>)
 800661c:	6323      	str	r3, [r4, #48]	; 0x30
                    STM32_DMA_CR_PL(STM32_SPI_SPI6_DMA_PRIORITY) |
                    STM32_DMA_CR_DIR_M2P |
                    STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE;
#endif
}
 800661e:	bd10      	pop	{r4, pc}
 8006620:	200018ac 	.word	0x200018ac
 8006624:	40013000 	.word	0x40013000
 8006628:	08013678 	.word	0x08013678
 800662c:	0000100a 	.word	0x0000100a
 8006630:	00001018 	.word	0x00001018
	...

08006640 <Vector80>:
 *
 * @notapi
 */
void gpt_lld_serve_interrupt(GPTDriver *gptp) {

  gptp->tim->SR = 0;
 8006640:	2200      	movs	r2, #0
 8006642:	480b      	ldr	r0, [pc, #44]	; (8006670 <Vector80+0x30>)
OSAL_IRQ_HANDLER(STM32_TIM3_HANDLER) {
 8006644:	b510      	push	{r4, lr}
  gptp->tim->SR = 0;
 8006646:	68c3      	ldr	r3, [r0, #12]
  if (gptp->state == GPT_ONESHOT) {
 8006648:	7801      	ldrb	r1, [r0, #0]
  OSAL_IRQ_PROLOGUE();
 800664a:	4674      	mov	r4, lr
  gptp->tim->SR = 0;
 800664c:	611a      	str	r2, [r3, #16]
  if (gptp->state == GPT_ONESHOT) {
 800664e:	2904      	cmp	r1, #4
 8006650:	d107      	bne.n	8006662 <Vector80+0x22>
    gptp->state = GPT_READY;                /* Back in GPT_READY state.     */
 8006652:	3902      	subs	r1, #2
 8006654:	7001      	strb	r1, [r0, #0]
  gptp->tim->CR1   = 0;                         /* Initially stopped.       */
 8006656:	601a      	str	r2, [r3, #0]
  gptp->tim->SR    = 0;                         /* Clear pending IRQs.      */
 8006658:	611a      	str	r2, [r3, #16]
  gptp->tim->DIER &= ~STM32_TIM_DIER_IRQ_MASK;
 800665a:	68da      	ldr	r2, [r3, #12]
 800665c:	31fd      	adds	r1, #253	; 0xfd
 800665e:	438a      	bics	r2, r1
 8006660:	60da      	str	r2, [r3, #12]
    gpt_lld_stop_timer(gptp);               /* Timer automatically stopped. */
  }
  gptp->config->callback(gptp);
 8006662:	6843      	ldr	r3, [r0, #4]
 8006664:	685b      	ldr	r3, [r3, #4]
 8006666:	4798      	blx	r3
  OSAL_IRQ_EPILOGUE();
 8006668:	0020      	movs	r0, r4
 800666a:	f7fd fda9 	bl	80041c0 <_port_irq_epilogue>
}
 800666e:	bd10      	pop	{r4, pc}
 8006670:	200018e0 	.word	0x200018e0
	...

08006680 <gpt_lld_init>:
void gpt_lld_init(void) {
 8006680:	b510      	push	{r4, lr}
  GPTD3.tim = STM32_TIM3;
 8006682:	4803      	ldr	r0, [pc, #12]	; (8006690 <gpt_lld_init+0x10>)
 8006684:	4b03      	ldr	r3, [pc, #12]	; (8006694 <gpt_lld_init+0x14>)
 8006686:	60c3      	str	r3, [r0, #12]
  gptObjectInit(&GPTD3);
 8006688:	f7fe f9d2 	bl	8004a30 <gptObjectInit>
}
 800668c:	bd10      	pop	{r4, pc}
 800668e:	46c0      	nop			; (mov r8, r8)
 8006690:	200018e0 	.word	0x200018e0
 8006694:	40000400 	.word	0x40000400
	...

080066a0 <gpt_lld_start>:
  if (gptp->state == GPT_STOP) {
 80066a0:	7803      	ldrb	r3, [r0, #0]
void gpt_lld_start(GPTDriver *gptp) {
 80066a2:	b570      	push	{r4, r5, r6, lr}
 80066a4:	0004      	movs	r4, r0
  if (gptp->state == GPT_STOP) {
 80066a6:	2b01      	cmp	r3, #1
 80066a8:	d012      	beq.n	80066d0 <gpt_lld_start+0x30>
  psc = (uint16_t)((gptp->clock / gptp->config->frequency) - 1);
 80066aa:	6865      	ldr	r5, [r4, #4]
 80066ac:	68a0      	ldr	r0, [r4, #8]
 80066ae:	6829      	ldr	r1, [r5, #0]
 80066b0:	f7f9 fd8e 	bl	80001d0 <__udivsi3>
  gptp->tim->CR1  = 0;                          /* Initially stopped.       */
 80066b4:	2200      	movs	r2, #0
  gptp->tim->CR2  = gptp->config->cr2;
 80066b6:	68a9      	ldr	r1, [r5, #8]
  gptp->tim->CR1  = 0;                          /* Initially stopped.       */
 80066b8:	68e3      	ldr	r3, [r4, #12]
  psc = (uint16_t)((gptp->clock / gptp->config->frequency) - 1);
 80066ba:	3801      	subs	r0, #1
  gptp->tim->CR1  = 0;                          /* Initially stopped.       */
 80066bc:	601a      	str	r2, [r3, #0]
  gptp->tim->CR2  = gptp->config->cr2;
 80066be:	6059      	str	r1, [r3, #4]
  gptp->tim->DIER = gptp->config->dier &        /* DMA-related DIER bits.   */
 80066c0:	21ff      	movs	r1, #255	; 0xff
  psc = (uint16_t)((gptp->clock / gptp->config->frequency) - 1);
 80066c2:	b280      	uxth	r0, r0
  gptp->tim->PSC  = psc;                        /* Prescaler value.         */
 80066c4:	6298      	str	r0, [r3, #40]	; 0x28
  gptp->tim->SR   = 0;                          /* Clear pending IRQs.      */
 80066c6:	611a      	str	r2, [r3, #16]
  gptp->tim->DIER = gptp->config->dier &        /* DMA-related DIER bits.   */
 80066c8:	68ea      	ldr	r2, [r5, #12]
 80066ca:	438a      	bics	r2, r1
 80066cc:	60da      	str	r2, [r3, #12]
}
 80066ce:	bd70      	pop	{r4, r5, r6, pc}
    if (&GPTD3 == gptp) {
 80066d0:	4b09      	ldr	r3, [pc, #36]	; (80066f8 <gpt_lld_start+0x58>)
 80066d2:	4298      	cmp	r0, r3
 80066d4:	d1e9      	bne.n	80066aa <gpt_lld_start+0xa>
      rccEnableTIM3(FALSE);
 80066d6:	2002      	movs	r0, #2
 80066d8:	4b08      	ldr	r3, [pc, #32]	; (80066fc <gpt_lld_start+0x5c>)
 80066da:	69d9      	ldr	r1, [r3, #28]
 80066dc:	4301      	orrs	r1, r0
 80066de:	61d9      	str	r1, [r3, #28]
      rccResetTIM3();
 80066e0:	691a      	ldr	r2, [r3, #16]
      nvicEnableVector(STM32_TIM3_NUMBER, STM32_GPT_TIM3_IRQ_PRIORITY);
 80066e2:	2102      	movs	r1, #2
      rccResetTIM3();
 80066e4:	4302      	orrs	r2, r0
 80066e6:	611a      	str	r2, [r3, #16]
 80066e8:	2200      	movs	r2, #0
      nvicEnableVector(STM32_TIM3_NUMBER, STM32_GPT_TIM3_IRQ_PRIORITY);
 80066ea:	300e      	adds	r0, #14
      rccResetTIM3();
 80066ec:	611a      	str	r2, [r3, #16]
      nvicEnableVector(STM32_TIM3_NUMBER, STM32_GPT_TIM3_IRQ_PRIORITY);
 80066ee:	f7ff f82f 	bl	8005750 <nvicEnableVector>
      gptp->clock = STM32_TIMCLK1;
 80066f2:	4b03      	ldr	r3, [pc, #12]	; (8006700 <gpt_lld_start+0x60>)
 80066f4:	60a3      	str	r3, [r4, #8]
 80066f6:	e7d8      	b.n	80066aa <gpt_lld_start+0xa>
 80066f8:	200018e0 	.word	0x200018e0
 80066fc:	40021000 	.word	0x40021000
 8006700:	02dc6c00 	.word	0x02dc6c00
	...

08006710 <gpt_lld_start_timer>:
  gptp->tim->ARR   = (uint32_t)(interval - 1);  /* Time constant.           */
 8006710:	68c3      	ldr	r3, [r0, #12]
 8006712:	3901      	subs	r1, #1
 8006714:	62d9      	str	r1, [r3, #44]	; 0x2c
  gptp->tim->CNT   = 0;                         /* Reset counter.           */
 8006716:	2200      	movs	r2, #0
  gptp->tim->EGR   = STM32_TIM_EGR_UG;          /* Update event.            */
 8006718:	2101      	movs	r1, #1
 800671a:	6159      	str	r1, [r3, #20]
  gptp->tim->CNT   = 0;                         /* Reset counter.           */
 800671c:	625a      	str	r2, [r3, #36]	; 0x24
  gptp->tim->SR    = 0;                         /* Clear pending IRQs.      */
 800671e:	611a      	str	r2, [r3, #16]
  if (NULL != gptp->config->callback)
 8006720:	6842      	ldr	r2, [r0, #4]
 8006722:	6852      	ldr	r2, [r2, #4]
 8006724:	2a00      	cmp	r2, #0
 8006726:	d002      	beq.n	800672e <gpt_lld_start_timer+0x1e>
    gptp->tim->DIER |= STM32_TIM_DIER_UIE;      /* Update Event IRQ enabled.*/
 8006728:	68da      	ldr	r2, [r3, #12]
 800672a:	430a      	orrs	r2, r1
 800672c:	60da      	str	r2, [r3, #12]
  gptp->tim->CR1   = STM32_TIM_CR1_URS | STM32_TIM_CR1_CEN;
 800672e:	2205      	movs	r2, #5
 8006730:	601a      	str	r2, [r3, #0]
}
 8006732:	4770      	bx	lr
	...

08006740 <gpt_lld_polled_delay>:
  gptp->tim->ARR  = (uint32_t)(interval - 1);   /* Time constant.           */
 8006740:	68c2      	ldr	r2, [r0, #12]
  gptp->tim->EGR  = STM32_TIM_EGR_UG;           /* Update event.            */
 8006742:	2301      	movs	r3, #1
  gptp->tim->ARR  = (uint32_t)(interval - 1);   /* Time constant.           */
 8006744:	3901      	subs	r1, #1
 8006746:	62d1      	str	r1, [r2, #44]	; 0x2c
  while (!(gptp->tim->SR & STM32_TIM_SR_UIF))
 8006748:	2101      	movs	r1, #1
  gptp->tim->EGR  = STM32_TIM_EGR_UG;           /* Update event.            */
 800674a:	6153      	str	r3, [r2, #20]
  gptp->tim->CR1  = STM32_TIM_CR1_OPM | STM32_TIM_CR1_URS | STM32_TIM_CR1_CEN;
 800674c:	330c      	adds	r3, #12
 800674e:	6013      	str	r3, [r2, #0]
  while (!(gptp->tim->SR & STM32_TIM_SR_UIF))
 8006750:	6913      	ldr	r3, [r2, #16]
 8006752:	4219      	tst	r1, r3
 8006754:	d0fc      	beq.n	8006750 <gpt_lld_polled_delay+0x10>
  gptp->tim->SR   = 0;                          /* Clear pending IRQs.      */
 8006756:	2300      	movs	r3, #0
 8006758:	6113      	str	r3, [r2, #16]
}
 800675a:	4770      	bx	lr
 800675c:	0000      	movs	r0, r0
	...

08006760 <notify1>:

#if STM32_SERIAL_USE_USART1 || defined(__DOXYGEN__)
static void notify1(io_queue_t *qp) {

  (void)qp;
  USART1->CR1 |= USART_CR1_TXEIE;
 8006760:	2180      	movs	r1, #128	; 0x80
 8006762:	4a02      	ldr	r2, [pc, #8]	; (800676c <notify1+0xc>)
 8006764:	6813      	ldr	r3, [r2, #0]
 8006766:	430b      	orrs	r3, r1
 8006768:	6013      	str	r3, [r2, #0]
}
 800676a:	4770      	bx	lr
 800676c:	40013800 	.word	0x40013800

08006770 <VectorAC>:
/**
 * @brief   USART1 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART1_HANDLER) {
 8006770:	b5f0      	push	{r4, r5, r6, r7, lr}
 8006772:	46c6      	mov	lr, r8
  USART_TypeDef *u = sdp->usart;
 8006774:	4e35      	ldr	r6, [pc, #212]	; (800684c <VectorAC+0xdc>)
OSAL_IRQ_HANDLER(STM32_USART1_HANDLER) {
 8006776:	b500      	push	{lr}
  USART_TypeDef *u = sdp->usart;
 8006778:	6f75      	ldr	r5, [r6, #116]	; 0x74

  OSAL_IRQ_PROLOGUE();
 800677a:	46f0      	mov	r8, lr
  uint32_t cr1 = u->CR1;
 800677c:	682f      	ldr	r7, [r5, #0]
  isr = u->ISR;
 800677e:	69ec      	ldr	r4, [r5, #28]
  u->ICR = isr;
 8006780:	622c      	str	r4, [r5, #32]
  if (isr & (USART_ISR_ORE | USART_ISR_NE | USART_ISR_FE  | USART_ISR_PE))
 8006782:	0723      	lsls	r3, r4, #28
 8006784:	d129      	bne.n	80067da <VectorAC+0x6a>
  if (isr & USART_ISR_LBDF) {
 8006786:	05e3      	lsls	r3, r4, #23
 8006788:	d41f      	bmi.n	80067ca <VectorAC+0x5a>
  if (isr & USART_ISR_RXNE) {
 800678a:	06a3      	lsls	r3, r4, #26
 800678c:	d415      	bmi.n	80067ba <VectorAC+0x4a>
  if ((cr1 & USART_CR1_TXEIE) && (isr & USART_ISR_TXE)) {
 800678e:	2380      	movs	r3, #128	; 0x80
 8006790:	423b      	tst	r3, r7
 8006792:	d001      	beq.n	8006798 <VectorAC+0x28>
 8006794:	4223      	tst	r3, r4
 8006796:	d136      	bne.n	8006806 <VectorAC+0x96>
  if (isr & USART_ISR_TC) {
 8006798:	0663      	lsls	r3, r4, #25
 800679a:	d508      	bpl.n	80067ae <VectorAC+0x3e>
 800679c:	b672      	cpsid	i
    if (oqIsEmptyI(&sdp->oqueue))
 800679e:	6c73      	ldr	r3, [r6, #68]	; 0x44
 80067a0:	6cb2      	ldr	r2, [r6, #72]	; 0x48
 80067a2:	4293      	cmp	r3, r2
 80067a4:	d03a      	beq.n	800681c <VectorAC+0xac>
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 80067a6:	2340      	movs	r3, #64	; 0x40
 80067a8:	439f      	bics	r7, r3
 80067aa:	602f      	str	r7, [r5, #0]
  __ASM volatile ("cpsie i" : : : "memory");
 80067ac:	b662      	cpsie	i

  serve_interrupt(&SD1);

  OSAL_IRQ_EPILOGUE();
 80067ae:	4640      	mov	r0, r8
 80067b0:	f7fd fd06 	bl	80041c0 <_port_irq_epilogue>
}
 80067b4:	bc04      	pop	{r2}
 80067b6:	4690      	mov	r8, r2
 80067b8:	bdf0      	pop	{r4, r5, r6, r7, pc}
  __ASM volatile ("cpsid i" : : : "memory");
 80067ba:	b672      	cpsid	i
    sdIncomingDataI(sdp, (uint8_t)u->RDR);
 80067bc:	8ca9      	ldrh	r1, [r5, #36]	; 0x24
 80067be:	0030      	movs	r0, r6
 80067c0:	b2c9      	uxtb	r1, r1
 80067c2:	f7fe fa65 	bl	8004c90 <sdIncomingDataI>
  __ASM volatile ("cpsie i" : : : "memory");
 80067c6:	b662      	cpsie	i
 80067c8:	e7e1      	b.n	800678e <VectorAC+0x1e>
  __ASM volatile ("cpsid i" : : : "memory");
 80067ca:	b672      	cpsid	i
  chEvtBroadcastFlagsI(esp, flags);
 80067cc:	2180      	movs	r1, #128	; 0x80
 80067ce:	1d30      	adds	r0, r6, #4
 80067d0:	0089      	lsls	r1, r1, #2
 80067d2:	f7fd fccd 	bl	8004170 <chEvtBroadcastFlagsI>
  __ASM volatile ("cpsie i" : : : "memory");
 80067d6:	b662      	cpsie	i
 80067d8:	e7d7      	b.n	800678a <VectorAC+0x1a>
  if (isr & USART_ISR_ORE)
 80067da:	0721      	lsls	r1, r4, #28
    sts |= SD_OVERRUN_ERROR;
 80067dc:	0fc9      	lsrs	r1, r1, #31
 80067de:	01c9      	lsls	r1, r1, #7
  if (isr & USART_ISR_PE)
 80067e0:	07e3      	lsls	r3, r4, #31
 80067e2:	d501      	bpl.n	80067e8 <VectorAC+0x78>
    sts |= SD_PARITY_ERROR;
 80067e4:	2320      	movs	r3, #32
 80067e6:	4319      	orrs	r1, r3
  if (isr & USART_ISR_FE)
 80067e8:	07a3      	lsls	r3, r4, #30
 80067ea:	d501      	bpl.n	80067f0 <VectorAC+0x80>
    sts |= SD_FRAMING_ERROR;
 80067ec:	2340      	movs	r3, #64	; 0x40
 80067ee:	4319      	orrs	r1, r3
  if (isr & USART_ISR_NE)
 80067f0:	0763      	lsls	r3, r4, #29
 80067f2:	d502      	bpl.n	80067fa <VectorAC+0x8a>
    sts |= SD_NOISE_ERROR;
 80067f4:	2380      	movs	r3, #128	; 0x80
 80067f6:	005b      	lsls	r3, r3, #1
 80067f8:	4319      	orrs	r1, r3
  __ASM volatile ("cpsid i" : : : "memory");
 80067fa:	b672      	cpsid	i
 80067fc:	1d30      	adds	r0, r6, #4
 80067fe:	f7fd fcb7 	bl	8004170 <chEvtBroadcastFlagsI>
  __ASM volatile ("cpsie i" : : : "memory");
 8006802:	b662      	cpsie	i
 8006804:	e7bf      	b.n	8006786 <VectorAC+0x16>
  __ASM volatile ("cpsid i" : : : "memory");
 8006806:	b672      	cpsid	i
    b = oqGetI(&sdp->oqueue);
 8006808:	0030      	movs	r0, r6
 800680a:	3030      	adds	r0, #48	; 0x30
 800680c:	f7fe f870 	bl	80048f0 <oqGetI>
    if (b < MSG_OK) {
 8006810:	2800      	cmp	r0, #0
 8006812:	db0f      	blt.n	8006834 <VectorAC+0xc4>
      u->TDR = b;
 8006814:	b280      	uxth	r0, r0
 8006816:	8528      	strh	r0, [r5, #40]	; 0x28
  __ASM volatile ("cpsie i" : : : "memory");
 8006818:	b662      	cpsie	i
 800681a:	e7bd      	b.n	8006798 <VectorAC+0x28>
    if (oqIsEmptyI(&sdp->oqueue))
 800681c:	6bb3      	ldr	r3, [r6, #56]	; 0x38
 800681e:	2b00      	cmp	r3, #0
 8006820:	d0c1      	beq.n	80067a6 <VectorAC+0x36>
 8006822:	1d30      	adds	r0, r6, #4
 8006824:	2110      	movs	r1, #16
 8006826:	f7fd fca3 	bl	8004170 <chEvtBroadcastFlagsI>
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 800682a:	2340      	movs	r3, #64	; 0x40
 800682c:	439f      	bics	r7, r3
 800682e:	602f      	str	r7, [r5, #0]
 8006830:	b662      	cpsie	i
 8006832:	e7bc      	b.n	80067ae <VectorAC+0x3e>
 8006834:	1d30      	adds	r0, r6, #4
 8006836:	2108      	movs	r1, #8
 8006838:	f7fd fc9a 	bl	8004170 <chEvtBroadcastFlagsI>
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
 800683c:	23c0      	movs	r3, #192	; 0xc0
 800683e:	003a      	movs	r2, r7
 8006840:	439a      	bics	r2, r3
 8006842:	0013      	movs	r3, r2
 8006844:	2240      	movs	r2, #64	; 0x40
 8006846:	4313      	orrs	r3, r2
 8006848:	602b      	str	r3, [r5, #0]
 800684a:	e7e5      	b.n	8006818 <VectorAC+0xa8>
 800684c:	200018f0 	.word	0x200018f0

08006850 <sd_lld_init>:
/**
 * @brief   Low level serial driver initialization.
 *
 * @notapi
 */
void sd_lld_init(void) {
 8006850:	b510      	push	{r4, lr}

#if STM32_SERIAL_USE_USART1
  sdObjectInit(&SD1, NULL, notify1);
 8006852:	4c07      	ldr	r4, [pc, #28]	; (8006870 <sd_lld_init+0x20>)
 8006854:	4a07      	ldr	r2, [pc, #28]	; (8006874 <sd_lld_init+0x24>)
 8006856:	0020      	movs	r0, r4
 8006858:	2100      	movs	r1, #0
 800685a:	f7fe f9f9 	bl	8004c50 <sdObjectInit>
  SD1.usart = USART1;
 800685e:	4b06      	ldr	r3, [pc, #24]	; (8006878 <sd_lld_init+0x28>)
  SD1.clock = STM32_USART1CLK;
#if defined(STM32_USART1_NUMBER)
  nvicEnableVector(STM32_USART1_NUMBER, STM32_SERIAL_USART1_PRIORITY);
 8006860:	2103      	movs	r1, #3
  SD1.usart = USART1;
 8006862:	6763      	str	r3, [r4, #116]	; 0x74
  SD1.clock = STM32_USART1CLK;
 8006864:	4b05      	ldr	r3, [pc, #20]	; (800687c <sd_lld_init+0x2c>)
  nvicEnableVector(STM32_USART1_NUMBER, STM32_SERIAL_USART1_PRIORITY);
 8006866:	201b      	movs	r0, #27
  SD1.clock = STM32_USART1CLK;
 8006868:	67a3      	str	r3, [r4, #120]	; 0x78
  nvicEnableVector(STM32_USART1_NUMBER, STM32_SERIAL_USART1_PRIORITY);
 800686a:	f7fe ff71 	bl	8005750 <nvicEnableVector>
    STM32_SERIAL_USE_UART7  ||  STM32_SERIAL_USE_UART8 || defined(__DOXYGEN__)
#if defined(STM32_USART3_8_HANDLER)
  nvicEnableVector(STM32_USART3_8_NUMBER, STM32_SERIAL_USART3_8_PRIORITY);
#endif
#endif
}
 800686e:	bd10      	pop	{r4, pc}
 8006870:	200018f0 	.word	0x200018f0
 8006874:	08006761 	.word	0x08006761
 8006878:	40013800 	.word	0x40013800
 800687c:	02dc6c00 	.word	0x02dc6c00

08006880 <VectorBC>:
/**
 * @brief   USB low priority interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USB1_LP_HANDLER) {
 8006880:	b5f0      	push	{r4, r5, r6, r7, lr}
 8006882:	46de      	mov	lr, fp
 8006884:	4657      	mov	r7, sl
 8006886:	464e      	mov	r6, r9
 8006888:	4645      	mov	r5, r8
  uint32_t istr;
  USBDriver *usbp = &USBD1;

  OSAL_IRQ_PROLOGUE();
 800688a:	4673      	mov	r3, lr
OSAL_IRQ_HANDLER(STM32_USB1_LP_HANDLER) {
 800688c:	b5e0      	push	{r5, r6, r7, lr}
 800688e:	b089      	sub	sp, #36	; 0x24
  OSAL_IRQ_PROLOGUE();
 8006890:	9307      	str	r3, [sp, #28]

  istr = STM32_USB->ISTR;
 8006892:	4ba1      	ldr	r3, [pc, #644]	; (8006b18 <VectorBC+0x298>)
 8006894:	6c5c      	ldr	r4, [r3, #68]	; 0x44

  /* USB bus reset condition handling.*/
  if (istr & ISTR_RESET) {
 8006896:	0562      	lsls	r2, r4, #21
 8006898:	d500      	bpl.n	800689c <VectorBC+0x1c>
 800689a:	e12a      	b.n	8006af2 <VectorBC+0x272>

    _usb_reset(usbp);
  }

  /* USB bus SUSPEND condition handling.*/
  if (istr & ISTR_SUSP) {
 800689c:	0523      	lsls	r3, r4, #20
 800689e:	d500      	bpl.n	80068a2 <VectorBC+0x22>
 80068a0:	e11b      	b.n	8006ada <VectorBC+0x25a>

    _usb_suspend(usbp);
  }

  /* USB bus WAKEUP condition handling.*/
  if (istr & ISTR_WKUP) {
 80068a2:	04e3      	lsls	r3, r4, #19
 80068a4:	d507      	bpl.n	80068b6 <VectorBC+0x36>
    uint32_t fnr = STM32_USB->FNR;
 80068a6:	4b9c      	ldr	r3, [pc, #624]	; (8006b18 <VectorBC+0x298>)
 80068a8:	6c9a      	ldr	r2, [r3, #72]	; 0x48
    if (!(fnr & FNR_RXDP)) {
 80068aa:	0412      	lsls	r2, r2, #16
 80068ac:	d400      	bmi.n	80068b0 <VectorBC+0x30>
 80068ae:	e127      	b.n	8006b00 <VectorBC+0x280>
      /* Just noise, going back in SUSPEND mode, reference manual 22.4.5,
         table 169.*/
      STM32_USB->CNTR |= CNTR_LP_MODE;
    }
#endif
    STM32_USB->ISTR = ~ISTR_WKUP;
 80068b0:	4b99      	ldr	r3, [pc, #612]	; (8006b18 <VectorBC+0x298>)
 80068b2:	4a9a      	ldr	r2, [pc, #616]	; (8006b1c <VectorBC+0x29c>)
 80068b4:	645a      	str	r2, [r3, #68]	; 0x44
  }

  /* SOF handling.*/
  if (istr & ISTR_SOF) {
 80068b6:	05a3      	lsls	r3, r4, #22
 80068b8:	d50a      	bpl.n	80068d0 <VectorBC+0x50>
    _usb_isr_invoke_sof_cb(usbp);
 80068ba:	4b99      	ldr	r3, [pc, #612]	; (8006b20 <VectorBC+0x2a0>)
 80068bc:	469a      	mov	sl, r3
 80068be:	685b      	ldr	r3, [r3, #4]
 80068c0:	68db      	ldr	r3, [r3, #12]
 80068c2:	2b00      	cmp	r3, #0
 80068c4:	d001      	beq.n	80068ca <VectorBC+0x4a>
 80068c6:	4650      	mov	r0, sl
 80068c8:	4798      	blx	r3
    STM32_USB->ISTR = ~ISTR_SOF;
 80068ca:	4b93      	ldr	r3, [pc, #588]	; (8006b18 <VectorBC+0x298>)
 80068cc:	4a95      	ldr	r2, [pc, #596]	; (8006b24 <VectorBC+0x2a4>)
 80068ce:	645a      	str	r2, [r3, #68]	; 0x44
  }

  /* Endpoint events handling.*/
  while (istr & ISTR_CTR) {
 80068d0:	2380      	movs	r3, #128	; 0x80
 80068d2:	021b      	lsls	r3, r3, #8
 80068d4:	421c      	tst	r4, r3
 80068d6:	d073      	beq.n	80069c0 <VectorBC+0x140>
 80068d8:	4a91      	ldr	r2, [pc, #580]	; (8006b20 <VectorBC+0x2a0>)
    EPR_CLEAR_CTR_TX(ep);
 80068da:	9300      	str	r3, [sp, #0]
  stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
 80068dc:	4b8e      	ldr	r3, [pc, #568]	; (8006b18 <VectorBC+0x298>)
 80068de:	0017      	movs	r7, r2
 80068e0:	469b      	mov	fp, r3
    usb_serve_endpoints(usbp, istr & ISTR_EP_ID_MASK);
 80068e2:	230f      	movs	r3, #15
 80068e4:	401c      	ands	r4, r3
  uint32_t epr = STM32_USB->EPR[ep];
 80068e6:	4b8c      	ldr	r3, [pc, #560]	; (8006b18 <VectorBC+0x298>)
 80068e8:	00a5      	lsls	r5, r4, #2
 80068ea:	469c      	mov	ip, r3
 80068ec:	4465      	add	r5, ip
 80068ee:	682b      	ldr	r3, [r5, #0]
  const USBEndpointConfig *epcp = usbp->epc[ep];
 80068f0:	1ca6      	adds	r6, r4, #2
  uint32_t epr = STM32_USB->EPR[ep];
 80068f2:	4699      	mov	r9, r3
  const USBEndpointConfig *epcp = usbp->epc[ep];
 80068f4:	00b3      	lsls	r3, r6, #2
 80068f6:	18fb      	adds	r3, r7, r3
 80068f8:	685b      	ldr	r3, [r3, #4]
 80068fa:	4698      	mov	r8, r3
  if (epr & EPR_CTR_TX) {
 80068fc:	464b      	mov	r3, r9
 80068fe:	061b      	lsls	r3, r3, #24
 8006900:	d544      	bpl.n	800698c <VectorBC+0x10c>
    USBInEndpointState *isp = epcp->in_state;
 8006902:	4643      	mov	r3, r8
    EPR_CLEAR_CTR_TX(ep);
 8006904:	4988      	ldr	r1, [pc, #544]	; (8006b28 <VectorBC+0x2a8>)
    USBInEndpointState *isp = epcp->in_state;
 8006906:	695a      	ldr	r2, [r3, #20]
    EPR_CLEAR_CTR_TX(ep);
 8006908:	682b      	ldr	r3, [r5, #0]
 800690a:	400b      	ands	r3, r1
 800690c:	9900      	ldr	r1, [sp, #0]
 800690e:	430b      	orrs	r3, r1
 8006910:	602b      	str	r3, [r5, #0]
    isp->txcnt += isp->txlast;
 8006912:	6851      	ldr	r1, [r2, #4]
 8006914:	68d3      	ldr	r3, [r2, #12]
 8006916:	1858      	adds	r0, r3, r1
    n = isp->txsize - isp->txcnt;
 8006918:	6811      	ldr	r1, [r2, #0]
    isp->txcnt += isp->txlast;
 800691a:	6050      	str	r0, [r2, #4]
    n = isp->txsize - isp->txcnt;
 800691c:	1a08      	subs	r0, r1, r0
    if (n > 0) {
 800691e:	d059      	beq.n	80069d4 <VectorBC+0x154>
      if (n > epcp->in_maxsize)
 8006920:	4641      	mov	r1, r8
 8006922:	8a09      	ldrh	r1, [r1, #16]
 8006924:	4281      	cmp	r1, r0
 8006926:	d900      	bls.n	800692a <VectorBC+0xaa>
 8006928:	0001      	movs	r1, r0
      isp->txbuf += isp->txlast;
 800692a:	6890      	ldr	r0, [r2, #8]
      isp->txlast = n;
 800692c:	60d1      	str	r1, [r2, #12]
      isp->txbuf += isp->txlast;
 800692e:	4684      	mov	ip, r0
 8006930:	4463      	add	r3, ip
 8006932:	6093      	str	r3, [r2, #8]
 8006934:	469a      	mov	sl, r3
  stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
 8006936:	465a      	mov	r2, fp
 8006938:	4b7c      	ldr	r3, [pc, #496]	; (8006b2c <VectorBC+0x2ac>)
 800693a:	6d12      	ldr	r2, [r2, #80]	; 0x50
 800693c:	469c      	mov	ip, r3
 800693e:	00e0      	lsls	r0, r4, #3
 8006940:	4462      	add	r2, ip
 8006942:	1882      	adds	r2, r0, r2
  stm32_usb_pma_t *pmap = USB_ADDR2PTR(udp->TXADDR0);
 8006944:	8810      	ldrh	r0, [r2, #0]
  udp->TXCOUNT0 = (stm32_usb_pma_t)n;
 8006946:	b28b      	uxth	r3, r1
  stm32_usb_pma_t *pmap = USB_ADDR2PTR(udp->TXADDR0);
 8006948:	4460      	add	r0, ip
  udp->TXCOUNT0 = (stm32_usb_pma_t)n;
 800694a:	8053      	strh	r3, [r2, #2]
  while (i > 0) {
 800694c:	2900      	cmp	r1, #0
 800694e:	d015      	beq.n	800697c <VectorBC+0xfc>
 8006950:	4653      	mov	r3, sl
 8006952:	3901      	subs	r1, #1
 8006954:	0849      	lsrs	r1, r1, #1
 8006956:	3101      	adds	r1, #1
 8006958:	0049      	lsls	r1, r1, #1
 800695a:	4451      	add	r1, sl
 800695c:	1ac0      	subs	r0, r0, r3
 800695e:	46a4      	mov	ip, r4
 8006960:	46aa      	mov	sl, r5
 8006962:	0004      	movs	r4, r0
 8006964:	0008      	movs	r0, r1
 8006966:	0019      	movs	r1, r3
    w  = *buf++;
 8006968:	785a      	ldrb	r2, [r3, #1]
 800696a:	781d      	ldrb	r5, [r3, #0]
 800696c:	0212      	lsls	r2, r2, #8
 800696e:	432a      	orrs	r2, r5
    w |= *buf++ << 8;
 8006970:	3302      	adds	r3, #2
    *pmap++ = (stm32_usb_pma_t)w;
 8006972:	530a      	strh	r2, [r1, r4]
  while (i > 0) {
 8006974:	4298      	cmp	r0, r3
 8006976:	d1f6      	bne.n	8006966 <VectorBC+0xe6>
 8006978:	4664      	mov	r4, ip
 800697a:	4655      	mov	r5, sl
      EPR_SET_STAT_TX(ep, EPR_STAT_TX_VALID);
 800697c:	682b      	ldr	r3, [r5, #0]
 800697e:	4a6c      	ldr	r2, [pc, #432]	; (8006b30 <VectorBC+0x2b0>)
 8006980:	4013      	ands	r3, r2
 8006982:	2230      	movs	r2, #48	; 0x30
 8006984:	4053      	eors	r3, r2
 8006986:	4a6b      	ldr	r2, [pc, #428]	; (8006b34 <VectorBC+0x2b4>)
 8006988:	4313      	orrs	r3, r2
 800698a:	602b      	str	r3, [r5, #0]
  if (epr & EPR_CTR_RX) {
 800698c:	464b      	mov	r3, r9
 800698e:	9a00      	ldr	r2, [sp, #0]
 8006990:	4213      	tst	r3, r2
 8006992:	d010      	beq.n	80069b6 <VectorBC+0x136>
    EPR_CLEAR_CTR_RX(ep);
 8006994:	682b      	ldr	r3, [r5, #0]
 8006996:	4a64      	ldr	r2, [pc, #400]	; (8006b28 <VectorBC+0x2a8>)
 8006998:	b2e1      	uxtb	r1, r4
 800699a:	4013      	ands	r3, r2
 800699c:	2280      	movs	r2, #128	; 0x80
 800699e:	4313      	orrs	r3, r2
 80069a0:	602b      	str	r3, [r5, #0]
    if (epr & EPR_SETUP) {
 80069a2:	464b      	mov	r3, r9
 80069a4:	9101      	str	r1, [sp, #4]
 80069a6:	051b      	lsls	r3, r3, #20
 80069a8:	d521      	bpl.n	80069ee <VectorBC+0x16e>
      _usb_isr_invoke_setup_cb(usbp, ep);
 80069aa:	00b6      	lsls	r6, r6, #2
 80069ac:	19be      	adds	r6, r7, r6
 80069ae:	6873      	ldr	r3, [r6, #4]
 80069b0:	0038      	movs	r0, r7
 80069b2:	685b      	ldr	r3, [r3, #4]
 80069b4:	4798      	blx	r3
    istr = STM32_USB->ISTR;
 80069b6:	465b      	mov	r3, fp
 80069b8:	6c5c      	ldr	r4, [r3, #68]	; 0x44
  while (istr & ISTR_CTR) {
 80069ba:	9b00      	ldr	r3, [sp, #0]
 80069bc:	421c      	tst	r4, r3
 80069be:	d190      	bne.n	80068e2 <VectorBC+0x62>
  }

  OSAL_IRQ_EPILOGUE();
 80069c0:	9807      	ldr	r0, [sp, #28]
 80069c2:	f7fd fbfd 	bl	80041c0 <_port_irq_epilogue>
}
 80069c6:	b009      	add	sp, #36	; 0x24
 80069c8:	bc3c      	pop	{r2, r3, r4, r5}
 80069ca:	4690      	mov	r8, r2
 80069cc:	4699      	mov	r9, r3
 80069ce:	46a2      	mov	sl, r4
 80069d0:	46ab      	mov	fp, r5
 80069d2:	bdf0      	pop	{r4, r5, r6, r7, pc}
      _usb_isr_invoke_in_cb(usbp, ep);
 80069d4:	2201      	movs	r2, #1
 80069d6:	40a2      	lsls	r2, r4
 80069d8:	893b      	ldrh	r3, [r7, #8]
 80069da:	4393      	bics	r3, r2
 80069dc:	813b      	strh	r3, [r7, #8]
 80069de:	4643      	mov	r3, r8
 80069e0:	689b      	ldr	r3, [r3, #8]
 80069e2:	2b00      	cmp	r3, #0
 80069e4:	d0d2      	beq.n	800698c <VectorBC+0x10c>
 80069e6:	b2e1      	uxtb	r1, r4
 80069e8:	0038      	movs	r0, r7
 80069ea:	4798      	blx	r3
 80069ec:	e7ce      	b.n	800698c <VectorBC+0x10c>
      USBOutEndpointState *osp = epcp->out_state;
 80069ee:	4643      	mov	r3, r8
 80069f0:	6999      	ldr	r1, [r3, #24]
  stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
 80069f2:	4a4e      	ldr	r2, [pc, #312]	; (8006b2c <VectorBC+0x2ac>)
      n = usb_packet_read_to_buffer(ep, osp->rxbuf);
 80069f4:	688b      	ldr	r3, [r1, #8]
  stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
 80069f6:	4694      	mov	ip, r2
      n = usb_packet_read_to_buffer(ep, osp->rxbuf);
 80069f8:	469a      	mov	sl, r3
  stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
 80069fa:	465b      	mov	r3, fp
 80069fc:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 80069fe:	00e2      	lsls	r2, r4, #3
 8006a00:	4463      	add	r3, ip
 8006a02:	189b      	adds	r3, r3, r2
  stm32_usb_pma_t *pmap = USB_ADDR2PTR(udp->RXADDR0);
 8006a04:	8898      	ldrh	r0, [r3, #4]
 8006a06:	b280      	uxth	r0, r0
 8006a08:	4484      	add	ip, r0
 8006a0a:	4662      	mov	r2, ip
 8006a0c:	9202      	str	r2, [sp, #8]
  n = (size_t)udp->RXCOUNT0 & RXCOUNT_COUNT_MASK;
 8006a0e:	88db      	ldrh	r3, [r3, #6]
 8006a10:	b29b      	uxth	r3, r3
 8006a12:	059a      	lsls	r2, r3, #22
 8006a14:	0d92      	lsrs	r2, r2, #22
 8006a16:	4691      	mov	r9, r2
  while (i >= 2) {
 8006a18:	4a47      	ldr	r2, [pc, #284]	; (8006b38 <VectorBC+0x2b8>)
 8006a1a:	4213      	tst	r3, r2
 8006a1c:	d079      	beq.n	8006b12 <VectorBC+0x292>
 8006a1e:	464b      	mov	r3, r9
 8006a20:	3b02      	subs	r3, #2
 8006a22:	9304      	str	r3, [sp, #16]
 8006a24:	085b      	lsrs	r3, r3, #1
 8006a26:	005a      	lsls	r2, r3, #1
 8006a28:	9303      	str	r3, [sp, #12]
 8006a2a:	4653      	mov	r3, sl
 8006a2c:	4694      	mov	ip, r2
 8006a2e:	3302      	adds	r3, #2
 8006a30:	449c      	add	ip, r3
 8006a32:	4653      	mov	r3, sl
 8006a34:	1ac0      	subs	r0, r0, r3
 8006a36:	0002      	movs	r2, r0
 8006a38:	9106      	str	r1, [sp, #24]
 8006a3a:	4660      	mov	r0, ip
 8006a3c:	0011      	movs	r1, r2
 8006a3e:	9405      	str	r4, [sp, #20]
    uint32_t w = *pmap++;
 8006a40:	4c3a      	ldr	r4, [pc, #232]	; (8006b2c <VectorBC+0x2ac>)
 8006a42:	185a      	adds	r2, r3, r1
 8006a44:	46a4      	mov	ip, r4
 8006a46:	4462      	add	r2, ip
 8006a48:	8812      	ldrh	r2, [r2, #0]
    *buf++ = (uint8_t)w;
 8006a4a:	701a      	strb	r2, [r3, #0]
    *buf++ = (uint8_t)(w >> 8);
 8006a4c:	0a12      	lsrs	r2, r2, #8
 8006a4e:	705a      	strb	r2, [r3, #1]
    i -= 2;
 8006a50:	3302      	adds	r3, #2
  while (i >= 2) {
 8006a52:	4298      	cmp	r0, r3
 8006a54:	d1f4      	bne.n	8006a40 <VectorBC+0x1c0>
 8006a56:	9802      	ldr	r0, [sp, #8]
 8006a58:	9a03      	ldr	r2, [sp, #12]
 8006a5a:	4684      	mov	ip, r0
 8006a5c:	1c53      	adds	r3, r2, #1
 8006a5e:	005b      	lsls	r3, r3, #1
 8006a60:	449c      	add	ip, r3
 8006a62:	4660      	mov	r0, ip
 8006a64:	449a      	add	sl, r3
 8006a66:	0053      	lsls	r3, r2, #1
 8006a68:	9a04      	ldr	r2, [sp, #16]
 8006a6a:	9c05      	ldr	r4, [sp, #20]
 8006a6c:	9906      	ldr	r1, [sp, #24]
 8006a6e:	9002      	str	r0, [sp, #8]
 8006a70:	1ad3      	subs	r3, r2, r3
  if (i >= 1) {
 8006a72:	2b00      	cmp	r3, #0
 8006a74:	d003      	beq.n	8006a7e <VectorBC+0x1fe>
    *buf = (uint8_t)*pmap;
 8006a76:	4652      	mov	r2, sl
 8006a78:	9b02      	ldr	r3, [sp, #8]
 8006a7a:	881b      	ldrh	r3, [r3, #0]
 8006a7c:	7013      	strb	r3, [r2, #0]
      osp->rxsize -= n;
 8006a7e:	464a      	mov	r2, r9
      osp->rxbuf += n;
 8006a80:	688b      	ldr	r3, [r1, #8]
 8006a82:	444b      	add	r3, r9
 8006a84:	608b      	str	r3, [r1, #8]
      osp->rxcnt  += n;
 8006a86:	684b      	ldr	r3, [r1, #4]
 8006a88:	444b      	add	r3, r9
 8006a8a:	604b      	str	r3, [r1, #4]
      osp->rxsize -= n;
 8006a8c:	680b      	ldr	r3, [r1, #0]
 8006a8e:	1a9b      	subs	r3, r3, r2
      if ((n < epcp->out_maxsize) || (osp->rxpkts == 0)) {
 8006a90:	4642      	mov	r2, r8
      osp->rxsize -= n;
 8006a92:	600b      	str	r3, [r1, #0]
      osp->rxpkts -= 1;
 8006a94:	898b      	ldrh	r3, [r1, #12]
 8006a96:	3b01      	subs	r3, #1
 8006a98:	b29b      	uxth	r3, r3
 8006a9a:	818b      	strh	r3, [r1, #12]
      if ((n < epcp->out_maxsize) || (osp->rxpkts == 0)) {
 8006a9c:	8a52      	ldrh	r2, [r2, #18]
 8006a9e:	454a      	cmp	r2, r9
 8006aa0:	d801      	bhi.n	8006aa6 <VectorBC+0x226>
 8006aa2:	2b00      	cmp	r3, #0
 8006aa4:	d10f      	bne.n	8006ac6 <VectorBC+0x246>
        _usb_isr_invoke_out_cb(usbp, ep);
 8006aa6:	2201      	movs	r2, #1
 8006aa8:	40a2      	lsls	r2, r4
 8006aaa:	897b      	ldrh	r3, [r7, #10]
 8006aac:	00b6      	lsls	r6, r6, #2
 8006aae:	4393      	bics	r3, r2
 8006ab0:	19be      	adds	r6, r7, r6
 8006ab2:	817b      	strh	r3, [r7, #10]
 8006ab4:	6873      	ldr	r3, [r6, #4]
 8006ab6:	68db      	ldr	r3, [r3, #12]
 8006ab8:	2b00      	cmp	r3, #0
 8006aba:	d100      	bne.n	8006abe <VectorBC+0x23e>
 8006abc:	e77b      	b.n	80069b6 <VectorBC+0x136>
 8006abe:	9901      	ldr	r1, [sp, #4]
 8006ac0:	0038      	movs	r0, r7
 8006ac2:	4798      	blx	r3
 8006ac4:	e777      	b.n	80069b6 <VectorBC+0x136>
        EPR_SET_STAT_RX(ep, EPR_STAT_RX_VALID);
 8006ac6:	682a      	ldr	r2, [r5, #0]
 8006ac8:	4b1c      	ldr	r3, [pc, #112]	; (8006b3c <VectorBC+0x2bc>)
 8006aca:	401a      	ands	r2, r3
 8006acc:	23c0      	movs	r3, #192	; 0xc0
 8006ace:	019b      	lsls	r3, r3, #6
 8006ad0:	405a      	eors	r2, r3
 8006ad2:	4b18      	ldr	r3, [pc, #96]	; (8006b34 <VectorBC+0x2b4>)
 8006ad4:	4313      	orrs	r3, r2
 8006ad6:	602b      	str	r3, [r5, #0]
 8006ad8:	e76d      	b.n	80069b6 <VectorBC+0x136>
    STM32_USB->CNTR |= CNTR_FSUSP;
 8006ada:	2108      	movs	r1, #8
 8006adc:	4b0e      	ldr	r3, [pc, #56]	; (8006b18 <VectorBC+0x298>)
 8006ade:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8006ae0:	430a      	orrs	r2, r1
 8006ae2:	641a      	str	r2, [r3, #64]	; 0x40
    STM32_USB->ISTR = ~ISTR_SUSP;
 8006ae4:	4a16      	ldr	r2, [pc, #88]	; (8006b40 <VectorBC+0x2c0>)
 8006ae6:	645a      	str	r2, [r3, #68]	; 0x44
    _usb_suspend(usbp);
 8006ae8:	4b0d      	ldr	r3, [pc, #52]	; (8006b20 <VectorBC+0x2a0>)
 8006aea:	0018      	movs	r0, r3
 8006aec:	f7fe fbe8 	bl	80052c0 <_usb_suspend>
 8006af0:	e6d7      	b.n	80068a2 <VectorBC+0x22>
    STM32_USB->ISTR = ~ISTR_RESET;
 8006af2:	4a14      	ldr	r2, [pc, #80]	; (8006b44 <VectorBC+0x2c4>)
 8006af4:	645a      	str	r2, [r3, #68]	; 0x44
    _usb_reset(usbp);
 8006af6:	4b0a      	ldr	r3, [pc, #40]	; (8006b20 <VectorBC+0x2a0>)
 8006af8:	0018      	movs	r0, r3
 8006afa:	f7fe fbc1 	bl	8005280 <_usb_reset>
 8006afe:	e6cd      	b.n	800689c <VectorBC+0x1c>
      STM32_USB->CNTR &= ~CNTR_FSUSP;
 8006b00:	2108      	movs	r1, #8
 8006b02:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8006b04:	438a      	bics	r2, r1
 8006b06:	641a      	str	r2, [r3, #64]	; 0x40
      _usb_wakeup(usbp);
 8006b08:	4b05      	ldr	r3, [pc, #20]	; (8006b20 <VectorBC+0x2a0>)
 8006b0a:	0018      	movs	r0, r3
 8006b0c:	f7fe fbe8 	bl	80052e0 <_usb_wakeup>
 8006b10:	e6ce      	b.n	80068b0 <VectorBC+0x30>
  while (i >= 2) {
 8006b12:	464b      	mov	r3, r9
 8006b14:	e7ad      	b.n	8006a72 <VectorBC+0x1f2>
 8006b16:	46c0      	nop			; (mov r8, r8)
 8006b18:	40005c00 	.word	0x40005c00
 8006b1c:	ffffefff 	.word	0xffffefff
 8006b20:	2000196c 	.word	0x2000196c
 8006b24:	fffffdff 	.word	0xfffffdff
 8006b28:	ffff070f 	.word	0xffff070f
 8006b2c:	40006000 	.word	0x40006000
 8006b30:	ffff87bf 	.word	0xffff87bf
 8006b34:	00008080 	.word	0x00008080
 8006b38:	000003fe 	.word	0x000003fe
 8006b3c:	ffffb78f 	.word	0xffffb78f
 8006b40:	fffff7ff 	.word	0xfffff7ff
 8006b44:	fffffbff 	.word	0xfffffbff
	...

08006b50 <usb_lld_init>:
/**
 * @brief   Low level USB driver initialization.
 *
 * @notapi
 */
void usb_lld_init(void) {
 8006b50:	b510      	push	{r4, lr}

  /* Driver initialization.*/
  usbObjectInit(&USBD1);
 8006b52:	4802      	ldr	r0, [pc, #8]	; (8006b5c <usb_lld_init+0xc>)
 8006b54:	f7fe fb1c 	bl	8005190 <usbObjectInit>
}
 8006b58:	bd10      	pop	{r4, pc}
 8006b5a:	46c0      	nop			; (mov r8, r8)
 8006b5c:	2000196c 	.word	0x2000196c

08006b60 <usb_lld_start>:
 *
 * @notapi
 */
void usb_lld_start(USBDriver *usbp) {

  if (usbp->state == USB_STOP) {
 8006b60:	7803      	ldrb	r3, [r0, #0]
void usb_lld_start(USBDriver *usbp) {
 8006b62:	b570      	push	{r4, r5, r6, lr}
 8006b64:	0004      	movs	r4, r0
  if (usbp->state == USB_STOP) {
 8006b66:	2b01      	cmp	r3, #1
 8006b68:	d000      	beq.n	8006b6c <usb_lld_start+0xc>
    }
#endif
    /* Reset procedure enforced on driver start.*/
    _usb_reset(usbp);
  }
}
 8006b6a:	bd70      	pop	{r4, r5, r6, pc}
    if (&USBD1 == usbp) {
 8006b6c:	4a0a      	ldr	r2, [pc, #40]	; (8006b98 <usb_lld_start+0x38>)
 8006b6e:	4290      	cmp	r0, r2
 8006b70:	d003      	beq.n	8006b7a <usb_lld_start+0x1a>
    _usb_reset(usbp);
 8006b72:	0020      	movs	r0, r4
 8006b74:	f7fe fb84 	bl	8005280 <_usb_reset>
}
 8006b78:	e7f7      	b.n	8006b6a <usb_lld_start+0xa>
      rccEnableUSB(FALSE);
 8006b7a:	2280      	movs	r2, #128	; 0x80
 8006b7c:	4907      	ldr	r1, [pc, #28]	; (8006b9c <usb_lld_start+0x3c>)
      STM32_USB->CNTR = CNTR_FRES;
 8006b7e:	4d08      	ldr	r5, [pc, #32]	; (8006ba0 <usb_lld_start+0x40>)
      rccEnableUSB(FALSE);
 8006b80:	69c8      	ldr	r0, [r1, #28]
 8006b82:	0412      	lsls	r2, r2, #16
 8006b84:	4302      	orrs	r2, r0
 8006b86:	61ca      	str	r2, [r1, #28]
      nvicEnableVector(STM32_USB1_LP_NUMBER, STM32_USB_USB1_LP_IRQ_PRIORITY);
 8006b88:	201f      	movs	r0, #31
      STM32_USB->CNTR = CNTR_FRES;
 8006b8a:	642b      	str	r3, [r5, #64]	; 0x40
      nvicEnableVector(STM32_USB1_LP_NUMBER, STM32_USB_USB1_LP_IRQ_PRIORITY);
 8006b8c:	2103      	movs	r1, #3
 8006b8e:	f7fe fddf 	bl	8005750 <nvicEnableVector>
      STM32_USB->CNTR = 0;
 8006b92:	2300      	movs	r3, #0
 8006b94:	642b      	str	r3, [r5, #64]	; 0x40
 8006b96:	e7ec      	b.n	8006b72 <usb_lld_start+0x12>
 8006b98:	2000196c 	.word	0x2000196c
 8006b9c:	40021000 	.word	0x40021000
 8006ba0:	40005c00 	.word	0x40005c00
	...

08006bb0 <usb_lld_set_address>:
 *
 * @notapi
 */
void usb_lld_set_address(USBDriver *usbp) {

  STM32_USB->DADDR = (uint32_t)(usbp->address) | DADDR_EF;
 8006bb0:	237e      	movs	r3, #126	; 0x7e
 8006bb2:	2280      	movs	r2, #128	; 0x80
 8006bb4:	5cc3      	ldrb	r3, [r0, r3]
 8006bb6:	4313      	orrs	r3, r2
 8006bb8:	4a01      	ldr	r2, [pc, #4]	; (8006bc0 <usb_lld_set_address+0x10>)
 8006bba:	64d3      	str	r3, [r2, #76]	; 0x4c
}
 8006bbc:	4770      	bx	lr
 8006bbe:	46c0      	nop			; (mov r8, r8)
 8006bc0:	40005c00 	.word	0x40005c00
	...

08006bd0 <usb_lld_init_endpoint>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_init_endpoint(USBDriver *usbp, usbep_t ep) {
 8006bd0:	b5f0      	push	{r4, r5, r6, r7, lr}
  const USBEndpointConfig *epcp = usbp->epc[ep];

  /* Setting the endpoint type. Note that isochronous endpoints cannot be
     bidirectional because it uses double buffering and both transmit and
     receive descriptor fields are used for either direction.*/
  switch (epcp->ep_mode & USB_EP_MODE_TYPE) {
 8006bd2:	2203      	movs	r2, #3
void usb_lld_init_endpoint(USBDriver *usbp, usbep_t ep) {
 8006bd4:	46ce      	mov	lr, r9
 8006bd6:	4647      	mov	r7, r8
  const USBEndpointConfig *epcp = usbp->epc[ep];
 8006bd8:	1c8b      	adds	r3, r1, #2
 8006bda:	009b      	lsls	r3, r3, #2
 8006bdc:	18c3      	adds	r3, r0, r3
 8006bde:	685d      	ldr	r5, [r3, #4]
void usb_lld_init_endpoint(USBDriver *usbp, usbep_t ep) {
 8006be0:	b580      	push	{r7, lr}
  switch (epcp->ep_mode & USB_EP_MODE_TYPE) {
 8006be2:	682b      	ldr	r3, [r5, #0]
 8006be4:	401a      	ands	r2, r3
 8006be6:	d061      	beq.n	8006cac <usb_lld_init_endpoint+0xdc>
    break;
#else
    osalDbgAssert(false, "isochronous support disabled");
#endif
  case USB_EP_MODE_TYPE_BULK:
    epr = EPR_EP_TYPE_BULK;
 8006be8:	2300      	movs	r3, #0
  switch (epcp->ep_mode & USB_EP_MODE_TYPE) {
 8006bea:	2a02      	cmp	r2, #2
 8006bec:	d90a      	bls.n	8006c04 <usb_lld_init_endpoint+0x34>
    break;
  case USB_EP_MODE_TYPE_INTR:
    epr = EPR_EP_TYPE_INTERRUPT;
    break;
  default:
    epr = EPR_EP_TYPE_CONTROL;
 8006bee:	3a03      	subs	r2, #3
 8006bf0:	4253      	negs	r3, r2
 8006bf2:	4153      	adcs	r3, r2
 8006bf4:	425a      	negs	r2, r3
 8006bf6:	2380      	movs	r3, #128	; 0x80
 8006bf8:	00db      	lsls	r3, r3, #3
 8006bfa:	4013      	ands	r3, r2
 8006bfc:	2280      	movs	r2, #128	; 0x80
 8006bfe:	0092      	lsls	r2, r2, #2
 8006c00:	4694      	mov	ip, r2
 8006c02:	4463      	add	r3, ip
  }

  dp = USB_GET_DESCRIPTOR(ep);
 8006c04:	4c2b      	ldr	r4, [pc, #172]	; (8006cb4 <usb_lld_init_endpoint+0xe4>)
 8006c06:	4a2c      	ldr	r2, [pc, #176]	; (8006cb8 <usb_lld_init_endpoint+0xe8>)
 8006c08:	46a4      	mov	ip, r4
 8006c0a:	6d12      	ldr	r2, [r2, #80]	; 0x50
 8006c0c:	00ce      	lsls	r6, r1, #3
 8006c0e:	4462      	add	r2, ip
 8006c10:	18b4      	adds	r4, r6, r2

  /* IN endpoint handling.*/
  if (epcp->in_state != NULL) {
 8006c12:	696a      	ldr	r2, [r5, #20]
 8006c14:	2a00      	cmp	r2, #0
 8006c16:	d011      	beq.n	8006c3c <usb_lld_init_endpoint+0x6c>
    dp->TXCOUNT0 = 0;
 8006c18:	2200      	movs	r2, #0
 8006c1a:	8062      	strh	r2, [r4, #2]
  next = usbp->pmnext;
 8006c1c:	3280      	adds	r2, #128	; 0x80
 8006c1e:	5886      	ldr	r6, [r0, r2]
 8006c20:	4691      	mov	r9, r2
    dp->TXADDR0  = usb_pm_alloc(usbp, epcp->in_maxsize);
 8006c22:	8a2a      	ldrh	r2, [r5, #16]
  usbp->pmnext += (size + 1) & ~1;
 8006c24:	3201      	adds	r2, #1
 8006c26:	4690      	mov	r8, r2
 8006c28:	2201      	movs	r2, #1
 8006c2a:	4647      	mov	r7, r8
 8006c2c:	4397      	bics	r7, r2
 8006c2e:	19ba      	adds	r2, r7, r6
 8006c30:	464f      	mov	r7, r9
 8006c32:	51c2      	str	r2, [r0, r7]
    }
    else {
      epr |= EPR_STAT_TX_NAK;
    }
#else
    epr |= EPR_STAT_TX_NAK;
 8006c34:	2220      	movs	r2, #32
    dp->TXADDR0  = usb_pm_alloc(usbp, epcp->in_maxsize);
 8006c36:	b2b6      	uxth	r6, r6
 8006c38:	8026      	strh	r6, [r4, #0]
    epr |= EPR_STAT_TX_NAK;
 8006c3a:	4313      	orrs	r3, r2
#endif
  }

  /* OUT endpoint handling.*/
  if (epcp->out_state != NULL) {
 8006c3c:	69aa      	ldr	r2, [r5, #24]
 8006c3e:	2a00      	cmp	r2, #0
 8006c40:	d016      	beq.n	8006c70 <usb_lld_init_endpoint+0xa0>
    uint16_t nblocks;

    /* Endpoint size and address initialization.*/
    if (epcp->out_maxsize > 62)
 8006c42:	8a6d      	ldrh	r5, [r5, #18]
 8006c44:	1e6a      	subs	r2, r5, #1
 8006c46:	2d3e      	cmp	r5, #62	; 0x3e
 8006c48:	d827      	bhi.n	8006c9a <usb_lld_init_endpoint+0xca>
      nblocks = (((((epcp->out_maxsize - 1) | 0x1f) + 1) / 32) << 10) |
                0x8000;
    else
      nblocks = ((((epcp->out_maxsize - 1) | 1) + 1) / 2) << 10;
 8006c4a:	2601      	movs	r6, #1
 8006c4c:	4332      	orrs	r2, r6
 8006c4e:	3201      	adds	r2, #1
 8006c50:	1052      	asrs	r2, r2, #1
 8006c52:	0292      	lsls	r2, r2, #10
 8006c54:	b292      	uxth	r2, r2
  next = usbp->pmnext;
 8006c56:	2680      	movs	r6, #128	; 0x80
  usbp->pmnext += (size + 1) & ~1;
 8006c58:	2701      	movs	r7, #1
    dp->RXCOUNT0 = nblocks;
 8006c5a:	80e2      	strh	r2, [r4, #6]
  usbp->pmnext += (size + 1) & ~1;
 8006c5c:	3501      	adds	r5, #1
  next = usbp->pmnext;
 8006c5e:	5982      	ldr	r2, [r0, r6]
  usbp->pmnext += (size + 1) & ~1;
 8006c60:	43bd      	bics	r5, r7
 8006c62:	18ad      	adds	r5, r5, r2
    dp->RXADDR0  = usb_pm_alloc(usbp, epcp->out_maxsize);
 8006c64:	b292      	uxth	r2, r2
  usbp->pmnext += (size + 1) & ~1;
 8006c66:	5185      	str	r5, [r0, r6]
    dp->RXADDR0  = usb_pm_alloc(usbp, epcp->out_maxsize);
 8006c68:	80a2      	strh	r2, [r4, #4]
    }
    else {
      epr |= EPR_STAT_RX_NAK;
    }
#else
    epr |= EPR_STAT_RX_NAK;
 8006c6a:	2280      	movs	r2, #128	; 0x80
 8006c6c:	0192      	lsls	r2, r2, #6
 8006c6e:	4313      	orrs	r3, r2
#endif
  }

  /* EPxR register setup.*/
  EPR_SET(ep, epr | ep);
 8006c70:	001a      	movs	r2, r3
 8006c72:	4c11      	ldr	r4, [pc, #68]	; (8006cb8 <usb_lld_init_endpoint+0xe8>)
 8006c74:	4811      	ldr	r0, [pc, #68]	; (8006cbc <usb_lld_init_endpoint+0xec>)
 8006c76:	46a4      	mov	ip, r4
 8006c78:	430a      	orrs	r2, r1
 8006c7a:	4002      	ands	r2, r0
 8006c7c:	4810      	ldr	r0, [pc, #64]	; (8006cc0 <usb_lld_init_endpoint+0xf0>)
 8006c7e:	0089      	lsls	r1, r1, #2
 8006c80:	4461      	add	r1, ip
 8006c82:	4302      	orrs	r2, r0
 8006c84:	600a      	str	r2, [r1, #0]
  EPR_TOGGLE(ep, epr);
 8006c86:	4c0f      	ldr	r4, [pc, #60]	; (8006cc4 <usb_lld_init_endpoint+0xf4>)
 8006c88:	680a      	ldr	r2, [r1, #0]
 8006c8a:	4023      	ands	r3, r4
 8006c8c:	4053      	eors	r3, r2
 8006c8e:	4303      	orrs	r3, r0
 8006c90:	600b      	str	r3, [r1, #0]
}
 8006c92:	bc0c      	pop	{r2, r3}
 8006c94:	4690      	mov	r8, r2
 8006c96:	4699      	mov	r9, r3
 8006c98:	bdf0      	pop	{r4, r5, r6, r7, pc}
      nblocks = (((((epcp->out_maxsize - 1) | 0x1f) + 1) / 32) << 10) |
 8006c9a:	261f      	movs	r6, #31
 8006c9c:	4332      	orrs	r2, r6
 8006c9e:	3201      	adds	r2, #1
 8006ca0:	1152      	asrs	r2, r2, #5
 8006ca2:	4e09      	ldr	r6, [pc, #36]	; (8006cc8 <usb_lld_init_endpoint+0xf8>)
 8006ca4:	0292      	lsls	r2, r2, #10
 8006ca6:	4332      	orrs	r2, r6
 8006ca8:	b292      	uxth	r2, r2
 8006caa:	e7d4      	b.n	8006c56 <usb_lld_init_endpoint+0x86>
    epr = EPR_EP_TYPE_CONTROL;
 8006cac:	2380      	movs	r3, #128	; 0x80
 8006cae:	009b      	lsls	r3, r3, #2
 8006cb0:	e7a8      	b.n	8006c04 <usb_lld_init_endpoint+0x34>
 8006cb2:	46c0      	nop			; (mov r8, r8)
 8006cb4:	40006000 	.word	0x40006000
 8006cb8:	40005c00 	.word	0x40005c00
 8006cbc:	ffff070f 	.word	0xffff070f
 8006cc0:	00008080 	.word	0x00008080
 8006cc4:	00007870 	.word	0x00007870
 8006cc8:	ffff8000 	.word	0xffff8000
 8006ccc:	00000000 	.word	0x00000000

08006cd0 <usb_lld_reset>:
  STM32_USB->BTABLE = BTABLE_ADDR;
 8006cd0:	2300      	movs	r3, #0
 8006cd2:	4a0c      	ldr	r2, [pc, #48]	; (8006d04 <usb_lld_reset+0x34>)
void usb_lld_reset(USBDriver *usbp) {
 8006cd4:	b510      	push	{r4, lr}
  STM32_USB->BTABLE = BTABLE_ADDR;
 8006cd6:	6513      	str	r3, [r2, #80]	; 0x50
  STM32_USB->ISTR   = 0;
 8006cd8:	6453      	str	r3, [r2, #68]	; 0x44
  if (usbp->config->sof_cb != NULL)
 8006cda:	6843      	ldr	r3, [r0, #4]
  STM32_USB->DADDR  = DADDR_EF;
 8006cdc:	2180      	movs	r1, #128	; 0x80
  if (usbp->config->sof_cb != NULL)
 8006cde:	68db      	ldr	r3, [r3, #12]
  STM32_USB->DADDR  = DADDR_EF;
 8006ce0:	64d1      	str	r1, [r2, #76]	; 0x4c
    cntr |= CNTR_SOFM;
 8006ce2:	425c      	negs	r4, r3
 8006ce4:	4163      	adcs	r3, r4
 8006ce6:	249e      	movs	r4, #158	; 0x9e
 8006ce8:	0224      	lsls	r4, r4, #8
 8006cea:	46a4      	mov	ip, r4
 8006cec:	425b      	negs	r3, r3
 8006cee:	025b      	lsls	r3, r3, #9
 8006cf0:	4463      	add	r3, ip
  STM32_USB->CNTR = cntr;
 8006cf2:	6413      	str	r3, [r2, #64]	; 0x40
  usbp->pmnext = 64;
 8006cf4:	2340      	movs	r3, #64	; 0x40
 8006cf6:	5043      	str	r3, [r0, r1]
  usbp->epc[0] = &ep0config;
 8006cf8:	4b03      	ldr	r3, [pc, #12]	; (8006d08 <usb_lld_reset+0x38>)
  usb_lld_init_endpoint(usbp, 0);
 8006cfa:	2100      	movs	r1, #0
  usbp->epc[0] = &ep0config;
 8006cfc:	60c3      	str	r3, [r0, #12]
  usb_lld_init_endpoint(usbp, 0);
 8006cfe:	f7ff ff67 	bl	8006bd0 <usb_lld_init_endpoint>
}
 8006d02:	bd10      	pop	{r4, pc}
 8006d04:	40005c00 	.word	0x40005c00
 8006d08:	080136fc 	.word	0x080136fc
 8006d0c:	00000000 	.word	0x00000000

08006d10 <usb_lld_get_status_out>:
 * @notapi
 */
usbepstatus_t usb_lld_get_status_out(USBDriver *usbp, usbep_t ep) {

  (void)usbp;
  switch (STM32_USB->EPR[ep] & EPR_STAT_RX_MASK) {
 8006d10:	4b07      	ldr	r3, [pc, #28]	; (8006d30 <usb_lld_get_status_out+0x20>)
 8006d12:	0089      	lsls	r1, r1, #2
 8006d14:	58c8      	ldr	r0, [r1, r3]
 8006d16:	23c0      	movs	r3, #192	; 0xc0
 8006d18:	019b      	lsls	r3, r3, #6
 8006d1a:	4018      	ands	r0, r3
 8006d1c:	d006      	beq.n	8006d2c <usb_lld_get_status_out+0x1c>
  case EPR_STAT_RX_DIS:
    return EP_STATUS_DISABLED;
  case EPR_STAT_RX_STALL:
    return EP_STATUS_STALLED;
  default:
    return EP_STATUS_ACTIVE;
 8006d1e:	4b05      	ldr	r3, [pc, #20]	; (8006d34 <usb_lld_get_status_out+0x24>)
 8006d20:	469c      	mov	ip, r3
 8006d22:	4460      	add	r0, ip
 8006d24:	1e43      	subs	r3, r0, #1
 8006d26:	4198      	sbcs	r0, r3
 8006d28:	3001      	adds	r0, #1
  }
}
 8006d2a:	4770      	bx	lr
    return EP_STATUS_DISABLED;
 8006d2c:	2000      	movs	r0, #0
 8006d2e:	e7fc      	b.n	8006d2a <usb_lld_get_status_out+0x1a>
 8006d30:	40005c00 	.word	0x40005c00
 8006d34:	fffff000 	.word	0xfffff000
	...

08006d40 <usb_lld_get_status_in>:
 * @notapi
 */
usbepstatus_t usb_lld_get_status_in(USBDriver *usbp, usbep_t ep) {

  (void)usbp;
  switch (STM32_USB->EPR[ep] & EPR_STAT_TX_MASK) {
 8006d40:	2030      	movs	r0, #48	; 0x30
 8006d42:	4b06      	ldr	r3, [pc, #24]	; (8006d5c <usb_lld_get_status_in+0x1c>)
 8006d44:	0089      	lsls	r1, r1, #2
 8006d46:	58cb      	ldr	r3, [r1, r3]
 8006d48:	4018      	ands	r0, r3
 8006d4a:	d004      	beq.n	8006d56 <usb_lld_get_status_in+0x16>
  case EPR_STAT_TX_DIS:
    return EP_STATUS_DISABLED;
  case EPR_STAT_TX_STALL:
    return EP_STATUS_STALLED;
  default:
    return EP_STATUS_ACTIVE;
 8006d4c:	3810      	subs	r0, #16
 8006d4e:	1e43      	subs	r3, r0, #1
 8006d50:	4198      	sbcs	r0, r3
 8006d52:	3001      	adds	r0, #1
  }
}
 8006d54:	4770      	bx	lr
    return EP_STATUS_DISABLED;
 8006d56:	2000      	movs	r0, #0
 8006d58:	e7fc      	b.n	8006d54 <usb_lld_get_status_in+0x14>
 8006d5a:	46c0      	nop			; (mov r8, r8)
 8006d5c:	40005c00 	.word	0x40005c00

08006d60 <usb_lld_read_setup>:
  stm32_usb_pma_t *pmap;
  stm32_usb_descriptor_t *udp;
  uint32_t n;

  (void)usbp;
  udp = USB_GET_DESCRIPTOR(ep);
 8006d60:	480a      	ldr	r0, [pc, #40]	; (8006d8c <usb_lld_read_setup+0x2c>)
 8006d62:	4b0b      	ldr	r3, [pc, #44]	; (8006d90 <usb_lld_read_setup+0x30>)
 8006d64:	4684      	mov	ip, r0
void usb_lld_read_setup(USBDriver *usbp, usbep_t ep, uint8_t *buf) {
 8006d66:	b510      	push	{r4, lr}
  udp = USB_GET_DESCRIPTOR(ep);
 8006d68:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8006d6a:	00c9      	lsls	r1, r1, #3
 8006d6c:	4463      	add	r3, ip
 8006d6e:	18c9      	adds	r1, r1, r3
  pmap = USB_ADDR2PTR(udp->RXADDR0);
 8006d70:	8888      	ldrh	r0, [r1, #4]
 8006d72:	0014      	movs	r4, r2
  for (n = 0; n < 4; n++) {
    *(uint16_t *)buf = (uint16_t)*pmap++;
 8006d74:	4661      	mov	r1, ip
  pmap = USB_ADDR2PTR(udp->RXADDR0);
 8006d76:	b280      	uxth	r0, r0
  for (n = 0; n < 4; n++) {
 8006d78:	3408      	adds	r4, #8
    *(uint16_t *)buf = (uint16_t)*pmap++;
 8006d7a:	1a89      	subs	r1, r1, r2
 8006d7c:	1813      	adds	r3, r2, r0
 8006d7e:	5a5b      	ldrh	r3, [r3, r1]
 8006d80:	8013      	strh	r3, [r2, #0]
    buf += 2;
 8006d82:	3202      	adds	r2, #2
  for (n = 0; n < 4; n++) {
 8006d84:	42a2      	cmp	r2, r4
 8006d86:	d1f9      	bne.n	8006d7c <usb_lld_read_setup+0x1c>
  }
}
 8006d88:	bd10      	pop	{r4, pc}
 8006d8a:	46c0      	nop			; (mov r8, r8)
 8006d8c:	40006000 	.word	0x40006000
 8006d90:	40005c00 	.word	0x40005c00
	...

08006da0 <usb_lld_start_out>:
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_start_out(USBDriver *usbp, usbep_t ep) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 8006da0:	1c8b      	adds	r3, r1, #2
 8006da2:	009b      	lsls	r3, r3, #2
 8006da4:	18c0      	adds	r0, r0, r3
 8006da6:	6842      	ldr	r2, [r0, #4]
void usb_lld_start_out(USBDriver *usbp, usbep_t ep) {
 8006da8:	b570      	push	{r4, r5, r6, lr}
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 8006daa:	6995      	ldr	r5, [r2, #24]
void usb_lld_start_out(USBDriver *usbp, usbep_t ep) {
 8006dac:	000c      	movs	r4, r1

  /* Transfer initialization.*/
  if (osp->rxsize == 0)         /* Special case for zero sized packets.*/
 8006dae:	6828      	ldr	r0, [r5, #0]
    osp->rxpkts = 1;
 8006db0:	2301      	movs	r3, #1
  if (osp->rxsize == 0)         /* Special case for zero sized packets.*/
 8006db2:	2800      	cmp	r0, #0
 8006db4:	d005      	beq.n	8006dc2 <usb_lld_start_out+0x22>
  else
    osp->rxpkts = (uint16_t)((osp->rxsize + usbp->epc[ep]->out_maxsize - 1) /
 8006db6:	8a51      	ldrh	r1, [r2, #18]
 8006db8:	1840      	adds	r0, r0, r1
 8006dba:	3801      	subs	r0, #1
 8006dbc:	f7f9 fa08 	bl	80001d0 <__udivsi3>
 8006dc0:	b283      	uxth	r3, r0
 8006dc2:	81ab      	strh	r3, [r5, #12]
                             usbp->epc[ep]->out_maxsize);

  EPR_SET_STAT_RX(ep, EPR_STAT_RX_VALID);
 8006dc4:	4b06      	ldr	r3, [pc, #24]	; (8006de0 <usb_lld_start_out+0x40>)
 8006dc6:	00a4      	lsls	r4, r4, #2
 8006dc8:	469c      	mov	ip, r3
 8006dca:	4464      	add	r4, ip
 8006dcc:	6822      	ldr	r2, [r4, #0]
 8006dce:	4b05      	ldr	r3, [pc, #20]	; (8006de4 <usb_lld_start_out+0x44>)
 8006dd0:	401a      	ands	r2, r3
 8006dd2:	23c0      	movs	r3, #192	; 0xc0
 8006dd4:	019b      	lsls	r3, r3, #6
 8006dd6:	405a      	eors	r2, r3
 8006dd8:	4b03      	ldr	r3, [pc, #12]	; (8006de8 <usb_lld_start_out+0x48>)
 8006dda:	4313      	orrs	r3, r2
 8006ddc:	6023      	str	r3, [r4, #0]
}
 8006dde:	bd70      	pop	{r4, r5, r6, pc}
 8006de0:	40005c00 	.word	0x40005c00
 8006de4:	ffffb78f 	.word	0xffffb78f
 8006de8:	00008080 	.word	0x00008080
 8006dec:	00000000 	.word	0x00000000

08006df0 <usb_lld_start_in>:
 *
 * @notapi
 */
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {
  size_t n;
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 8006df0:	1c8b      	adds	r3, r1, #2
 8006df2:	009b      	lsls	r3, r3, #2
 8006df4:	18c0      	adds	r0, r0, r3
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {
 8006df6:	b570      	push	{r4, r5, r6, lr}
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 8006df8:	6842      	ldr	r2, [r0, #4]
 8006dfa:	6953      	ldr	r3, [r2, #20]

  /* Transfer initialization.*/
  n = isp->txsize;
  if (n > (size_t)usbp->epc[ep]->in_maxsize)
 8006dfc:	8a14      	ldrh	r4, [r2, #16]
  n = isp->txsize;
 8006dfe:	6818      	ldr	r0, [r3, #0]
  if (n > (size_t)usbp->epc[ep]->in_maxsize)
 8006e00:	4284      	cmp	r4, r0
 8006e02:	d900      	bls.n	8006e06 <usb_lld_start_in+0x16>
 8006e04:	0004      	movs	r4, r0
  stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
 8006e06:	4d17      	ldr	r5, [pc, #92]	; (8006e64 <usb_lld_start_in+0x74>)
 8006e08:	4a17      	ldr	r2, [pc, #92]	; (8006e68 <usb_lld_start_in+0x78>)
 8006e0a:	46ac      	mov	ip, r5
 8006e0c:	6d12      	ldr	r2, [r2, #80]	; 0x50
 8006e0e:	00c8      	lsls	r0, r1, #3
 8006e10:	4462      	add	r2, ip
 8006e12:	1882      	adds	r2, r0, r2
  stm32_usb_pma_t *pmap = USB_ADDR2PTR(udp->TXADDR0);
 8006e14:	8816      	ldrh	r6, [r2, #0]
  udp->TXCOUNT0 = (stm32_usb_pma_t)n;
 8006e16:	b2a0      	uxth	r0, r4
    n = (size_t)usbp->epc[ep]->in_maxsize;

  isp->txlast = n;
 8006e18:	60dc      	str	r4, [r3, #12]
  stm32_usb_pma_t *pmap = USB_ADDR2PTR(udp->TXADDR0);
 8006e1a:	b2b6      	uxth	r6, r6
  usb_packet_write_from_buffer(ep, isp->txbuf, n);
 8006e1c:	689b      	ldr	r3, [r3, #8]
  udp->TXCOUNT0 = (stm32_usb_pma_t)n;
 8006e1e:	8050      	strh	r0, [r2, #2]
  while (i > 0) {
 8006e20:	2c00      	cmp	r4, #0
 8006e22:	d012      	beq.n	8006e4a <usb_lld_start_in+0x5a>
 8006e24:	3c01      	subs	r4, #1
 8006e26:	0864      	lsrs	r4, r4, #1
 8006e28:	3401      	adds	r4, #1
 8006e2a:	0064      	lsls	r4, r4, #1
 8006e2c:	191c      	adds	r4, r3, r4
 8006e2e:	1af6      	subs	r6, r6, r3
 8006e30:	7858      	ldrb	r0, [r3, #1]
 8006e32:	781d      	ldrb	r5, [r3, #0]
 8006e34:	0200      	lsls	r0, r0, #8
 8006e36:	4328      	orrs	r0, r5
    *pmap++ = (stm32_usb_pma_t)w;
 8006e38:	4d0a      	ldr	r5, [pc, #40]	; (8006e64 <usb_lld_start_in+0x74>)
 8006e3a:	001a      	movs	r2, r3
 8006e3c:	46ac      	mov	ip, r5
 8006e3e:	1992      	adds	r2, r2, r6
 8006e40:	4462      	add	r2, ip
 8006e42:	3302      	adds	r3, #2
 8006e44:	8010      	strh	r0, [r2, #0]
  while (i > 0) {
 8006e46:	42a3      	cmp	r3, r4
 8006e48:	d1f2      	bne.n	8006e30 <usb_lld_start_in+0x40>

  EPR_SET_STAT_TX(ep, EPR_STAT_TX_VALID);
 8006e4a:	4b07      	ldr	r3, [pc, #28]	; (8006e68 <usb_lld_start_in+0x78>)
 8006e4c:	0089      	lsls	r1, r1, #2
 8006e4e:	469c      	mov	ip, r3
 8006e50:	4461      	add	r1, ip
 8006e52:	680b      	ldr	r3, [r1, #0]
 8006e54:	4a05      	ldr	r2, [pc, #20]	; (8006e6c <usb_lld_start_in+0x7c>)
 8006e56:	4013      	ands	r3, r2
 8006e58:	2230      	movs	r2, #48	; 0x30
 8006e5a:	4053      	eors	r3, r2
 8006e5c:	4a04      	ldr	r2, [pc, #16]	; (8006e70 <usb_lld_start_in+0x80>)
 8006e5e:	4313      	orrs	r3, r2
 8006e60:	600b      	str	r3, [r1, #0]
}
 8006e62:	bd70      	pop	{r4, r5, r6, pc}
 8006e64:	40006000 	.word	0x40006000
 8006e68:	40005c00 	.word	0x40005c00
 8006e6c:	ffff87bf 	.word	0xffff87bf
 8006e70:	00008080 	.word	0x00008080
	...

08006e80 <usb_lld_stall_out>:
 */
void usb_lld_stall_out(USBDriver *usbp, usbep_t ep) {

  (void)usbp;

  EPR_SET_STAT_RX(ep, EPR_STAT_RX_STALL);
 8006e80:	4b06      	ldr	r3, [pc, #24]	; (8006e9c <usb_lld_stall_out+0x1c>)
 8006e82:	0089      	lsls	r1, r1, #2
 8006e84:	469c      	mov	ip, r3
 8006e86:	4461      	add	r1, ip
 8006e88:	680a      	ldr	r2, [r1, #0]
 8006e8a:	4b05      	ldr	r3, [pc, #20]	; (8006ea0 <usb_lld_stall_out+0x20>)
 8006e8c:	401a      	ands	r2, r3
 8006e8e:	2380      	movs	r3, #128	; 0x80
 8006e90:	015b      	lsls	r3, r3, #5
 8006e92:	405a      	eors	r2, r3
 8006e94:	4b03      	ldr	r3, [pc, #12]	; (8006ea4 <usb_lld_stall_out+0x24>)
 8006e96:	4313      	orrs	r3, r2
 8006e98:	600b      	str	r3, [r1, #0]
}
 8006e9a:	4770      	bx	lr
 8006e9c:	40005c00 	.word	0x40005c00
 8006ea0:	ffffb78f 	.word	0xffffb78f
 8006ea4:	00008080 	.word	0x00008080
	...

08006eb0 <usb_lld_stall_in>:
 */
void usb_lld_stall_in(USBDriver *usbp, usbep_t ep) {

  (void)usbp;

  EPR_SET_STAT_TX(ep, EPR_STAT_TX_STALL);
 8006eb0:	4b06      	ldr	r3, [pc, #24]	; (8006ecc <usb_lld_stall_in+0x1c>)
 8006eb2:	0089      	lsls	r1, r1, #2
 8006eb4:	469c      	mov	ip, r3
 8006eb6:	4461      	add	r1, ip
 8006eb8:	680b      	ldr	r3, [r1, #0]
 8006eba:	4a05      	ldr	r2, [pc, #20]	; (8006ed0 <usb_lld_stall_in+0x20>)
 8006ebc:	4013      	ands	r3, r2
 8006ebe:	2210      	movs	r2, #16
 8006ec0:	4053      	eors	r3, r2
 8006ec2:	4a04      	ldr	r2, [pc, #16]	; (8006ed4 <usb_lld_stall_in+0x24>)
 8006ec4:	4313      	orrs	r3, r2
 8006ec6:	600b      	str	r3, [r1, #0]
}
 8006ec8:	4770      	bx	lr
 8006eca:	46c0      	nop			; (mov r8, r8)
 8006ecc:	40005c00 	.word	0x40005c00
 8006ed0:	ffff87bf 	.word	0xffff87bf
 8006ed4:	00008080 	.word	0x00008080
	...

08006ee0 <usb_lld_clear_out>:

  (void)usbp;

  /* Makes sure to not put to NAK an endpoint that is already
     transferring.*/
  if ((STM32_USB->EPR[ep] & EPR_STAT_RX_MASK) != EPR_STAT_RX_VALID)
 8006ee0:	4b08      	ldr	r3, [pc, #32]	; (8006f04 <usb_lld_clear_out+0x24>)
 8006ee2:	22c0      	movs	r2, #192	; 0xc0
 8006ee4:	469c      	mov	ip, r3
 8006ee6:	0089      	lsls	r1, r1, #2
 8006ee8:	4461      	add	r1, ip
 8006eea:	680b      	ldr	r3, [r1, #0]
 8006eec:	0192      	lsls	r2, r2, #6
 8006eee:	4013      	ands	r3, r2
 8006ef0:	4293      	cmp	r3, r2
 8006ef2:	d005      	beq.n	8006f00 <usb_lld_clear_out+0x20>
    EPR_SET_STAT_TX(ep, EPR_STAT_RX_NAK);
 8006ef4:	680b      	ldr	r3, [r1, #0]
 8006ef6:	4a04      	ldr	r2, [pc, #16]	; (8006f08 <usb_lld_clear_out+0x28>)
 8006ef8:	401a      	ands	r2, r3
 8006efa:	4b04      	ldr	r3, [pc, #16]	; (8006f0c <usb_lld_clear_out+0x2c>)
 8006efc:	4313      	orrs	r3, r2
 8006efe:	600b      	str	r3, [r1, #0]
}
 8006f00:	4770      	bx	lr
 8006f02:	46c0      	nop			; (mov r8, r8)
 8006f04:	40005c00 	.word	0x40005c00
 8006f08:	ffff87bf 	.word	0xffff87bf
 8006f0c:	0000a080 	.word	0x0000a080

08006f10 <usb_lld_clear_in>:

  (void)usbp;

  /* Makes sure to not put to NAK an endpoint that is already
     transferring.*/
  if ((STM32_USB->EPR[ep] & EPR_STAT_TX_MASK) != EPR_STAT_TX_VALID)
 8006f10:	4b08      	ldr	r3, [pc, #32]	; (8006f34 <usb_lld_clear_in+0x24>)
 8006f12:	0089      	lsls	r1, r1, #2
 8006f14:	469c      	mov	ip, r3
 8006f16:	2330      	movs	r3, #48	; 0x30
 8006f18:	4461      	add	r1, ip
 8006f1a:	680a      	ldr	r2, [r1, #0]
 8006f1c:	4013      	ands	r3, r2
 8006f1e:	2b30      	cmp	r3, #48	; 0x30
 8006f20:	d007      	beq.n	8006f32 <usb_lld_clear_in+0x22>
    EPR_SET_STAT_TX(ep, EPR_STAT_TX_NAK);
 8006f22:	680b      	ldr	r3, [r1, #0]
 8006f24:	4a04      	ldr	r2, [pc, #16]	; (8006f38 <usb_lld_clear_in+0x28>)
 8006f26:	4013      	ands	r3, r2
 8006f28:	2220      	movs	r2, #32
 8006f2a:	4053      	eors	r3, r2
 8006f2c:	4a03      	ldr	r2, [pc, #12]	; (8006f3c <usb_lld_clear_in+0x2c>)
 8006f2e:	4313      	orrs	r3, r2
 8006f30:	600b      	str	r3, [r1, #0]
}
 8006f32:	4770      	bx	lr
 8006f34:	40005c00 	.word	0x40005c00
 8006f38:	ffff87bf 	.word	0xffff87bf
 8006f3c:	00008080 	.word	0x00008080

08006f40 <__early_init>:
/*
 * Early initialization code.
 * This initialization must be performed just after stack setup and before
 * any other initialization.
 */
void __early_init(void) {
 8006f40:	b580      	push	{r7, lr}
  if ( *((unsigned long *)BOOT_FROM_SYTEM_MEMORY_MAGIC_ADDRESS) == BOOT_FROM_SYTEM_MEMORY_MAGIC ) {
 8006f42:	4b0a      	ldr	r3, [pc, #40]	; (8006f6c <__early_init+0x2c>)
 8006f44:	4a0a      	ldr	r2, [pc, #40]	; (8006f70 <__early_init+0x30>)
 8006f46:	6819      	ldr	r1, [r3, #0]
void __early_init(void) {
 8006f48:	af00      	add	r7, sp, #0
  if ( *((unsigned long *)BOOT_FROM_SYTEM_MEMORY_MAGIC_ADDRESS) == BOOT_FROM_SYTEM_MEMORY_MAGIC ) {
 8006f4a:	4291      	cmp	r1, r2
 8006f4c:	d109      	bne.n	8006f62 <__early_init+0x22>
 8006f4e:	b662      	cpsie	i
    // require irq
    __enable_irq();
    // reset magic bytes
    *((unsigned long *)BOOT_FROM_SYTEM_MEMORY_MAGIC_ADDRESS) = 0;
 8006f50:	2200      	movs	r2, #0
 8006f52:	601a      	str	r2, [r3, #0]

    \param [in]    topOfMainStack  Main Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
{
  __ASM volatile ("MSR msp, %0\n" : : "r" (topOfMainStack) : "sp");
 8006f54:	4b07      	ldr	r3, [pc, #28]	; (8006f74 <__early_init+0x34>)
 8006f56:	f383 8808 	msr	MSP, r3
    // RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
    // SYSCFG->CFGR1 = 0x01;
    // set msp for system memory
    __set_MSP(SYSTEM_BOOT_MSP); 
    // jump to system memory
    ( (void (*)(void)) (*((uint32_t *)(STM32F072xB_SYSTEM_MEMORY+4))) )();
 8006f5a:	4b07      	ldr	r3, [pc, #28]	; (8006f78 <__early_init+0x38>)
 8006f5c:	681b      	ldr	r3, [r3, #0]
 8006f5e:	4798      	blx	r3
    while (1);
 8006f60:	e7fe      	b.n	8006f60 <__early_init+0x20>
  }

  //si5351_setup();
  stm32_clock_init();
 8006f62:	f7fe fcfd 	bl	8005960 <stm32_clock_init>
}
 8006f66:	46bd      	mov	sp, r7
 8006f68:	bd80      	pop	{r7, pc}
 8006f6a:	46c0      	nop			; (mov r8, r8)
 8006f6c:	20003ff0 	.word	0x20003ff0
 8006f70:	deadbeef 	.word	0xdeadbeef
 8006f74:	20002250 	.word	0x20002250
 8006f78:	1fffc804 	.word	0x1fffc804
 8006f7c:	00000000 	.word	0x00000000

08006f80 <boardInit>:

/*
 * Board-specific initialization code.
 */
void boardInit(void) {
}
 8006f80:	4770      	bx	lr
 8006f82:	46c0      	nop			; (mov r8, r8)
	...

08006f90 <chvprintf>:
 * @return              The number of bytes that would have been
 *                      written to @p chp if no stream error occurs
 *
 * @api
 */
int chvprintf(BaseSequentialStream *chp, const char *fmt, va_list ap) {
 8006f90:	b5f0      	push	{r4, r5, r6, r7, lr}
 8006f92:	464e      	mov	r6, r9
 8006f94:	4645      	mov	r5, r8
 8006f96:	46de      	mov	lr, fp
 8006f98:	4657      	mov	r7, sl
  char *p, *s, c, filler;
  int i, precision, width;
  int n = 0;
 8006f9a:	2300      	movs	r3, #0
int chvprintf(BaseSequentialStream *chp, const char *fmt, va_list ap) {
 8006f9c:	b5e0      	push	{r5, r6, r7, lr}
 8006f9e:	0005      	movs	r5, r0
 8006fa0:	000e      	movs	r6, r1
 8006fa2:	b095      	sub	sp, #84	; 0x54
 8006fa4:	9202      	str	r2, [sp, #8]
  int n = 0;
 8006fa6:	9301      	str	r3, [sp, #4]
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (true) {
    c = *fmt++;
 8006fa8:	7831      	ldrb	r1, [r6, #0]
 8006faa:	1c77      	adds	r7, r6, #1
    if (c == 0)
 8006fac:	2900      	cmp	r1, #0
 8006fae:	d00d      	beq.n	8006fcc <chvprintf+0x3c>
      return n;
    if (c != '%') {
 8006fb0:	2925      	cmp	r1, #37	; 0x25
 8006fb2:	d013      	beq.n	8006fdc <chvprintf+0x4c>
    c = *fmt++;
 8006fb4:	003e      	movs	r6, r7
      streamPut(chp, (uint8_t)c);
 8006fb6:	682b      	ldr	r3, [r5, #0]
 8006fb8:	0028      	movs	r0, r5
 8006fba:	689b      	ldr	r3, [r3, #8]
 8006fbc:	4798      	blx	r3
      n++;
 8006fbe:	9b01      	ldr	r3, [sp, #4]
    c = *fmt++;
 8006fc0:	7831      	ldrb	r1, [r6, #0]
      n++;
 8006fc2:	3301      	adds	r3, #1
 8006fc4:	9301      	str	r3, [sp, #4]
    c = *fmt++;
 8006fc6:	1c77      	adds	r7, r6, #1
    if (c == 0)
 8006fc8:	2900      	cmp	r1, #0
 8006fca:	d1f1      	bne.n	8006fb0 <chvprintf+0x20>
      streamPut(chp, (uint8_t)filler);
      n++;
      width--;
    }
  }
}
 8006fcc:	9801      	ldr	r0, [sp, #4]
 8006fce:	b015      	add	sp, #84	; 0x54
 8006fd0:	bc3c      	pop	{r2, r3, r4, r5}
 8006fd2:	4690      	mov	r8, r2
 8006fd4:	4699      	mov	r9, r3
 8006fd6:	46a2      	mov	sl, r4
 8006fd8:	46ab      	mov	fp, r5
 8006fda:	bdf0      	pop	{r4, r5, r6, r7, pc}
    left_align = FALSE;
 8006fdc:	2300      	movs	r3, #0
    if (*fmt == '-') {
 8006fde:	7872      	ldrb	r2, [r6, #1]
    left_align = FALSE;
 8006fe0:	9304      	str	r3, [sp, #16]
    if (*fmt == '-') {
 8006fe2:	2a2d      	cmp	r2, #45	; 0x2d
 8006fe4:	d103      	bne.n	8006fee <chvprintf+0x5e>
      left_align = TRUE;
 8006fe6:	3301      	adds	r3, #1
 8006fe8:	78b2      	ldrb	r2, [r6, #2]
      fmt++;
 8006fea:	1cb7      	adds	r7, r6, #2
      left_align = TRUE;
 8006fec:	9304      	str	r3, [sp, #16]
    filler = ' ';
 8006fee:	2320      	movs	r3, #32
 8006ff0:	9303      	str	r3, [sp, #12]
    if (*fmt == '0') {
 8006ff2:	2a30      	cmp	r2, #48	; 0x30
 8006ff4:	d103      	bne.n	8006ffe <chvprintf+0x6e>
      filler = '0';
 8006ff6:	3310      	adds	r3, #16
 8006ff8:	787a      	ldrb	r2, [r7, #1]
 8006ffa:	9303      	str	r3, [sp, #12]
      fmt++;
 8006ffc:	3701      	adds	r7, #1
    width = 0;
 8006ffe:	2400      	movs	r4, #0
 8007000:	0010      	movs	r0, r2
 8007002:	0021      	movs	r1, r4
 8007004:	9a02      	ldr	r2, [sp, #8]
 8007006:	e006      	b.n	8007016 <chvprintf+0x86>
        c = va_arg(ap, int);
 8007008:	ca08      	ldmia	r2!, {r3}
 800700a:	b2db      	uxtb	r3, r3
      width = width * 10 + c;
 800700c:	008c      	lsls	r4, r1, #2
 800700e:	1864      	adds	r4, r4, r1
 8007010:	0064      	lsls	r4, r4, #1
 8007012:	7838      	ldrb	r0, [r7, #0]
 8007014:	1919      	adds	r1, r3, r4
      if (c >= '0' && c <= '9')
 8007016:	0003      	movs	r3, r0
 8007018:	3b30      	subs	r3, #48	; 0x30
 800701a:	b2db      	uxtb	r3, r3
      c = *fmt++;
 800701c:	3701      	adds	r7, #1
      if (c >= '0' && c <= '9')
 800701e:	2b09      	cmp	r3, #9
 8007020:	d9f4      	bls.n	800700c <chvprintf+0x7c>
      else if (c == '*')
 8007022:	282a      	cmp	r0, #42	; 0x2a
 8007024:	d0f0      	beq.n	8007008 <chvprintf+0x78>
    precision = 0;
 8007026:	2300      	movs	r3, #0
 8007028:	9202      	str	r2, [sp, #8]
 800702a:	000c      	movs	r4, r1
 800702c:	0002      	movs	r2, r0
 800702e:	4699      	mov	r9, r3
    if (c == '.') {
 8007030:	282e      	cmp	r0, #46	; 0x2e
 8007032:	d100      	bne.n	8007036 <chvprintf+0xa6>
 8007034:	e159      	b.n	80072ea <chvprintf+0x35a>
    if (c == 'l' || c == 'L') {
 8007036:	23df      	movs	r3, #223	; 0xdf
 8007038:	4013      	ands	r3, r2
 800703a:	2b4c      	cmp	r3, #76	; 0x4c
 800703c:	d00c      	beq.n	8007058 <chvprintf+0xc8>
    switch (c) {
 800703e:	0013      	movs	r3, r2
      is_long = (c >= 'A') && (c <= 'Z');
 8007040:	0011      	movs	r1, r2
    switch (c) {
 8007042:	3b44      	subs	r3, #68	; 0x44
      is_long = (c >= 'A') && (c <= 'Z');
 8007044:	3941      	subs	r1, #65	; 0x41
    switch (c) {
 8007046:	b2db      	uxtb	r3, r3
      is_long = (c >= 'A') && (c <= 'Z');
 8007048:	b2c9      	uxtb	r1, r1
    switch (c) {
 800704a:	2b34      	cmp	r3, #52	; 0x34
 800704c:	d900      	bls.n	8007050 <chvprintf+0xc0>
 800704e:	e13e      	b.n	80072ce <chvprintf+0x33e>
 8007050:	48cf      	ldr	r0, [pc, #828]	; (8007390 <chvprintf+0x400>)
 8007052:	009b      	lsls	r3, r3, #2
 8007054:	58c3      	ldr	r3, [r0, r3]
 8007056:	469f      	mov	pc, r3
      if (*fmt)
 8007058:	7839      	ldrb	r1, [r7, #0]
 800705a:	2900      	cmp	r1, #0
 800705c:	d100      	bne.n	8007060 <chvprintf+0xd0>
 800705e:	e136      	b.n	80072ce <chvprintf+0x33e>
    switch (c) {
 8007060:	000b      	movs	r3, r1
 8007062:	3b44      	subs	r3, #68	; 0x44
 8007064:	b2db      	uxtb	r3, r3
 8007066:	1c7e      	adds	r6, r7, #1
 8007068:	2b34      	cmp	r3, #52	; 0x34
 800706a:	d900      	bls.n	800706e <chvprintf+0xde>
 800706c:	e12d      	b.n	80072ca <chvprintf+0x33a>
 800706e:	4ac9      	ldr	r2, [pc, #804]	; (8007394 <chvprintf+0x404>)
 8007070:	009b      	lsls	r3, r3, #2
 8007072:	58d3      	ldr	r3, [r2, r3]
 8007074:	469f      	mov	pc, r3
 8007076:	003e      	movs	r6, r7
      if ((s = va_arg(ap, char *)) == 0)
 8007078:	9f02      	ldr	r7, [sp, #8]
 800707a:	cf08      	ldmia	r7!, {r3}
 800707c:	4698      	mov	r8, r3
 800707e:	2b00      	cmp	r3, #0
 8007080:	d100      	bne.n	8007084 <chvprintf+0xf4>
 8007082:	e1f6      	b.n	8007472 <chvprintf+0x4e2>
      if (precision == 0)
 8007084:	464a      	mov	r2, r9
 8007086:	781b      	ldrb	r3, [r3, #0]
 8007088:	2a00      	cmp	r2, #0
 800708a:	d101      	bne.n	8007090 <chvprintf+0x100>
        precision = 32767;
 800708c:	4ac2      	ldr	r2, [pc, #776]	; (8007398 <chvprintf+0x408>)
 800708e:	4691      	mov	r9, r2
      for (p = s; *p && (--precision >= 0); p++)
 8007090:	2b00      	cmp	r3, #0
 8007092:	d100      	bne.n	8007096 <chvprintf+0x106>
 8007094:	e215      	b.n	80074c2 <chvprintf+0x532>
    switch (c) {
 8007096:	4641      	mov	r1, r8
 8007098:	4642      	mov	r2, r8
 800709a:	4648      	mov	r0, r9
 800709c:	e003      	b.n	80070a6 <chvprintf+0x116>
 800709e:	43cb      	mvns	r3, r1
 80070a0:	18d3      	adds	r3, r2, r3
      for (p = s; *p && (--precision >= 0); p++)
 80070a2:	42c3      	cmn	r3, r0
 80070a4:	d403      	bmi.n	80070ae <chvprintf+0x11e>
 80070a6:	3101      	adds	r1, #1
 80070a8:	780b      	ldrb	r3, [r1, #0]
 80070aa:	2b00      	cmp	r3, #0
 80070ac:	d1f7      	bne.n	800709e <chvprintf+0x10e>
 80070ae:	1a89      	subs	r1, r1, r2
 80070b0:	1e4b      	subs	r3, r1, #1
 80070b2:	469b      	mov	fp, r3
      filler = ' ';
 80070b4:	2320      	movs	r3, #32
 80070b6:	9303      	str	r3, [sp, #12]
    if ((width -= i) < 0)
 80070b8:	1a63      	subs	r3, r4, r1
 80070ba:	4690      	mov	r8, r2
      if ((s = va_arg(ap, char *)) == 0)
 80070bc:	9702      	str	r7, [sp, #8]
    if ((width -= i) < 0)
 80070be:	4699      	mov	r9, r3
 80070c0:	d400      	bmi.n	80070c4 <chvprintf+0x134>
 80070c2:	e0be      	b.n	8007242 <chvprintf+0x2b2>
      width = -width;
 80070c4:	2300      	movs	r3, #0
 80070c6:	4699      	mov	r9, r3
    while (--i >= 0) {
 80070c8:	465b      	mov	r3, fp
 80070ca:	2b00      	cmp	r3, #0
 80070cc:	db00      	blt.n	80070d0 <chvprintf+0x140>
 80070ce:	e0db      	b.n	8007288 <chvprintf+0x2f8>
 80070d0:	e76a      	b.n	8006fa8 <chvprintf+0x18>
    switch (c) {
 80070d2:	003e      	movs	r6, r7
      f = (float) va_arg(ap, double);
 80070d4:	2207      	movs	r2, #7
 80070d6:	9b02      	ldr	r3, [sp, #8]
 80070d8:	3307      	adds	r3, #7
 80070da:	4393      	bics	r3, r2
 80070dc:	cb03      	ldmia	r3!, {r0, r1}
 80070de:	9302      	str	r3, [sp, #8]
 80070e0:	f7fc f9d6 	bl	8003490 <__aeabi_d2f>
      if (f < 0) {
 80070e4:	2100      	movs	r1, #0
      f = (float) va_arg(ap, double);
 80070e6:	1c07      	adds	r7, r0, #0
      if (f < 0) {
 80070e8:	f7f9 fa4c 	bl	8000584 <__aeabi_fcmplt>
        *p++ = '-';
 80070ec:	ab0e      	add	r3, sp, #56	; 0x38
      if (f < 0) {
 80070ee:	2800      	cmp	r0, #0
 80070f0:	d000      	beq.n	80070f4 <chvprintf+0x164>
 80070f2:	e1b1      	b.n	8007458 <chvprintf+0x4c8>
    p = tmpbuf;
 80070f4:	469b      	mov	fp, r3
 80070f6:	9305      	str	r3, [sp, #20]
      p = ftoa(p, f, precision);
 80070f8:	1c38      	adds	r0, r7, #0
 80070fa:	f7fc f971 	bl	80033e0 <__aeabi_f2d>
  if ((precision == 0) || (precision > FLOAT_PRECISION))
 80070fe:	464b      	mov	r3, r9
 8007100:	3b01      	subs	r3, #1
      p = ftoa(p, f, precision);
 8007102:	9008      	str	r0, [sp, #32]
 8007104:	9109      	str	r1, [sp, #36]	; 0x24
  if ((precision == 0) || (precision > FLOAT_PRECISION))
 8007106:	2b08      	cmp	r3, #8
 8007108:	d900      	bls.n	800710c <chvprintf+0x17c>
 800710a:	e1ce      	b.n	80074aa <chvprintf+0x51a>
 800710c:	4aa3      	ldr	r2, [pc, #652]	; (800739c <chvprintf+0x40c>)
 800710e:	009b      	lsls	r3, r3, #2
 8007110:	589b      	ldr	r3, [r3, r2]
 8007112:	0018      	movs	r0, r3
 8007114:	4698      	mov	r8, r3
 8007116:	930b      	str	r3, [sp, #44]	; 0x2c
 8007118:	f7fc f92a 	bl	8003370 <__aeabi_ui2d>
 800711c:	900c      	str	r0, [sp, #48]	; 0x30
 800711e:	910d      	str	r1, [sp, #52]	; 0x34
 8007120:	210a      	movs	r1, #10
 8007122:	4640      	mov	r0, r8
 8007124:	f7f9 f854 	bl	80001d0 <__udivsi3>
 8007128:	9007      	str	r0, [sp, #28]
  l = (long)num;
 800712a:	1c38      	adds	r0, r7, #0
 800712c:	f7fa fa38 	bl	80015a0 <__aeabi_f2iz>
  q = p + MAX_FILLER;
 8007130:	230b      	movs	r3, #11
 8007132:	445b      	add	r3, fp
 8007134:	4699      	mov	r9, r3
 8007136:	001f      	movs	r7, r3
 8007138:	46a0      	mov	r8, r4
 800713a:	46aa      	mov	sl, r5
  l = (long)num;
 800713c:	900a      	str	r0, [sp, #40]	; 0x28
    i = (int)(l % radix);
 800713e:	210a      	movs	r1, #10
 8007140:	0005      	movs	r5, r0
 8007142:	f7f9 f8cb 	bl	80002dc <__aeabi_uidivmod>
    i += '0';
 8007146:	3130      	adds	r1, #48	; 0x30
    *--q = i;
 8007148:	b2cc      	uxtb	r4, r1
 800714a:	3f01      	subs	r7, #1
 800714c:	703c      	strb	r4, [r7, #0]
    l /= radix;
 800714e:	210a      	movs	r1, #10
 8007150:	0028      	movs	r0, r5
 8007152:	f7f9 f83d 	bl	80001d0 <__udivsi3>
  } while ((ll /= radix) != 0);
 8007156:	2d09      	cmp	r5, #9
 8007158:	d8f1      	bhi.n	800713e <chvprintf+0x1ae>
 800715a:	0023      	movs	r3, r4
 800715c:	4644      	mov	r4, r8
 800715e:	4698      	mov	r8, r3
  i = (int)(p + MAX_FILLER - q);
 8007160:	464b      	mov	r3, r9
 8007162:	4655      	mov	r5, sl
 8007164:	1bda      	subs	r2, r3, r7
 8007166:	4658      	mov	r0, fp
 8007168:	2300      	movs	r3, #0
 800716a:	4641      	mov	r1, r8
 800716c:	e000      	b.n	8007170 <chvprintf+0x1e0>
 800716e:	5cf9      	ldrb	r1, [r7, r3]
    *p++ = *q++;
 8007170:	54c1      	strb	r1, [r0, r3]
 8007172:	3301      	adds	r3, #1
  while (--i);
 8007174:	429a      	cmp	r2, r3
 8007176:	d1fa      	bne.n	800716e <chvprintf+0x1de>
 8007178:	4683      	mov	fp, r0
 800717a:	1e53      	subs	r3, r2, #1
 800717c:	445b      	add	r3, fp
 800717e:	001f      	movs	r7, r3
  *p++ = '.';
 8007180:	3302      	adds	r3, #2
 8007182:	9306      	str	r3, [sp, #24]
 8007184:	232e      	movs	r3, #46	; 0x2e
 8007186:	5483      	strb	r3, [r0, r2]
  l = (long)((num - l) * precision);
 8007188:	980a      	ldr	r0, [sp, #40]	; 0x28
 800718a:	f7fc f8b1 	bl	80032f0 <__aeabi_i2d>
 800718e:	0002      	movs	r2, r0
 8007190:	000b      	movs	r3, r1
 8007192:	9808      	ldr	r0, [sp, #32]
 8007194:	9909      	ldr	r1, [sp, #36]	; 0x24
 8007196:	f7fb fcbb 	bl	8002b10 <__aeabi_dsub>
 800719a:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 800719c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800719e:	f7fb fa2f 	bl	8002600 <__aeabi_dmul>
 80071a2:	f7fc f86d 	bl	8003280 <__aeabi_d2iz>
  if (divisor == 0) {
 80071a6:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
  l = (long)((num - l) * precision);
 80071a8:	4682      	mov	sl, r0
  if (divisor == 0) {
 80071aa:	2b09      	cmp	r3, #9
 80071ac:	d800      	bhi.n	80071b0 <chvprintf+0x220>
    ll = num;
 80071ae:	9007      	str	r0, [sp, #28]
  q = p + MAX_FILLER;
 80071b0:	230d      	movs	r3, #13
 80071b2:	4699      	mov	r9, r3
 80071b4:	9b07      	ldr	r3, [sp, #28]
 80071b6:	44b9      	add	r9, r7
 80071b8:	4698      	mov	r8, r3
 80071ba:	002b      	movs	r3, r5
 80071bc:	464f      	mov	r7, r9
 80071be:	4655      	mov	r5, sl
 80071c0:	46b3      	mov	fp, r6
 80071c2:	469a      	mov	sl, r3
 80071c4:	9408      	str	r4, [sp, #32]
    i = (int)(l % radix);
 80071c6:	0028      	movs	r0, r5
 80071c8:	210a      	movs	r1, #10
 80071ca:	f7f9 f887 	bl	80002dc <__aeabi_uidivmod>
    i += '0';
 80071ce:	3130      	adds	r1, #48	; 0x30
    *--q = i;
 80071d0:	b2cc      	uxtb	r4, r1
 80071d2:	3f01      	subs	r7, #1
    l /= radix;
 80071d4:	210a      	movs	r1, #10
 80071d6:	0028      	movs	r0, r5
    *--q = i;
 80071d8:	703c      	strb	r4, [r7, #0]
    l /= radix;
 80071da:	f7f8 fff9 	bl	80001d0 <__udivsi3>
  } while ((ll /= radix) != 0);
 80071de:	210a      	movs	r1, #10
    l /= radix;
 80071e0:	0005      	movs	r5, r0
  } while ((ll /= radix) != 0);
 80071e2:	4640      	mov	r0, r8
 80071e4:	4646      	mov	r6, r8
 80071e6:	f7f8 fff3 	bl	80001d0 <__udivsi3>
 80071ea:	4680      	mov	r8, r0
 80071ec:	2e09      	cmp	r6, #9
 80071ee:	d8ea      	bhi.n	80071c6 <chvprintf+0x236>
 80071f0:	46a0      	mov	r8, r4
  i = (int)(p + MAX_FILLER - q);
 80071f2:	464b      	mov	r3, r9
 80071f4:	9c08      	ldr	r4, [sp, #32]
 80071f6:	4655      	mov	r5, sl
 80071f8:	465e      	mov	r6, fp
 80071fa:	1bdb      	subs	r3, r3, r7
 80071fc:	2200      	movs	r2, #0
 80071fe:	9806      	ldr	r0, [sp, #24]
 8007200:	4641      	mov	r1, r8
 8007202:	e000      	b.n	8007206 <chvprintf+0x276>
 8007204:	5cb9      	ldrb	r1, [r7, r2]
    *p++ = *q++;
 8007206:	5481      	strb	r1, [r0, r2]
 8007208:	3201      	adds	r2, #1
  while (--i);
 800720a:	4293      	cmp	r3, r2
 800720c:	d1fa      	bne.n	8007204 <chvprintf+0x274>
 800720e:	9a06      	ldr	r2, [sp, #24]
 8007210:	4694      	mov	ip, r2
 8007212:	4463      	add	r3, ip
 8007214:	9a05      	ldr	r2, [sp, #20]
 8007216:	1a99      	subs	r1, r3, r2
 8007218:	1e4b      	subs	r3, r1, #1
 800721a:	469b      	mov	fp, r3
    s = tmpbuf;
 800721c:	4690      	mov	r8, r2
 800721e:	e00c      	b.n	800723a <chvprintf+0x2aa>
    switch (c) {
 8007220:	003e      	movs	r6, r7
      *p++ = va_arg(ap, int);
 8007222:	9b02      	ldr	r3, [sp, #8]
 8007224:	a90e      	add	r1, sp, #56	; 0x38
 8007226:	cb04      	ldmia	r3!, {r2}
 8007228:	9302      	str	r3, [sp, #8]
      break;
 800722a:	2300      	movs	r3, #0
 800722c:	469b      	mov	fp, r3
      filler = ' ';
 800722e:	3320      	adds	r3, #32
 8007230:	9303      	str	r3, [sp, #12]
    s = tmpbuf;
 8007232:	ab0e      	add	r3, sp, #56	; 0x38
      *p++ = va_arg(ap, int);
 8007234:	700a      	strb	r2, [r1, #0]
    s = tmpbuf;
 8007236:	4698      	mov	r8, r3
      break;
 8007238:	2101      	movs	r1, #1
    if ((width -= i) < 0)
 800723a:	1a63      	subs	r3, r4, r1
 800723c:	4699      	mov	r9, r3
 800723e:	d500      	bpl.n	8007242 <chvprintf+0x2b2>
 8007240:	e740      	b.n	80070c4 <chvprintf+0x134>
    if (left_align == FALSE)
 8007242:	9b04      	ldr	r3, [sp, #16]
 8007244:	2b00      	cmp	r3, #0
 8007246:	d14c      	bne.n	80072e2 <chvprintf+0x352>
      width = -width;
 8007248:	1b0b      	subs	r3, r1, r4
 800724a:	469a      	mov	sl, r3
    if (width < 0) {
 800724c:	464b      	mov	r3, r9
 800724e:	2b00      	cmp	r3, #0
 8007250:	d046      	beq.n	80072e0 <chvprintf+0x350>
      if (*s == '-' && filler == '0') {
 8007252:	4642      	mov	r2, r8
 8007254:	682b      	ldr	r3, [r5, #0]
 8007256:	7812      	ldrb	r2, [r2, #0]
 8007258:	689b      	ldr	r3, [r3, #8]
 800725a:	2a2d      	cmp	r2, #45	; 0x2d
 800725c:	d100      	bne.n	8007260 <chvprintf+0x2d0>
 800725e:	e110      	b.n	8007482 <chvprintf+0x4f2>
    if (width < 0) {
 8007260:	9f03      	ldr	r7, [sp, #12]
 8007262:	4654      	mov	r4, sl
 8007264:	e001      	b.n	800726a <chvprintf+0x2da>
 8007266:	682b      	ldr	r3, [r5, #0]
 8007268:	689b      	ldr	r3, [r3, #8]
        streamPut(chp, (uint8_t)filler);
 800726a:	0039      	movs	r1, r7
 800726c:	0028      	movs	r0, r5
      } while (++width != 0);
 800726e:	3401      	adds	r4, #1
        streamPut(chp, (uint8_t)filler);
 8007270:	4798      	blx	r3
      } while (++width != 0);
 8007272:	2c00      	cmp	r4, #0
 8007274:	d1f7      	bne.n	8007266 <chvprintf+0x2d6>
 8007276:	4652      	mov	r2, sl
 8007278:	9b01      	ldr	r3, [sp, #4]
 800727a:	46a1      	mov	r9, r4
 800727c:	1a9b      	subs	r3, r3, r2
 800727e:	9301      	str	r3, [sp, #4]
    while (--i >= 0) {
 8007280:	465b      	mov	r3, fp
 8007282:	2b00      	cmp	r3, #0
 8007284:	da00      	bge.n	8007288 <chvprintf+0x2f8>
 8007286:	e68f      	b.n	8006fa8 <chvprintf+0x18>
      width = -width;
 8007288:	4644      	mov	r4, r8
 800728a:	465b      	mov	r3, fp
 800728c:	18e7      	adds	r7, r4, r3
      streamPut(chp, (uint8_t)*s++);
 800728e:	682b      	ldr	r3, [r5, #0]
 8007290:	7821      	ldrb	r1, [r4, #0]
 8007292:	689b      	ldr	r3, [r3, #8]
 8007294:	0028      	movs	r0, r5
 8007296:	3401      	adds	r4, #1
 8007298:	4798      	blx	r3
      n++;
 800729a:	1b3b      	subs	r3, r7, r4
    while (--i >= 0) {
 800729c:	d5f7      	bpl.n	800728e <chvprintf+0x2fe>
 800729e:	9b01      	ldr	r3, [sp, #4]
 80072a0:	3301      	adds	r3, #1
 80072a2:	445b      	add	r3, fp
 80072a4:	9301      	str	r3, [sp, #4]
    while (width) {
 80072a6:	464b      	mov	r3, r9
 80072a8:	2b00      	cmp	r3, #0
 80072aa:	d100      	bne.n	80072ae <chvprintf+0x31e>
 80072ac:	e67c      	b.n	8006fa8 <chvprintf+0x18>
 80072ae:	464c      	mov	r4, r9
 80072b0:	9f03      	ldr	r7, [sp, #12]
      streamPut(chp, (uint8_t)filler);
 80072b2:	682b      	ldr	r3, [r5, #0]
 80072b4:	0039      	movs	r1, r7
 80072b6:	689b      	ldr	r3, [r3, #8]
 80072b8:	0028      	movs	r0, r5
      width--;
 80072ba:	3c01      	subs	r4, #1
      streamPut(chp, (uint8_t)filler);
 80072bc:	4798      	blx	r3
    while (width) {
 80072be:	2c00      	cmp	r4, #0
 80072c0:	d1f7      	bne.n	80072b2 <chvprintf+0x322>
 80072c2:	9b01      	ldr	r3, [sp, #4]
 80072c4:	444b      	add	r3, r9
 80072c6:	9301      	str	r3, [sp, #4]
 80072c8:	e66e      	b.n	8006fa8 <chvprintf+0x18>
    switch (c) {
 80072ca:	000a      	movs	r2, r1
        c = *fmt++;
 80072cc:	0037      	movs	r7, r6
      *p++ = c;
 80072ce:	ab0e      	add	r3, sp, #56	; 0x38
 80072d0:	701a      	strb	r2, [r3, #0]
      break;
 80072d2:	2300      	movs	r3, #0
 80072d4:	469b      	mov	fp, r3
    s = tmpbuf;
 80072d6:	ab0e      	add	r3, sp, #56	; 0x38
      break;
 80072d8:	003e      	movs	r6, r7
 80072da:	2101      	movs	r1, #1
    s = tmpbuf;
 80072dc:	4698      	mov	r8, r3
      break;
 80072de:	e7ac      	b.n	800723a <chvprintf+0x2aa>
      width = -width;
 80072e0:	46d1      	mov	r9, sl
    while (--i >= 0) {
 80072e2:	465b      	mov	r3, fp
 80072e4:	2b00      	cmp	r3, #0
 80072e6:	dacf      	bge.n	8007288 <chvprintf+0x2f8>
 80072e8:	e7dd      	b.n	80072a6 <chvprintf+0x316>
 80072ea:	003b      	movs	r3, r7
 80072ec:	4648      	mov	r0, r9
 80072ee:	9e02      	ldr	r6, [sp, #8]
 80072f0:	e006      	b.n	8007300 <chvprintf+0x370>
          c = va_arg(ap, int);
 80072f2:	ce08      	ldmia	r6!, {r3}
 80072f4:	b2db      	uxtb	r3, r3
        precision *= 10;
 80072f6:	0082      	lsls	r2, r0, #2
 80072f8:	1812      	adds	r2, r2, r0
 80072fa:	0052      	lsls	r2, r2, #1
        precision += c;
 80072fc:	1898      	adds	r0, r3, r2
 80072fe:	000b      	movs	r3, r1
        c = *fmt++;
 8007300:	781a      	ldrb	r2, [r3, #0]
 8007302:	1c59      	adds	r1, r3, #1
        if (c >= '0' && c <= '9')
 8007304:	0013      	movs	r3, r2
 8007306:	3b30      	subs	r3, #48	; 0x30
 8007308:	b2db      	uxtb	r3, r3
 800730a:	000f      	movs	r7, r1
 800730c:	2b09      	cmp	r3, #9
 800730e:	d9f2      	bls.n	80072f6 <chvprintf+0x366>
        else if (c == '*')
 8007310:	2a2a      	cmp	r2, #42	; 0x2a
 8007312:	d0ee      	beq.n	80072f2 <chvprintf+0x362>
 8007314:	4681      	mov	r9, r0
 8007316:	9602      	str	r6, [sp, #8]
 8007318:	e68d      	b.n	8007036 <chvprintf+0xa6>
      if (is_long)
 800731a:	9b02      	ldr	r3, [sp, #8]
 800731c:	cb01      	ldmia	r3!, {r0}
 800731e:	9302      	str	r3, [sp, #8]
    switch (c) {
 8007320:	2308      	movs	r3, #8
 8007322:	469a      	mov	sl, r3
  q = p + MAX_FILLER;
 8007324:	aa0e      	add	r2, sp, #56	; 0x38
 8007326:	230b      	movs	r3, #11
 8007328:	4694      	mov	ip, r2
 800732a:	4463      	add	r3, ip
 800732c:	46a9      	mov	r9, r5
 800732e:	469b      	mov	fp, r3
 8007330:	001f      	movs	r7, r3
 8007332:	46a0      	mov	r8, r4
 8007334:	4655      	mov	r5, sl
    i = (int)(l % radix);
 8007336:	0029      	movs	r1, r5
 8007338:	0004      	movs	r4, r0
 800733a:	f7f8 ffcf 	bl	80002dc <__aeabi_uidivmod>
    i += '0';
 800733e:	000b      	movs	r3, r1
 8007340:	3330      	adds	r3, #48	; 0x30
    if (i > '9')
 8007342:	2b39      	cmp	r3, #57	; 0x39
 8007344:	dd00      	ble.n	8007348 <chvprintf+0x3b8>
      i += 'A' - '0' - 10;
 8007346:	3307      	adds	r3, #7
    *--q = i;
 8007348:	3f01      	subs	r7, #1
 800734a:	b2db      	uxtb	r3, r3
 800734c:	703b      	strb	r3, [r7, #0]
  } while ((ll /= radix) != 0);
 800734e:	42ac      	cmp	r4, r5
 8007350:	d2f1      	bcs.n	8007336 <chvprintf+0x3a6>
  i = (int)(p + MAX_FILLER - q);
 8007352:	4659      	mov	r1, fp
 8007354:	aa0e      	add	r2, sp, #56	; 0x38
 8007356:	4644      	mov	r4, r8
 8007358:	464d      	mov	r5, r9
 800735a:	9205      	str	r2, [sp, #20]
 800735c:	1bc9      	subs	r1, r1, r7
 800735e:	e000      	b.n	8007362 <chvprintf+0x3d2>
 8007360:	783b      	ldrb	r3, [r7, #0]
    *p++ = *q++;
 8007362:	3701      	adds	r7, #1
 8007364:	7013      	strb	r3, [r2, #0]
 8007366:	3201      	adds	r2, #1
  while (--i);
 8007368:	455f      	cmp	r7, fp
 800736a:	d1f9      	bne.n	8007360 <chvprintf+0x3d0>
 800736c:	1e4b      	subs	r3, r1, #1
 800736e:	469b      	mov	fp, r3
    s = tmpbuf;
 8007370:	9b05      	ldr	r3, [sp, #20]
 8007372:	4698      	mov	r8, r3
 8007374:	e761      	b.n	800723a <chvprintf+0x2aa>
      if (is_long)
 8007376:	9b02      	ldr	r3, [sp, #8]
 8007378:	cb01      	ldmia	r3!, {r0}
 800737a:	9302      	str	r3, [sp, #8]
    switch (c) {
 800737c:	230a      	movs	r3, #10
 800737e:	469a      	mov	sl, r3
 8007380:	e7d0      	b.n	8007324 <chvprintf+0x394>
 8007382:	9b02      	ldr	r3, [sp, #8]
 8007384:	cb01      	ldmia	r3!, {r0}
 8007386:	9302      	str	r3, [sp, #8]
 8007388:	2310      	movs	r3, #16
 800738a:	469a      	mov	sl, r3
 800738c:	e7ca      	b.n	8007324 <chvprintf+0x394>
 800738e:	46c0      	nop			; (mov r8, r8)
 8007390:	080137c8 	.word	0x080137c8
 8007394:	0801389c 	.word	0x0801389c
 8007398:	00007fff 	.word	0x00007fff
 800739c:	08013978 	.word	0x08013978
 80073a0:	9b02      	ldr	r3, [sp, #8]
 80073a2:	3304      	adds	r3, #4
        l = va_arg(ap, long);
 80073a4:	9a02      	ldr	r2, [sp, #8]
 80073a6:	9302      	str	r3, [sp, #8]
 80073a8:	6812      	ldr	r2, [r2, #0]
 80073aa:	4692      	mov	sl, r2
      if (l < 0) {
 80073ac:	4653      	mov	r3, sl
 80073ae:	2b00      	cmp	r3, #0
 80073b0:	db38      	blt.n	8007424 <chvprintf+0x494>
    p = tmpbuf;
 80073b2:	ab0e      	add	r3, sp, #56	; 0x38
 80073b4:	469b      	mov	fp, r3
 80073b6:	9305      	str	r3, [sp, #20]
  q = p + MAX_FILLER;
 80073b8:	230b      	movs	r3, #11
 80073ba:	445b      	add	r3, fp
 80073bc:	4698      	mov	r8, r3
 80073be:	001f      	movs	r7, r3
 80073c0:	002b      	movs	r3, r5
 80073c2:	46a1      	mov	r9, r4
 80073c4:	4655      	mov	r5, sl
 80073c6:	469a      	mov	sl, r3
 80073c8:	e000      	b.n	80073cc <chvprintf+0x43c>
  } while ((ll /= radix) != 0);
 80073ca:	0005      	movs	r5, r0
    i = (int)(l % radix);
 80073cc:	210a      	movs	r1, #10
 80073ce:	0028      	movs	r0, r5
 80073d0:	f7f8 ff84 	bl	80002dc <__aeabi_uidivmod>
    i += '0';
 80073d4:	3130      	adds	r1, #48	; 0x30
    *--q = i;
 80073d6:	b2cc      	uxtb	r4, r1
 80073d8:	3f01      	subs	r7, #1
 80073da:	703c      	strb	r4, [r7, #0]
    l /= radix;
 80073dc:	210a      	movs	r1, #10
 80073de:	0028      	movs	r0, r5
 80073e0:	f7f8 fef6 	bl	80001d0 <__udivsi3>
  } while ((ll /= radix) != 0);
 80073e4:	2d09      	cmp	r5, #9
 80073e6:	dcf0      	bgt.n	80073ca <chvprintf+0x43a>
 80073e8:	0023      	movs	r3, r4
 80073ea:	464c      	mov	r4, r9
 80073ec:	4699      	mov	r9, r3
  i = (int)(p + MAX_FILLER - q);
 80073ee:	4643      	mov	r3, r8
 80073f0:	4655      	mov	r5, sl
 80073f2:	1bdb      	subs	r3, r3, r7
 80073f4:	2200      	movs	r2, #0
 80073f6:	4658      	mov	r0, fp
 80073f8:	4649      	mov	r1, r9
 80073fa:	e000      	b.n	80073fe <chvprintf+0x46e>
 80073fc:	5cb9      	ldrb	r1, [r7, r2]
    *p++ = *q++;
 80073fe:	5481      	strb	r1, [r0, r2]
 8007400:	3201      	adds	r2, #1
  while (--i);
 8007402:	4293      	cmp	r3, r2
 8007404:	d1fa      	bne.n	80073fc <chvprintf+0x46c>
 8007406:	4683      	mov	fp, r0
 8007408:	445b      	add	r3, fp
 800740a:	e703      	b.n	8007214 <chvprintf+0x284>
      if (is_long)
 800740c:	9b02      	ldr	r3, [sp, #8]
 800740e:	3304      	adds	r3, #4
 8007410:	2919      	cmp	r1, #25
 8007412:	d96c      	bls.n	80074ee <chvprintf+0x55e>
        l = va_arg(ap, int);
 8007414:	9a02      	ldr	r2, [sp, #8]
 8007416:	9302      	str	r3, [sp, #8]
 8007418:	6812      	ldr	r2, [r2, #0]
 800741a:	003e      	movs	r6, r7
 800741c:	4692      	mov	sl, r2
      if (l < 0) {
 800741e:	4653      	mov	r3, sl
 8007420:	2b00      	cmp	r3, #0
 8007422:	dac6      	bge.n	80073b2 <chvprintf+0x422>
        *p++ = '-';
 8007424:	ab0e      	add	r3, sp, #56	; 0x38
 8007426:	001a      	movs	r2, r3
 8007428:	9305      	str	r3, [sp, #20]
 800742a:	232d      	movs	r3, #45	; 0x2d
 800742c:	7013      	strb	r3, [r2, #0]
        l = -l;
 800742e:	4653      	mov	r3, sl
 8007430:	425b      	negs	r3, r3
 8007432:	469a      	mov	sl, r3
        *p++ = '-';
 8007434:	4694      	mov	ip, r2
 8007436:	2301      	movs	r3, #1
 8007438:	4463      	add	r3, ip
 800743a:	469b      	mov	fp, r3
 800743c:	e7bc      	b.n	80073b8 <chvprintf+0x428>
    switch (c) {
 800743e:	230a      	movs	r3, #10
 8007440:	469a      	mov	sl, r3
      if (is_long)
 8007442:	9b02      	ldr	r3, [sp, #8]
 8007444:	003e      	movs	r6, r7
 8007446:	cb01      	ldmia	r3!, {r0}
 8007448:	9302      	str	r3, [sp, #8]
 800744a:	e76b      	b.n	8007324 <chvprintf+0x394>
    switch (c) {
 800744c:	2310      	movs	r3, #16
 800744e:	469a      	mov	sl, r3
 8007450:	e7f7      	b.n	8007442 <chvprintf+0x4b2>
 8007452:	2308      	movs	r3, #8
 8007454:	469a      	mov	sl, r3
 8007456:	e7f4      	b.n	8007442 <chvprintf+0x4b2>
        *p++ = '-';
 8007458:	001a      	movs	r2, r3
 800745a:	9305      	str	r3, [sp, #20]
 800745c:	232d      	movs	r3, #45	; 0x2d
 800745e:	7013      	strb	r3, [r2, #0]
        f = -f;
 8007460:	2380      	movs	r3, #128	; 0x80
 8007462:	061b      	lsls	r3, r3, #24
 8007464:	469c      	mov	ip, r3
        *p++ = '-';
 8007466:	2301      	movs	r3, #1
        f = -f;
 8007468:	4467      	add	r7, ip
        *p++ = '-';
 800746a:	4694      	mov	ip, r2
 800746c:	4463      	add	r3, ip
 800746e:	469b      	mov	fp, r3
 8007470:	e642      	b.n	80070f8 <chvprintf+0x168>
      if (precision == 0)
 8007472:	464b      	mov	r3, r9
 8007474:	2b00      	cmp	r3, #0
 8007476:	d121      	bne.n	80074bc <chvprintf+0x52c>
        precision = 32767;
 8007478:	4b1e      	ldr	r3, [pc, #120]	; (80074f4 <chvprintf+0x564>)
 800747a:	4699      	mov	r9, r3
        s = "(null)";
 800747c:	4b1e      	ldr	r3, [pc, #120]	; (80074f8 <chvprintf+0x568>)
 800747e:	4698      	mov	r8, r3
 8007480:	e609      	b.n	8007096 <chvprintf+0x106>
      if (*s == '-' && filler == '0') {
 8007482:	9a03      	ldr	r2, [sp, #12]
 8007484:	2a30      	cmp	r2, #48	; 0x30
 8007486:	d000      	beq.n	800748a <chvprintf+0x4fa>
 8007488:	e6ea      	b.n	8007260 <chvprintf+0x2d0>
 800748a:	9a01      	ldr	r2, [sp, #4]
        streamPut(chp, (uint8_t)*s++);
 800748c:	212d      	movs	r1, #45	; 0x2d
 800748e:	3201      	adds	r2, #1
 8007490:	9201      	str	r2, [sp, #4]
 8007492:	2201      	movs	r2, #1
 8007494:	4694      	mov	ip, r2
 8007496:	0028      	movs	r0, r5
 8007498:	44e0      	add	r8, ip
 800749a:	4798      	blx	r3
        i--;
 800749c:	2301      	movs	r3, #1
 800749e:	425b      	negs	r3, r3
 80074a0:	469c      	mov	ip, r3
 80074a2:	682b      	ldr	r3, [r5, #0]
 80074a4:	44e3      	add	fp, ip
 80074a6:	689b      	ldr	r3, [r3, #8]
 80074a8:	e6da      	b.n	8007260 <chvprintf+0x2d0>
  if ((precision == 0) || (precision > FLOAT_PRECISION))
 80074aa:	2200      	movs	r2, #0
 80074ac:	4b13      	ldr	r3, [pc, #76]	; (80074fc <chvprintf+0x56c>)
 80074ae:	9307      	str	r3, [sp, #28]
 80074b0:	4b13      	ldr	r3, [pc, #76]	; (8007500 <chvprintf+0x570>)
 80074b2:	920c      	str	r2, [sp, #48]	; 0x30
 80074b4:	930d      	str	r3, [sp, #52]	; 0x34
 80074b6:	4b13      	ldr	r3, [pc, #76]	; (8007504 <chvprintf+0x574>)
 80074b8:	930b      	str	r3, [sp, #44]	; 0x2c
 80074ba:	e636      	b.n	800712a <chvprintf+0x19a>
        s = "(null)";
 80074bc:	4b0e      	ldr	r3, [pc, #56]	; (80074f8 <chvprintf+0x568>)
 80074be:	4698      	mov	r8, r3
 80074c0:	e5e9      	b.n	8007096 <chvprintf+0x106>
    if (left_align == FALSE)
 80074c2:	9b04      	ldr	r3, [sp, #16]
 80074c4:	2b00      	cmp	r3, #0
 80074c6:	d109      	bne.n	80074dc <chvprintf+0x54c>
      width = -width;
 80074c8:	4263      	negs	r3, r4
 80074ca:	469a      	mov	sl, r3
      if ((s = va_arg(ap, char *)) == 0)
 80074cc:	9702      	str	r7, [sp, #8]
    if (width < 0) {
 80074ce:	2c00      	cmp	r4, #0
 80074d0:	d009      	beq.n	80074e6 <chvprintf+0x556>
      filler = ' ';
 80074d2:	2320      	movs	r3, #32
 80074d4:	9303      	str	r3, [sp, #12]
    if (width < 0) {
 80074d6:	3b21      	subs	r3, #33	; 0x21
 80074d8:	469b      	mov	fp, r3
 80074da:	e6ba      	b.n	8007252 <chvprintf+0x2c2>
      filler = ' ';
 80074dc:	2320      	movs	r3, #32
      if ((s = va_arg(ap, char *)) == 0)
 80074de:	9702      	str	r7, [sp, #8]
    if (left_align == FALSE)
 80074e0:	46a1      	mov	r9, r4
      filler = ' ';
 80074e2:	9303      	str	r3, [sp, #12]
 80074e4:	e6df      	b.n	80072a6 <chvprintf+0x316>
      width = -width;
 80074e6:	4699      	mov	r9, r3
      filler = ' ';
 80074e8:	2320      	movs	r3, #32
 80074ea:	9303      	str	r3, [sp, #12]
 80074ec:	e6db      	b.n	80072a6 <chvprintf+0x316>
 80074ee:	003e      	movs	r6, r7
 80074f0:	e758      	b.n	80073a4 <chvprintf+0x414>
 80074f2:	46c0      	nop			; (mov r8, r8)
 80074f4:	00007fff 	.word	0x00007fff
 80074f8:	08013970 	.word	0x08013970
 80074fc:	05f5e100 	.word	0x05f5e100
 8007500:	41cdcd65 	.word	0x41cdcd65
 8007504:	3b9aca00 	.word	0x3b9aca00
	...

08007510 <chprintf>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 8007510:	b40e      	push	{r1, r2, r3}
 8007512:	b500      	push	{lr}
 8007514:	b082      	sub	sp, #8
 8007516:	aa03      	add	r2, sp, #12
 8007518:	ca02      	ldmia	r2!, {r1}
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 800751a:	9201      	str	r2, [sp, #4]
  formatted_bytes = chvprintf(chp, fmt, ap);
 800751c:	f7ff fd38 	bl	8006f90 <chvprintf>
  va_end(ap);

  return formatted_bytes;
}
 8007520:	b002      	add	sp, #8
 8007522:	bc08      	pop	{r3}
 8007524:	b003      	add	sp, #12
 8007526:	4718      	bx	r3
	...

08007530 <chsnprintf>:
 *                      terminating NUL byte) that would have been
 *                      stored in @p str if there was room.
 *
 * @api
 */
int chsnprintf(char *str, size_t size, const char *fmt, ...) {
 8007530:	b40c      	push	{r2, r3}
 8007532:	b530      	push	{r4, r5, lr}
 8007534:	0005      	movs	r5, r0
 8007536:	b087      	sub	sp, #28
 8007538:	1e0c      	subs	r4, r1, #0
  MemoryStream ms;
  BaseSequentialStream *chp;
  size_t size_wo_nul;
  int retval;

  if (size > 0)
 800753a:	d015      	beq.n	8007568 <chsnprintf+0x38>
    size_wo_nul = size - 1;
 800753c:	1e4a      	subs	r2, r1, #1
  else
    size_wo_nul = 0;

  /* Memory stream object to be used as a string writer, reserving one
     byte for the final zero.*/
  msObjectInit(&ms, (uint8_t *)str, size_wo_nul, 0);
 800753e:	2300      	movs	r3, #0
 8007540:	0001      	movs	r1, r0
 8007542:	a801      	add	r0, sp, #4
 8007544:	f000 f874 	bl	8007630 <msObjectInit>

  /* Performing the print operation using the common code.*/
  chp = (BaseSequentialStream *)(void *)&ms;
  va_start(ap, fmt);
 8007548:	aa0b      	add	r2, sp, #44	; 0x2c
  retval = chvprintf(chp, fmt, ap);
 800754a:	990a      	ldr	r1, [sp, #40]	; 0x28
 800754c:	a801      	add	r0, sp, #4
  va_start(ap, fmt);
 800754e:	9200      	str	r2, [sp, #0]
  retval = chvprintf(chp, fmt, ap);
 8007550:	f7ff fd1e 	bl	8006f90 <chvprintf>
  va_end(ap);

  /* Terminate with a zero, unless size==0.*/
  if (ms.eos < size)
 8007554:	9b04      	ldr	r3, [sp, #16]
 8007556:	42a3      	cmp	r3, r4
 8007558:	d201      	bcs.n	800755e <chsnprintf+0x2e>
      str[ms.eos] = 0;
 800755a:	2200      	movs	r2, #0
 800755c:	54ea      	strb	r2, [r5, r3]

  /* Return number of bytes that would have been written.*/
  return retval;
}
 800755e:	b007      	add	sp, #28
 8007560:	bc30      	pop	{r4, r5}
 8007562:	bc08      	pop	{r3}
 8007564:	b002      	add	sp, #8
 8007566:	4718      	bx	r3
  msObjectInit(&ms, (uint8_t *)str, size_wo_nul, 0);
 8007568:	0001      	movs	r1, r0
 800756a:	2300      	movs	r3, #0
 800756c:	a801      	add	r0, sp, #4
 800756e:	2200      	movs	r2, #0
 8007570:	f000 f85e 	bl	8007630 <msObjectInit>
  va_start(ap, fmt);
 8007574:	aa0b      	add	r2, sp, #44	; 0x2c
  retval = chvprintf(chp, fmt, ap);
 8007576:	990a      	ldr	r1, [sp, #40]	; 0x28
 8007578:	a801      	add	r0, sp, #4
  va_start(ap, fmt);
 800757a:	9200      	str	r2, [sp, #0]
  retval = chvprintf(chp, fmt, ap);
 800757c:	f7ff fd08 	bl	8006f90 <chvprintf>
  if (ms.eos < size)
 8007580:	e7ed      	b.n	800755e <chsnprintf+0x2e>
 8007582:	46c0      	nop			; (mov r8, r8)
	...

08007590 <put>:
}

static msg_t put(void *ip, uint8_t b) {
  MemoryStream *msp = ip;

  if (msp->size - msp->eos <= 0)
 8007590:	68c3      	ldr	r3, [r0, #12]
 8007592:	6882      	ldr	r2, [r0, #8]
 8007594:	429a      	cmp	r2, r3
 8007596:	d006      	beq.n	80075a6 <put+0x16>
    return MSG_RESET;
  *(msp->buffer + msp->eos) = b;
 8007598:	6842      	ldr	r2, [r0, #4]
 800759a:	54d1      	strb	r1, [r2, r3]
  msp->eos += 1;
 800759c:	68c3      	ldr	r3, [r0, #12]
 800759e:	3301      	adds	r3, #1
 80075a0:	60c3      	str	r3, [r0, #12]
  return MSG_OK;
 80075a2:	2000      	movs	r0, #0
}
 80075a4:	4770      	bx	lr
    return MSG_RESET;
 80075a6:	2002      	movs	r0, #2
 80075a8:	4240      	negs	r0, r0
 80075aa:	e7fb      	b.n	80075a4 <put+0x14>
 80075ac:	0000      	movs	r0, r0
	...

080075b0 <get>:

static msg_t get(void *ip) {
  uint8_t b;
  MemoryStream *msp = ip;

  if (msp->eos - msp->offset <= 0)
 80075b0:	6903      	ldr	r3, [r0, #16]
 80075b2:	68c2      	ldr	r2, [r0, #12]
 80075b4:	429a      	cmp	r2, r3
 80075b6:	d005      	beq.n	80075c4 <get+0x14>
    return MSG_RESET;
  b = *(msp->buffer + msp->offset);
 80075b8:	6842      	ldr	r2, [r0, #4]
 80075ba:	5cd2      	ldrb	r2, [r2, r3]
  msp->offset += 1;
 80075bc:	3301      	adds	r3, #1
 80075be:	6103      	str	r3, [r0, #16]
  return b;
 80075c0:	0010      	movs	r0, r2
}
 80075c2:	4770      	bx	lr
    return MSG_RESET;
 80075c4:	2002      	movs	r0, #2
 80075c6:	4240      	negs	r0, r0
 80075c8:	e7fb      	b.n	80075c2 <get+0x12>
 80075ca:	46c0      	nop			; (mov r8, r8)
 80075cc:	0000      	movs	r0, r0
	...

080075d0 <reads>:
static size_t reads(void *ip, uint8_t *bp, size_t n) {
 80075d0:	b570      	push	{r4, r5, r6, lr}
 80075d2:	0005      	movs	r5, r0
 80075d4:	0008      	movs	r0, r1
  if (msp->eos - msp->offset < n)
 80075d6:	68eb      	ldr	r3, [r5, #12]
 80075d8:	6929      	ldr	r1, [r5, #16]
 80075da:	1a5c      	subs	r4, r3, r1
 80075dc:	4294      	cmp	r4, r2
 80075de:	d900      	bls.n	80075e2 <reads+0x12>
 80075e0:	0014      	movs	r4, r2
  memcpy(bp, msp->buffer + msp->offset, n);
 80075e2:	686b      	ldr	r3, [r5, #4]
 80075e4:	0022      	movs	r2, r4
 80075e6:	469c      	mov	ip, r3
 80075e8:	4461      	add	r1, ip
 80075ea:	f00b fd71 	bl	80130d0 <memcpy>
  msp->offset += n;
 80075ee:	692b      	ldr	r3, [r5, #16]
}
 80075f0:	0020      	movs	r0, r4
  msp->offset += n;
 80075f2:	191b      	adds	r3, r3, r4
 80075f4:	612b      	str	r3, [r5, #16]
}
 80075f6:	bd70      	pop	{r4, r5, r6, pc}
	...

08007600 <writes>:
static size_t writes(void *ip, const uint8_t *bp, size_t n) {
 8007600:	b570      	push	{r4, r5, r6, lr}
 8007602:	0005      	movs	r5, r0
  if (msp->size - msp->eos < n)
 8007604:	68c0      	ldr	r0, [r0, #12]
 8007606:	68ab      	ldr	r3, [r5, #8]
 8007608:	1a1c      	subs	r4, r3, r0
 800760a:	4294      	cmp	r4, r2
 800760c:	d900      	bls.n	8007610 <writes+0x10>
 800760e:	0014      	movs	r4, r2
  memcpy(msp->buffer + msp->eos, bp, n);
 8007610:	686b      	ldr	r3, [r5, #4]
 8007612:	0022      	movs	r2, r4
 8007614:	469c      	mov	ip, r3
 8007616:	4460      	add	r0, ip
 8007618:	f00b fd5a 	bl	80130d0 <memcpy>
  msp->eos += n;
 800761c:	68eb      	ldr	r3, [r5, #12]
}
 800761e:	0020      	movs	r0, r4
  msp->eos += n;
 8007620:	191b      	adds	r3, r3, r4
 8007622:	60eb      	str	r3, [r5, #12]
}
 8007624:	bd70      	pop	{r4, r5, r6, pc}
 8007626:	46c0      	nop			; (mov r8, r8)
	...

08007630 <msObjectInit>:
                  size_t size, size_t eos) {

  msp->vmt    = &vmt;
  msp->buffer = buffer;
  msp->size   = size;
  msp->eos    = eos;
 8007630:	60c3      	str	r3, [r0, #12]
  msp->offset = 0;
 8007632:	2300      	movs	r3, #0
                  size_t size, size_t eos) {
 8007634:	b510      	push	{r4, lr}
  msp->vmt    = &vmt;
 8007636:	4c03      	ldr	r4, [pc, #12]	; (8007644 <msObjectInit+0x14>)
  msp->buffer = buffer;
 8007638:	6041      	str	r1, [r0, #4]
  msp->vmt    = &vmt;
 800763a:	6004      	str	r4, [r0, #0]
  msp->size   = size;
 800763c:	6082      	str	r2, [r0, #8]
  msp->offset = 0;
 800763e:	6103      	str	r3, [r0, #16]
}
 8007640:	bd10      	pop	{r4, pc}
 8007642:	46c0      	nop			; (mov r8, r8)
 8007644:	0801399c 	.word	0x0801399c
	...

08007650 <parse_arguments>:

/*===========================================================================*/
/* Module local functions.                                                   */
/*===========================================================================*/

static char *parse_arguments(char *str, char **saveptr) {
 8007650:	b570      	push	{r4, r5, r6, lr}
 8007652:	0004      	movs	r4, r0
 8007654:	000d      	movs	r5, r1
  char *p;

  if (str != NULL)
 8007656:	2800      	cmp	r0, #0
 8007658:	d018      	beq.n	800768c <parse_arguments+0x3c>
    *saveptr = str;
 800765a:	6028      	str	r0, [r5, #0]
  if (!p) {
    return NULL;
  }

  /* Skipping white space.*/
  p += strspn(p, " \t");
 800765c:	4e12      	ldr	r6, [pc, #72]	; (80076a8 <parse_arguments+0x58>)
 800765e:	0020      	movs	r0, r4
 8007660:	0031      	movs	r1, r6
 8007662:	f00b fd7d 	bl	8013160 <strspn>
 8007666:	1824      	adds	r4, r4, r0

  if (*p == '"') {
 8007668:	7823      	ldrb	r3, [r4, #0]
 800766a:	2b22      	cmp	r3, #34	; 0x22
 800766c:	d013      	beq.n	8007696 <parse_arguments+0x46>
    p++;
    *saveptr = strpbrk(p, "\"");
  }
  else {
    /* The delimiter is white space.*/
    *saveptr = strpbrk(p, " \t");
 800766e:	0031      	movs	r1, r6
 8007670:	0020      	movs	r0, r4
 8007672:	f00b fd55 	bl	8013120 <strpbrk>
  }

  /* Replacing the delimiter with a zero.*/
  if (*saveptr != NULL) {
 8007676:	2800      	cmp	r0, #0
 8007678:	d014      	beq.n	80076a4 <parse_arguments+0x54>
    *(*saveptr)++ = '\0';
 800767a:	1c43      	adds	r3, r0, #1
 800767c:	602b      	str	r3, [r5, #0]
 800767e:	2300      	movs	r3, #0
 8007680:	7003      	strb	r3, [r0, #0]
  }

  return *p != '\0' ? p : NULL;
 8007682:	7823      	ldrb	r3, [r4, #0]
 8007684:	2b00      	cmp	r3, #0
 8007686:	d004      	beq.n	8007692 <parse_arguments+0x42>
}
 8007688:	0020      	movs	r0, r4
 800768a:	bd70      	pop	{r4, r5, r6, pc}
  p = *saveptr;
 800768c:	680c      	ldr	r4, [r1, #0]
  if (!p) {
 800768e:	2c00      	cmp	r4, #0
 8007690:	d1e4      	bne.n	800765c <parse_arguments+0xc>
    return NULL;
 8007692:	2400      	movs	r4, #0
 8007694:	e7f8      	b.n	8007688 <parse_arguments+0x38>
    p++;
 8007696:	3401      	adds	r4, #1
    *saveptr = strpbrk(p, "\"");
 8007698:	2122      	movs	r1, #34	; 0x22
 800769a:	0020      	movs	r0, r4
 800769c:	f00b fd30 	bl	8013100 <strchr>
  if (*saveptr != NULL) {
 80076a0:	2800      	cmp	r0, #0
 80076a2:	d1ea      	bne.n	800767a <parse_arguments+0x2a>
 80076a4:	6028      	str	r0, [r5, #0]
 80076a6:	e7ec      	b.n	8007682 <parse_arguments+0x32>
 80076a8:	080139ac 	.word	0x080139ac
 80076ac:	00000000 	.word	0x00000000

080076b0 <shellInit>:
 80076b0:	4b01      	ldr	r3, [pc, #4]	; (80076b8 <shellInit+0x8>)
 80076b2:	601b      	str	r3, [r3, #0]
 * @api
 */
void shellInit(void) {

  chEvtObjectInit(&shell_terminated);
}
 80076b4:	4770      	bx	lr
 80076b6:	46c0      	nop			; (mov r8, r8)
 80076b8:	20001a08 	.word	0x20001a08
 80076bc:	00000000 	.word	0x00000000

080076c0 <shellExit>:
 *
 * @param[in] msg       shell exit code
 *
 * @api
 */
void shellExit(msg_t msg) {
 80076c0:	b510      	push	{r4, lr}
 80076c2:	0004      	movs	r4, r0
  __ASM volatile ("cpsid i" : : : "memory");
 80076c4:	b672      	cpsid	i
 *
 * @iclass
 */
static inline void chEvtBroadcastI(event_source_t *esp) {

  chEvtBroadcastFlagsI(esp, (eventflags_t)0);
 80076c6:	2100      	movs	r1, #0
 80076c8:	4803      	ldr	r0, [pc, #12]	; (80076d8 <shellExit+0x18>)
 80076ca:	f7fc fd51 	bl	8004170 <chEvtBroadcastFlagsI>

  /* Atomically broadcasting the event source and terminating the thread,
     there is not a chSysUnlock() because the thread terminates upon return.*/
  chSysLock();
  chEvtBroadcastI(&shell_terminated);
  chThdExitS(msg);
 80076ce:	0020      	movs	r0, r4
 80076d0:	f7fc fbc6 	bl	8003e60 <chThdExitS>
}
 80076d4:	bd10      	pop	{r4, pc}
 80076d6:	46c0      	nop			; (mov r8, r8)
 80076d8:	20001a08 	.word	0x20001a08
 80076dc:	00000000 	.word	0x00000000

080076e0 <shellGetLine>:
 * @retval true         the channel was reset or CTRL-D pressed.
 * @retval false        operation successful.
 *
 * @api
 */
bool shellGetLine(ShellConfig *scfg, char *line, unsigned size, ShellHistory *shp) {
 80076e0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80076e2:	46c6      	mov	lr, r8
 80076e4:	4688      	mov	r8, r1
 80076e6:	b500      	push	{lr}
      continue;
    }
#endif
    if (c < 0x20)
      continue;
    if (p < line + size - 1) {
 80076e8:	3a01      	subs	r2, #1
bool shellGetLine(ShellConfig *scfg, char *line, unsigned size, ShellHistory *shp) {
 80076ea:	b082      	sub	sp, #8
  BaseSequentialStream *chp = scfg->sc_channel;
 80076ec:	000e      	movs	r6, r1
    if (p < line + size - 1) {
 80076ee:	4442      	add	r2, r8
 80076f0:	4669      	mov	r1, sp
 80076f2:	0017      	movs	r7, r2
  BaseSequentialStream *chp = scfg->sc_channel;
 80076f4:	6804      	ldr	r4, [r0, #0]
 80076f6:	1dcd      	adds	r5, r1, #7
 80076f8:	6823      	ldr	r3, [r4, #0]
    if (streamRead(chp, (uint8_t *)&c, 1) == 0)
 80076fa:	685b      	ldr	r3, [r3, #4]
 80076fc:	2201      	movs	r2, #1
 80076fe:	0029      	movs	r1, r5
 8007700:	0020      	movs	r0, r4
 8007702:	4798      	blx	r3
 8007704:	2800      	cmp	r0, #0
 8007706:	d01b      	beq.n	8007740 <shellGetLine+0x60>
    if (c == 4) {
 8007708:	7829      	ldrb	r1, [r5, #0]
 800770a:	2904      	cmp	r1, #4
 800770c:	d031      	beq.n	8007772 <shellGetLine+0x92>
    if ((c == 8) || (c == 127)) {
 800770e:	2908      	cmp	r1, #8
 8007710:	d01b      	beq.n	800774a <shellGetLine+0x6a>
 8007712:	297f      	cmp	r1, #127	; 0x7f
 8007714:	d019      	beq.n	800774a <shellGetLine+0x6a>
    if (c == '\r') {
 8007716:	290d      	cmp	r1, #13
 8007718:	d031      	beq.n	800777e <shellGetLine+0x9e>
    if (c < 0x20)
 800771a:	6823      	ldr	r3, [r4, #0]
 800771c:	291f      	cmp	r1, #31
 800771e:	d9ec      	bls.n	80076fa <shellGetLine+0x1a>
    if (p < line + size - 1) {
 8007720:	42be      	cmp	r6, r7
 8007722:	d2ea      	bcs.n	80076fa <shellGetLine+0x1a>
      streamPut(chp, c);
 8007724:	689b      	ldr	r3, [r3, #8]
 8007726:	0020      	movs	r0, r4
 8007728:	4798      	blx	r3
      *p++ = (char)c;
 800772a:	782b      	ldrb	r3, [r5, #0]
    if (streamRead(chp, (uint8_t *)&c, 1) == 0)
 800772c:	2201      	movs	r2, #1
      *p++ = (char)c;
 800772e:	7033      	strb	r3, [r6, #0]
 8007730:	6823      	ldr	r3, [r4, #0]
    if (streamRead(chp, (uint8_t *)&c, 1) == 0)
 8007732:	0029      	movs	r1, r5
 8007734:	685b      	ldr	r3, [r3, #4]
 8007736:	0020      	movs	r0, r4
      *p++ = (char)c;
 8007738:	3601      	adds	r6, #1
    if (streamRead(chp, (uint8_t *)&c, 1) == 0)
 800773a:	4798      	blx	r3
 800773c:	2800      	cmp	r0, #0
 800773e:	d1e3      	bne.n	8007708 <shellGetLine+0x28>
      return true;
 8007740:	2001      	movs	r0, #1
    }
  }
}
 8007742:	b002      	add	sp, #8
 8007744:	bc04      	pop	{r2}
 8007746:	4690      	mov	r8, r2
 8007748:	bdf0      	pop	{r4, r5, r6, r7, pc}
      if (p != line) {
 800774a:	6823      	ldr	r3, [r4, #0]
 800774c:	4546      	cmp	r6, r8
 800774e:	d0d4      	beq.n	80076fa <shellGetLine+0x1a>
        streamPut(chp, 8);
 8007750:	689b      	ldr	r3, [r3, #8]
 8007752:	2108      	movs	r1, #8
 8007754:	0020      	movs	r0, r4
 8007756:	4798      	blx	r3
        streamPut(chp, 0x20);
 8007758:	6823      	ldr	r3, [r4, #0]
 800775a:	2120      	movs	r1, #32
 800775c:	689b      	ldr	r3, [r3, #8]
 800775e:	0020      	movs	r0, r4
 8007760:	4798      	blx	r3
        streamPut(chp, 8);
 8007762:	6823      	ldr	r3, [r4, #0]
 8007764:	2108      	movs	r1, #8
 8007766:	689b      	ldr	r3, [r3, #8]
 8007768:	0020      	movs	r0, r4
 800776a:	4798      	blx	r3
        p--;
 800776c:	3e01      	subs	r6, #1
 800776e:	6823      	ldr	r3, [r4, #0]
 8007770:	e7c3      	b.n	80076fa <shellGetLine+0x1a>
      chprintf(chp, "^D");
 8007772:	4907      	ldr	r1, [pc, #28]	; (8007790 <shellGetLine+0xb0>)
 8007774:	0020      	movs	r0, r4
 8007776:	f7ff fecb 	bl	8007510 <chprintf>
      return true;
 800777a:	2001      	movs	r0, #1
 800777c:	e7e1      	b.n	8007742 <shellGetLine+0x62>
      chprintf(chp, SHELL_NEWLINE_STR);
 800777e:	4905      	ldr	r1, [pc, #20]	; (8007794 <shellGetLine+0xb4>)
 8007780:	0020      	movs	r0, r4
 8007782:	f7ff fec5 	bl	8007510 <chprintf>
      *p = 0;
 8007786:	2300      	movs	r3, #0
      return false;
 8007788:	2000      	movs	r0, #0
      *p = 0;
 800778a:	7033      	strb	r3, [r6, #0]
      return false;
 800778c:	e7d9      	b.n	8007742 <shellGetLine+0x62>
 800778e:	46c0      	nop			; (mov r8, r8)
 8007790:	080139b0 	.word	0x080139b0
 8007794:	08013f50 	.word	0x08013f50
	...

080077a0 <shellThread>:
THD_FUNCTION(shellThread, p) {
 80077a0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80077a2:	46de      	mov	lr, fp
 80077a4:	464e      	mov	r6, r9
 80077a6:	4657      	mov	r7, sl
 80077a8:	4645      	mov	r5, r8
 80077aa:	b5e0      	push	{r5, r6, r7, lr}
  const ShellCommand *scp = scfg->sc_commands;
 80077ac:	6843      	ldr	r3, [r0, #4]
THD_FUNCTION(shellThread, p) {
 80077ae:	b09b      	sub	sp, #108	; 0x6c
  BaseSequentialStream *chp = scfg->sc_channel;
 80077b0:	6806      	ldr	r6, [r0, #0]
  const ShellCommand *scp = scfg->sc_commands;
 80077b2:	9301      	str	r3, [sp, #4]
  chprintf(chp, SHELL_NEWLINE_STR);
 80077b4:	4b61      	ldr	r3, [pc, #388]	; (800793c <shellThread+0x19c>)
THD_FUNCTION(shellThread, p) {
 80077b6:	4680      	mov	r8, r0
  chprintf(chp, SHELL_NEWLINE_STR);
 80077b8:	0019      	movs	r1, r3
 80077ba:	0030      	movs	r0, r6
 80077bc:	469a      	mov	sl, r3
 80077be:	f7ff fea7 	bl	8007510 <chprintf>
  chprintf(chp, "ChibiOS/RT Shell"SHELL_NEWLINE_STR);
 80077c2:	495f      	ldr	r1, [pc, #380]	; (8007940 <shellThread+0x1a0>)
 80077c4:	0030      	movs	r0, r6
 80077c6:	f7ff fea3 	bl	8007510 <chprintf>
 80077ca:	4b5e      	ldr	r3, [pc, #376]	; (8007944 <shellThread+0x1a4>)
 80077cc:	4699      	mov	r9, r3
    chprintf(chp, SHELL_PROMPT_STR);
 80077ce:	4649      	mov	r1, r9
 80077d0:	0030      	movs	r0, r6
 80077d2:	f7ff fe9d 	bl	8007510 <chprintf>
    if (shellGetLine(scfg, line, sizeof(line), shp)) {
 80077d6:	2300      	movs	r3, #0
 80077d8:	2240      	movs	r2, #64	; 0x40
 80077da:	a90a      	add	r1, sp, #40	; 0x28
 80077dc:	4640      	mov	r0, r8
 80077de:	f7ff ff7f 	bl	80076e0 <shellGetLine>
 80077e2:	2800      	cmp	r0, #0
 80077e4:	d133      	bne.n	800784e <shellThread+0xae>
    lp = parse_arguments(line, &tokp);
 80077e6:	ad03      	add	r5, sp, #12
 80077e8:	0029      	movs	r1, r5
 80077ea:	a80a      	add	r0, sp, #40	; 0x28
 80077ec:	f7ff ff30 	bl	8007650 <parse_arguments>
    while ((lp = parse_arguments(NULL, &tokp)) != NULL) {
 80077f0:	0029      	movs	r1, r5
    lp = parse_arguments(line, &tokp);
 80077f2:	0007      	movs	r7, r0
    while ((lp = parse_arguments(NULL, &tokp)) != NULL) {
 80077f4:	2000      	movs	r0, #0
    n = 0;
 80077f6:	2400      	movs	r4, #0
    while ((lp = parse_arguments(NULL, &tokp)) != NULL) {
 80077f8:	f7ff ff2a 	bl	8007650 <parse_arguments>
 80077fc:	2800      	cmp	r0, #0
 80077fe:	d00a      	beq.n	8007816 <shellThread+0x76>
      if (n >= SHELL_MAX_ARGUMENTS) {
 8007800:	2c05      	cmp	r4, #5
 8007802:	d01d      	beq.n	8007840 <shellThread+0xa0>
      args[n++] = lp;
 8007804:	3401      	adds	r4, #1
 8007806:	00a3      	lsls	r3, r4, #2
 8007808:	50e8      	str	r0, [r5, r3]
    while ((lp = parse_arguments(NULL, &tokp)) != NULL) {
 800780a:	0029      	movs	r1, r5
 800780c:	2000      	movs	r0, #0
 800780e:	f7ff ff1f 	bl	8007650 <parse_arguments>
 8007812:	2800      	cmp	r0, #0
 8007814:	d1f4      	bne.n	8007800 <shellThread+0x60>
    args[n] = NULL;
 8007816:	2108      	movs	r1, #8
 8007818:	aa02      	add	r2, sp, #8
 800781a:	00a3      	lsls	r3, r4, #2
 800781c:	1852      	adds	r2, r2, r1
 800781e:	50d0      	str	r0, [r2, r3]
    if (cmd != NULL) {
 8007820:	2f00      	cmp	r7, #0
 8007822:	d0d4      	beq.n	80077ce <shellThread+0x2e>
      if (strcmp(cmd, "help") == 0) {
 8007824:	4948      	ldr	r1, [pc, #288]	; (8007948 <shellThread+0x1a8>)
 8007826:	0038      	movs	r0, r7
 8007828:	f7fb ffd2 	bl	80037d0 <strcmp>
 800782c:	2800      	cmp	r0, #0
 800782e:	d125      	bne.n	800787c <shellThread+0xdc>
        if (n > 0) {
 8007830:	2c00      	cmp	r4, #0
 8007832:	d037      	beq.n	80078a4 <shellThread+0x104>
          shellUsage(chp, "help");
 8007834:	4a44      	ldr	r2, [pc, #272]	; (8007948 <shellThread+0x1a8>)
 8007836:	4945      	ldr	r1, [pc, #276]	; (800794c <shellThread+0x1ac>)
 8007838:	0030      	movs	r0, r6
 800783a:	f7ff fe69 	bl	8007510 <chprintf>
          continue;
 800783e:	e7c6      	b.n	80077ce <shellThread+0x2e>
        chprintf(chp, "too many arguments"SHELL_NEWLINE_STR);
 8007840:	4943      	ldr	r1, [pc, #268]	; (8007950 <shellThread+0x1b0>)
 8007842:	0030      	movs	r0, r6
 8007844:	f7ff fe64 	bl	8007510 <chprintf>
    args[n] = NULL;
 8007848:	2300      	movs	r3, #0
 800784a:	9309      	str	r3, [sp, #36]	; 0x24
    if (cmd != NULL) {
 800784c:	e7bf      	b.n	80077ce <shellThread+0x2e>
      chprintf(chp, SHELL_NEWLINE_STR);
 800784e:	4651      	mov	r1, sl
 8007850:	0030      	movs	r0, r6
 8007852:	f7ff fe5d 	bl	8007510 <chprintf>
      chprintf(chp, "logout");
 8007856:	493f      	ldr	r1, [pc, #252]	; (8007954 <shellThread+0x1b4>)
 8007858:	0030      	movs	r0, r6
 800785a:	f7ff fe59 	bl	8007510 <chprintf>
 800785e:	b672      	cpsid	i
 8007860:	2100      	movs	r1, #0
 8007862:	483d      	ldr	r0, [pc, #244]	; (8007958 <shellThread+0x1b8>)
 8007864:	f7fc fc84 	bl	8004170 <chEvtBroadcastFlagsI>
  chThdExitS(msg);
 8007868:	2000      	movs	r0, #0
 800786a:	f7fc faf9 	bl	8003e60 <chThdExitS>
}
 800786e:	b01b      	add	sp, #108	; 0x6c
 8007870:	bc3c      	pop	{r2, r3, r4, r5}
 8007872:	4690      	mov	r8, r2
 8007874:	4699      	mov	r9, r3
 8007876:	46a2      	mov	sl, r4
 8007878:	46ab      	mov	fp, r5
 800787a:	bdf0      	pop	{r4, r5, r6, r7, pc}
  while (scp->sc_name != NULL) {
 800787c:	4d37      	ldr	r5, [pc, #220]	; (800795c <shellThread+0x1bc>)
 800787e:	6828      	ldr	r0, [r5, #0]
 8007880:	2800      	cmp	r0, #0
 8007882:	d104      	bne.n	800788e <shellThread+0xee>
 8007884:	e028      	b.n	80078d8 <shellThread+0x138>
    scp++;
 8007886:	3508      	adds	r5, #8
  while (scp->sc_name != NULL) {
 8007888:	6828      	ldr	r0, [r5, #0]
 800788a:	2800      	cmp	r0, #0
 800788c:	d024      	beq.n	80078d8 <shellThread+0x138>
    if (strcmp(scp->sc_name, name) == 0) {
 800788e:	0039      	movs	r1, r7
 8007890:	f7fb ff9e 	bl	80037d0 <strcmp>
 8007894:	2800      	cmp	r0, #0
 8007896:	d1f6      	bne.n	8007886 <shellThread+0xe6>
      scp->sc_function(chp, argc, argv);
 8007898:	686b      	ldr	r3, [r5, #4]
 800789a:	aa04      	add	r2, sp, #16
 800789c:	0021      	movs	r1, r4
 800789e:	0030      	movs	r0, r6
 80078a0:	4798      	blx	r3
      return false;
 80078a2:	e794      	b.n	80077ce <shellThread+0x2e>
        chprintf(chp, "Commands: help ");
 80078a4:	492e      	ldr	r1, [pc, #184]	; (8007960 <shellThread+0x1c0>)
 80078a6:	0030      	movs	r0, r6
 80078a8:	f7ff fe32 	bl	8007510 <chprintf>
  while (scp->sc_name != NULL) {
 80078ac:	4b2b      	ldr	r3, [pc, #172]	; (800795c <shellThread+0x1bc>)
 80078ae:	681a      	ldr	r2, [r3, #0]
 80078b0:	2a00      	cmp	r2, #0
 80078b2:	d009      	beq.n	80078c8 <shellThread+0x128>
 80078b4:	001c      	movs	r4, r3
 80078b6:	4d2b      	ldr	r5, [pc, #172]	; (8007964 <shellThread+0x1c4>)
    chprintf(chp, "%s ", scp->sc_name);
 80078b8:	0029      	movs	r1, r5
 80078ba:	0030      	movs	r0, r6
    scp++;
 80078bc:	3408      	adds	r4, #8
    chprintf(chp, "%s ", scp->sc_name);
 80078be:	f7ff fe27 	bl	8007510 <chprintf>
  while (scp->sc_name != NULL) {
 80078c2:	6822      	ldr	r2, [r4, #0]
 80078c4:	2a00      	cmp	r2, #0
 80078c6:	d1f7      	bne.n	80078b8 <shellThread+0x118>
        if (scp != NULL)
 80078c8:	9c01      	ldr	r4, [sp, #4]
 80078ca:	2c00      	cmp	r4, #0
 80078cc:	d11b      	bne.n	8007906 <shellThread+0x166>
        chprintf(chp, SHELL_NEWLINE_STR);
 80078ce:	4651      	mov	r1, sl
 80078d0:	0030      	movs	r0, r6
 80078d2:	f7ff fe1d 	bl	8007510 <chprintf>
 80078d6:	e77a      	b.n	80077ce <shellThread+0x2e>
      else if (cmdexec(shell_local_commands, chp, cmd, n, args) &&
 80078d8:	9b01      	ldr	r3, [sp, #4]
 80078da:	2b00      	cmp	r3, #0
 80078dc:	d024      	beq.n	8007928 <shellThread+0x188>
  while (scp->sc_name != NULL) {
 80078de:	6818      	ldr	r0, [r3, #0]
 80078e0:	2800      	cmp	r0, #0
 80078e2:	d021      	beq.n	8007928 <shellThread+0x188>
 80078e4:	001d      	movs	r5, r3
 80078e6:	e003      	b.n	80078f0 <shellThread+0x150>
    scp++;
 80078e8:	3508      	adds	r5, #8
  while (scp->sc_name != NULL) {
 80078ea:	6828      	ldr	r0, [r5, #0]
 80078ec:	2800      	cmp	r0, #0
 80078ee:	d01b      	beq.n	8007928 <shellThread+0x188>
    if (strcmp(scp->sc_name, name) == 0) {
 80078f0:	0039      	movs	r1, r7
 80078f2:	f7fb ff6d 	bl	80037d0 <strcmp>
 80078f6:	2800      	cmp	r0, #0
 80078f8:	d1f6      	bne.n	80078e8 <shellThread+0x148>
      scp->sc_function(chp, argc, argv);
 80078fa:	686b      	ldr	r3, [r5, #4]
 80078fc:	aa04      	add	r2, sp, #16
 80078fe:	0021      	movs	r1, r4
 8007900:	0030      	movs	r0, r6
 8007902:	4798      	blx	r3
      return false;
 8007904:	e763      	b.n	80077ce <shellThread+0x2e>
  while (scp->sc_name != NULL) {
 8007906:	6822      	ldr	r2, [r4, #0]
 8007908:	2a00      	cmp	r2, #0
 800790a:	d0e0      	beq.n	80078ce <shellThread+0x12e>
 800790c:	4d15      	ldr	r5, [pc, #84]	; (8007964 <shellThread+0x1c4>)
    chprintf(chp, "%s ", scp->sc_name);
 800790e:	0029      	movs	r1, r5
 8007910:	0030      	movs	r0, r6
    scp++;
 8007912:	3408      	adds	r4, #8
    chprintf(chp, "%s ", scp->sc_name);
 8007914:	f7ff fdfc 	bl	8007510 <chprintf>
  while (scp->sc_name != NULL) {
 8007918:	6822      	ldr	r2, [r4, #0]
 800791a:	2a00      	cmp	r2, #0
 800791c:	d1f7      	bne.n	800790e <shellThread+0x16e>
        chprintf(chp, SHELL_NEWLINE_STR);
 800791e:	4651      	mov	r1, sl
 8007920:	0030      	movs	r0, r6
 8007922:	f7ff fdf5 	bl	8007510 <chprintf>
 8007926:	e752      	b.n	80077ce <shellThread+0x2e>
        chprintf(chp, "%s", cmd);
 8007928:	003a      	movs	r2, r7
 800792a:	490f      	ldr	r1, [pc, #60]	; (8007968 <shellThread+0x1c8>)
 800792c:	0030      	movs	r0, r6
 800792e:	f7ff fdef 	bl	8007510 <chprintf>
        chprintf(chp, " ?"SHELL_NEWLINE_STR);
 8007932:	490e      	ldr	r1, [pc, #56]	; (800796c <shellThread+0x1cc>)
 8007934:	0030      	movs	r0, r6
 8007936:	f7ff fdeb 	bl	8007510 <chprintf>
 800793a:	e748      	b.n	80077ce <shellThread+0x2e>
 800793c:	08013f50 	.word	0x08013f50
 8007940:	080139b4 	.word	0x080139b4
 8007944:	080139c8 	.word	0x080139c8
 8007948:	080139f0 	.word	0x080139f0
 800794c:	080139f8 	.word	0x080139f8
 8007950:	080139d8 	.word	0x080139d8
 8007954:	080139d0 	.word	0x080139d0
 8007958:	20001a08 	.word	0x20001a08
 800795c:	20000408 	.word	0x20000408
 8007960:	08013a04 	.word	0x08013a04
 8007964:	08013a14 	.word	0x08013a14
 8007968:	08013a18 	.word	0x08013a18
 800796c:	08013a1c 	.word	0x08013a1c

08007970 <cmd_info>:
  shellExit(MSG_OK);
}
#endif

#if (SHELL_CMD_INFO_ENABLED == TRUE) || defined(__DOXYGEN__)
static void cmd_info(BaseSequentialStream *chp, int argc, char *argv[]) {
 8007970:	b510      	push	{r4, lr}
 8007972:	0004      	movs	r4, r0
 8007974:	b082      	sub	sp, #8

  (void)argv;
  if (argc > 0) {
 8007976:	2900      	cmp	r1, #0
 8007978:	dc2b      	bgt.n	80079d2 <cmd_info+0x62>
    shellUsage(chp, "info");
    return;
  }

  chprintf(chp, "Kernel:       %s"SHELL_NEWLINE_STR, CH_KERNEL_VERSION);
 800797a:	4a18      	ldr	r2, [pc, #96]	; (80079dc <cmd_info+0x6c>)
 800797c:	4918      	ldr	r1, [pc, #96]	; (80079e0 <cmd_info+0x70>)
 800797e:	f7ff fdc7 	bl	8007510 <chprintf>
#ifdef PORT_COMPILER_NAME
  chprintf(chp, "Compiler:     %s"SHELL_NEWLINE_STR, PORT_COMPILER_NAME);
 8007982:	4a18      	ldr	r2, [pc, #96]	; (80079e4 <cmd_info+0x74>)
 8007984:	4918      	ldr	r1, [pc, #96]	; (80079e8 <cmd_info+0x78>)
 8007986:	0020      	movs	r0, r4
 8007988:	f7ff fdc2 	bl	8007510 <chprintf>
#endif
  chprintf(chp, "Architecture: %s"SHELL_NEWLINE_STR, PORT_ARCHITECTURE_NAME);
 800798c:	4a17      	ldr	r2, [pc, #92]	; (80079ec <cmd_info+0x7c>)
 800798e:	4918      	ldr	r1, [pc, #96]	; (80079f0 <cmd_info+0x80>)
 8007990:	0020      	movs	r0, r4
 8007992:	f7ff fdbd 	bl	8007510 <chprintf>
#ifdef PORT_CORE_VARIANT_NAME
  chprintf(chp, "Core Variant: %s"SHELL_NEWLINE_STR, PORT_CORE_VARIANT_NAME);
 8007996:	4a17      	ldr	r2, [pc, #92]	; (80079f4 <cmd_info+0x84>)
 8007998:	4917      	ldr	r1, [pc, #92]	; (80079f8 <cmd_info+0x88>)
 800799a:	0020      	movs	r0, r4
 800799c:	f7ff fdb8 	bl	8007510 <chprintf>
#endif
#ifdef PORT_INFO
  chprintf(chp, "Port Info:    %s"SHELL_NEWLINE_STR, PORT_INFO);
 80079a0:	4a16      	ldr	r2, [pc, #88]	; (80079fc <cmd_info+0x8c>)
 80079a2:	4917      	ldr	r1, [pc, #92]	; (8007a00 <cmd_info+0x90>)
 80079a4:	0020      	movs	r0, r4
 80079a6:	f7ff fdb3 	bl	8007510 <chprintf>
#endif
#ifdef PLATFORM_NAME
  chprintf(chp, "Platform:     %s"SHELL_NEWLINE_STR, PLATFORM_NAME);
 80079aa:	4a16      	ldr	r2, [pc, #88]	; (8007a04 <cmd_info+0x94>)
 80079ac:	4916      	ldr	r1, [pc, #88]	; (8007a08 <cmd_info+0x98>)
 80079ae:	0020      	movs	r0, r4
 80079b0:	f7ff fdae 	bl	8007510 <chprintf>
#endif
#ifdef BOARD_NAME
  chprintf(chp, "Board:        %s"SHELL_NEWLINE_STR, BOARD_NAME);
 80079b4:	4a15      	ldr	r2, [pc, #84]	; (8007a0c <cmd_info+0x9c>)
 80079b6:	4916      	ldr	r1, [pc, #88]	; (8007a10 <cmd_info+0xa0>)
 80079b8:	0020      	movs	r0, r4
 80079ba:	f7ff fda9 	bl	8007510 <chprintf>
#endif
#ifdef __DATE__
#ifdef __TIME__
  chprintf(chp, "Build time:   %s%s%s"SHELL_NEWLINE_STR, __DATE__, " - ", __TIME__);
 80079be:	4b15      	ldr	r3, [pc, #84]	; (8007a14 <cmd_info+0xa4>)
 80079c0:	4a15      	ldr	r2, [pc, #84]	; (8007a18 <cmd_info+0xa8>)
 80079c2:	9300      	str	r3, [sp, #0]
 80079c4:	4915      	ldr	r1, [pc, #84]	; (8007a1c <cmd_info+0xac>)
 80079c6:	4b16      	ldr	r3, [pc, #88]	; (8007a20 <cmd_info+0xb0>)
 80079c8:	0020      	movs	r0, r4
 80079ca:	f7ff fda1 	bl	8007510 <chprintf>
#endif
#endif
}
 80079ce:	b002      	add	sp, #8
 80079d0:	bd10      	pop	{r4, pc}
    shellUsage(chp, "info");
 80079d2:	4a14      	ldr	r2, [pc, #80]	; (8007a24 <cmd_info+0xb4>)
 80079d4:	4914      	ldr	r1, [pc, #80]	; (8007a28 <cmd_info+0xb8>)
 80079d6:	f7ff fd9b 	bl	8007510 <chprintf>
    return;
 80079da:	e7f8      	b.n	80079ce <cmd_info+0x5e>
 80079dc:	08013a34 	.word	0x08013a34
 80079e0:	08013a3c 	.word	0x08013a3c
 80079e4:	08013a50 	.word	0x08013a50
 80079e8:	08013a8c 	.word	0x08013a8c
 80079ec:	08013aa0 	.word	0x08013aa0
 80079f0:	08013aa8 	.word	0x08013aa8
 80079f4:	08013abc 	.word	0x08013abc
 80079f8:	08013ac8 	.word	0x08013ac8
 80079fc:	08013adc 	.word	0x08013adc
 8007a00:	08013af4 	.word	0x08013af4
 8007a04:	08013b08 	.word	0x08013b08
 8007a08:	08013b38 	.word	0x08013b38
 8007a0c:	08013b4c 	.word	0x08013b4c
 8007a10:	08013b58 	.word	0x08013b58
 8007a14:	08013b94 	.word	0x08013b94
 8007a18:	08013b70 	.word	0x08013b70
 8007a1c:	08013b7c 	.word	0x08013b7c
 8007a20:	08013b6c 	.word	0x08013b6c
 8007a24:	08013a2c 	.word	0x08013a2c
 8007a28:	080139f8 	.word	0x080139f8
 8007a2c:	00000000 	.word	0x00000000

08007a30 <cmd_threads>:
  chprintf(chp, "heap free largest: %u bytes"SHELL_NEWLINE_STR, largest);
}
#endif

#if (SHELL_CMD_THREADS_ENABLED == TRUE) || defined(__DOXYGEN__)
static void cmd_threads(BaseSequentialStream *chp, int argc, char *argv[]) {
 8007a30:	b5f0      	push	{r4, r5, r6, r7, lr}
 8007a32:	4645      	mov	r5, r8
 8007a34:	46de      	mov	lr, fp
 8007a36:	4657      	mov	r7, sl
 8007a38:	464e      	mov	r6, r9
 8007a3a:	b5e0      	push	{r5, r6, r7, lr}
 8007a3c:	0005      	movs	r5, r0
 8007a3e:	b087      	sub	sp, #28
  static const char *states[] = {CH_STATE_NAMES};
  thread_t *tp;

  (void)argv;
  if (argc > 0) {
 8007a40:	2900      	cmp	r1, #0
 8007a42:	dc2e      	bgt.n	8007aa2 <cmd_threads+0x72>
    shellUsage(chp, "threads");
    return;
  }
  chprintf(chp, "stklimit    stack     addr refs prio     state         name\r\n"SHELL_NEWLINE_STR);
 8007a44:	491c      	ldr	r1, [pc, #112]	; (8007ab8 <cmd_threads+0x88>)
 8007a46:	f7ff fd63 	bl	8007510 <chprintf>
  tp = chRegFirstThread();
 8007a4a:	f7fc fac1 	bl	8003fd0 <chRegFirstThread>
 8007a4e:	4b1b      	ldr	r3, [pc, #108]	; (8007abc <cmd_threads+0x8c>)
 8007a50:	0004      	movs	r4, r0
 8007a52:	4699      	mov	r9, r3
 8007a54:	4b1a      	ldr	r3, [pc, #104]	; (8007ac0 <cmd_threads+0x90>)
#else
    uint32_t stklimit = 0U;
#endif
    chprintf(chp, "%08lx %08lx %08lx %4lu %4lu %9s %12s"SHELL_NEWLINE_STR,
             stklimit, (uint32_t)tp->ctx.sp, (uint32_t)tp,
             (uint32_t)tp->refs - 1, (uint32_t)tp->prio, states[tp->state],
 8007a56:	2722      	movs	r7, #34	; 0x22
 8007a58:	4698      	mov	r8, r3
    chprintf(chp, "%08lx %08lx %08lx %4lu %4lu %9s %12s"SHELL_NEWLINE_STR,
 8007a5a:	4b1a      	ldr	r3, [pc, #104]	; (8007ac4 <cmd_threads+0x94>)
 8007a5c:	469a      	mov	sl, r3
 8007a5e:	e00f      	b.n	8007a80 <cmd_threads+0x50>
 8007a60:	9004      	str	r0, [sp, #16]
 8007a62:	4658      	mov	r0, fp
 8007a64:	9003      	str	r0, [sp, #12]
 8007a66:	4660      	mov	r0, ip
 8007a68:	9101      	str	r1, [sp, #4]
 8007a6a:	9002      	str	r0, [sp, #8]
 8007a6c:	9400      	str	r4, [sp, #0]
 8007a6e:	4641      	mov	r1, r8
 8007a70:	0028      	movs	r0, r5
 8007a72:	f7ff fd4d 	bl	8007510 <chprintf>
             tp->name == NULL ? "" : tp->name);
    tp = chRegNextThread(tp);
 8007a76:	0020      	movs	r0, r4
 8007a78:	f7fc fab2 	bl	8003fe0 <chRegNextThread>
 8007a7c:	1e04      	subs	r4, r0, #0
  } while (tp != NULL);
 8007a7e:	d014      	beq.n	8007aaa <cmd_threads+0x7a>
             (uint32_t)tp->refs - 1, (uint32_t)tp->prio, states[tp->state],
 8007a80:	68a0      	ldr	r0, [r4, #8]
    chprintf(chp, "%08lx %08lx %08lx %4lu %4lu %9s %12s"SHELL_NEWLINE_STR,
 8007a82:	464e      	mov	r6, r9
             (uint32_t)tp->refs - 1, (uint32_t)tp->prio, states[tp->state],
 8007a84:	4684      	mov	ip, r0
 8007a86:	2020      	movs	r0, #32
 8007a88:	5c20      	ldrb	r0, [r4, r0]
 8007a8a:	5de1      	ldrb	r1, [r4, r7]
    chprintf(chp, "%08lx %08lx %08lx %4lu %4lu %9s %12s"SHELL_NEWLINE_STR,
 8007a8c:	0080      	lsls	r0, r0, #2
 8007a8e:	5830      	ldr	r0, [r6, r0]
    uint32_t stklimit = (uint32_t)tp->wabase;
 8007a90:	69e2      	ldr	r2, [r4, #28]
    chprintf(chp, "%08lx %08lx %08lx %4lu %4lu %9s %12s"SHELL_NEWLINE_STR,
 8007a92:	4683      	mov	fp, r0
             tp->name == NULL ? "" : tp->name);
 8007a94:	69a0      	ldr	r0, [r4, #24]
    chprintf(chp, "%08lx %08lx %08lx %4lu %4lu %9s %12s"SHELL_NEWLINE_STR,
 8007a96:	68e3      	ldr	r3, [r4, #12]
 8007a98:	3901      	subs	r1, #1
 8007a9a:	2800      	cmp	r0, #0
 8007a9c:	d1e0      	bne.n	8007a60 <cmd_threads+0x30>
 8007a9e:	4650      	mov	r0, sl
 8007aa0:	e7de      	b.n	8007a60 <cmd_threads+0x30>
    shellUsage(chp, "threads");
 8007aa2:	4a09      	ldr	r2, [pc, #36]	; (8007ac8 <cmd_threads+0x98>)
 8007aa4:	4909      	ldr	r1, [pc, #36]	; (8007acc <cmd_threads+0x9c>)
 8007aa6:	f7ff fd33 	bl	8007510 <chprintf>
}
 8007aaa:	b007      	add	sp, #28
 8007aac:	bc3c      	pop	{r2, r3, r4, r5}
 8007aae:	4690      	mov	r8, r2
 8007ab0:	4699      	mov	r9, r3
 8007ab2:	46a2      	mov	sl, r4
 8007ab4:	46ab      	mov	fp, r5
 8007ab6:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8007ab8:	08013ba8 	.word	0x08013ba8
 8007abc:	08013c10 	.word	0x08013c10
 8007ac0:	08013be8 	.word	0x08013be8
 8007ac4:	08013f2c 	.word	0x08013f2c
 8007ac8:	08013ba0 	.word	0x08013ba0
 8007acc:	080139f8 	.word	0x080139f8

08007ad0 <cmd_exit>:
static void cmd_exit(BaseSequentialStream *chp, int argc, char *argv[]) {
 8007ad0:	b510      	push	{r4, lr}
  if (argc > 0) {
 8007ad2:	2900      	cmp	r1, #0
 8007ad4:	dc03      	bgt.n	8007ade <cmd_exit+0xe>
  shellExit(MSG_OK);
 8007ad6:	2000      	movs	r0, #0
 8007ad8:	f7ff fdf2 	bl	80076c0 <shellExit>
}
 8007adc:	bd10      	pop	{r4, pc}
    shellUsage(chp, "exit");
 8007ade:	4a02      	ldr	r2, [pc, #8]	; (8007ae8 <cmd_exit+0x18>)
 8007ae0:	4902      	ldr	r1, [pc, #8]	; (8007aec <cmd_exit+0x1c>)
 8007ae2:	f7ff fd15 	bl	8007510 <chprintf>
    return;
 8007ae6:	e7f9      	b.n	8007adc <cmd_exit+0xc>
 8007ae8:	08013a24 	.word	0x08013a24
 8007aec:	080139f8 	.word	0x080139f8

08007af0 <get_descriptor>:
                                           uint8_t dindex,
                                           uint16_t lang) {

  (void)usbp;
  (void)lang;
  switch (dtype) {
 8007af0:	2902      	cmp	r1, #2
 8007af2:	d00e      	beq.n	8007b12 <get_descriptor+0x22>
 8007af4:	2903      	cmp	r1, #3
 8007af6:	d005      	beq.n	8007b04 <get_descriptor+0x14>
 8007af8:	2901      	cmp	r1, #1
 8007afa:	d001      	beq.n	8007b00 <get_descriptor+0x10>
    return &vcom_configuration_descriptor;
  case USB_DESCRIPTOR_STRING:
    if (dindex < 4)
      return &vcom_strings[dindex];
  }
  return NULL;
 8007afc:	2000      	movs	r0, #0
}
 8007afe:	4770      	bx	lr
    return &vcom_device_descriptor;
 8007b00:	4805      	ldr	r0, [pc, #20]	; (8007b18 <get_descriptor+0x28>)
 8007b02:	e7fc      	b.n	8007afe <get_descriptor+0xe>
  return NULL;
 8007b04:	2000      	movs	r0, #0
    if (dindex < 4)
 8007b06:	2a03      	cmp	r2, #3
 8007b08:	d8f9      	bhi.n	8007afe <get_descriptor+0xe>
      return &vcom_strings[dindex];
 8007b0a:	4804      	ldr	r0, [pc, #16]	; (8007b1c <get_descriptor+0x2c>)
 8007b0c:	00d2      	lsls	r2, r2, #3
 8007b0e:	1880      	adds	r0, r0, r2
 8007b10:	e7f5      	b.n	8007afe <get_descriptor+0xe>
    return &vcom_configuration_descriptor;
 8007b12:	4803      	ldr	r0, [pc, #12]	; (8007b20 <get_descriptor+0x30>)
 8007b14:	e7f3      	b.n	8007afe <get_descriptor+0xe>
 8007b16:	46c0      	nop			; (mov r8, r8)
 8007b18:	08013d88 	.word	0x08013d88
 8007b1c:	08013e10 	.word	0x08013e10
 8007b20:	08013d3c 	.word	0x08013d3c
	...

08007b30 <sof_handler>:
}

/*
 * Handles the USB driver global events.
 */
static void sof_handler(USBDriver *usbp) {
 8007b30:	b510      	push	{r4, lr}
 8007b32:	b672      	cpsid	i

  (void)usbp;

  osalSysLockFromISR();
  sduSOFHookI(&SDU1);
 8007b34:	4802      	ldr	r0, [pc, #8]	; (8007b40 <sof_handler+0x10>)
 8007b36:	f7fd fa53 	bl	8004fe0 <sduSOFHookI>
  __ASM volatile ("cpsie i" : : : "memory");
 8007b3a:	b662      	cpsie	i
  osalSysUnlockFromISR();
}
 8007b3c:	bd10      	pop	{r4, pc}
 8007b3e:	46c0      	nop			; (mov r8, r8)
 8007b40:	20001a0c 	.word	0x20001a0c
	...

08007b50 <usb_event>:
static void usb_event(USBDriver *usbp, usbevent_t event) {
 8007b50:	b510      	push	{r4, lr}
 8007b52:	0004      	movs	r4, r0
  switch (event) {
 8007b54:	2902      	cmp	r1, #2
 8007b56:	d007      	beq.n	8007b68 <usb_event+0x18>
 8007b58:	2903      	cmp	r1, #3
 8007b5a:	d104      	bne.n	8007b66 <usb_event+0x16>
  __ASM volatile ("cpsid i" : : : "memory");
 8007b5c:	b672      	cpsid	i
    sduDisconnectI(&SDU1);
 8007b5e:	480a      	ldr	r0, [pc, #40]	; (8007b88 <usb_event+0x38>)
 8007b60:	f7fd f9ee 	bl	8004f40 <sduDisconnectI>
  __ASM volatile ("cpsie i" : : : "memory");
 8007b64:	b662      	cpsie	i
}
 8007b66:	bd10      	pop	{r4, pc}
  __ASM volatile ("cpsid i" : : : "memory");
 8007b68:	b672      	cpsid	i
    usbInitEndpointI(usbp, USBD1_DATA_REQUEST_EP, &ep1config);
 8007b6a:	4a08      	ldr	r2, [pc, #32]	; (8007b8c <usb_event+0x3c>)
 8007b6c:	2101      	movs	r1, #1
 8007b6e:	f7fd fb37 	bl	80051e0 <usbInitEndpointI>
    usbInitEndpointI(usbp, USBD1_INTERRUPT_REQUEST_EP, &ep2config);
 8007b72:	4a07      	ldr	r2, [pc, #28]	; (8007b90 <usb_event+0x40>)
 8007b74:	2102      	movs	r1, #2
 8007b76:	0020      	movs	r0, r4
 8007b78:	f7fd fb32 	bl	80051e0 <usbInitEndpointI>
    sduConfigureHookI(&SDU1);
 8007b7c:	4802      	ldr	r0, [pc, #8]	; (8007b88 <usb_event+0x38>)
 8007b7e:	f7fd f9ef 	bl	8004f60 <sduConfigureHookI>
  __ASM volatile ("cpsie i" : : : "memory");
 8007b82:	b662      	cpsie	i
 8007b84:	e7ef      	b.n	8007b66 <usb_event+0x16>
 8007b86:	46c0      	nop			; (mov r8, r8)
 8007b88:	20001a0c 	.word	0x20001a0c
 8007b8c:	08013cdc 	.word	0x08013cdc
 8007b90:	08013d00 	.word	0x08013d00
	...

08007ba0 <cmd_pause>:
    }
}

static void pause_sweep(void)
{
    sweep_enabled = FALSE;
 8007ba0:	2200      	movs	r2, #0
 8007ba2:	4b01      	ldr	r3, [pc, #4]	; (8007ba8 <cmd_pause+0x8>)
 8007ba4:	701a      	strb	r2, [r3, #0]
{
    (void)chp;
    (void)argc;
    (void)argv;
    pause_sweep();
}
 8007ba6:	4770      	bx	lr
 8007ba8:	20001630 	.word	0x20001630
 8007bac:	00000000 	.word	0x00000000

08007bb0 <freq_mode_startstop>:
  chMtxUnlock(&mutex_sweep);
}

static void freq_mode_startstop(void)
{
  if (frequency1 <= 0) {
 8007bb0:	4a0b      	ldr	r2, [pc, #44]	; (8007be0 <freq_mode_startstop+0x30>)
{
 8007bb2:	b510      	push	{r4, lr}
  if (frequency1 <= 0) {
 8007bb4:	6893      	ldr	r3, [r2, #8]
 8007bb6:	2b00      	cmp	r3, #0
 8007bb8:	dd00      	ble.n	8007bbc <freq_mode_startstop+0xc>
    int span = -frequency1;
    ensure_edit_config();
    frequency0 = center - span/2;
    frequency1 = center + span/2;
  }
}
 8007bba:	bd10      	pop	{r4, pc}
  if (active_props == &current_props)
 8007bbc:	4909      	ldr	r1, [pc, #36]	; (8007be4 <freq_mode_startstop+0x34>)
    int center = frequency0;
 8007bbe:	6850      	ldr	r0, [r2, #4]
  if (active_props == &current_props)
 8007bc0:	680c      	ldr	r4, [r1, #0]
    int span = -frequency1;
 8007bc2:	425b      	negs	r3, r3
  if (active_props == &current_props)
 8007bc4:	4294      	cmp	r4, r2
 8007bc6:	d002      	beq.n	8007bce <freq_mode_startstop+0x1e>
  active_props = &current_props;
 8007bc8:	600a      	str	r2, [r1, #0]
  cal_status = 0;
 8007bca:	2100      	movs	r1, #0
 8007bcc:	81d1      	strh	r1, [r2, #14]
    frequency0 = center - span/2;
 8007bce:	0fd9      	lsrs	r1, r3, #31
 8007bd0:	18c9      	adds	r1, r1, r3
 8007bd2:	1049      	asrs	r1, r1, #1
    frequency1 = center + span/2;
 8007bd4:	105b      	asrs	r3, r3, #1
    frequency0 = center - span/2;
 8007bd6:	1a41      	subs	r1, r0, r1
    frequency1 = center + span/2;
 8007bd8:	181b      	adds	r3, r3, r0
    frequency0 = center - span/2;
 8007bda:	6051      	str	r1, [r2, #4]
    frequency1 = center + span/2;
 8007bdc:	6093      	str	r3, [r2, #8]
}
 8007bde:	e7ec      	b.n	8007bba <freq_mode_startstop+0xa>
 8007be0:	20000454 	.word	0x20000454
 8007be4:	20000428 	.word	0x20000428
	...

08007bf0 <eterm_calc_er>:
  cal_status &= ~CALSTAT_OPEN;
  cal_status |= CALSTAT_ES;
}

static void eterm_calc_er(int sign)
{
 8007bf0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8007bf2:	46de      	mov	lr, fp
 8007bf4:	4657      	mov	r7, sl
 8007bf6:	464e      	mov	r6, r9
 8007bf8:	4645      	mov	r5, r8
 8007bfa:	b5e0      	push	{r5, r6, r7, lr}
  int i;
  for (i = 0; i < sweep_points; i++) {
 8007bfc:	4b47      	ldr	r3, [pc, #284]	; (8007d1c <eterm_calc_er+0x12c>)
{
 8007bfe:	b085      	sub	sp, #20
 8007c00:	9001      	str	r0, [sp, #4]
  for (i = 0; i < sweep_points; i++) {
 8007c02:	220c      	movs	r2, #12
 8007c04:	5e9b      	ldrsh	r3, [r3, r2]
 8007c06:	9303      	str	r3, [sp, #12]
 8007c08:	2b00      	cmp	r3, #0
 8007c0a:	dd77      	ble.n	8007cfc <eterm_calc_er+0x10c>
    // Er = sign*(1-sign*Es)S11ms'
    float s11sr = cal_data[CAL_SHORT][i][0] - cal_data[ETERM_ED][i][0];
 8007c0c:	4b44      	ldr	r3, [pc, #272]	; (8007d20 <eterm_calc_er+0x130>)
 8007c0e:	681c      	ldr	r4, [r3, #0]
 8007c10:	4b44      	ldr	r3, [pc, #272]	; (8007d24 <eterm_calc_er+0x134>)
 8007c12:	0027      	movs	r7, r4
 8007c14:	18e6      	adds	r6, r4, r3
 8007c16:	4b44      	ldr	r3, [pc, #272]	; (8007d28 <eterm_calc_er+0x138>)
 8007c18:	37a5      	adds	r7, #165	; 0xa5
 8007c1a:	469c      	mov	ip, r3
  for (i = 0; i < sweep_points; i++) {
 8007c1c:	2300      	movs	r3, #0
 8007c1e:	37ff      	adds	r7, #255	; 0xff
 8007c20:	4464      	add	r4, ip
 8007c22:	469b      	mov	fp, r3
 8007c24:	e02f      	b.n	8007c86 <eterm_calc_er+0x96>
    float s11si = cal_data[CAL_SHORT][i][1] - cal_data[ETERM_ED][i][1];
    float esr = cal_data[ETERM_ES][i][0];
    float esi = cal_data[ETERM_ES][i][1];
    if (sign > 0) {
      esr = -esr;
      esi = -esi;
 8007c26:	2380      	movs	r3, #128	; 0x80
 8007c28:	1c01      	adds	r1, r0, #0
 8007c2a:	061b      	lsls	r3, r3, #24
 8007c2c:	20fe      	movs	r0, #254	; 0xfe
 8007c2e:	469c      	mov	ip, r3
 8007c30:	0580      	lsls	r0, r0, #22
 8007c32:	4465      	add	r5, ip
    }
    esr = 1 + esr;
 8007c34:	f7f9 faf4 	bl	8001220 <__aeabi_fsub>
    float err = esr * s11sr - esi * s11si;
 8007c38:	4649      	mov	r1, r9
 8007c3a:	9002      	str	r0, [sp, #8]
 8007c3c:	f7f9 f9d8 	bl	8000ff0 <__aeabi_fmul>
 8007c40:	1c29      	adds	r1, r5, #0
 8007c42:	4680      	mov	r8, r0
 8007c44:	4650      	mov	r0, sl
 8007c46:	f7f9 f9d3 	bl	8000ff0 <__aeabi_fmul>
 8007c4a:	1c01      	adds	r1, r0, #0
 8007c4c:	4640      	mov	r0, r8
 8007c4e:	f7f9 fae7 	bl	8001220 <__aeabi_fsub>
    float eri = esr * s11si + esi * s11sr;
 8007c52:	4651      	mov	r1, sl
    float err = esr * s11sr - esi * s11si;
 8007c54:	4680      	mov	r8, r0
    float eri = esr * s11si + esi * s11sr;
 8007c56:	9802      	ldr	r0, [sp, #8]
 8007c58:	f7f9 f9ca 	bl	8000ff0 <__aeabi_fmul>
 8007c5c:	1c29      	adds	r1, r5, #0
 8007c5e:	4682      	mov	sl, r0
 8007c60:	4648      	mov	r0, r9
 8007c62:	f7f9 f9c5 	bl	8000ff0 <__aeabi_fmul>
 8007c66:	1c01      	adds	r1, r0, #0
 8007c68:	4650      	mov	r0, sl
 8007c6a:	f7f8 fe61 	bl	8000930 <__aeabi_fadd>
    if (sign < 0) {
      err = -err;
      eri = -eri;
    }
    cal_data[ETERM_ER][i][0] = err;
 8007c6e:	4643      	mov	r3, r8
 8007c70:	6023      	str	r3, [r4, #0]
  for (i = 0; i < sweep_points; i++) {
 8007c72:	2301      	movs	r3, #1
 8007c74:	469c      	mov	ip, r3
 8007c76:	9b03      	ldr	r3, [sp, #12]
 8007c78:	44e3      	add	fp, ip
    cal_data[ETERM_ER][i][1] = eri;
 8007c7a:	6060      	str	r0, [r4, #4]
 8007c7c:	3708      	adds	r7, #8
 8007c7e:	3608      	adds	r6, #8
 8007c80:	3408      	adds	r4, #8
  for (i = 0; i < sweep_points; i++) {
 8007c82:	459b      	cmp	fp, r3
 8007c84:	da3a      	bge.n	8007cfc <eterm_calc_er+0x10c>
    float s11sr = cal_data[CAL_SHORT][i][0] - cal_data[ETERM_ED][i][0];
 8007c86:	6839      	ldr	r1, [r7, #0]
 8007c88:	6820      	ldr	r0, [r4, #0]
 8007c8a:	f7f9 fac9 	bl	8001220 <__aeabi_fsub>
    float s11si = cal_data[CAL_SHORT][i][1] - cal_data[ETERM_ED][i][1];
 8007c8e:	6879      	ldr	r1, [r7, #4]
    float s11sr = cal_data[CAL_SHORT][i][0] - cal_data[ETERM_ED][i][0];
 8007c90:	4681      	mov	r9, r0
    float s11si = cal_data[CAL_SHORT][i][1] - cal_data[ETERM_ED][i][1];
 8007c92:	6860      	ldr	r0, [r4, #4]
 8007c94:	f7f9 fac4 	bl	8001220 <__aeabi_fsub>
    if (sign > 0) {
 8007c98:	9b01      	ldr	r3, [sp, #4]
    float s11si = cal_data[CAL_SHORT][i][1] - cal_data[ETERM_ED][i][1];
 8007c9a:	4682      	mov	sl, r0
    float esi = cal_data[ETERM_ES][i][1];
 8007c9c:	6875      	ldr	r5, [r6, #4]
    float esr = cal_data[ETERM_ES][i][0];
 8007c9e:	6830      	ldr	r0, [r6, #0]
    if (sign > 0) {
 8007ca0:	2b01      	cmp	r3, #1
 8007ca2:	d0c0      	beq.n	8007c26 <eterm_calc_er+0x36>
    esr = 1 + esr;
 8007ca4:	21fe      	movs	r1, #254	; 0xfe
 8007ca6:	0589      	lsls	r1, r1, #22
 8007ca8:	f7f8 fe42 	bl	8000930 <__aeabi_fadd>
    float err = esr * s11sr - esi * s11si;
 8007cac:	1c01      	adds	r1, r0, #0
 8007cae:	9002      	str	r0, [sp, #8]
 8007cb0:	4648      	mov	r0, r9
 8007cb2:	f7f9 f99d 	bl	8000ff0 <__aeabi_fmul>
 8007cb6:	1c29      	adds	r1, r5, #0
 8007cb8:	4680      	mov	r8, r0
 8007cba:	4650      	mov	r0, sl
 8007cbc:	f7f9 f998 	bl	8000ff0 <__aeabi_fmul>
 8007cc0:	1c01      	adds	r1, r0, #0
 8007cc2:	4640      	mov	r0, r8
 8007cc4:	f7f9 faac 	bl	8001220 <__aeabi_fsub>
    float eri = esr * s11si + esi * s11sr;
 8007cc8:	9902      	ldr	r1, [sp, #8]
    float err = esr * s11sr - esi * s11si;
 8007cca:	4680      	mov	r8, r0
    float eri = esr * s11si + esi * s11sr;
 8007ccc:	4650      	mov	r0, sl
 8007cce:	f7f9 f98f 	bl	8000ff0 <__aeabi_fmul>
 8007cd2:	1c29      	adds	r1, r5, #0
 8007cd4:	4682      	mov	sl, r0
 8007cd6:	4648      	mov	r0, r9
 8007cd8:	f7f9 f98a 	bl	8000ff0 <__aeabi_fmul>
 8007cdc:	1c01      	adds	r1, r0, #0
 8007cde:	4650      	mov	r0, sl
 8007ce0:	f7f8 fe26 	bl	8000930 <__aeabi_fadd>
    if (sign < 0) {
 8007ce4:	9b01      	ldr	r3, [sp, #4]
 8007ce6:	3301      	adds	r3, #1
 8007ce8:	d1c1      	bne.n	8007c6e <eterm_calc_er+0x7e>
      err = -err;
 8007cea:	2380      	movs	r3, #128	; 0x80
 8007cec:	061b      	lsls	r3, r3, #24
 8007cee:	4443      	add	r3, r8
 8007cf0:	4698      	mov	r8, r3
      eri = -eri;
 8007cf2:	2380      	movs	r3, #128	; 0x80
 8007cf4:	061b      	lsls	r3, r3, #24
 8007cf6:	469c      	mov	ip, r3
 8007cf8:	4460      	add	r0, ip
 8007cfa:	e7b8      	b.n	8007c6e <eterm_calc_er+0x7e>
  }
  cal_status &= ~CALSTAT_SHORT;
 8007cfc:	2204      	movs	r2, #4
 8007cfe:	4b07      	ldr	r3, [pc, #28]	; (8007d1c <eterm_calc_er+0x12c>)
 8007d00:	89db      	ldrh	r3, [r3, #14]
 8007d02:	4393      	bics	r3, r2
  cal_status |= CALSTAT_ER;
 8007d04:	2240      	movs	r2, #64	; 0x40
 8007d06:	4313      	orrs	r3, r2
 8007d08:	4a04      	ldr	r2, [pc, #16]	; (8007d1c <eterm_calc_er+0x12c>)
 8007d0a:	81d3      	strh	r3, [r2, #14]
}
 8007d0c:	b005      	add	sp, #20
 8007d0e:	bc3c      	pop	{r2, r3, r4, r5}
 8007d10:	4690      	mov	r8, r2
 8007d12:	4699      	mov	r9, r3
 8007d14:	46a2      	mov	sl, r4
 8007d16:	46ab      	mov	fp, r5
 8007d18:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8007d1a:	46c0      	nop			; (mov r8, r8)
 8007d1c:	20000454 	.word	0x20000454
 8007d20:	20000428 	.word	0x20000428
 8007d24:	000004cc 	.word	0x000004cc
 8007d28:	000007f4 	.word	0x000007f4
 8007d2c:	00000000 	.word	0x00000000

08007d30 <set_frequencies>:
{
 8007d30:	b5f0      	push	{r4, r5, r6, r7, lr}
 8007d32:	46de      	mov	lr, fp
 8007d34:	4657      	mov	r7, sl
 8007d36:	464e      	mov	r6, r9
 8007d38:	4645      	mov	r5, r8
 8007d3a:	4682      	mov	sl, r0
 8007d3c:	b5e0      	push	{r5, r6, r7, lr}
  chMtxLock(&mutex_sweep);
 8007d3e:	4824      	ldr	r0, [pc, #144]	; (8007dd0 <set_frequencies+0xa0>)
{
 8007d40:	b085      	sub	sp, #20
 8007d42:	000c      	movs	r4, r1
 8007d44:	4691      	mov	r9, r2
  chMtxLock(&mutex_sweep);
 8007d46:	f7fc f9bb 	bl	80040c0 <chMtxLock>
  uint32_t span = stop - start;
 8007d4a:	4653      	mov	r3, sl
 8007d4c:	1ae3      	subs	r3, r4, r3
  for (i = 0; i < points; i++) {
 8007d4e:	464c      	mov	r4, r9
 8007d50:	2c00      	cmp	r4, #0
 8007d52:	d026      	beq.n	8007da2 <set_frequencies+0x72>
 8007d54:	0019      	movs	r1, r3
 8007d56:	2300      	movs	r3, #0
 8007d58:	001a      	movs	r2, r3
 8007d5a:	3b01      	subs	r3, #1
 8007d5c:	444b      	add	r3, r9
 8007d5e:	469b      	mov	fp, r3
 8007d60:	17db      	asrs	r3, r3, #31
 8007d62:	9301      	str	r3, [sp, #4]
 8007d64:	4b1b      	ldr	r3, [pc, #108]	; (8007dd4 <set_frequencies+0xa4>)
 8007d66:	2500      	movs	r5, #0
 8007d68:	4698      	mov	r8, r3
 8007d6a:	465b      	mov	r3, fp
 8007d6c:	9403      	str	r4, [sp, #12]
 8007d6e:	46d3      	mov	fp, sl
 8007d70:	2600      	movs	r6, #0
 8007d72:	46c2      	mov	sl, r8
 8007d74:	2700      	movs	r7, #0
 8007d76:	46a8      	mov	r8, r5
 8007d78:	000c      	movs	r4, r1
 8007d7a:	0015      	movs	r5, r2
 8007d7c:	9302      	str	r3, [sp, #8]
    uint32_t offset = (uint32_t)((i * (uint64_t)span) / (points - 1));
 8007d7e:	9b01      	ldr	r3, [sp, #4]
 8007d80:	0030      	movs	r0, r6
 8007d82:	0039      	movs	r1, r7
 8007d84:	9a02      	ldr	r2, [sp, #8]
 8007d86:	f7f8 fc53 	bl	8000630 <__aeabi_uldivmod>
    frequencies[i] = start + (uint32_t)offset;
 8007d8a:	4653      	mov	r3, sl
 8007d8c:	4458      	add	r0, fp
 8007d8e:	c301      	stmia	r3!, {r0}
 8007d90:	469a      	mov	sl, r3
  for (i = 0; i < points; i++) {
 8007d92:	2301      	movs	r3, #1
 8007d94:	469c      	mov	ip, r3
 8007d96:	44e0      	add	r8, ip
 8007d98:	1936      	adds	r6, r6, r4
 8007d9a:	416f      	adcs	r7, r5
 8007d9c:	45c8      	cmp	r8, r9
 8007d9e:	d3ee      	bcc.n	8007d7e <set_frequencies+0x4e>
 8007da0:	9c03      	ldr	r4, [sp, #12]
  for (; i < sweep_points; i++)
 8007da2:	4a0d      	ldr	r2, [pc, #52]	; (8007dd8 <set_frequencies+0xa8>)
    frequencies[i] = 0;
 8007da4:	2000      	movs	r0, #0
  for (; i < sweep_points; i++)
 8007da6:	230c      	movs	r3, #12
 8007da8:	5ed1      	ldrsh	r1, [r2, r3]
 8007daa:	3210      	adds	r2, #16
 8007dac:	4549      	cmp	r1, r9
 8007dae:	d905      	bls.n	8007dbc <set_frequencies+0x8c>
    frequencies[i] = 0;
 8007db0:	00a3      	lsls	r3, r4, #2
 8007db2:	18d3      	adds	r3, r2, r3
  for (; i < sweep_points; i++)
 8007db4:	3401      	adds	r4, #1
    frequencies[i] = 0;
 8007db6:	6018      	str	r0, [r3, #0]
  for (; i < sweep_points; i++)
 8007db8:	428c      	cmp	r4, r1
 8007dba:	d3f9      	bcc.n	8007db0 <set_frequencies+0x80>
  chMtxUnlock(&mutex_sweep);
 8007dbc:	4804      	ldr	r0, [pc, #16]	; (8007dd0 <set_frequencies+0xa0>)
 8007dbe:	f7fc f987 	bl	80040d0 <chMtxUnlock>
}
 8007dc2:	b005      	add	sp, #20
 8007dc4:	bc3c      	pop	{r2, r3, r4, r5}
 8007dc6:	4690      	mov	r8, r2
 8007dc8:	4699      	mov	r9, r3
 8007dca:	46a2      	mov	sl, r4
 8007dcc:	46ab      	mov	fp, r5
 8007dce:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8007dd0:	20002220 	.word	0x20002220
 8007dd4:	20000464 	.word	0x20000464
 8007dd8:	20000454 	.word	0x20000454
 8007ddc:	00000000 	.word	0x00000000

08007de0 <update_frequencies>:
{
 8007de0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8007de2:	46de      	mov	lr, fp
 8007de4:	4657      	mov	r7, sl
 8007de6:	464e      	mov	r6, r9
 8007de8:	4645      	mov	r5, r8
 8007dea:	b5e0      	push	{r5, r6, r7, lr}
  chMtxLock(&mutex_sweep);
 8007dec:	4f38      	ldr	r7, [pc, #224]	; (8007ed0 <update_frequencies+0xf0>)
{
 8007dee:	b083      	sub	sp, #12
  chMtxLock(&mutex_sweep);
 8007df0:	0038      	movs	r0, r7
 8007df2:	f7fc f965 	bl	80040c0 <chMtxLock>
  if (frequency1 > 0) {
 8007df6:	4c37      	ldr	r4, [pc, #220]	; (8007ed4 <update_frequencies+0xf4>)
 8007df8:	68a1      	ldr	r1, [r4, #8]
 8007dfa:	2900      	cmp	r1, #0
 8007dfc:	dd3a      	ble.n	8007e74 <update_frequencies+0x94>
    start = frequency0;
 8007dfe:	6860      	ldr	r0, [r4, #4]
  set_frequencies(start, stop, sweep_points);
 8007e00:	230c      	movs	r3, #12
 8007e02:	5ee2      	ldrsh	r2, [r4, r3]
 8007e04:	f7ff ff94 	bl	8007d30 <set_frequencies>
  operation_requested = OP_FREQCHANGE;
 8007e08:	2203      	movs	r2, #3
 8007e0a:	218e      	movs	r1, #142	; 0x8e
 8007e0c:	4b32      	ldr	r3, [pc, #200]	; (8007ed8 <update_frequencies+0xf8>)
 8007e0e:	0149      	lsls	r1, r1, #5
 8007e10:	701a      	strb	r2, [r3, #0]
    if (f < frequencies[0]) {
 8007e12:	6923      	ldr	r3, [r4, #16]
 8007e14:	468b      	mov	fp, r1
 8007e16:	469c      	mov	ip, r3
    } else if (f >= frequencies[sweep_points-1]) {
 8007e18:	230c      	movs	r3, #12
 8007e1a:	5ee2      	ldrsh	r2, [r4, r3]
 8007e1c:	44a3      	add	fp, r4
 8007e1e:	1e56      	subs	r6, r2, #1
      markers[m].index = sweep_points-1;
 8007e20:	b233      	sxth	r3, r6
 8007e22:	9301      	str	r3, [sp, #4]
    } else if (f >= frequencies[sweep_points-1]) {
 8007e24:	3203      	adds	r2, #3
 8007e26:	238d      	movs	r3, #141	; 0x8d
 8007e28:	0092      	lsls	r2, r2, #2
      for (i = 0; i < sweep_points-1; i++) {
 8007e2a:	4690      	mov	r8, r2
 8007e2c:	015b      	lsls	r3, r3, #5
 8007e2e:	18e3      	adds	r3, r4, r3
    if (!markers[m].enabled)
 8007e30:	2200      	movs	r2, #0
 8007e32:	569a      	ldrsb	r2, [r3, r2]
 8007e34:	2a00      	cmp	r2, #0
 8007e36:	d006      	beq.n	8007e46 <update_frequencies+0x66>
    uint32_t f = markers[m].frequency;
 8007e38:	6859      	ldr	r1, [r3, #4]
    if (f < frequencies[0]) {
 8007e3a:	4561      	cmp	r1, ip
 8007e3c:	d212      	bcs.n	8007e64 <update_frequencies+0x84>
      markers[m].index = 0;
 8007e3e:	2200      	movs	r2, #0
 8007e40:	805a      	strh	r2, [r3, #2]
      markers[m].frequency = frequencies[0];
 8007e42:	4662      	mov	r2, ip
 8007e44:	605a      	str	r2, [r3, #4]
 8007e46:	3308      	adds	r3, #8
  for (m = 0; m < MARKER_COUNT; m++) {
 8007e48:	455b      	cmp	r3, fp
 8007e4a:	d1f1      	bne.n	8007e30 <update_frequencies+0x50>
  update_grid();
 8007e4c:	f004 f8a8 	bl	800bfa0 <update_grid>
  chMtxUnlock(&mutex_sweep);
 8007e50:	0038      	movs	r0, r7
 8007e52:	f7fc f93d 	bl	80040d0 <chMtxUnlock>
}
 8007e56:	b003      	add	sp, #12
 8007e58:	bc3c      	pop	{r2, r3, r4, r5}
 8007e5a:	4690      	mov	r8, r2
 8007e5c:	4699      	mov	r9, r3
 8007e5e:	46a2      	mov	sl, r4
 8007e60:	46ab      	mov	fp, r5
 8007e62:	bdf0      	pop	{r4, r5, r6, r7, pc}
    } else if (f >= frequencies[sweep_points-1]) {
 8007e64:	4642      	mov	r2, r8
 8007e66:	58a0      	ldr	r0, [r4, r2]
 8007e68:	4281      	cmp	r1, r0
 8007e6a:	d30c      	bcc.n	8007e86 <update_frequencies+0xa6>
      markers[m].index = sweep_points-1;
 8007e6c:	9a01      	ldr	r2, [sp, #4]
      markers[m].frequency = frequencies[sweep_points-1];
 8007e6e:	6058      	str	r0, [r3, #4]
      markers[m].index = sweep_points-1;
 8007e70:	805a      	strh	r2, [r3, #2]
      markers[m].frequency = frequencies[sweep_points-1];
 8007e72:	e7e8      	b.n	8007e46 <update_frequencies+0x66>
    int32_t span = -frequency1;
 8007e74:	4249      	negs	r1, r1
    start = center - span/2;
 8007e76:	0fc8      	lsrs	r0, r1, #31
    int32_t center = frequency0;
 8007e78:	6863      	ldr	r3, [r4, #4]
    start = center - span/2;
 8007e7a:	1840      	adds	r0, r0, r1
 8007e7c:	1040      	asrs	r0, r0, #1
    stop = center + span/2;
 8007e7e:	1049      	asrs	r1, r1, #1
    start = center - span/2;
 8007e80:	1a18      	subs	r0, r3, r0
    stop = center + span/2;
 8007e82:	18c9      	adds	r1, r1, r3
 8007e84:	e7bc      	b.n	8007e00 <update_frequencies+0x20>
 8007e86:	0020      	movs	r0, r4
      for (i = 0; i < sweep_points-1; i++) {
 8007e88:	2500      	movs	r5, #0
 8007e8a:	3010      	adds	r0, #16
 8007e8c:	46b1      	mov	r9, r6
 8007e8e:	469a      	mov	sl, r3
 8007e90:	2e00      	cmp	r6, #0
 8007e92:	ddd8      	ble.n	8007e46 <update_frequencies+0x66>
        if (frequencies[i] <= f && f < frequencies[i+1]) {
 8007e94:	6802      	ldr	r2, [r0, #0]
 8007e96:	1c6e      	adds	r6, r5, #1
 8007e98:	4291      	cmp	r1, r2
 8007e9a:	d302      	bcc.n	8007ea2 <update_frequencies+0xc2>
 8007e9c:	6843      	ldr	r3, [r0, #4]
 8007e9e:	4299      	cmp	r1, r3
 8007ea0:	d306      	bcc.n	8007eb0 <update_frequencies+0xd0>
 8007ea2:	3004      	adds	r0, #4
 8007ea4:	0035      	movs	r5, r6
      for (i = 0; i < sweep_points-1; i++) {
 8007ea6:	45b1      	cmp	r9, r6
 8007ea8:	dcf4      	bgt.n	8007e94 <update_frequencies+0xb4>
 8007eaa:	464e      	mov	r6, r9
 8007eac:	4653      	mov	r3, sl
 8007eae:	e7ca      	b.n	8007e46 <update_frequencies+0x66>
 8007eb0:	4650      	mov	r0, sl
 8007eb2:	469a      	mov	sl, r3
 8007eb4:	0033      	movs	r3, r6
          uint32_t mid = (frequencies[i] + frequencies[i+1])/2;
 8007eb6:	4452      	add	r2, sl
 8007eb8:	464e      	mov	r6, r9
 8007eba:	0852      	lsrs	r2, r2, #1
 8007ebc:	4699      	mov	r9, r3
 8007ebe:	0003      	movs	r3, r0
          if (f < mid) {
 8007ec0:	4291      	cmp	r1, r2
 8007ec2:	d201      	bcs.n	8007ec8 <update_frequencies+0xe8>
            markers[m].index = i;
 8007ec4:	8045      	strh	r5, [r0, #2]
 8007ec6:	e7be      	b.n	8007e46 <update_frequencies+0x66>
            markers[m].index = i + 1;
 8007ec8:	464a      	mov	r2, r9
 8007eca:	8042      	strh	r2, [r0, #2]
 8007ecc:	e7bb      	b.n	8007e46 <update_frequencies+0x66>
 8007ece:	46c0      	nop			; (mov r8, r8)
 8007ed0:	20002220 	.word	0x20002220
 8007ed4:	20000454 	.word	0x20000454
 8007ed8:	200030a3 	.word	0x200030a3
 8007edc:	00000000 	.word	0x00000000

08007ee0 <cal_interpolate>:
  redraw_request |= REDRAW_CAL_STATUS;
  chMtxUnlock(&mutex_sweep);
}

static void cal_interpolate(int s)
{
 8007ee0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8007ee2:	46de      	mov	lr, fp
 8007ee4:	4657      	mov	r7, sl
 8007ee6:	464e      	mov	r6, r9
 8007ee8:	4645      	mov	r5, r8
 8007eea:	0004      	movs	r4, r0
 8007eec:	b5e0      	push	{r5, r6, r7, lr}
  chMtxLock(&mutex_sweep);
 8007eee:	489b      	ldr	r0, [pc, #620]	; (800815c <cal_interpolate+0x27c>)
{
 8007ef0:	b08b      	sub	sp, #44	; 0x2c
  chMtxLock(&mutex_sweep);
 8007ef2:	f7fc f8e5 	bl	80040c0 <chMtxLock>
  const properties_t *src = caldata_ref(s);
 8007ef6:	0020      	movs	r0, r4
 8007ef8:	f008 ffb2 	bl	8010e60 <caldata_ref>
 8007efc:	9003      	str	r0, [sp, #12]
  int i, j;
  int eterm;
  if (src == NULL) {
 8007efe:	2800      	cmp	r0, #0
 8007f00:	d100      	bne.n	8007f04 <cal_interpolate+0x24>
 8007f02:	e0ac      	b.n	800805e <cal_interpolate+0x17e>
  if (active_props == &current_props)
 8007f04:	4b96      	ldr	r3, [pc, #600]	; (8008160 <cal_interpolate+0x280>)
 8007f06:	4997      	ldr	r1, [pc, #604]	; (8008164 <cal_interpolate+0x284>)
 8007f08:	681a      	ldr	r2, [r3, #0]
 8007f0a:	428a      	cmp	r2, r1
 8007f0c:	d100      	bne.n	8007f10 <cal_interpolate+0x30>
 8007f0e:	e11e      	b.n	800814e <cal_interpolate+0x26e>
  active_props = &current_props;
 8007f10:	4a94      	ldr	r2, [pc, #592]	; (8008164 <cal_interpolate+0x284>)
  cal_status = 0;
 8007f12:	4994      	ldr	r1, [pc, #592]	; (8008164 <cal_interpolate+0x284>)
  active_props = &current_props;
 8007f14:	601a      	str	r2, [r3, #0]
  cal_status = 0;
 8007f16:	2200      	movs	r2, #0
 8007f18:	81ca      	strh	r2, [r1, #14]
 8007f1a:	9208      	str	r2, [sp, #32]
  }

  ensure_edit_config();

  // lower than start freq of src range
  for (i = 0; i < sweep_points; i++) {
 8007f1c:	4a91      	ldr	r2, [pc, #580]	; (8008164 <cal_interpolate+0x284>)
 8007f1e:	210c      	movs	r1, #12
 8007f20:	5e52      	ldrsh	r2, [r2, r1]
 8007f22:	9204      	str	r2, [sp, #16]
 8007f24:	2a00      	cmp	r2, #0
 8007f26:	dc00      	bgt.n	8007f2a <cal_interpolate+0x4a>
 8007f28:	e08a      	b.n	8008040 <cal_interpolate+0x160>
    if (frequencies[i] >= src->_frequencies[0])
 8007f2a:	4a8e      	ldr	r2, [pc, #568]	; (8008164 <cal_interpolate+0x284>)
 8007f2c:	681b      	ldr	r3, [r3, #0]
 8007f2e:	6910      	ldr	r0, [r2, #16]
 8007f30:	9a03      	ldr	r2, [sp, #12]
 8007f32:	9309      	str	r3, [sp, #36]	; 0x24
 8007f34:	6915      	ldr	r5, [r2, #16]
 8007f36:	4285      	cmp	r5, r0
 8007f38:	d800      	bhi.n	8007f3c <cal_interpolate+0x5c>
 8007f3a:	e10b      	b.n	8008154 <cal_interpolate+0x274>
 8007f3c:	33a5      	adds	r3, #165	; 0xa5
 8007f3e:	33ff      	adds	r3, #255	; 0xff
 8007f40:	0019      	movs	r1, r3
 8007f42:	2300      	movs	r3, #0
 8007f44:	4699      	mov	r9, r3
 8007f46:	4b88      	ldr	r3, [pc, #544]	; (8008168 <cal_interpolate+0x288>)
 8007f48:	0016      	movs	r6, r2
 8007f4a:	469c      	mov	ip, r3
 8007f4c:	464f      	mov	r7, r9
 8007f4e:	4c85      	ldr	r4, [pc, #532]	; (8008164 <cal_interpolate+0x284>)
 8007f50:	36a5      	adds	r6, #165	; 0xa5
 8007f52:	4462      	add	r2, ip
 8007f54:	46ac      	mov	ip, r5
 8007f56:	9d04      	ldr	r5, [sp, #16]
 8007f58:	3414      	adds	r4, #20
 8007f5a:	36ff      	adds	r6, #255	; 0xff
 8007f5c:	0033      	movs	r3, r6
 8007f5e:	0008      	movs	r0, r1
 8007f60:	4689      	mov	r9, r1
      break;

    // fill cal_data at head of src range
    for (eterm = 0; eterm < 5; eterm++) {
      cal_data[eterm][i][0] = src->_cal_data[eterm][0][0];
 8007f62:	6819      	ldr	r1, [r3, #0]
 8007f64:	6001      	str	r1, [r0, #0]
      cal_data[eterm][i][1] = src->_cal_data[eterm][0][1];
 8007f66:	6859      	ldr	r1, [r3, #4]
 8007f68:	6041      	str	r1, [r0, #4]
 8007f6a:	21ca      	movs	r1, #202	; 0xca
 8007f6c:	0089      	lsls	r1, r1, #2
 8007f6e:	4688      	mov	r8, r1
 8007f70:	4443      	add	r3, r8
 8007f72:	4440      	add	r0, r8
    for (eterm = 0; eterm < 5; eterm++) {
 8007f74:	429a      	cmp	r2, r3
 8007f76:	d1f4      	bne.n	8007f62 <cal_interpolate+0x82>
  for (i = 0; i < sweep_points; i++) {
 8007f78:	3701      	adds	r7, #1
 8007f7a:	4649      	mov	r1, r9
 8007f7c:	42af      	cmp	r7, r5
 8007f7e:	da5f      	bge.n	8008040 <cal_interpolate+0x160>
    if (frequencies[i] >= src->_frequencies[0])
 8007f80:	cc01      	ldmia	r4!, {r0}
 8007f82:	3108      	adds	r1, #8
 8007f84:	4560      	cmp	r0, ip
 8007f86:	d3e9      	bcc.n	8007f5c <cal_interpolate+0x7c>
 8007f88:	46b9      	mov	r9, r7
        // found f between freqs at j and j+1
        float k1 = (float)(f - src->_frequencies[j])
                        / (src->_frequencies[j+1] - src->_frequencies[j]);
        
        // avoid glitch between freqs in different harmonics mode
        if (IS_HARMONIC_MODE(src->_frequencies[j]) != IS_HARMONIC_MODE(src->_frequencies[j+1])) {
 8007f8a:	4b78      	ldr	r3, [pc, #480]	; (800816c <cal_interpolate+0x28c>)
 8007f8c:	4a76      	ldr	r2, [pc, #472]	; (8008168 <cal_interpolate+0x288>)
 8007f8e:	69db      	ldr	r3, [r3, #28]
 8007f90:	4694      	mov	ip, r2
 8007f92:	9305      	str	r3, [sp, #20]
 8007f94:	9b04      	ldr	r3, [sp, #16]
 8007f96:	2400      	movs	r4, #0
 8007f98:	3b01      	subs	r3, #1
 8007f9a:	469b      	mov	fp, r3
 8007f9c:	46ca      	mov	sl, r9
 8007f9e:	465d      	mov	r5, fp
 8007fa0:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8007fa2:	33a5      	adds	r3, #165	; 0xa5
 8007fa4:	33ff      	adds	r3, #255	; 0xff
 8007fa6:	9306      	str	r3, [sp, #24]
 8007fa8:	9b03      	ldr	r3, [sp, #12]
 8007faa:	4463      	add	r3, ip
 8007fac:	9307      	str	r3, [sp, #28]
    for (; j < sweep_points-1; j++) {
 8007fae:	42a5      	cmp	r5, r4
 8007fb0:	dd10      	ble.n	8007fd4 <cal_interpolate+0xf4>
 8007fb2:	9a03      	ldr	r2, [sp, #12]
 8007fb4:	0026      	movs	r6, r4
 8007fb6:	4694      	mov	ip, r2
 8007fb8:	1d23      	adds	r3, r4, #4
 8007fba:	009b      	lsls	r3, r3, #2
 8007fbc:	4463      	add	r3, ip
      if (src->_frequencies[j] <= f && f < src->_frequencies[j+1]) {
 8007fbe:	681f      	ldr	r7, [r3, #0]
 8007fc0:	3401      	adds	r4, #1
 8007fc2:	4287      	cmp	r7, r0
 8007fc4:	d802      	bhi.n	8007fcc <cal_interpolate+0xec>
 8007fc6:	685a      	ldr	r2, [r3, #4]
 8007fc8:	4282      	cmp	r2, r0
 8007fca:	d852      	bhi.n	8008072 <cal_interpolate+0x192>
 8007fcc:	3304      	adds	r3, #4
 8007fce:	0026      	movs	r6, r4
    for (; j < sweep_points-1; j++) {
 8007fd0:	42a5      	cmp	r5, r4
 8007fd2:	dcf4      	bgt.n	8007fbe <cal_interpolate+0xde>
          cal_data[eterm][i][1] = src->_cal_data[eterm][j][1] * k0 + src->_cal_data[eterm][j+1][1] * k1;
        }
        break;
      }
    }
    if (j == sweep_points-1)
 8007fd4:	42a5      	cmp	r5, r4
 8007fd6:	d00a      	beq.n	8007fee <cal_interpolate+0x10e>
  for (; i < sweep_points; i++) {
 8007fd8:	2301      	movs	r3, #1
 8007fda:	469c      	mov	ip, r3
 8007fdc:	9b04      	ldr	r3, [sp, #16]
 8007fde:	44e2      	add	sl, ip
 8007fe0:	459a      	cmp	sl, r3
 8007fe2:	da2d      	bge.n	8008040 <cal_interpolate+0x160>
 8007fe4:	4653      	mov	r3, sl
 8007fe6:	4a62      	ldr	r2, [pc, #392]	; (8008170 <cal_interpolate+0x290>)
 8007fe8:	009b      	lsls	r3, r3, #2
 8007fea:	58d0      	ldr	r0, [r2, r3]
 8007fec:	e7df      	b.n	8007fae <cal_interpolate+0xce>
      break;
  }
  
  // upper than end freq of src range
  for (; i < sweep_points; i++) {
 8007fee:	9b04      	ldr	r3, [sp, #16]
 8007ff0:	4553      	cmp	r3, sl
 8007ff2:	dd25      	ble.n	8008040 <cal_interpolate+0x160>
 8007ff4:	4653      	mov	r3, sl
 8007ff6:	00d8      	lsls	r0, r3, #3
 8007ff8:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8007ffa:	00e9      	lsls	r1, r5, #3
 8007ffc:	469c      	mov	ip, r3
 8007ffe:	000c      	movs	r4, r1
 8008000:	9b03      	ldr	r3, [sp, #12]
 8008002:	30a5      	adds	r0, #165	; 0xa5
 8008004:	30ff      	adds	r0, #255	; 0xff
 8008006:	4460      	add	r0, ip
 8008008:	469c      	mov	ip, r3
 800800a:	34a5      	adds	r4, #165	; 0xa5
 800800c:	4a56      	ldr	r2, [pc, #344]	; (8008168 <cal_interpolate+0x288>)
 800800e:	34ff      	adds	r4, #255	; 0xff
 8008010:	4464      	add	r4, ip
 8008012:	4694      	mov	ip, r2
 8008014:	4461      	add	r1, ip
 8008016:	469c      	mov	ip, r3
 8008018:	4655      	mov	r5, sl
 800801a:	9e04      	ldr	r6, [sp, #16]
 800801c:	4461      	add	r1, ip
 800801e:	0002      	movs	r2, r0
 8008020:	0023      	movs	r3, r4
    // fill cal_data at tail of src
    for (eterm = 0; eterm < 5; eterm++) {
      cal_data[eterm][i][0] = src->_cal_data[eterm][sweep_points-1][0];
 8008022:	681f      	ldr	r7, [r3, #0]
 8008024:	6017      	str	r7, [r2, #0]
      cal_data[eterm][i][1] = src->_cal_data[eterm][sweep_points-1][1];
 8008026:	685f      	ldr	r7, [r3, #4]
 8008028:	6057      	str	r7, [r2, #4]
 800802a:	27ca      	movs	r7, #202	; 0xca
 800802c:	00bf      	lsls	r7, r7, #2
 800802e:	46bc      	mov	ip, r7
 8008030:	4463      	add	r3, ip
 8008032:	4462      	add	r2, ip
    for (eterm = 0; eterm < 5; eterm++) {
 8008034:	428b      	cmp	r3, r1
 8008036:	d1f4      	bne.n	8008022 <cal_interpolate+0x142>
  for (; i < sweep_points; i++) {
 8008038:	3501      	adds	r5, #1
 800803a:	3008      	adds	r0, #8
 800803c:	42b5      	cmp	r5, r6
 800803e:	dbee      	blt.n	800801e <cal_interpolate+0x13e>
    }
  }
    
  cal_status |= src->_cal_status | CALSTAT_APPLY | CALSTAT_INTERPOLATED;
 8008040:	9b03      	ldr	r3, [sp, #12]
  redraw_request |= REDRAW_CAL_STATUS;  
 8008042:	2104      	movs	r1, #4
  cal_status |= src->_cal_status | CALSTAT_APPLY | CALSTAT_INTERPOLATED;
 8008044:	89da      	ldrh	r2, [r3, #14]
 8008046:	9b08      	ldr	r3, [sp, #32]
 8008048:	4313      	orrs	r3, r2
 800804a:	001a      	movs	r2, r3
 800804c:	23c0      	movs	r3, #192	; 0xc0
 800804e:	009b      	lsls	r3, r3, #2
 8008050:	4313      	orrs	r3, r2
 8008052:	4a44      	ldr	r2, [pc, #272]	; (8008164 <cal_interpolate+0x284>)
 8008054:	81d3      	strh	r3, [r2, #14]
  redraw_request |= REDRAW_CAL_STATUS;  
 8008056:	4a47      	ldr	r2, [pc, #284]	; (8008174 <cal_interpolate+0x294>)
 8008058:	8813      	ldrh	r3, [r2, #0]
 800805a:	430b      	orrs	r3, r1
 800805c:	8013      	strh	r3, [r2, #0]
  chMtxUnlock(&mutex_sweep);
 800805e:	483f      	ldr	r0, [pc, #252]	; (800815c <cal_interpolate+0x27c>)
 8008060:	f7fc f836 	bl	80040d0 <chMtxUnlock>
}
 8008064:	b00b      	add	sp, #44	; 0x2c
 8008066:	bc3c      	pop	{r2, r3, r4, r5}
 8008068:	4690      	mov	r8, r2
 800806a:	4699      	mov	r9, r3
 800806c:	46a2      	mov	sl, r4
 800806e:	46ab      	mov	fp, r5
 8008070:	bdf0      	pop	{r4, r5, r6, r7, pc}
        if (IS_HARMONIC_MODE(src->_frequencies[j]) != IS_HARMONIC_MODE(src->_frequencies[j+1])) {
 8008072:	9b05      	ldr	r3, [sp, #20]
 8008074:	4690      	mov	r8, r2
 8008076:	469c      	mov	ip, r3
 8008078:	45bc      	cmp	ip, r7
 800807a:	4192      	sbcs	r2, r2
 800807c:	45c4      	cmp	ip, r8
 800807e:	419b      	sbcs	r3, r3
 8008080:	4252      	negs	r2, r2
 8008082:	425b      	negs	r3, r3
 8008084:	429a      	cmp	r2, r3
 8008086:	d048      	beq.n	800811a <cal_interpolate+0x23a>
          k1 = IS_HARMONIC_MODE(f) ? 1.0 : 0.0;
 8008088:	9b05      	ldr	r3, [sp, #20]
 800808a:	4283      	cmp	r3, r0
 800808c:	d359      	bcc.n	8008142 <cal_interpolate+0x262>
 800808e:	23fe      	movs	r3, #254	; 0xfe
 8008090:	059b      	lsls	r3, r3, #22
 8008092:	9301      	str	r3, [sp, #4]
 8008094:	2300      	movs	r3, #0
 8008096:	4699      	mov	r9, r3
        for (eterm = 0; eterm < 5; eterm++) {
 8008098:	9a03      	ldr	r2, [sp, #12]
 800809a:	9906      	ldr	r1, [sp, #24]
 800809c:	4694      	mov	ip, r2
 800809e:	00f3      	lsls	r3, r6, #3
 80080a0:	4652      	mov	r2, sl
 80080a2:	001f      	movs	r7, r3
 80080a4:	4688      	mov	r8, r1
 80080a6:	00d2      	lsls	r2, r2, #3
 80080a8:	00e4      	lsls	r4, r4, #3
 80080aa:	4490      	add	r8, r2
 80080ac:	37a5      	adds	r7, #165	; 0xa5
 80080ae:	34a5      	adds	r4, #165	; 0xa5
 80080b0:	9a07      	ldr	r2, [sp, #28]
 80080b2:	37ff      	adds	r7, #255	; 0xff
 80080b4:	34ff      	adds	r4, #255	; 0xff
 80080b6:	4464      	add	r4, ip
 80080b8:	4467      	add	r7, ip
 80080ba:	4694      	mov	ip, r2
 80080bc:	46b3      	mov	fp, r6
 80080be:	464e      	mov	r6, r9
 80080c0:	46a9      	mov	r9, r5
 80080c2:	0025      	movs	r5, r4
 80080c4:	4644      	mov	r4, r8
 80080c6:	4463      	add	r3, ip
 80080c8:	9302      	str	r3, [sp, #8]
          cal_data[eterm][i][0] = src->_cal_data[eterm][j][0] * k0 + src->_cal_data[eterm][j+1][0] * k1;
 80080ca:	6839      	ldr	r1, [r7, #0]
 80080cc:	9801      	ldr	r0, [sp, #4]
 80080ce:	f7f8 ff8f 	bl	8000ff0 <__aeabi_fmul>
 80080d2:	6829      	ldr	r1, [r5, #0]
 80080d4:	4680      	mov	r8, r0
 80080d6:	1c30      	adds	r0, r6, #0
 80080d8:	f7f8 ff8a 	bl	8000ff0 <__aeabi_fmul>
 80080dc:	1c01      	adds	r1, r0, #0
 80080de:	4640      	mov	r0, r8
 80080e0:	f7f8 fc26 	bl	8000930 <__aeabi_fadd>
 80080e4:	6020      	str	r0, [r4, #0]
          cal_data[eterm][i][1] = src->_cal_data[eterm][j][1] * k0 + src->_cal_data[eterm][j+1][1] * k1;
 80080e6:	6879      	ldr	r1, [r7, #4]
 80080e8:	9801      	ldr	r0, [sp, #4]
 80080ea:	f7f8 ff81 	bl	8000ff0 <__aeabi_fmul>
 80080ee:	6869      	ldr	r1, [r5, #4]
 80080f0:	4680      	mov	r8, r0
 80080f2:	1c30      	adds	r0, r6, #0
 80080f4:	f7f8 ff7c 	bl	8000ff0 <__aeabi_fmul>
 80080f8:	1c01      	adds	r1, r0, #0
 80080fa:	4640      	mov	r0, r8
 80080fc:	f7f8 fc18 	bl	8000930 <__aeabi_fadd>
 8008100:	23ca      	movs	r3, #202	; 0xca
 8008102:	009b      	lsls	r3, r3, #2
 8008104:	469c      	mov	ip, r3
        for (eterm = 0; eterm < 5; eterm++) {
 8008106:	9b02      	ldr	r3, [sp, #8]
 8008108:	4467      	add	r7, ip
          cal_data[eterm][i][1] = src->_cal_data[eterm][j][1] * k0 + src->_cal_data[eterm][j+1][1] * k1;
 800810a:	6060      	str	r0, [r4, #4]
 800810c:	4465      	add	r5, ip
 800810e:	4464      	add	r4, ip
        for (eterm = 0; eterm < 5; eterm++) {
 8008110:	429f      	cmp	r7, r3
 8008112:	d1da      	bne.n	80080ca <cal_interpolate+0x1ea>
 8008114:	464d      	mov	r5, r9
 8008116:	465c      	mov	r4, fp
 8008118:	e75c      	b.n	8007fd4 <cal_interpolate+0xf4>
        float k1 = (float)(f - src->_frequencies[j])
 800811a:	1bc0      	subs	r0, r0, r7
 800811c:	f7f9 fab0 	bl	8001680 <__aeabi_ui2f>
                        / (src->_frequencies[j+1] - src->_frequencies[j]);
 8008120:	4643      	mov	r3, r8
        float k1 = (float)(f - src->_frequencies[j])
 8008122:	4681      	mov	r9, r0
                        / (src->_frequencies[j+1] - src->_frequencies[j]);
 8008124:	1bd8      	subs	r0, r3, r7
 8008126:	f7f9 faab 	bl	8001680 <__aeabi_ui2f>
 800812a:	1c01      	adds	r1, r0, #0
        float k1 = (float)(f - src->_frequencies[j])
 800812c:	4648      	mov	r0, r9
 800812e:	f7f8 fd7f 	bl	8000c30 <__aeabi_fdiv>
 8008132:	1c01      	adds	r1, r0, #0
 8008134:	4681      	mov	r9, r0
 8008136:	20fe      	movs	r0, #254	; 0xfe
 8008138:	0580      	lsls	r0, r0, #22
 800813a:	f7f9 f871 	bl	8001220 <__aeabi_fsub>
 800813e:	9001      	str	r0, [sp, #4]
 8008140:	e7aa      	b.n	8008098 <cal_interpolate+0x1b8>
 8008142:	2300      	movs	r3, #0
 8008144:	9301      	str	r3, [sp, #4]
          k1 = IS_HARMONIC_MODE(f) ? 1.0 : 0.0;
 8008146:	23fe      	movs	r3, #254	; 0xfe
 8008148:	059b      	lsls	r3, r3, #22
 800814a:	4699      	mov	r9, r3
 800814c:	e7a4      	b.n	8008098 <cal_interpolate+0x1b8>
 800814e:	89ca      	ldrh	r2, [r1, #14]
 8008150:	9208      	str	r2, [sp, #32]
 8008152:	e6e3      	b.n	8007f1c <cal_interpolate+0x3c>
    if (frequencies[i] >= src->_frequencies[0])
 8008154:	2300      	movs	r3, #0
 8008156:	4699      	mov	r9, r3
 8008158:	e717      	b.n	8007f8a <cal_interpolate+0xaa>
 800815a:	46c0      	nop			; (mov r8, r8)
 800815c:	20002220 	.word	0x20002220
 8008160:	20000428 	.word	0x20000428
 8008164:	20000454 	.word	0x20000454
 8008168:	0000116c 	.word	0x0000116c
 800816c:	2000042c 	.word	0x2000042c
 8008170:	20000464 	.word	0x20000464
 8008174:	20002236 	.word	0x20002236
	...

08008180 <cmd_resume>:
{
 8008180:	b510      	push	{r4, lr}
    chMtxLock(&mutex_sweep);
 8008182:	4c0b      	ldr	r4, [pc, #44]	; (80081b0 <cmd_resume+0x30>)
 8008184:	0020      	movs	r0, r4
 8008186:	f7fb ff9b 	bl	80040c0 <chMtxLock>
    update_frequencies();
 800818a:	f7ff fe29 	bl	8007de0 <update_frequencies>
    if (cal_auto_interpolate && (cal_status & CALSTAT_APPLY))
 800818e:	4b09      	ldr	r3, [pc, #36]	; (80081b4 <cmd_resume+0x34>)
 8008190:	89db      	ldrh	r3, [r3, #14]
 8008192:	05db      	lsls	r3, r3, #23
 8008194:	d406      	bmi.n	80081a4 <cmd_resume+0x24>
    chMtxUnlock(&mutex_sweep);
 8008196:	0020      	movs	r0, r4
 8008198:	f7fb ff9a 	bl	80040d0 <chMtxUnlock>
    sweep_enabled = TRUE;
 800819c:	2201      	movs	r2, #1
 800819e:	4b06      	ldr	r3, [pc, #24]	; (80081b8 <cmd_resume+0x38>)
 80081a0:	701a      	strb	r2, [r3, #0]
}
 80081a2:	bd10      	pop	{r4, pc}
        cal_interpolate(lastsaveid);
 80081a4:	4b05      	ldr	r3, [pc, #20]	; (80081bc <cmd_resume+0x3c>)
 80081a6:	2000      	movs	r0, #0
 80081a8:	5e18      	ldrsh	r0, [r3, r0]
 80081aa:	f7ff fe99 	bl	8007ee0 <cal_interpolate>
 80081ae:	e7f2      	b.n	8008196 <cmd_resume+0x16>
 80081b0:	20002220 	.word	0x20002220
 80081b4:	20000454 	.word	0x20000454
 80081b8:	20001630 	.word	0x20001630
 80081bc:	200038b0 	.word	0x200038b0

080081c0 <cmd_vbat>:
  (void)argv;
  chprintf(chp, "%s\r\n", NANOVNA_VERSION);
}

static void cmd_vbat(BaseSequentialStream *chp, int argc, char *argv[])
{
 80081c0:	b510      	push	{r4, lr}
  (void)argc;
  (void)argv;
  chprintf(chp, "%d mV\r\n", vbat);
 80081c2:	4b03      	ldr	r3, [pc, #12]	; (80081d0 <cmd_vbat+0x10>)
 80081c4:	4903      	ldr	r1, [pc, #12]	; (80081d4 <cmd_vbat+0x14>)
 80081c6:	2200      	movs	r2, #0
 80081c8:	5e9a      	ldrsh	r2, [r3, r2]
 80081ca:	f7ff f9a1 	bl	8007510 <chprintf>
}
 80081ce:	bd10      	pop	{r4, pc}
 80081d0:	200023c6 	.word	0x200023c6
 80081d4:	08014450 	.word	0x08014450
	...

080081e0 <cmd_scan>:
{
 80081e0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80081e2:	4646      	mov	r6, r8
 80081e4:	46d6      	mov	lr, sl
 80081e6:	464f      	mov	r7, r9
  if (argc != 2 && argc != 3) {
 80081e8:	1e8b      	subs	r3, r1, #2
{
 80081ea:	b5c0      	push	{r6, r7, lr}
 80081ec:	000d      	movs	r5, r1
 80081ee:	0006      	movs	r6, r0
 80081f0:	0014      	movs	r4, r2
  if (argc != 2 && argc != 3) {
 80081f2:	2b01      	cmp	r3, #1
 80081f4:	d83f      	bhi.n	8008276 <cmd_scan+0x96>
  int16_t points = sweep_points;
 80081f6:	4b2d      	ldr	r3, [pc, #180]	; (80082ac <cmd_scan+0xcc>)
  start = atoi(argv[0]);
 80081f8:	6820      	ldr	r0, [r4, #0]
  int16_t points = sweep_points;
 80081fa:	4699      	mov	r9, r3
 80081fc:	220c      	movs	r2, #12
 80081fe:	5e9b      	ldrsh	r3, [r3, r2]
 8008200:	469a      	mov	sl, r3
  start = atoi(argv[0]);
 8008202:	f00a ff55 	bl	80130b0 <atoi>
 8008206:	0007      	movs	r7, r0
  stop = atoi(argv[1]);
 8008208:	6860      	ldr	r0, [r4, #4]
 800820a:	f00a ff51 	bl	80130b0 <atoi>
 800820e:	4680      	mov	r8, r0
  if (start == 0 || stop == 0 || start > stop) {
 8008210:	2f00      	cmp	r7, #0
 8008212:	d027      	beq.n	8008264 <cmd_scan+0x84>
 8008214:	2800      	cmp	r0, #0
 8008216:	d025      	beq.n	8008264 <cmd_scan+0x84>
 8008218:	4287      	cmp	r7, r0
 800821a:	dc23      	bgt.n	8008264 <cmd_scan+0x84>
  if (argc == 3) {
 800821c:	2d03      	cmp	r5, #3
 800821e:	d02e      	beq.n	800827e <cmd_scan+0x9e>
    sweep_enabled = FALSE;
 8008220:	2200      	movs	r2, #0
  chMtxLock(&mutex_sweep);
 8008222:	4d23      	ldr	r5, [pc, #140]	; (80082b0 <cmd_scan+0xd0>)
    sweep_enabled = FALSE;
 8008224:	4b23      	ldr	r3, [pc, #140]	; (80082b4 <cmd_scan+0xd4>)
  chMtxLock(&mutex_sweep);
 8008226:	0028      	movs	r0, r5
    sweep_enabled = FALSE;
 8008228:	701a      	strb	r2, [r3, #0]
  chMtxLock(&mutex_sweep);
 800822a:	f7fb ff49 	bl	80040c0 <chMtxLock>
  set_frequencies(start, stop, points);
 800822e:	4652      	mov	r2, sl
 8008230:	4641      	mov	r1, r8
 8008232:	0038      	movs	r0, r7
 8008234:	f7ff fd7c 	bl	8007d30 <set_frequencies>
  if (cal_auto_interpolate && (cal_status & CALSTAT_APPLY))
 8008238:	464b      	mov	r3, r9
 800823a:	89db      	ldrh	r3, [r3, #14]
 800823c:	05db      	lsls	r3, r3, #23
 800823e:	d42f      	bmi.n	80082a0 <cmd_scan+0xc0>
  sweep_once = TRUE;
 8008240:	2301      	movs	r3, #1
 8008242:	4c1d      	ldr	r4, [pc, #116]	; (80082b8 <cmd_scan+0xd8>)
  chMtxUnlock(&mutex_sweep);
 8008244:	0028      	movs	r0, r5
  sweep_once = TRUE;
 8008246:	7023      	strb	r3, [r4, #0]
  chMtxUnlock(&mutex_sweep);
 8008248:	f7fb ff42 	bl	80040d0 <chMtxUnlock>
  while (sweep_once)
 800824c:	2300      	movs	r3, #0
 800824e:	56e3      	ldrsb	r3, [r4, r3]
 8008250:	2b00      	cmp	r3, #0
 8008252:	d00b      	beq.n	800826c <cmd_scan+0x8c>
    chThdSleepMilliseconds(10);
 8008254:	2064      	movs	r0, #100	; 0x64
 8008256:	f7fb fe5b 	bl	8003f10 <chThdSleep>
  while (sweep_once)
 800825a:	2300      	movs	r3, #0
 800825c:	56e3      	ldrsb	r3, [r4, r3]
 800825e:	2b00      	cmp	r3, #0
 8008260:	d1f8      	bne.n	8008254 <cmd_scan+0x74>
 8008262:	e003      	b.n	800826c <cmd_scan+0x8c>
      chprintf(chp, "frequency range is invalid\r\n");
 8008264:	4915      	ldr	r1, [pc, #84]	; (80082bc <cmd_scan+0xdc>)
 8008266:	0030      	movs	r0, r6
 8008268:	f7ff f952 	bl	8007510 <chprintf>
}
 800826c:	bc1c      	pop	{r2, r3, r4}
 800826e:	4690      	mov	r8, r2
 8008270:	4699      	mov	r9, r3
 8008272:	46a2      	mov	sl, r4
 8008274:	bdf0      	pop	{r4, r5, r6, r7, pc}
    chprintf(chp, "usage: scan {start(Hz)} {stop(Hz)} [points]\r\n");
 8008276:	4912      	ldr	r1, [pc, #72]	; (80082c0 <cmd_scan+0xe0>)
 8008278:	f7ff f94a 	bl	8007510 <chprintf>
    return;
 800827c:	e7f6      	b.n	800826c <cmd_scan+0x8c>
    points = atoi(argv[2]);
 800827e:	68a0      	ldr	r0, [r4, #8]
 8008280:	f00a ff16 	bl	80130b0 <atoi>
 8008284:	b203      	sxth	r3, r0
 8008286:	469a      	mov	sl, r3
    if (points <= 0 || points > sweep_points) {
 8008288:	2b00      	cmp	r3, #0
 800828a:	dd04      	ble.n	8008296 <cmd_scan+0xb6>
 800828c:	464b      	mov	r3, r9
 800828e:	220c      	movs	r2, #12
 8008290:	5e9b      	ldrsh	r3, [r3, r2]
 8008292:	4553      	cmp	r3, sl
 8008294:	dac4      	bge.n	8008220 <cmd_scan+0x40>
      chprintf(chp, "sweep points exceeds range\r\n");
 8008296:	490b      	ldr	r1, [pc, #44]	; (80082c4 <cmd_scan+0xe4>)
 8008298:	0030      	movs	r0, r6
 800829a:	f7ff f939 	bl	8007510 <chprintf>
      return;
 800829e:	e7e5      	b.n	800826c <cmd_scan+0x8c>
    cal_interpolate(lastsaveid);
 80082a0:	4b09      	ldr	r3, [pc, #36]	; (80082c8 <cmd_scan+0xe8>)
 80082a2:	2000      	movs	r0, #0
 80082a4:	5e18      	ldrsh	r0, [r3, r0]
 80082a6:	f7ff fe1b 	bl	8007ee0 <cal_interpolate>
 80082aa:	e7c9      	b.n	8008240 <cmd_scan+0x60>
 80082ac:	20000454 	.word	0x20000454
 80082b0:	20002220 	.word	0x20002220
 80082b4:	20001630 	.word	0x20001630
 80082b8:	200023c4 	.word	0x200023c4
 80082bc:	08014128 	.word	0x08014128
 80082c0:	080140f8 	.word	0x080140f8
 80082c4:	08014148 	.word	0x08014148
 80082c8:	200038b0 	.word	0x200038b0
 80082cc:	00000000 	.word	0x00000000

080082d0 <cmd_frequencies>:
{
 80082d0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80082d2:	46c6      	mov	lr, r8
 80082d4:	b500      	push	{lr}
  for (i = 0; i < sweep_points; i++) {
 80082d6:	4e11      	ldr	r6, [pc, #68]	; (800831c <cmd_frequencies+0x4c>)
{
 80082d8:	0007      	movs	r7, r0
  for (i = 0; i < sweep_points; i++) {
 80082da:	220c      	movs	r2, #12
 80082dc:	5eb3      	ldrsh	r3, [r6, r2]
 80082de:	2b00      	cmp	r3, #0
 80082e0:	dd18      	ble.n	8008314 <cmd_frequencies+0x44>
 80082e2:	0035      	movs	r5, r6
      chprintf(chp, "%d\r\n", frequencies[i]);
 80082e4:	4b0e      	ldr	r3, [pc, #56]	; (8008320 <cmd_frequencies+0x50>)
 80082e6:	3510      	adds	r5, #16
  for (i = 0; i < sweep_points; i++) {
 80082e8:	2400      	movs	r4, #0
      chprintf(chp, "%d\r\n", frequencies[i]);
 80082ea:	4698      	mov	r8, r3
 80082ec:	e005      	b.n	80082fa <cmd_frequencies+0x2a>
  for (i = 0; i < sweep_points; i++) {
 80082ee:	220c      	movs	r2, #12
 80082f0:	5eb3      	ldrsh	r3, [r6, r2]
 80082f2:	3401      	adds	r4, #1
 80082f4:	3504      	adds	r5, #4
 80082f6:	42a3      	cmp	r3, r4
 80082f8:	dd0c      	ble.n	8008314 <cmd_frequencies+0x44>
    if (frequencies[i] != 0)
 80082fa:	682a      	ldr	r2, [r5, #0]
 80082fc:	2a00      	cmp	r2, #0
 80082fe:	d0f6      	beq.n	80082ee <cmd_frequencies+0x1e>
      chprintf(chp, "%d\r\n", frequencies[i]);
 8008300:	4641      	mov	r1, r8
 8008302:	0038      	movs	r0, r7
 8008304:	f7ff f904 	bl	8007510 <chprintf>
  for (i = 0; i < sweep_points; i++) {
 8008308:	220c      	movs	r2, #12
 800830a:	5eb3      	ldrsh	r3, [r6, r2]
 800830c:	3401      	adds	r4, #1
 800830e:	3504      	adds	r5, #4
 8008310:	42a3      	cmp	r3, r4
 8008312:	dcf2      	bgt.n	80082fa <cmd_frequencies+0x2a>
}
 8008314:	bc04      	pop	{r2}
 8008316:	4690      	mov	r8, r2
 8008318:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800831a:	46c0      	nop			; (mov r8, r8)
 800831c:	20000454 	.word	0x20000454
 8008320:	0801419c 	.word	0x0801419c
	...

08008330 <cmd_data>:
{
 8008330:	b5f0      	push	{r4, r5, r6, r7, lr}
 8008332:	464e      	mov	r6, r9
 8008334:	46de      	mov	lr, fp
 8008336:	4657      	mov	r7, sl
 8008338:	4645      	mov	r5, r8
 800833a:	b5e0      	push	{r5, r6, r7, lr}
 800833c:	4681      	mov	r9, r0
 800833e:	b083      	sub	sp, #12
 8008340:	2400      	movs	r4, #0
    if (argc == 1)
 8008342:	2901      	cmp	r1, #1
 8008344:	d033      	beq.n	80083ae <cmd_data+0x7e>
        chMtxLock(&mutex_sweep);
 8008346:	4b21      	ldr	r3, [pc, #132]	; (80083cc <cmd_data+0x9c>)
 8008348:	0018      	movs	r0, r3
 800834a:	469b      	mov	fp, r3
 800834c:	f7fb feb8 	bl	80040c0 <chMtxLock>
        for (int i = 0; i < sweep_points; i++) {
 8008350:	4b1f      	ldr	r3, [pc, #124]	; (80083d0 <cmd_data+0xa0>)
 8008352:	4698      	mov	r8, r3
 8008354:	220c      	movs	r2, #12
 8008356:	5e9b      	ldrsh	r3, [r3, r2]
 8008358:	2b00      	cmp	r3, #0
 800835a:	dd1e      	ble.n	800839a <cmd_data+0x6a>
 800835c:	23ca      	movs	r3, #202	; 0xca
 800835e:	009b      	lsls	r3, r3, #2
 8008360:	435c      	muls	r4, r3
 8008362:	4b1c      	ldr	r3, [pc, #112]	; (80083d4 <cmd_data+0xa4>)
 8008364:	2500      	movs	r5, #0
 8008366:	18e4      	adds	r4, r4, r3
 8008368:	4b1b      	ldr	r3, [pc, #108]	; (80083d8 <cmd_data+0xa8>)
 800836a:	469a      	mov	sl, r3
            chprintf(chp, "%f %f\r\n", measured[sel][i][0], measured[sel][i][1]);
 800836c:	6820      	ldr	r0, [r4, #0]
 800836e:	f7fb f837 	bl	80033e0 <__aeabi_f2d>
 8008372:	0006      	movs	r6, r0
 8008374:	6860      	ldr	r0, [r4, #4]
 8008376:	000f      	movs	r7, r1
 8008378:	f7fb f832 	bl	80033e0 <__aeabi_f2d>
 800837c:	0032      	movs	r2, r6
 800837e:	9000      	str	r0, [sp, #0]
 8008380:	9101      	str	r1, [sp, #4]
 8008382:	003b      	movs	r3, r7
 8008384:	4651      	mov	r1, sl
 8008386:	4648      	mov	r0, r9
 8008388:	f7ff f8c2 	bl	8007510 <chprintf>
        for (int i = 0; i < sweep_points; i++) {
 800838c:	4643      	mov	r3, r8
 800838e:	220c      	movs	r2, #12
 8008390:	5e9b      	ldrsh	r3, [r3, r2]
 8008392:	3501      	adds	r5, #1
 8008394:	3408      	adds	r4, #8
 8008396:	42ab      	cmp	r3, r5
 8008398:	dce8      	bgt.n	800836c <cmd_data+0x3c>
        chMtxUnlock(&mutex_sweep);
 800839a:	4658      	mov	r0, fp
 800839c:	f7fb fe98 	bl	80040d0 <chMtxUnlock>
}
 80083a0:	b003      	add	sp, #12
 80083a2:	bc3c      	pop	{r2, r3, r4, r5}
 80083a4:	4690      	mov	r8, r2
 80083a6:	4699      	mov	r9, r3
 80083a8:	46a2      	mov	sl, r4
 80083aa:	46ab      	mov	fp, r5
 80083ac:	bdf0      	pop	{r4, r5, r6, r7, pc}
        sel = atoi(argv[0]);
 80083ae:	6810      	ldr	r0, [r2, #0]
 80083b0:	f00a fe7e 	bl	80130b0 <atoi>
 80083b4:	0004      	movs	r4, r0
    if (sel < 0 || sel > 6) {
 80083b6:	2806      	cmp	r0, #6
 80083b8:	d803      	bhi.n	80083c2 <cmd_data+0x92>
        if (sel > 1) 
 80083ba:	2801      	cmp	r0, #1
 80083bc:	ddc3      	ble.n	8008346 <cmd_data+0x16>
            sel = sel-2; 
 80083be:	3c02      	subs	r4, #2
 80083c0:	e7c1      	b.n	8008346 <cmd_data+0x16>
        chprintf(chp, "usage: data [array]\r\n");
 80083c2:	4906      	ldr	r1, [pc, #24]	; (80083dc <cmd_data+0xac>)
 80083c4:	4648      	mov	r0, r9
 80083c6:	f7ff f8a3 	bl	8007510 <chprintf>
 80083ca:	e7e9      	b.n	80083a0 <cmd_data+0x70>
 80083cc:	20002220 	.word	0x20002220
 80083d0:	20000454 	.word	0x20000454
 80083d4:	20001bbc 	.word	0x20001bbc
 80083d8:	08013f6c 	.word	0x08013f6c
 80083dc:	08013f54 	.word	0x08013f54

080083e0 <cmd_version>:
{
 80083e0:	b510      	push	{r4, lr}
  chprintf(chp, "%s\r\n", NANOVNA_VERSION);
 80083e2:	4a02      	ldr	r2, [pc, #8]	; (80083ec <cmd_version+0xc>)
 80083e4:	4902      	ldr	r1, [pc, #8]	; (80083f0 <cmd_version+0x10>)
 80083e6:	f7ff f893 	bl	8007510 <chprintf>
}
 80083ea:	bd10      	pop	{r4, pc}
 80083ec:	08013e80 	.word	0x08013e80
 80083f0:	08014458 	.word	0x08014458
	...

08008400 <cmd_transform>:
{
 8008400:	b5f0      	push	{r4, r5, r6, r7, lr}
 8008402:	4657      	mov	r7, sl
 8008404:	464e      	mov	r6, r9
 8008406:	46de      	mov	lr, fp
 8008408:	4645      	mov	r5, r8
 800840a:	b5e0      	push	{r5, r6, r7, lr}
 800840c:	b083      	sub	sp, #12
 800840e:	9001      	str	r0, [sp, #4]
 8008410:	000e      	movs	r6, r1
 8008412:	0017      	movs	r7, r2
  if (argc == 0) {
 8008414:	2900      	cmp	r1, #0
 8008416:	d100      	bne.n	800841a <cmd_transform+0x1a>
 8008418:	e078      	b.n	800850c <cmd_transform+0x10c>
  for (i = 0; i < argc; i++) {
 800841a:	dd41      	ble.n	80084a0 <cmd_transform+0xa0>
 800841c:	4b4a      	ldr	r3, [pc, #296]	; (8008548 <cmd_transform+0x148>)
 800841e:	2400      	movs	r4, #0
 8008420:	4698      	mov	r8, r3
    } else if (strcmp(cmd, "off") == 0) {
 8008422:	4b4a      	ldr	r3, [pc, #296]	; (800854c <cmd_transform+0x14c>)
 8008424:	4699      	mov	r9, r3
    } else if (strcmp(cmd, "impulse") == 0) {
 8008426:	4b4a      	ldr	r3, [pc, #296]	; (8008550 <cmd_transform+0x150>)
 8008428:	469a      	mov	sl, r3
    } else if (strcmp(cmd, "step") == 0) {
 800842a:	4b4a      	ldr	r3, [pc, #296]	; (8008554 <cmd_transform+0x154>)
 800842c:	469b      	mov	fp, r3
 800842e:	e010      	b.n	8008452 <cmd_transform+0x52>
  if (mode != (domain_mode & DOMAIN_MODE)) {
 8008430:	4949      	ldr	r1, [pc, #292]	; (8008558 <cmd_transform+0x158>)
 8008432:	4a4a      	ldr	r2, [pc, #296]	; (800855c <cmd_transform+0x15c>)
 8008434:	3001      	adds	r0, #1
 8008436:	5c8b      	ldrb	r3, [r1, r2]
 8008438:	4218      	tst	r0, r3
 800843a:	d107      	bne.n	800844c <cmd_transform+0x4c>
    domain_mode = (domain_mode & ~DOMAIN_MODE) | (mode & DOMAIN_MODE);
 800843c:	4383      	bics	r3, r0
 800843e:	4303      	orrs	r3, r0
 8008440:	548b      	strb	r3, [r1, r2]
    redraw_request |= REDRAW_FREQUENCY;
 8008442:	2102      	movs	r1, #2
 8008444:	4a46      	ldr	r2, [pc, #280]	; (8008560 <cmd_transform+0x160>)
 8008446:	8813      	ldrh	r3, [r2, #0]
 8008448:	430b      	orrs	r3, r1
 800844a:	8013      	strh	r3, [r2, #0]
  for (i = 0; i < argc; i++) {
 800844c:	3401      	adds	r4, #1
 800844e:	42a6      	cmp	r6, r4
 8008450:	d026      	beq.n	80084a0 <cmd_transform+0xa0>
    char *cmd = argv[i];
 8008452:	00a3      	lsls	r3, r4, #2
 8008454:	58fd      	ldr	r5, [r7, r3]
    if (strcmp(cmd, "on") == 0) {
 8008456:	4641      	mov	r1, r8
 8008458:	0028      	movs	r0, r5
 800845a:	f7fb f9b9 	bl	80037d0 <strcmp>
 800845e:	2800      	cmp	r0, #0
 8008460:	d0e6      	beq.n	8008430 <cmd_transform+0x30>
    } else if (strcmp(cmd, "off") == 0) {
 8008462:	4649      	mov	r1, r9
 8008464:	0028      	movs	r0, r5
 8008466:	f7fb f9b3 	bl	80037d0 <strcmp>
 800846a:	2800      	cmp	r0, #0
 800846c:	d107      	bne.n	800847e <cmd_transform+0x7e>
  if (mode != (domain_mode & DOMAIN_MODE)) {
 800846e:	493a      	ldr	r1, [pc, #232]	; (8008558 <cmd_transform+0x158>)
 8008470:	4a3a      	ldr	r2, [pc, #232]	; (800855c <cmd_transform+0x15c>)
 8008472:	3001      	adds	r0, #1
 8008474:	5c8b      	ldrb	r3, [r1, r2]
 8008476:	4218      	tst	r0, r3
 8008478:	d0e8      	beq.n	800844c <cmd_transform+0x4c>
    domain_mode = (domain_mode & ~DOMAIN_MODE) | (mode & DOMAIN_MODE);
 800847a:	4383      	bics	r3, r0
 800847c:	e7e0      	b.n	8008440 <cmd_transform+0x40>
    } else if (strcmp(cmd, "impulse") == 0) {
 800847e:	4651      	mov	r1, sl
 8008480:	0028      	movs	r0, r5
 8008482:	f7fb f9a5 	bl	80037d0 <strcmp>
 8008486:	2800      	cmp	r0, #0
 8008488:	d111      	bne.n	80084ae <cmd_transform+0xae>
  domain_mode = (domain_mode & ~TD_FUNC) | (func & TD_FUNC);
 800848a:	4933      	ldr	r1, [pc, #204]	; (8008558 <cmd_transform+0x158>)
 800848c:	4a33      	ldr	r2, [pc, #204]	; (800855c <cmd_transform+0x15c>)
 800848e:	3006      	adds	r0, #6
 8008490:	5c8b      	ldrb	r3, [r1, r2]
  for (i = 0; i < argc; i++) {
 8008492:	3401      	adds	r4, #1
  domain_mode = (domain_mode & ~TD_FUNC) | (func & TD_FUNC);
 8008494:	4383      	bics	r3, r0
 8008496:	2002      	movs	r0, #2
 8008498:	4303      	orrs	r3, r0
 800849a:	548b      	strb	r3, [r1, r2]
  for (i = 0; i < argc; i++) {
 800849c:	42a6      	cmp	r6, r4
 800849e:	d1d8      	bne.n	8008452 <cmd_transform+0x52>
}
 80084a0:	b003      	add	sp, #12
 80084a2:	bc3c      	pop	{r2, r3, r4, r5}
 80084a4:	4690      	mov	r8, r2
 80084a6:	4699      	mov	r9, r3
 80084a8:	46a2      	mov	sl, r4
 80084aa:	46ab      	mov	fp, r5
 80084ac:	bdf0      	pop	{r4, r5, r6, r7, pc}
    } else if (strcmp(cmd, "step") == 0) {
 80084ae:	4659      	mov	r1, fp
 80084b0:	0028      	movs	r0, r5
 80084b2:	f7fb f98d 	bl	80037d0 <strcmp>
 80084b6:	2800      	cmp	r0, #0
 80084b8:	d108      	bne.n	80084cc <cmd_transform+0xcc>
  domain_mode = (domain_mode & ~TD_FUNC) | (func & TD_FUNC);
 80084ba:	4927      	ldr	r1, [pc, #156]	; (8008558 <cmd_transform+0x158>)
 80084bc:	4a27      	ldr	r2, [pc, #156]	; (800855c <cmd_transform+0x15c>)
 80084be:	3006      	adds	r0, #6
 80084c0:	5c8b      	ldrb	r3, [r1, r2]
 80084c2:	4383      	bics	r3, r0
 80084c4:	2004      	movs	r0, #4
 80084c6:	4303      	orrs	r3, r0
 80084c8:	548b      	strb	r3, [r1, r2]
 80084ca:	e7bf      	b.n	800844c <cmd_transform+0x4c>
    } else if (strcmp(cmd, "bandpass") == 0) {
 80084cc:	4925      	ldr	r1, [pc, #148]	; (8008564 <cmd_transform+0x164>)
 80084ce:	0028      	movs	r0, r5
 80084d0:	f7fb f97e 	bl	80037d0 <strcmp>
 80084d4:	2800      	cmp	r0, #0
 80084d6:	d106      	bne.n	80084e6 <cmd_transform+0xe6>
  domain_mode = (domain_mode & ~TD_FUNC) | (func & TD_FUNC);
 80084d8:	491f      	ldr	r1, [pc, #124]	; (8008558 <cmd_transform+0x158>)
 80084da:	4a20      	ldr	r2, [pc, #128]	; (800855c <cmd_transform+0x15c>)
 80084dc:	3006      	adds	r0, #6
 80084de:	5c8b      	ldrb	r3, [r1, r2]
 80084e0:	4383      	bics	r3, r0
 80084e2:	548b      	strb	r3, [r1, r2]
 80084e4:	e7b2      	b.n	800844c <cmd_transform+0x4c>
    } else if (strcmp(cmd, "minimum") == 0) {
 80084e6:	4920      	ldr	r1, [pc, #128]	; (8008568 <cmd_transform+0x168>)
 80084e8:	0028      	movs	r0, r5
 80084ea:	f7fb f971 	bl	80037d0 <strcmp>
 80084ee:	2800      	cmp	r0, #0
 80084f0:	d011      	beq.n	8008516 <cmd_transform+0x116>
    } else if (strcmp(cmd, "normal") == 0) {
 80084f2:	491e      	ldr	r1, [pc, #120]	; (800856c <cmd_transform+0x16c>)
 80084f4:	0028      	movs	r0, r5
 80084f6:	f7fb f96b 	bl	80037d0 <strcmp>
 80084fa:	2800      	cmp	r0, #0
 80084fc:	d114      	bne.n	8008528 <cmd_transform+0x128>
  domain_mode = (domain_mode & ~TD_WINDOW) | (func & TD_WINDOW);
 80084fe:	4916      	ldr	r1, [pc, #88]	; (8008558 <cmd_transform+0x158>)
 8008500:	4a16      	ldr	r2, [pc, #88]	; (800855c <cmd_transform+0x15c>)
 8008502:	3018      	adds	r0, #24
 8008504:	5c8b      	ldrb	r3, [r1, r2]
 8008506:	4383      	bics	r3, r0
 8008508:	548b      	strb	r3, [r1, r2]
 800850a:	e79f      	b.n	800844c <cmd_transform+0x4c>
  chprintf(chp, "usage: transform {on|off|impulse|step|bandpass|minimum|normal|maximum} [...]\r\n");
 800850c:	4918      	ldr	r1, [pc, #96]	; (8008570 <cmd_transform+0x170>)
 800850e:	9801      	ldr	r0, [sp, #4]
 8008510:	f7fe fffe 	bl	8007510 <chprintf>
 8008514:	e7c4      	b.n	80084a0 <cmd_transform+0xa0>
  domain_mode = (domain_mode & ~TD_WINDOW) | (func & TD_WINDOW);
 8008516:	4910      	ldr	r1, [pc, #64]	; (8008558 <cmd_transform+0x158>)
 8008518:	4a10      	ldr	r2, [pc, #64]	; (800855c <cmd_transform+0x15c>)
 800851a:	3018      	adds	r0, #24
 800851c:	5c8b      	ldrb	r3, [r1, r2]
 800851e:	4383      	bics	r3, r0
 8008520:	2008      	movs	r0, #8
 8008522:	4303      	orrs	r3, r0
 8008524:	548b      	strb	r3, [r1, r2]
 8008526:	e791      	b.n	800844c <cmd_transform+0x4c>
    } else if (strcmp(cmd, "maximum") == 0) {
 8008528:	4912      	ldr	r1, [pc, #72]	; (8008574 <cmd_transform+0x174>)
 800852a:	0028      	movs	r0, r5
 800852c:	f7fb f950 	bl	80037d0 <strcmp>
 8008530:	2800      	cmp	r0, #0
 8008532:	d1eb      	bne.n	800850c <cmd_transform+0x10c>
  domain_mode = (domain_mode & ~TD_WINDOW) | (func & TD_WINDOW);
 8008534:	2118      	movs	r1, #24
 8008536:	4a09      	ldr	r2, [pc, #36]	; (800855c <cmd_transform+0x15c>)
 8008538:	4b07      	ldr	r3, [pc, #28]	; (8008558 <cmd_transform+0x158>)
 800853a:	5c9b      	ldrb	r3, [r3, r2]
 800853c:	438b      	bics	r3, r1
 800853e:	2110      	movs	r1, #16
 8008540:	430b      	orrs	r3, r1
 8008542:	4905      	ldr	r1, [pc, #20]	; (8008558 <cmd_transform+0x158>)
 8008544:	548b      	strb	r3, [r1, r2]
 8008546:	e781      	b.n	800844c <cmd_transform+0x4c>
 8008548:	080143c4 	.word	0x080143c4
 800854c:	080143c8 	.word	0x080143c8
 8008550:	080143cc 	.word	0x080143cc
 8008554:	080143d4 	.word	0x080143d4
 8008558:	20000454 	.word	0x20000454
 800855c:	000011c4 	.word	0x000011c4
 8008560:	20002236 	.word	0x20002236
 8008564:	080143dc 	.word	0x080143dc
 8008568:	080143e8 	.word	0x080143e8
 800856c:	080143f0 	.word	0x080143f0
 8008570:	08014400 	.word	0x08014400
 8008574:	080143f8 	.word	0x080143f8
	...

08008580 <cmd_sample>:
{
 8008580:	b570      	push	{r4, r5, r6, lr}
 8008582:	0004      	movs	r4, r0
  if (argc == 1) {
 8008584:	2901      	cmp	r1, #1
 8008586:	d112      	bne.n	80085ae <cmd_sample+0x2e>
    if (strcmp(argv[0], "ref") == 0) {
 8008588:	6815      	ldr	r5, [r2, #0]
 800858a:	4911      	ldr	r1, [pc, #68]	; (80085d0 <cmd_sample+0x50>)
 800858c:	0028      	movs	r0, r5
 800858e:	f7fb f91f 	bl	80037d0 <strcmp>
 8008592:	2800      	cmp	r0, #0
 8008594:	d010      	beq.n	80085b8 <cmd_sample+0x38>
    } else if (strcmp(argv[0], "ampl") == 0) {
 8008596:	490f      	ldr	r1, [pc, #60]	; (80085d4 <cmd_sample+0x54>)
 8008598:	0028      	movs	r0, r5
 800859a:	f7fb f919 	bl	80037d0 <strcmp>
 800859e:	2800      	cmp	r0, #0
 80085a0:	d012      	beq.n	80085c8 <cmd_sample+0x48>
    } else if (strcmp(argv[0], "gamma") == 0) {
 80085a2:	490d      	ldr	r1, [pc, #52]	; (80085d8 <cmd_sample+0x58>)
 80085a4:	0028      	movs	r0, r5
 80085a6:	f7fb f913 	bl	80037d0 <strcmp>
 80085aa:	2800      	cmp	r0, #0
 80085ac:	d008      	beq.n	80085c0 <cmd_sample+0x40>
  chprintf(chp, "usage: sample {gamma|ampl|ref}\r\n");
 80085ae:	490b      	ldr	r1, [pc, #44]	; (80085dc <cmd_sample+0x5c>)
 80085b0:	0020      	movs	r0, r4
 80085b2:	f7fe ffad 	bl	8007510 <chprintf>
}
 80085b6:	bd70      	pop	{r4, r5, r6, pc}
      sample_func = fetch_amplitude_ref;
 80085b8:	4b09      	ldr	r3, [pc, #36]	; (80085e0 <cmd_sample+0x60>)
 80085ba:	4a0a      	ldr	r2, [pc, #40]	; (80085e4 <cmd_sample+0x64>)
 80085bc:	601a      	str	r2, [r3, #0]
      return;
 80085be:	e7fa      	b.n	80085b6 <cmd_sample+0x36>
      sample_func = calculate_gamma;
 80085c0:	4b07      	ldr	r3, [pc, #28]	; (80085e0 <cmd_sample+0x60>)
 80085c2:	4a09      	ldr	r2, [pc, #36]	; (80085e8 <cmd_sample+0x68>)
 80085c4:	601a      	str	r2, [r3, #0]
      return;
 80085c6:	e7f6      	b.n	80085b6 <cmd_sample+0x36>
      sample_func = fetch_amplitude;
 80085c8:	4b05      	ldr	r3, [pc, #20]	; (80085e0 <cmd_sample+0x60>)
 80085ca:	4a08      	ldr	r2, [pc, #32]	; (80085ec <cmd_sample+0x6c>)
 80085cc:	601a      	str	r2, [r3, #0]
      return;
 80085ce:	e7f2      	b.n	80085b6 <cmd_sample+0x36>
 80085d0:	080140a4 	.word	0x080140a4
 80085d4:	080140a8 	.word	0x080140a8
 80085d8:	080140b0 	.word	0x080140b0
 80085dc:	080140b8 	.word	0x080140b8
 80085e0:	2000162c 	.word	0x2000162c
 80085e4:	0800b7b1 	.word	0x0800b7b1
 80085e8:	0800b6b1 	.word	0x0800b6b1
 80085ec:	0800b761 	.word	0x0800b761

080085f0 <cmd_capture>:
{
 80085f0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80085f2:	46ce      	mov	lr, r9
 80085f4:	4647      	mov	r7, r8
 80085f6:	b580      	push	{r7, lr}
    chMtxLock(&mutex_ili9341); // [capture display + spi_buffer]
 80085f8:	4b22      	ldr	r3, [pc, #136]	; (8008684 <cmd_capture+0x94>)
{
 80085fa:	b083      	sub	sp, #12
 80085fc:	0005      	movs	r5, r0
    chMtxLock(&mutex_ili9341); // [capture display + spi_buffer]
 80085fe:	0018      	movs	r0, r3
 8008600:	4699      	mov	r9, r3
 8008602:	f7fb fd5d 	bl	80040c0 <chMtxLock>
    ili9341_read_memory(0, 0, 320, 240, PART, buf);
 8008606:	4b20      	ldr	r3, [pc, #128]	; (8008688 <cmd_capture+0x98>)
 8008608:	22a0      	movs	r2, #160	; 0xa0
 800860a:	4698      	mov	r8, r3
 800860c:	9301      	str	r3, [sp, #4]
 800860e:	23f0      	movs	r3, #240	; 0xf0
 8008610:	26f0      	movs	r6, #240	; 0xf0
 8008612:	009b      	lsls	r3, r3, #2
 8008614:	9300      	str	r3, [sp, #0]
 8008616:	0052      	lsls	r2, r2, #1
 8008618:	23f0      	movs	r3, #240	; 0xf0
 800861a:	2100      	movs	r1, #0
 800861c:	2000      	movs	r0, #0
 800861e:	f008 f887 	bl	8010730 <ili9341_read_memory>
 8008622:	4644      	mov	r4, r8
 8008624:	00f6      	lsls	r6, r6, #3
 8008626:	4446      	add	r6, r8
        streamPut(chp, buf[i] >> 8);
 8008628:	8821      	ldrh	r1, [r4, #0]
 800862a:	682b      	ldr	r3, [r5, #0]
 800862c:	0a09      	lsrs	r1, r1, #8
 800862e:	689b      	ldr	r3, [r3, #8]
 8008630:	0028      	movs	r0, r5
 8008632:	4798      	blx	r3
        streamPut(chp, buf[i] & 0xff);
 8008634:	682b      	ldr	r3, [r5, #0]
 8008636:	7821      	ldrb	r1, [r4, #0]
 8008638:	689b      	ldr	r3, [r3, #8]
 800863a:	0028      	movs	r0, r5
 800863c:	3402      	adds	r4, #2
 800863e:	4798      	blx	r3
    for (i = 0; i < PART; i++) {
 8008640:	42b4      	cmp	r4, r6
 8008642:	d1f1      	bne.n	8008628 <cmd_capture+0x38>
 8008644:	274f      	movs	r7, #79	; 0x4f
        ili9341_read_memory_continue(PART, buf);
 8008646:	20f0      	movs	r0, #240	; 0xf0
 8008648:	4641      	mov	r1, r8
 800864a:	0080      	lsls	r0, r0, #2
 800864c:	f008 f8b0 	bl	80107b0 <ili9341_read_memory_continue>
 8008650:	4644      	mov	r4, r8
            streamPut(chp, buf[i] >> 8);
 8008652:	8821      	ldrh	r1, [r4, #0]
 8008654:	682b      	ldr	r3, [r5, #0]
 8008656:	0a09      	lsrs	r1, r1, #8
 8008658:	689b      	ldr	r3, [r3, #8]
 800865a:	0028      	movs	r0, r5
 800865c:	4798      	blx	r3
            streamPut(chp, buf[i] & 0xff);
 800865e:	682b      	ldr	r3, [r5, #0]
 8008660:	7821      	ldrb	r1, [r4, #0]
 8008662:	689b      	ldr	r3, [r3, #8]
 8008664:	0028      	movs	r0, r5
 8008666:	3402      	adds	r4, #2
 8008668:	4798      	blx	r3
        for (i = 0; i < PART; i++) {
 800866a:	42b4      	cmp	r4, r6
 800866c:	d1f1      	bne.n	8008652 <cmd_capture+0x62>
        len -= PART;
 800866e:	3f01      	subs	r7, #1
    while (len > 0) {
 8008670:	2f00      	cmp	r7, #0
 8008672:	d1e8      	bne.n	8008646 <cmd_capture+0x56>
    chMtxUnlock(&mutex_ili9341); // [/capture display + spi_buffer]
 8008674:	4648      	mov	r0, r9
 8008676:	f7fb fd2b 	bl	80040d0 <chMtxUnlock>
}
 800867a:	b003      	add	sp, #12
 800867c:	bc0c      	pop	{r2, r3}
 800867e:	4690      	mov	r8, r2
 8008680:	4699      	mov	r9, r3
 8008682:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8008684:	2000220c 	.word	0x2000220c
 8008688:	200030ac 	.word	0x200030ac
 800868c:	00000000 	.word	0x00000000

08008690 <cmd_save>:
{
 8008690:	b570      	push	{r4, r5, r6, lr}
 8008692:	0004      	movs	r4, r0
    int id = argc == 1 ? atoi(argv[0]) : -1;
 8008694:	2901      	cmp	r1, #1
 8008696:	d004      	beq.n	80086a2 <cmd_save+0x12>
        chprintf(chp, "save {id}\r\n");
 8008698:	490d      	ldr	r1, [pc, #52]	; (80086d0 <cmd_save+0x40>)
 800869a:	0020      	movs	r0, r4
 800869c:	f7fe ff38 	bl	8007510 <chprintf>
}
 80086a0:	bd70      	pop	{r4, r5, r6, pc}
    int id = argc == 1 ? atoi(argv[0]) : -1;
 80086a2:	6810      	ldr	r0, [r2, #0]
 80086a4:	f00a fd04 	bl	80130b0 <atoi>
 80086a8:	0005      	movs	r5, r0
    if (argc != 1 || id < 0 || id >= SAVEAREA_MAX) {
 80086aa:	2803      	cmp	r0, #3
 80086ac:	d8f4      	bhi.n	8008698 <cmd_save+0x8>
    chMtxLock(&mutex_sweep);
 80086ae:	4c09      	ldr	r4, [pc, #36]	; (80086d4 <cmd_save+0x44>)
 80086b0:	0020      	movs	r0, r4
 80086b2:	f7fb fd05 	bl	80040c0 <chMtxLock>
    caldata_save(id);
 80086b6:	0028      	movs	r0, r5
 80086b8:	f008 fb0a 	bl	8010cd0 <caldata_save>
    redraw_request |= REDRAW_CAL_STATUS;
 80086bc:	2104      	movs	r1, #4
 80086be:	4a06      	ldr	r2, [pc, #24]	; (80086d8 <cmd_save+0x48>)
    chMtxUnlock(&mutex_sweep);
 80086c0:	0020      	movs	r0, r4
    redraw_request |= REDRAW_CAL_STATUS;
 80086c2:	8813      	ldrh	r3, [r2, #0]
 80086c4:	430b      	orrs	r3, r1
 80086c6:	8013      	strh	r3, [r2, #0]
    chMtxUnlock(&mutex_sweep);
 80086c8:	f7fb fd02 	bl	80040d0 <chMtxUnlock>
 80086cc:	e7e8      	b.n	80086a0 <cmd_save+0x10>
 80086ce:	46c0      	nop			; (mov r8, r8)
 80086d0:	080140dc 	.word	0x080140dc
 80086d4:	20002220 	.word	0x20002220
 80086d8:	20002236 	.word	0x20002236
 80086dc:	00000000 	.word	0x00000000

080086e0 <cmd_touchtest>:
{
 80086e0:	b570      	push	{r4, r5, r6, lr}
  chMtxLock(&mutex_sweep);
 80086e2:	4d06      	ldr	r5, [pc, #24]	; (80086fc <cmd_touchtest+0x1c>)
{
 80086e4:	000c      	movs	r4, r1
  chMtxLock(&mutex_sweep);
 80086e6:	0028      	movs	r0, r5
 80086e8:	f7fb fcea 	bl	80040c0 <chMtxLock>
    touch_draw_test();
 80086ec:	f007 fa20 	bl	800fb30 <touch_draw_test>
  } while(argc);
 80086f0:	2c00      	cmp	r4, #0
 80086f2:	d1fb      	bne.n	80086ec <cmd_touchtest+0xc>
  chMtxUnlock(&mutex_sweep);
 80086f4:	0028      	movs	r0, r5
 80086f6:	f7fb fceb 	bl	80040d0 <chMtxUnlock>
}
 80086fa:	bd70      	pop	{r4, r5, r6, pc}
 80086fc:	20002220 	.word	0x20002220

08008700 <cmd_touchcal>:
{
 8008700:	b5f0      	push	{r4, r5, r6, r7, lr}
 8008702:	46c6      	mov	lr, r8
 8008704:	0005      	movs	r5, r0
  chMtxLock(&mutex_sweep);
 8008706:	4b15      	ldr	r3, [pc, #84]	; (800875c <cmd_touchcal+0x5c>)
{
 8008708:	b500      	push	{lr}
  chMtxLock(&mutex_sweep);
 800870a:	0018      	movs	r0, r3
 800870c:	4698      	mov	r8, r3
 800870e:	f7fb fcd7 	bl	80040c0 <chMtxLock>
  chprintf(chp, "first touch upper left, then lower right...");
 8008712:	4913      	ldr	r1, [pc, #76]	; (8008760 <cmd_touchcal+0x60>)
 8008714:	0028      	movs	r0, r5
 8008716:	f7fe fefb 	bl	8007510 <chprintf>
  touch_cal_exec();
 800871a:	f007 f981 	bl	800fa20 <touch_cal_exec>
  chprintf(chp, "done\r\n");
 800871e:	4911      	ldr	r1, [pc, #68]	; (8008764 <cmd_touchcal+0x64>)
 8008720:	0028      	movs	r0, r5
 8008722:	f7fe fef5 	bl	8007510 <chprintf>
  chprintf(chp, "touch cal params: ");
 8008726:	4910      	ldr	r1, [pc, #64]	; (8008768 <cmd_touchcal+0x68>)
 8008728:	0028      	movs	r0, r5
 800872a:	f7fe fef1 	bl	8007510 <chprintf>
  for (int i = 0; i < 4; i++) {
 800872e:	4c0f      	ldr	r4, [pc, #60]	; (800876c <cmd_touchcal+0x6c>)
 8008730:	4e0f      	ldr	r6, [pc, #60]	; (8008770 <cmd_touchcal+0x70>)
 8008732:	0027      	movs	r7, r4
 8008734:	3708      	adds	r7, #8
    chprintf(chp, "%d ", config.touch_cal[i]);
 8008736:	2312      	movs	r3, #18
 8008738:	5ee2      	ldrsh	r2, [r4, r3]
 800873a:	0031      	movs	r1, r6
 800873c:	0028      	movs	r0, r5
 800873e:	3402      	adds	r4, #2
 8008740:	f7fe fee6 	bl	8007510 <chprintf>
  for (int i = 0; i < 4; i++) {
 8008744:	42bc      	cmp	r4, r7
 8008746:	d1f6      	bne.n	8008736 <cmd_touchcal+0x36>
  chprintf(chp, "\r\n");
 8008748:	490a      	ldr	r1, [pc, #40]	; (8008774 <cmd_touchcal+0x74>)
 800874a:	0028      	movs	r0, r5
 800874c:	f7fe fee0 	bl	8007510 <chprintf>
  chMtxUnlock(&mutex_sweep);
 8008750:	4640      	mov	r0, r8
 8008752:	f7fb fcbd 	bl	80040d0 <chMtxUnlock>
}
 8008756:	bc04      	pop	{r2}
 8008758:	4690      	mov	r8, r2
 800875a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800875c:	20002220 	.word	0x20002220
 8008760:	0801427c 	.word	0x0801427c
 8008764:	080142a8 	.word	0x080142a8
 8008768:	080142b0 	.word	0x080142b0
 800876c:	2000042c 	.word	0x2000042c
 8008770:	080142c4 	.word	0x080142c4
 8008774:	08013f50 	.word	0x08013f50
	...

08008780 <cmd_test>:
{
 8008780:	b570      	push	{r4, r5, r6, lr}
    chMtxLock(&mutex_sweep);
 8008782:	4d0f      	ldr	r5, [pc, #60]	; (80087c0 <cmd_test+0x40>)
{
 8008784:	b082      	sub	sp, #8
 8008786:	0004      	movs	r4, r0
    chMtxLock(&mutex_sweep);
 8008788:	0028      	movs	r0, r5
{
 800878a:	000e      	movs	r6, r1
    chMtxLock(&mutex_sweep);
 800878c:	f7fb fc98 	bl	80040c0 <chMtxLock>
    while (argc > 1) {
 8008790:	2e01      	cmp	r6, #1
 8008792:	dd0f      	ble.n	80087b4 <cmd_test+0x34>
 8008794:	4d0b      	ldr	r5, [pc, #44]	; (80087c4 <cmd_test+0x44>)
        touch_position(&x, &y);
 8008796:	a901      	add	r1, sp, #4
 8008798:	4668      	mov	r0, sp
 800879a:	f007 fa49 	bl	800fc30 <touch_position>
        chprintf(chp, "touch: %d %d\r\n", x, y);
 800879e:	9b01      	ldr	r3, [sp, #4]
 80087a0:	9a00      	ldr	r2, [sp, #0]
 80087a2:	0029      	movs	r1, r5
 80087a4:	0020      	movs	r0, r4
 80087a6:	f7fe feb3 	bl	8007510 <chprintf>
        chThdSleepMilliseconds(200);
 80087aa:	20fa      	movs	r0, #250	; 0xfa
 80087ac:	00c0      	lsls	r0, r0, #3
 80087ae:	f7fb fbaf 	bl	8003f10 <chThdSleep>
 80087b2:	e7f0      	b.n	8008796 <cmd_test+0x16>
    chMtxUnlock(&mutex_sweep);
 80087b4:	0028      	movs	r0, r5
 80087b6:	f7fb fc8b 	bl	80040d0 <chMtxUnlock>
}
 80087ba:	b002      	add	sp, #8
 80087bc:	bd70      	pop	{r4, r5, r6, pc}
 80087be:	46c0      	nop			; (mov r8, r8)
 80087c0:	20002220 	.word	0x20002220
 80087c4:	0801422c 	.word	0x0801422c
	...

080087d0 <cmd_stat>:
{
 80087d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80087d2:	46ce      	mov	lr, r9
 80087d4:	4647      	mov	r7, r8
 80087d6:	4c30      	ldr	r4, [pc, #192]	; (8008898 <cmd_stat+0xc8>)
 80087d8:	4681      	mov	r9, r0
 80087da:	0026      	movs	r6, r4
 80087dc:	0023      	movs	r3, r4
  acc0 = acc1 = 0;
 80087de:	2500      	movs	r5, #0
 80087e0:	2000      	movs	r0, #0
{
 80087e2:	b580      	push	{r7, lr}
 80087e4:	3681      	adds	r6, #129	; 0x81
 80087e6:	36ff      	adds	r6, #255	; 0xff
    acc0 += p[i];
 80087e8:	2100      	movs	r1, #0
 80087ea:	5e5a      	ldrsh	r2, [r3, r1]
 80087ec:	1880      	adds	r0, r0, r2
    acc1 += p[i+1];
 80087ee:	2102      	movs	r1, #2
 80087f0:	5e5a      	ldrsh	r2, [r3, r1]
 80087f2:	3304      	adds	r3, #4
 80087f4:	18ad      	adds	r5, r5, r2
  for (i = 0; i < AUDIO_BUFFER_LEN*2; i += 2) {
 80087f6:	429e      	cmp	r6, r3
 80087f8:	d1f6      	bne.n	80087e8 <cmd_stat+0x18>
  ave0 = acc0 / count;
 80087fa:	2160      	movs	r1, #96	; 0x60
 80087fc:	f7f7 fd78 	bl	80002f0 <__divsi3>
  ave1 = acc1 / count;
 8008800:	2160      	movs	r1, #96	; 0x60
  ave0 = acc0 / count;
 8008802:	0007      	movs	r7, r0
  ave1 = acc1 / count;
 8008804:	0028      	movs	r0, r5
 8008806:	f7f7 fd73 	bl	80002f0 <__divsi3>
  acc0 = acc1 = 0;
 800880a:	2500      	movs	r5, #0
  ave1 = acc1 / count;
 800880c:	4680      	mov	r8, r0
  acc0 = acc1 = 0;
 800880e:	2000      	movs	r0, #0
    acc0 += (p[i] - ave0)*(p[i] - ave0);
 8008810:	2200      	movs	r2, #0
 8008812:	5ea3      	ldrsh	r3, [r4, r2]
 8008814:	1bdb      	subs	r3, r3, r7
 8008816:	435b      	muls	r3, r3
 8008818:	18c0      	adds	r0, r0, r3
    acc1 += (p[i+1] - ave1)*(p[i+1] - ave1);
 800881a:	2202      	movs	r2, #2
 800881c:	5ea3      	ldrsh	r3, [r4, r2]
 800881e:	4642      	mov	r2, r8
 8008820:	1a9b      	subs	r3, r3, r2
 8008822:	435b      	muls	r3, r3
 8008824:	3404      	adds	r4, #4
 8008826:	18ed      	adds	r5, r5, r3
  for (i = 0; i < AUDIO_BUFFER_LEN*2; i += 2) {
 8008828:	42a6      	cmp	r6, r4
 800882a:	d1f1      	bne.n	8008810 <cmd_stat+0x40>
  stat.rms[0] = (int16_t)sqrtf(acc0 / count);
 800882c:	2160      	movs	r1, #96	; 0x60
 800882e:	f7f7 fd5f 	bl	80002f0 <__divsi3>
 8008832:	f7f8 fed5 	bl	80015e0 <__aeabi_i2f>
 8008836:	f008 fde3 	bl	8011400 <sqrtf>
 800883a:	f7f8 feb1 	bl	80015a0 <__aeabi_f2iz>
 800883e:	4c17      	ldr	r4, [pc, #92]	; (800889c <cmd_stat+0xcc>)
  stat.rms[1] = (int16_t)sqrtf(acc1 / count);
 8008840:	2160      	movs	r1, #96	; 0x60
  stat.rms[0] = (int16_t)sqrtf(acc0 / count);
 8008842:	8020      	strh	r0, [r4, #0]
  stat.rms[1] = (int16_t)sqrtf(acc1 / count);
 8008844:	0028      	movs	r0, r5
 8008846:	f7f7 fd53 	bl	80002f0 <__divsi3>
 800884a:	f7f8 fec9 	bl	80015e0 <__aeabi_i2f>
 800884e:	f008 fdd7 	bl	8011400 <sqrtf>
 8008852:	f7f8 fea5 	bl	80015a0 <__aeabi_f2iz>
  stat.ave[1] = ave1;
 8008856:	4643      	mov	r3, r8
  stat.ave[0] = ave0;
 8008858:	b23a      	sxth	r2, r7
  stat.rms[1] = (int16_t)sqrtf(acc1 / count);
 800885a:	8060      	strh	r0, [r4, #2]
  stat.ave[1] = ave1;
 800885c:	b21b      	sxth	r3, r3
  chprintf(chp, "average: %d %d\r\n", stat.ave[0], stat.ave[1]);
 800885e:	4910      	ldr	r1, [pc, #64]	; (80088a0 <cmd_stat+0xd0>)
 8008860:	4648      	mov	r0, r9
  stat.ave[0] = ave0;
 8008862:	80a2      	strh	r2, [r4, #4]
  stat.ave[1] = ave1;
 8008864:	80e3      	strh	r3, [r4, #6]
  chprintf(chp, "average: %d %d\r\n", stat.ave[0], stat.ave[1]);
 8008866:	f7fe fe53 	bl	8007510 <chprintf>
  chprintf(chp, "rms: %d %d\r\n", stat.rms[0], stat.rms[1]);
 800886a:	2202      	movs	r2, #2
 800886c:	5ea3      	ldrsh	r3, [r4, r2]
 800886e:	4648      	mov	r0, r9
 8008870:	2100      	movs	r1, #0
 8008872:	5e62      	ldrsh	r2, [r4, r1]
 8008874:	490b      	ldr	r1, [pc, #44]	; (80088a4 <cmd_stat+0xd4>)
 8008876:	f7fe fe4b 	bl	8007510 <chprintf>
  chprintf(chp, "callback count: %d\r\n", stat.callback_count);
 800887a:	68a2      	ldr	r2, [r4, #8]
 800887c:	4648      	mov	r0, r9
 800887e:	490a      	ldr	r1, [pc, #40]	; (80088a8 <cmd_stat+0xd8>)
 8008880:	f7fe fe46 	bl	8007510 <chprintf>
  chprintf(chp, "awd: %d\r\n", awd_count);
 8008884:	4b09      	ldr	r3, [pc, #36]	; (80088ac <cmd_stat+0xdc>)
 8008886:	4648      	mov	r0, r9
 8008888:	681a      	ldr	r2, [r3, #0]
 800888a:	4909      	ldr	r1, [pc, #36]	; (80088b0 <cmd_stat+0xe0>)
 800888c:	f7fe fe40 	bl	8007510 <chprintf>
}
 8008890:	bc0c      	pop	{r2, r3}
 8008892:	4690      	mov	r8, r2
 8008894:	4699      	mov	r9, r3
 8008896:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8008898:	20002238 	.word	0x20002238
 800889c:	200023b8 	.word	0x200023b8
 80088a0:	08014168 	.word	0x08014168
 80088a4:	0801417c 	.word	0x0801417c
 80088a8:	0801418c 	.word	0x0801418c
 80088ac:	20003074 	.word	0x20003074
 80088b0:	080141a4 	.word	0x080141a4
	...

080088c0 <cmd_saveconfig>:
{
 80088c0:	b510      	push	{r4, lr}
 80088c2:	0004      	movs	r4, r0
  config_save();
 80088c4:	f008 f98c 	bl	8010be0 <config_save>
  chprintf(chp, "Config saved.\r\n");
 80088c8:	4902      	ldr	r1, [pc, #8]	; (80088d4 <cmd_saveconfig+0x14>)
 80088ca:	0020      	movs	r0, r4
 80088cc:	f7fe fe20 	bl	8007510 <chprintf>
}
 80088d0:	bd10      	pop	{r4, pc}
 80088d2:	46c0      	nop			; (mov r8, r8)
 80088d4:	080140e8 	.word	0x080140e8
	...

080088e0 <i2s_end_callback>:
{
 80088e0:	b510      	push	{r4, lr}
  if (wait_count > 0) {
 80088e2:	4c0c      	ldr	r4, [pc, #48]	; (8008914 <i2s_end_callback+0x34>)
 80088e4:	8823      	ldrh	r3, [r4, #0]
 80088e6:	b21b      	sxth	r3, r3
 80088e8:	2b00      	cmp	r3, #0
 80088ea:	dd06      	ble.n	80088fa <i2s_end_callback+0x1a>
    if (wait_count == 1) 
 80088ec:	8823      	ldrh	r3, [r4, #0]
 80088ee:	2b01      	cmp	r3, #1
 80088f0:	d008      	beq.n	8008904 <i2s_end_callback+0x24>
    --wait_count;
 80088f2:	8823      	ldrh	r3, [r4, #0]
 80088f4:	3b01      	subs	r3, #1
 80088f6:	b21b      	sxth	r3, r3
 80088f8:	8023      	strh	r3, [r4, #0]
  stat.callback_count++;
 80088fa:	4a07      	ldr	r2, [pc, #28]	; (8008918 <i2s_end_callback+0x38>)
 80088fc:	6893      	ldr	r3, [r2, #8]
 80088fe:	3301      	adds	r3, #1
 8008900:	6093      	str	r3, [r2, #8]
}
 8008902:	bd10      	pop	{r4, pc}
  int16_t *p = &rx_buffer[offset];
 8008904:	0048      	lsls	r0, r1, #1
 8008906:	4905      	ldr	r1, [pc, #20]	; (800891c <i2s_end_callback+0x3c>)
 8008908:	1840      	adds	r0, r0, r1
      dsp_process(p, n);
 800890a:	0011      	movs	r1, r2
 800890c:	f002 fe68 	bl	800b5e0 <dsp_process>
 8008910:	e7ef      	b.n	80088f2 <i2s_end_callback+0x12>
 8008912:	46c0      	nop			; (mov r8, r8)
 8008914:	200029e8 	.word	0x200029e8
 8008918:	200023b8 	.word	0x200023b8
 800891c:	20002238 	.word	0x20002238

08008920 <cmd_vbat_offset>:
}
#endif


static void cmd_vbat_offset(BaseSequentialStream *chp, int argc, char *argv[])
{
 8008920:	b510      	push	{r4, lr}
    if (argc != 1) {
 8008922:	2901      	cmp	r1, #1
 8008924:	d006      	beq.n	8008934 <cmd_vbat_offset+0x14>
        chprintf(chp, "%d\r\n", config.vbat_offset);
 8008926:	4b06      	ldr	r3, [pc, #24]	; (8008940 <cmd_vbat_offset+0x20>)
 8008928:	4906      	ldr	r1, [pc, #24]	; (8008944 <cmd_vbat_offset+0x24>)
 800892a:	2220      	movs	r2, #32
 800892c:	5e9a      	ldrsh	r2, [r3, r2]
 800892e:	f7fe fdef 	bl	8007510 <chprintf>
        return;
    }
    int offset = atoi(argv[0]);
    config.vbat_offset = (int16_t)offset;
}
 8008932:	bd10      	pop	{r4, pc}
    int offset = atoi(argv[0]);
 8008934:	6810      	ldr	r0, [r2, #0]
 8008936:	f00a fbbb 	bl	80130b0 <atoi>
    config.vbat_offset = (int16_t)offset;
 800893a:	4b01      	ldr	r3, [pc, #4]	; (8008940 <cmd_vbat_offset+0x20>)
 800893c:	8418      	strh	r0, [r3, #32]
 800893e:	e7f8      	b.n	8008932 <cmd_vbat_offset+0x12>
 8008940:	2000042c 	.word	0x2000042c
 8008944:	0801419c 	.word	0x0801419c
	...

08008950 <cmd_threshold>:
{
 8008950:	b570      	push	{r4, r5, r6, lr}
 8008952:	0004      	movs	r4, r0
    if (argc != 1) {
 8008954:	2901      	cmp	r1, #1
 8008956:	d009      	beq.n	800896c <cmd_threshold+0x1c>
        chprintf(chp, "usage: threshold {frequency in harmonic mode}\r\n");
 8008958:	490b      	ldr	r1, [pc, #44]	; (8008988 <cmd_threshold+0x38>)
 800895a:	f7fe fdd9 	bl	8007510 <chprintf>
        chprintf(chp, "current: %d\r\n", config.harmonic_freq_threshold);
 800895e:	4b0b      	ldr	r3, [pc, #44]	; (800898c <cmd_threshold+0x3c>)
 8008960:	490b      	ldr	r1, [pc, #44]	; (8008990 <cmd_threshold+0x40>)
 8008962:	69da      	ldr	r2, [r3, #28]
 8008964:	0020      	movs	r0, r4
 8008966:	f7fe fdd3 	bl	8007510 <chprintf>
}
 800896a:	bd70      	pop	{r4, r5, r6, pc}
    value = atoi(argv[0]);
 800896c:	6810      	ldr	r0, [r2, #0]
 800896e:	f00a fb9f 	bl	80130b0 <atoi>
 8008972:	0005      	movs	r5, r0
    chMtxLock(&mutex_sweep);
 8008974:	4c07      	ldr	r4, [pc, #28]	; (8008994 <cmd_threshold+0x44>)
 8008976:	0020      	movs	r0, r4
 8008978:	f7fb fba2 	bl	80040c0 <chMtxLock>
    config.harmonic_freq_threshold = value;
 800897c:	4b03      	ldr	r3, [pc, #12]	; (800898c <cmd_threshold+0x3c>)
    chMtxUnlock(&mutex_sweep);
 800897e:	0020      	movs	r0, r4
    config.harmonic_freq_threshold = value;
 8008980:	61dd      	str	r5, [r3, #28]
    chMtxUnlock(&mutex_sweep);
 8008982:	f7fb fba5 	bl	80040d0 <chMtxUnlock>
 8008986:	e7f0      	b.n	800896a <cmd_threshold+0x1a>
 8008988:	0801423c 	.word	0x0801423c
 800898c:	2000042c 	.word	0x2000042c
 8008990:	0801426c 	.word	0x0801426c
 8008994:	20002220 	.word	0x20002220
	...

080089a0 <cmd_recall>:
{
 80089a0:	b570      	push	{r4, r5, r6, lr}
 80089a2:	0004      	movs	r4, r0
    int id = argc == 1 ? atoi(argv[0]) : -1;
 80089a4:	2901      	cmp	r1, #1
 80089a6:	d004      	beq.n	80089b2 <cmd_recall+0x12>
        chprintf(chp, "recall {id}\r\n");
 80089a8:	4912      	ldr	r1, [pc, #72]	; (80089f4 <cmd_recall+0x54>)
 80089aa:	0020      	movs	r0, r4
 80089ac:	f7fe fdb0 	bl	8007510 <chprintf>
}
 80089b0:	bd70      	pop	{r4, r5, r6, pc}
    int id = argc == 1 ? atoi(argv[0]) : -1;
 80089b2:	6810      	ldr	r0, [r2, #0]
 80089b4:	f00a fb7c 	bl	80130b0 <atoi>
 80089b8:	0005      	movs	r5, r0
    if (argc != 1 || id < 0 || id >= SAVEAREA_MAX) {
 80089ba:	2803      	cmp	r0, #3
 80089bc:	d8f4      	bhi.n	80089a8 <cmd_recall+0x8>
    sweep_enabled = FALSE;
 80089be:	2300      	movs	r3, #0
    chMtxLock(&mutex_sweep);
 80089c0:	4e0d      	ldr	r6, [pc, #52]	; (80089f8 <cmd_recall+0x58>)
    sweep_enabled = FALSE;
 80089c2:	4c0e      	ldr	r4, [pc, #56]	; (80089fc <cmd_recall+0x5c>)
    chMtxLock(&mutex_sweep);
 80089c4:	0030      	movs	r0, r6
    sweep_enabled = FALSE;
 80089c6:	7023      	strb	r3, [r4, #0]
    chMtxLock(&mutex_sweep);
 80089c8:	f7fb fb7a 	bl	80040c0 <chMtxLock>
    if (caldata_recall(id) == 0) {
 80089cc:	0028      	movs	r0, r5
 80089ce:	f008 fa07 	bl	8010de0 <caldata_recall>
 80089d2:	2800      	cmp	r0, #0
 80089d4:	d005      	beq.n	80089e2 <cmd_recall+0x42>
    chMtxUnlock(&mutex_sweep);
 80089d6:	0030      	movs	r0, r6
 80089d8:	f7fb fb7a 	bl	80040d0 <chMtxUnlock>
    sweep_enabled = TRUE;
 80089dc:	2301      	movs	r3, #1
 80089de:	7023      	strb	r3, [r4, #0]
 80089e0:	e7e6      	b.n	80089b0 <cmd_recall+0x10>
        update_frequencies();
 80089e2:	f7ff f9fd 	bl	8007de0 <update_frequencies>
        redraw_request |= REDRAW_CAL_STATUS;
 80089e6:	2104      	movs	r1, #4
 80089e8:	4a05      	ldr	r2, [pc, #20]	; (8008a00 <cmd_recall+0x60>)
 80089ea:	8813      	ldrh	r3, [r2, #0]
 80089ec:	430b      	orrs	r3, r1
 80089ee:	8013      	strh	r3, [r2, #0]
 80089f0:	e7f1      	b.n	80089d6 <cmd_recall+0x36>
 80089f2:	46c0      	nop			; (mov r8, r8)
 80089f4:	0801405c 	.word	0x0801405c
 80089f8:	20002220 	.word	0x20002220
 80089fc:	20001630 	.word	0x20001630
 8008a00:	20002236 	.word	0x20002236
	...

08008a10 <cmd_marker>:
{
 8008a10:	b5f0      	push	{r4, r5, r6, r7, lr}
 8008a12:	4646      	mov	r6, r8
 8008a14:	46d6      	mov	lr, sl
 8008a16:	464f      	mov	r7, r9
 8008a18:	b5c0      	push	{r6, r7, lr}
    chMtxLock(&mutex_sweep);
 8008a1a:	4e5b      	ldr	r6, [pc, #364]	; (8008b88 <cmd_marker+0x178>)
{
 8008a1c:	b082      	sub	sp, #8
 8008a1e:	4680      	mov	r8, r0
    chMtxLock(&mutex_sweep);
 8008a20:	0030      	movs	r0, r6
{
 8008a22:	000c      	movs	r4, r1
 8008a24:	0015      	movs	r5, r2
    chMtxLock(&mutex_sweep);
 8008a26:	f7fb fb4b 	bl	80040c0 <chMtxLock>
    if (argc == 0) {
 8008a2a:	2c00      	cmp	r4, #0
 8008a2c:	d045      	beq.n	8008aba <cmd_marker+0xaa>
    if (strcmp(argv[0], "off") == 0) {
 8008a2e:	4b57      	ldr	r3, [pc, #348]	; (8008b8c <cmd_marker+0x17c>)
 8008a30:	682f      	ldr	r7, [r5, #0]
 8008a32:	0019      	movs	r1, r3
 8008a34:	0038      	movs	r0, r7
 8008a36:	4699      	mov	r9, r3
 8008a38:	f7fa feca 	bl	80037d0 <strcmp>
 8008a3c:	2800      	cmp	r0, #0
 8008a3e:	d11b      	bne.n	8008a78 <cmd_marker+0x68>
        active_marker = -1;
 8008a40:	228e      	movs	r2, #142	; 0x8e
 8008a42:	2101      	movs	r1, #1
 8008a44:	4b52      	ldr	r3, [pc, #328]	; (8008b90 <cmd_marker+0x180>)
 8008a46:	0152      	lsls	r2, r2, #5
 8008a48:	4249      	negs	r1, r1
 8008a4a:	5099      	str	r1, [r3, r2]
            markers[t].enabled = FALSE;
 8008a4c:	3a20      	subs	r2, #32
 8008a4e:	5498      	strb	r0, [r3, r2]
 8008a50:	4a50      	ldr	r2, [pc, #320]	; (8008b94 <cmd_marker+0x184>)
 8008a52:	5498      	strb	r0, [r3, r2]
 8008a54:	4a50      	ldr	r2, [pc, #320]	; (8008b98 <cmd_marker+0x188>)
 8008a56:	5498      	strb	r0, [r3, r2]
 8008a58:	4a50      	ldr	r2, [pc, #320]	; (8008b9c <cmd_marker+0x18c>)
 8008a5a:	5498      	strb	r0, [r3, r2]
        redraw_request |= REDRAW_MARKER;
 8008a5c:	2108      	movs	r1, #8
 8008a5e:	4a50      	ldr	r2, [pc, #320]	; (8008ba0 <cmd_marker+0x190>)
 8008a60:	8813      	ldrh	r3, [r2, #0]
 8008a62:	430b      	orrs	r3, r1
 8008a64:	8013      	strh	r3, [r2, #0]
        chMtxUnlock(&mutex_sweep);
 8008a66:	0030      	movs	r0, r6
 8008a68:	f7fb fb32 	bl	80040d0 <chMtxUnlock>
}
 8008a6c:	b002      	add	sp, #8
 8008a6e:	bc1c      	pop	{r2, r3, r4}
 8008a70:	4690      	mov	r8, r2
 8008a72:	4699      	mov	r9, r3
 8008a74:	46a2      	mov	sl, r4
 8008a76:	bdf0      	pop	{r4, r5, r6, r7, pc}
    int t = atoi(argv[0]) - 1;
 8008a78:	0038      	movs	r0, r7
 8008a7a:	f00a fb19 	bl	80130b0 <atoi>
 8008a7e:	1e43      	subs	r3, r0, #1
 8008a80:	0007      	movs	r7, r0
 8008a82:	469a      	mov	sl, r3
    if (t < 0 || t >= MARKER_COUNT) {
 8008a84:	2b03      	cmp	r3, #3
 8008a86:	d831      	bhi.n	8008aec <cmd_marker+0xdc>
    if (argc == 1) {
 8008a88:	2c01      	cmp	r4, #1
 8008a8a:	d049      	beq.n	8008b20 <cmd_marker+0x110>
    else if (argc > 1) {
 8008a8c:	ddeb      	ble.n	8008a66 <cmd_marker+0x56>
        if (strcmp(argv[1], "off") == 0) {
 8008a8e:	686c      	ldr	r4, [r5, #4]
 8008a90:	4649      	mov	r1, r9
 8008a92:	0020      	movs	r0, r4
 8008a94:	f7fa fe9c 	bl	80037d0 <strcmp>
 8008a98:	2800      	cmp	r0, #0
 8008a9a:	d12f      	bne.n	8008afc <cmd_marker+0xec>
            markers[t].enabled = FALSE;
 8008a9c:	4a41      	ldr	r2, [pc, #260]	; (8008ba4 <cmd_marker+0x194>)
 8008a9e:	4b3c      	ldr	r3, [pc, #240]	; (8008b90 <cmd_marker+0x180>)
 8008aa0:	4694      	mov	ip, r2
            if (active_marker == t) {
 8008aa2:	228e      	movs	r2, #142	; 0x8e
 8008aa4:	0152      	lsls	r2, r2, #5
            markers[t].enabled = FALSE;
 8008aa6:	4467      	add	r7, ip
            if (active_marker == t) {
 8008aa8:	5899      	ldr	r1, [r3, r2]
            markers[t].enabled = FALSE;
 8008aaa:	00ff      	lsls	r7, r7, #3
 8008aac:	54f8      	strb	r0, [r7, r3]
            if (active_marker == t) {
 8008aae:	458a      	cmp	sl, r1
 8008ab0:	d1d4      	bne.n	8008a5c <cmd_marker+0x4c>
                active_marker = -1;
 8008ab2:	2101      	movs	r1, #1
 8008ab4:	4249      	negs	r1, r1
 8008ab6:	5099      	str	r1, [r3, r2]
            redraw_request |= REDRAW_MARKER;
 8008ab8:	e7d0      	b.n	8008a5c <cmd_marker+0x4c>
            if (markers[t].enabled) {
 8008aba:	2300      	movs	r3, #0
 8008abc:	4d3a      	ldr	r5, [pc, #232]	; (8008ba8 <cmd_marker+0x198>)
                chprintf(chp, "%d %d %d\r\n", t+1, markers[t].index, markers[t].frequency);
 8008abe:	4f3b      	ldr	r7, [pc, #236]	; (8008bac <cmd_marker+0x19c>)
            if (markers[t].enabled) {
 8008ac0:	56eb      	ldrsb	r3, [r5, r3]
 8008ac2:	3401      	adds	r4, #1
 8008ac4:	2b00      	cmp	r3, #0
 8008ac6:	d107      	bne.n	8008ad8 <cmd_marker+0xc8>
 8008ac8:	3508      	adds	r5, #8
        for (int t = 0; t < MARKER_COUNT; t++) {
 8008aca:	2c04      	cmp	r4, #4
 8008acc:	d0cb      	beq.n	8008a66 <cmd_marker+0x56>
            if (markers[t].enabled) {
 8008ace:	2300      	movs	r3, #0
 8008ad0:	56eb      	ldrsb	r3, [r5, r3]
 8008ad2:	3401      	adds	r4, #1
 8008ad4:	2b00      	cmp	r3, #0
 8008ad6:	d0f7      	beq.n	8008ac8 <cmd_marker+0xb8>
                chprintf(chp, "%d %d %d\r\n", t+1, markers[t].index, markers[t].frequency);
 8008ad8:	2202      	movs	r2, #2
 8008ada:	5eab      	ldrsh	r3, [r5, r2]
 8008adc:	686a      	ldr	r2, [r5, #4]
 8008ade:	0039      	movs	r1, r7
 8008ae0:	9200      	str	r2, [sp, #0]
 8008ae2:	4640      	mov	r0, r8
 8008ae4:	0022      	movs	r2, r4
 8008ae6:	f7fe fd13 	bl	8007510 <chprintf>
 8008aea:	e7ed      	b.n	8008ac8 <cmd_marker+0xb8>
        chprintf(chp, "marker [n] [off|{index}]\r\n");
 8008aec:	4930      	ldr	r1, [pc, #192]	; (8008bb0 <cmd_marker+0x1a0>)
 8008aee:	4640      	mov	r0, r8
 8008af0:	f7fe fd0e 	bl	8007510 <chprintf>
        chMtxUnlock(&mutex_sweep);
 8008af4:	0030      	movs	r0, r6
 8008af6:	f7fb faeb 	bl	80040d0 <chMtxUnlock>
        return;
 8008afa:	e7b7      	b.n	8008a6c <cmd_marker+0x5c>
        } else if (strcmp(argv[1], "on") == 0) {
 8008afc:	492d      	ldr	r1, [pc, #180]	; (8008bb4 <cmd_marker+0x1a4>)
 8008afe:	0020      	movs	r0, r4
 8008b00:	f7fa fe66 	bl	80037d0 <strcmp>
 8008b04:	2800      	cmp	r0, #0
 8008b06:	d123      	bne.n	8008b50 <cmd_marker+0x140>
            markers[t].enabled = TRUE;
 8008b08:	4a26      	ldr	r2, [pc, #152]	; (8008ba4 <cmd_marker+0x194>)
 8008b0a:	4b21      	ldr	r3, [pc, #132]	; (8008b90 <cmd_marker+0x180>)
 8008b0c:	4694      	mov	ip, r2
 8008b0e:	2201      	movs	r2, #1
 8008b10:	4467      	add	r7, ip
 8008b12:	00ff      	lsls	r7, r7, #3
 8008b14:	54fa      	strb	r2, [r7, r3]
                active_marker = t;
 8008b16:	228e      	movs	r2, #142	; 0x8e
 8008b18:	4651      	mov	r1, sl
 8008b1a:	0152      	lsls	r2, r2, #5
                active_marker = -1;
 8008b1c:	5099      	str	r1, [r3, r2]
            redraw_request |= REDRAW_MARKER;
 8008b1e:	e79d      	b.n	8008a5c <cmd_marker+0x4c>
        chprintf(chp, "%d %d %d\r\n", t+1, markers[t].index, frequency);
 8008b20:	4b1b      	ldr	r3, [pc, #108]	; (8008b90 <cmd_marker+0x180>)
 8008b22:	4922      	ldr	r1, [pc, #136]	; (8008bac <cmd_marker+0x19c>)
 8008b24:	4699      	mov	r9, r3
 8008b26:	4b1f      	ldr	r3, [pc, #124]	; (8008ba4 <cmd_marker+0x194>)
 8008b28:	18c5      	adds	r5, r0, r3
 8008b2a:	464b      	mov	r3, r9
 8008b2c:	00ed      	lsls	r5, r5, #3
 8008b2e:	195b      	adds	r3, r3, r5
 8008b30:	2202      	movs	r2, #2
 8008b32:	5e9b      	ldrsh	r3, [r3, r2]
 8008b34:	4a20      	ldr	r2, [pc, #128]	; (8008bb8 <cmd_marker+0x1a8>)
 8008b36:	6812      	ldr	r2, [r2, #0]
 8008b38:	9200      	str	r2, [sp, #0]
 8008b3a:	0002      	movs	r2, r0
 8008b3c:	4640      	mov	r0, r8
 8008b3e:	f7fe fce7 	bl	8007510 <chprintf>
        active_marker = t;
 8008b42:	238e      	movs	r3, #142	; 0x8e
 8008b44:	464a      	mov	r2, r9
 8008b46:	4651      	mov	r1, sl
 8008b48:	015b      	lsls	r3, r3, #5
 8008b4a:	50d1      	str	r1, [r2, r3]
        markers[t].enabled = TRUE;
 8008b4c:	54ac      	strb	r4, [r5, r2]
        redraw_request |= REDRAW_MARKER;
 8008b4e:	e785      	b.n	8008a5c <cmd_marker+0x4c>
            int index = atoi(argv[1]);
 8008b50:	0020      	movs	r0, r4
 8008b52:	f00a faad 	bl	80130b0 <atoi>
            if (index < 0 || index >= POINT_COUNT) {
 8008b56:	2864      	cmp	r0, #100	; 0x64
 8008b58:	d810      	bhi.n	8008b7c <cmd_marker+0x16c>
                markers[t].index = index;
 8008b5a:	4a12      	ldr	r2, [pc, #72]	; (8008ba4 <cmd_marker+0x194>)
 8008b5c:	4b0c      	ldr	r3, [pc, #48]	; (8008b90 <cmd_marker+0x180>)
 8008b5e:	4694      	mov	ip, r2
 8008b60:	4467      	add	r7, ip
 8008b62:	00ff      	lsls	r7, r7, #3
 8008b64:	19da      	adds	r2, r3, r7
 8008b66:	8050      	strh	r0, [r2, #2]
                markers[t].frequency = frequencies[index];
 8008b68:	3004      	adds	r0, #4
 8008b6a:	0080      	lsls	r0, r0, #2
 8008b6c:	58c1      	ldr	r1, [r0, r3]
 8008b6e:	6051      	str	r1, [r2, #4]
                markers[t].enabled = TRUE;
 8008b70:	2201      	movs	r2, #1
                previous_marker = -1;
 8008b72:	21ff      	movs	r1, #255	; 0xff
                markers[t].enabled = TRUE;
 8008b74:	54fa      	strb	r2, [r7, r3]
                previous_marker = -1;
 8008b76:	4a11      	ldr	r2, [pc, #68]	; (8008bbc <cmd_marker+0x1ac>)
 8008b78:	7011      	strb	r1, [r2, #0]
 8008b7a:	e7cc      	b.n	8008b16 <cmd_marker+0x106>
                chprintf(chp, "error: invalid index\r\n");
 8008b7c:	4910      	ldr	r1, [pc, #64]	; (8008bc0 <cmd_marker+0x1b0>)
 8008b7e:	4640      	mov	r0, r8
 8008b80:	f7fe fcc6 	bl	8007510 <chprintf>
 8008b84:	e76f      	b.n	8008a66 <cmd_marker+0x56>
 8008b86:	46c0      	nop			; (mov r8, r8)
 8008b88:	20002220 	.word	0x20002220
 8008b8c:	080143c8 	.word	0x080143c8
 8008b90:	20000454 	.word	0x20000454
 8008b94:	000011a8 	.word	0x000011a8
 8008b98:	000011b0 	.word	0x000011b0
 8008b9c:	000011b8 	.word	0x000011b8
 8008ba0:	20002236 	.word	0x20002236
 8008ba4:	00000233 	.word	0x00000233
 8008ba8:	200015f4 	.word	0x200015f4
 8008bac:	08013fc0 	.word	0x08013fc0
 8008bb0:	08013fcc 	.word	0x08013fcc
 8008bb4:	080143c4 	.word	0x080143c4
 8008bb8:	20001624 	.word	0x20001624
 8008bbc:	20001650 	.word	0x20001650
 8008bc0:	08013fe8 	.word	0x08013fe8
	...

08008bd0 <set_frequency.part.4>:
static int set_frequency(uint32_t freq)
 8008bd0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8008bd2:	46c6      	mov	lr, r8
  int new_order = (newfreq-1) / FREQ_HARMONICS; //Harmonics are switched after an integer multiple, and then the gain needs to be switched after an integer multiple.
 8008bd4:	4b19      	ldr	r3, [pc, #100]	; (8008c3c <set_frequency.part.4+0x6c>)
static int set_frequency(uint32_t freq)
 8008bd6:	b500      	push	{lr}
  int new_order = (newfreq-1) / FREQ_HARMONICS; //Harmonics are switched after an integer multiple, and then the gain needs to be switched after an integer multiple.
 8008bd8:	69df      	ldr	r7, [r3, #28]
static int set_frequency(uint32_t freq)
 8008bda:	0004      	movs	r4, r0
  int new_order = (newfreq-1) / FREQ_HARMONICS; //Harmonics are switched after an integer multiple, and then the gain needs to be switched after an integer multiple.
 8008bdc:	0039      	movs	r1, r7
 8008bde:	3801      	subs	r0, #1
 8008be0:	4698      	mov	r8, r3
 8008be2:	f7f7 faf5 	bl	80001d0 <__udivsi3>
  int old_order = (frequency-1) / FREQ_HARMONICS;
 8008be6:	4e16      	ldr	r6, [pc, #88]	; (8008c40 <set_frequency.part.4+0x70>)
 8008be8:	0039      	movs	r1, r7
 8008bea:	6833      	ldr	r3, [r6, #0]
  int new_order = (newfreq-1) / FREQ_HARMONICS; //Harmonics are switched after an integer multiple, and then the gain needs to be switched after an integer multiple.
 8008bec:	0005      	movs	r5, r0
  int old_order = (frequency-1) / FREQ_HARMONICS;
 8008bee:	1e58      	subs	r0, r3, #1
 8008bf0:	f7f7 faee 	bl	80001d0 <__udivsi3>
  int delay = 0;
 8008bf4:	2700      	movs	r7, #0
  if (new_order != old_order) {
 8008bf6:	4285      	cmp	r5, r0
 8008bf8:	d008      	beq.n	8008c0c <set_frequency.part.4+0x3c>
    tlv320aic3204_set_gain(gain_table[new_order][0], gain_table[new_order][1]);
 8008bfa:	2101      	movs	r1, #1
 8008bfc:	4b11      	ldr	r3, [pc, #68]	; (8008c44 <set_frequency.part.4+0x74>)
 8008bfe:	006d      	lsls	r5, r5, #1
 8008c00:	195a      	adds	r2, r3, r5
 8008c02:	5651      	ldrsb	r1, [r2, r1]
 8008c04:	56e8      	ldrsb	r0, [r5, r3]
 8008c06:	f002 fccb 	bl	800b5a0 <tlv320aic3204_set_gain>
    delay += 10;
 8008c0a:	370a      	adds	r7, #10
    int8_t ds = drive_strength;
 8008c0c:	2200      	movs	r2, #0
 8008c0e:	4b0e      	ldr	r3, [pc, #56]	; (8008c48 <set_frequency.part.4+0x78>)
 8008c10:	569a      	ldrsb	r2, [r3, r2]
    if (ds == DRIVE_STRENGTH_AUTO) {
 8008c12:	1c53      	adds	r3, r2, #1
 8008c14:	d00a      	beq.n	8008c2c <set_frequency.part.4+0x5c>
 8008c16:	b2d2      	uxtb	r2, r2
    delay += si5351_set_frequency_with_offset(freq, frequency_offset, ds);
 8008c18:	4b0c      	ldr	r3, [pc, #48]	; (8008c4c <set_frequency.part.4+0x7c>)
 8008c1a:	0020      	movs	r0, r4
 8008c1c:	6819      	ldr	r1, [r3, #0]
 8008c1e:	f002 facf 	bl	800b1c0 <si5351_set_frequency_with_offset>
 8008c22:	19c0      	adds	r0, r0, r7
    frequency = freq;
 8008c24:	6034      	str	r4, [r6, #0]
}
 8008c26:	bc04      	pop	{r2}
 8008c28:	4690      	mov	r8, r2
 8008c2a:	bdf0      	pop	{r4, r5, r6, r7, pc}
      ds = freq > FREQ_HARMONICS ? SI5351_CLK_DRIVE_STRENGTH_8MA : SI5351_CLK_DRIVE_STRENGTH_2MA;
 8008c2c:	4643      	mov	r3, r8
 8008c2e:	69db      	ldr	r3, [r3, #28]
 8008c30:	2203      	movs	r2, #3
 8008c32:	42a3      	cmp	r3, r4
 8008c34:	419b      	sbcs	r3, r3
 8008c36:	401a      	ands	r2, r3
 8008c38:	e7ee      	b.n	8008c18 <set_frequency.part.4+0x48>
 8008c3a:	46c0      	nop			; (mov r8, r8)
 8008c3c:	2000042c 	.word	0x2000042c
 8008c40:	20001624 	.word	0x20001624
 8008c44:	08014560 	.word	0x08014560
 8008c48:	20001620 	.word	0x20001620
 8008c4c:	20001628 	.word	0x20001628

08008c50 <cmd_power>:
{
 8008c50:	b510      	push	{r4, lr}
    if (argc != 1) {
 8008c52:	2901      	cmp	r1, #1
 8008c54:	d003      	beq.n	8008c5e <cmd_power+0xe>
        chprintf(chp, "usage: power {0-3|-1}\r\n");
 8008c56:	4908      	ldr	r1, [pc, #32]	; (8008c78 <cmd_power+0x28>)
 8008c58:	f7fe fc5a 	bl	8007510 <chprintf>
}
 8008c5c:	bd10      	pop	{r4, pc}
    drive_strength = atoi(argv[0]);
 8008c5e:	6810      	ldr	r0, [r2, #0]
 8008c60:	f00a fa26 	bl	80130b0 <atoi>
    chMtxLock(&mutex_sweep);
 8008c64:	4c05      	ldr	r4, [pc, #20]	; (8008c7c <cmd_power+0x2c>)
    drive_strength = atoi(argv[0]);
 8008c66:	4b06      	ldr	r3, [pc, #24]	; (8008c80 <cmd_power+0x30>)
 8008c68:	7018      	strb	r0, [r3, #0]
    chMtxLock(&mutex_sweep);
 8008c6a:	0020      	movs	r0, r4
 8008c6c:	f7fb fa28 	bl	80040c0 <chMtxLock>
    chMtxUnlock(&mutex_sweep);
 8008c70:	0020      	movs	r0, r4
 8008c72:	f7fb fa2d 	bl	80040d0 <chMtxUnlock>
 8008c76:	e7f1      	b.n	8008c5c <cmd_power+0xc>
 8008c78:	08014044 	.word	0x08014044
 8008c7c:	20002220 	.word	0x20002220
 8008c80:	20001620 	.word	0x20001620
	...

08008c90 <cmd_offset>:
{
 8008c90:	b570      	push	{r4, r5, r6, lr}
 8008c92:	0015      	movs	r5, r2
    if (argc != 1) {
 8008c94:	2901      	cmp	r1, #1
 8008c96:	d003      	beq.n	8008ca0 <cmd_offset+0x10>
        chprintf(chp, "usage: offset {frequency offset(Hz)}\r\n");
 8008c98:	4908      	ldr	r1, [pc, #32]	; (8008cbc <cmd_offset+0x2c>)
 8008c9a:	f7fe fc39 	bl	8007510 <chprintf>
}
 8008c9e:	bd70      	pop	{r4, r5, r6, pc}
    chMtxLock(&mutex_sweep);
 8008ca0:	4c07      	ldr	r4, [pc, #28]	; (8008cc0 <cmd_offset+0x30>)
 8008ca2:	0020      	movs	r0, r4
 8008ca4:	f7fb fa0c 	bl	80040c0 <chMtxLock>
    frequency_offset = atoi(argv[0]);
 8008ca8:	6828      	ldr	r0, [r5, #0]
 8008caa:	f00a fa01 	bl	80130b0 <atoi>
 8008cae:	4b05      	ldr	r3, [pc, #20]	; (8008cc4 <cmd_offset+0x34>)
 8008cb0:	6018      	str	r0, [r3, #0]
    chMtxUnlock(&mutex_sweep);
 8008cb2:	0020      	movs	r0, r4
 8008cb4:	f7fb fa0c 	bl	80040d0 <chMtxUnlock>
 8008cb8:	e7f1      	b.n	8008c9e <cmd_offset+0xe>
 8008cba:	46c0      	nop			; (mov r8, r8)
 8008cbc:	08014000 	.word	0x08014000
 8008cc0:	20002220 	.word	0x20002220
 8008cc4:	20001628 	.word	0x20001628
	...

08008cd0 <cmd_freq>:
{
 8008cd0:	b570      	push	{r4, r5, r6, lr}
 8008cd2:	0015      	movs	r5, r2
    if (argc != 1) {
 8008cd4:	2901      	cmp	r1, #1
 8008cd6:	d003      	beq.n	8008ce0 <cmd_freq+0x10>
        chprintf(chp, "usage: freq {frequency(Hz)}\r\n");
 8008cd8:	490b      	ldr	r1, [pc, #44]	; (8008d08 <cmd_freq+0x38>)
 8008cda:	f7fe fc19 	bl	8007510 <chprintf>
}
 8008cde:	bd70      	pop	{r4, r5, r6, pc}
    sweep_enabled = FALSE;
 8008ce0:	2200      	movs	r2, #0
    chMtxLock(&mutex_sweep);
 8008ce2:	4c0a      	ldr	r4, [pc, #40]	; (8008d0c <cmd_freq+0x3c>)
    sweep_enabled = FALSE;
 8008ce4:	4b0a      	ldr	r3, [pc, #40]	; (8008d10 <cmd_freq+0x40>)
    chMtxLock(&mutex_sweep);
 8008ce6:	0020      	movs	r0, r4
    sweep_enabled = FALSE;
 8008ce8:	701a      	strb	r2, [r3, #0]
    chMtxLock(&mutex_sweep);
 8008cea:	f7fb f9e9 	bl	80040c0 <chMtxLock>
    freq = atoi(argv[0]);
 8008cee:	6828      	ldr	r0, [r5, #0]
 8008cf0:	f00a f9de 	bl	80130b0 <atoi>
    if (frequency == freq)
 8008cf4:	4b07      	ldr	r3, [pc, #28]	; (8008d14 <cmd_freq+0x44>)
 8008cf6:	681b      	ldr	r3, [r3, #0]
 8008cf8:	4298      	cmp	r0, r3
 8008cfa:	d001      	beq.n	8008d00 <cmd_freq+0x30>
 8008cfc:	f7ff ff68 	bl	8008bd0 <set_frequency.part.4>
    chMtxUnlock(&mutex_sweep);
 8008d00:	0020      	movs	r0, r4
 8008d02:	f7fb f9e5 	bl	80040d0 <chMtxUnlock>
 8008d06:	e7ea      	b.n	8008cde <cmd_freq+0xe>
 8008d08:	08013f74 	.word	0x08013f74
 8008d0c:	20002220 	.word	0x20002220
 8008d10:	20001630 	.word	0x20001630
 8008d14:	20001624 	.word	0x20001624
	...

08008d20 <cmd_gain>:
  if (argc != 1 && argc != 2) {
 8008d20:	1e4b      	subs	r3, r1, #1
{
 8008d22:	b570      	push	{r4, r5, r6, lr}
 8008d24:	000c      	movs	r4, r1
 8008d26:	0015      	movs	r5, r2
  if (argc != 1 && argc != 2) {
 8008d28:	2b01      	cmp	r3, #1
 8008d2a:	d80a      	bhi.n	8008d42 <cmd_gain+0x22>
  rvalue = atoi(argv[0]);
 8008d2c:	6810      	ldr	r0, [r2, #0]
 8008d2e:	f00a f9bf 	bl	80130b0 <atoi>
 8008d32:	0006      	movs	r6, r0
  int lvalue = 0;
 8008d34:	2000      	movs	r0, #0
  if (argc == 2) 
 8008d36:	2c02      	cmp	r4, #2
 8008d38:	d007      	beq.n	8008d4a <cmd_gain+0x2a>
  tlv320aic3204_set_gain(lvalue, rvalue);
 8008d3a:	0031      	movs	r1, r6
 8008d3c:	f002 fc30 	bl	800b5a0 <tlv320aic3204_set_gain>
}
 8008d40:	bd70      	pop	{r4, r5, r6, pc}
    chprintf(chp, "usage: gain {lgain(0-95)} [rgain(0-95)]\r\n");
 8008d42:	4904      	ldr	r1, [pc, #16]	; (8008d54 <cmd_gain+0x34>)
 8008d44:	f7fe fbe4 	bl	8007510 <chprintf>
    return;
 8008d48:	e7fa      	b.n	8008d40 <cmd_gain+0x20>
    lvalue = atoi(argv[1]);
 8008d4a:	6868      	ldr	r0, [r5, #4]
 8008d4c:	f00a f9b0 	bl	80130b0 <atoi>
 8008d50:	e7f3      	b.n	8008d3a <cmd_gain+0x1a>
 8008d52:	46c0      	nop			; (mov r8, r8)
 8008d54:	08013f94 	.word	0x08013f94
	...

08008d60 <cmd_port>:
{
 8008d60:	b510      	push	{r4, lr}
  if (argc != 1) {
 8008d62:	2901      	cmp	r1, #1
 8008d64:	d003      	beq.n	8008d6e <cmd_port+0xe>
    chprintf(chp, "usage: port {0:TX 1:RX}\r\n");
 8008d66:	4905      	ldr	r1, [pc, #20]	; (8008d7c <cmd_port+0x1c>)
 8008d68:	f7fe fbd2 	bl	8007510 <chprintf>
}
 8008d6c:	bd10      	pop	{r4, pc}
  port = atoi(argv[0]);
 8008d6e:	6810      	ldr	r0, [r2, #0]
 8008d70:	f00a f99e 	bl	80130b0 <atoi>
  tlv320aic3204_select(port);
 8008d74:	f002 fbec 	bl	800b550 <tlv320aic3204_select>
 8008d78:	e7f8      	b.n	8008d6c <cmd_port+0xc>
 8008d7a:	46c0      	nop			; (mov r8, r8)
 8008d7c:	08014028 	.word	0x08014028

08008d80 <cmd_clearconfig>:
{
 8008d80:	b570      	push	{r4, r5, r6, lr}
 8008d82:	0004      	movs	r4, r0
    if (argc != 1) {
 8008d84:	2901      	cmp	r1, #1
 8008d86:	d118      	bne.n	8008dba <cmd_clearconfig+0x3a>
    if (strcmp(argv[0], "1234") != 0) {
 8008d88:	6810      	ldr	r0, [r2, #0]
 8008d8a:	490e      	ldr	r1, [pc, #56]	; (8008dc4 <cmd_clearconfig+0x44>)
 8008d8c:	f7fa fd20 	bl	80037d0 <strcmp>
 8008d90:	2800      	cmp	r0, #0
 8008d92:	d10d      	bne.n	8008db0 <cmd_clearconfig+0x30>
    chMtxLock(&mutex_sweep);        // TODO: separate mutex?
 8008d94:	4d0c      	ldr	r5, [pc, #48]	; (8008dc8 <cmd_clearconfig+0x48>)
 8008d96:	0028      	movs	r0, r5
 8008d98:	f7fb f992 	bl	80040c0 <chMtxLock>
    clear_all_config_prop_data();
 8008d9c:	f008 f890 	bl	8010ec0 <clear_all_config_prop_data>
    chMtxUnlock(&mutex_sweep);
 8008da0:	0028      	movs	r0, r5
 8008da2:	f7fb f995 	bl	80040d0 <chMtxUnlock>
    chprintf(chp, "Config and all cal data cleared.\r\n");
 8008da6:	4909      	ldr	r1, [pc, #36]	; (8008dcc <cmd_clearconfig+0x4c>)
 8008da8:	0020      	movs	r0, r4
 8008daa:	f7fe fbb1 	bl	8007510 <chprintf>
}
 8008dae:	bd70      	pop	{r4, r5, r6, pc}
        chprintf(chp, "Key unmatched.\r\n");
 8008db0:	4907      	ldr	r1, [pc, #28]	; (8008dd0 <cmd_clearconfig+0x50>)
 8008db2:	0020      	movs	r0, r4
 8008db4:	f7fe fbac 	bl	8007510 <chprintf>
        return;
 8008db8:	e7f9      	b.n	8008dae <cmd_clearconfig+0x2e>
        chprintf(chp, "usage: clearconfig {protection key}\r\n");
 8008dba:	4906      	ldr	r1, [pc, #24]	; (8008dd4 <cmd_clearconfig+0x54>)
 8008dbc:	f7fe fba8 	bl	8007510 <chprintf>
        return;
 8008dc0:	e7f5      	b.n	8008dae <cmd_clearconfig+0x2e>
 8008dc2:	46c0      	nop			; (mov r8, r8)
 8008dc4:	08013f14 	.word	0x08013f14
 8008dc8:	20002220 	.word	0x20002220
 8008dcc:	08013f30 	.word	0x08013f30
 8008dd0:	08013f1c 	.word	0x08013f1c
 8008dd4:	08013eec 	.word	0x08013eec
	...

08008de0 <cmd_reset>:
{
 8008de0:	b510      	push	{r4, lr}
 8008de2:	0004      	movs	r4, r0
    if (argc == 1) {
 8008de4:	2901      	cmp	r1, #1
 8008de6:	d105      	bne.n	8008df4 <cmd_reset+0x14>
        if (strcmp(argv[0], "dfu") == 0) {
 8008de8:	6810      	ldr	r0, [r2, #0]
 8008dea:	490e      	ldr	r1, [pc, #56]	; (8008e24 <cmd_reset+0x44>)
 8008dec:	f7fa fcf0 	bl	80037d0 <strcmp>
 8008df0:	2800      	cmp	r0, #0
 8008df2:	d00f      	beq.n	8008e14 <cmd_reset+0x34>
    chprintf(chp, "Performing reset\r\n");
 8008df4:	490c      	ldr	r1, [pc, #48]	; (8008e28 <cmd_reset+0x48>)
 8008df6:	0020      	movs	r0, r4
 8008df8:	f7fe fb8a 	bl	8007510 <chprintf>
    rccEnableWWDG(FALSE);
 8008dfc:	2380      	movs	r3, #128	; 0x80
 8008dfe:	4a0b      	ldr	r2, [pc, #44]	; (8008e2c <cmd_reset+0x4c>)
 8008e00:	011b      	lsls	r3, r3, #4
 8008e02:	69d1      	ldr	r1, [r2, #28]
 8008e04:	430b      	orrs	r3, r1
 8008e06:	61d3      	str	r3, [r2, #28]
    WWDG->CFR = 0x60;
 8008e08:	2260      	movs	r2, #96	; 0x60
 8008e0a:	4b09      	ldr	r3, [pc, #36]	; (8008e30 <cmd_reset+0x50>)
 8008e0c:	605a      	str	r2, [r3, #4]
    WWDG->CR = 0xff;
 8008e0e:	329f      	adds	r2, #159	; 0x9f
 8008e10:	601a      	str	r2, [r3, #0]
      ;
 8008e12:	e7fe      	b.n	8008e12 <cmd_reset+0x32>
            chprintf(chp, "Performing reset to DFU mode\r\n");
 8008e14:	4907      	ldr	r1, [pc, #28]	; (8008e34 <cmd_reset+0x54>)
 8008e16:	0020      	movs	r0, r4
 8008e18:	f7fe fb7a 	bl	8007510 <chprintf>
            enter_dfu();
 8008e1c:	f007 f810 	bl	800fe40 <enter_dfu>
}
 8008e20:	bd10      	pop	{r4, pc}
 8008e22:	46c0      	nop			; (mov r8, r8)
 8008e24:	0801406c 	.word	0x0801406c
 8008e28:	08014090 	.word	0x08014090
 8008e2c:	40021000 	.word	0x40021000
 8008e30:	40002c00 	.word	0x40002c00
 8008e34:	08014070 	.word	0x08014070
	...

08008e40 <Thread1>:
{
 8008e40:	b5f0      	push	{r4, r5, r6, r7, lr}
 8008e42:	46de      	mov	lr, fp
 8008e44:	4657      	mov	r7, sl
 8008e46:	464e      	mov	r6, r9
 8008e48:	4645      	mov	r5, r8
 * @api
 */
static inline void chRegSetThreadName(const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.current->name = name;
 8008e4a:	4be4      	ldr	r3, [pc, #912]	; (80091dc <Thread1+0x39c>)
 8008e4c:	4ae4      	ldr	r2, [pc, #912]	; (80091e0 <Thread1+0x3a0>)
 8008e4e:	699b      	ldr	r3, [r3, #24]
 8008e50:	b5e0      	push	{r5, r6, r7, lr}
 8008e52:	619a      	str	r2, [r3, #24]
 8008e54:	2280      	movs	r2, #128	; 0x80
 8008e56:	0112      	lsls	r2, r2, #4
 8008e58:	4694      	mov	ip, r2
 8008e5a:	4be2      	ldr	r3, [pc, #904]	; (80091e4 <Thread1+0x3a4>)
 8008e5c:	b095      	sub	sp, #84	; 0x54
 8008e5e:	005b      	lsls	r3, r3, #1
 8008e60:	449c      	add	ip, r3
 8008e62:	4662      	mov	r2, ip
 8008e64:	9212      	str	r2, [sp, #72]	; 0x48
 8008e66:	4ae0      	ldr	r2, [pc, #896]	; (80091e8 <Thread1+0x3a8>)
 8008e68:	4694      	mov	ip, r2
 8008e6a:	4463      	add	r3, ip
 8008e6c:	9313      	str	r3, [sp, #76]	; 0x4c
        if (sweep_enabled || sweep_once) {
 8008e6e:	4adf      	ldr	r2, [pc, #892]	; (80091ec <Thread1+0x3ac>)
 8008e70:	4bdf      	ldr	r3, [pc, #892]	; (80091f0 <Thread1+0x3b0>)
 8008e72:	7812      	ldrb	r2, [r2, #0]
 8008e74:	781b      	ldrb	r3, [r3, #0]
 8008e76:	4313      	orrs	r3, r2
 8008e78:	d122      	bne.n	8008ec0 <Thread1+0x80>
    Wait For Interrupt is a hint instruction that suspends execution
    until one of a number of events occurs.
 */
__attribute__((always_inline)) __STATIC_INLINE void __WFI(void)
{
  __ASM volatile ("wfi");
 8008e7a:	bf30      	wfi
        chMtxLock(&mutex_sweep);
 8008e7c:	48dd      	ldr	r0, [pc, #884]	; (80091f4 <Thread1+0x3b4>)
 8008e7e:	f7fb f91f 	bl	80040c0 <chMtxLock>
        ui_process();
 8008e82:	f007 f81d 	bl	800fec0 <ui_process>
        if (sweep_enabled) {
 8008e86:	4bda      	ldr	r3, [pc, #872]	; (80091f0 <Thread1+0x3b0>)
 8008e88:	781b      	ldrb	r3, [r3, #0]
 8008e8a:	b25b      	sxtb	r3, r3
 8008e8c:	2b00      	cmp	r3, #0
 8008e8e:	d00b      	beq.n	8008ea8 <Thread1+0x68>
            adc_stop(ADC1);
 8008e90:	48d9      	ldr	r0, [pc, #868]	; (80091f8 <Thread1+0x3b8>)
 8008e92:	f008 f915 	bl	80110c0 <adc_stop>
            vbat = adc_vbat_read(ADC1);
 8008e96:	48d8      	ldr	r0, [pc, #864]	; (80091f8 <Thread1+0x3b8>)
 8008e98:	f008 f88a 	bl	8010fb0 <adc_vbat_read>
 8008e9c:	4bd7      	ldr	r3, [pc, #860]	; (80091fc <Thread1+0x3bc>)
 8008e9e:	8018      	strh	r0, [r3, #0]
            touch_start_watchdog();
 8008ea0:	f006 fdae 	bl	800fa00 <touch_start_watchdog>
            draw_battery_status();
 8008ea4:	f005 f97c 	bl	800e1a0 <draw_battery_status>
            completed = sweep(true);
 8008ea8:	2000      	movs	r0, #0
        draw_all(completed); // flush markmap only if scan completed to prevent remaining traces
 8008eaa:	f005 f959 	bl	800e160 <draw_all>
        chMtxUnlock(&mutex_sweep);
 8008eae:	48d1      	ldr	r0, [pc, #836]	; (80091f4 <Thread1+0x3b4>)
 8008eb0:	f7fb f90e 	bl	80040d0 <chMtxUnlock>
        if (sweep_enabled || sweep_once) {
 8008eb4:	4bce      	ldr	r3, [pc, #824]	; (80091f0 <Thread1+0x3b0>)
 8008eb6:	4acd      	ldr	r2, [pc, #820]	; (80091ec <Thread1+0x3ac>)
 8008eb8:	781b      	ldrb	r3, [r3, #0]
 8008eba:	7812      	ldrb	r2, [r2, #0]
 8008ebc:	4313      	orrs	r3, r2
 8008ebe:	d0dc      	beq.n	8008e7a <Thread1+0x3a>
            chMtxLock(&mutex_sweep);
 8008ec0:	48cc      	ldr	r0, [pc, #816]	; (80091f4 <Thread1+0x3b4>)
 8008ec2:	f7fb f8fd 	bl	80040c0 <chMtxLock>
            palClearPad(GPIOC, GPIOC_LED);  // disable led and wait for voltage stabilization
 8008ec6:	2280      	movs	r2, #128	; 0x80
 8008ec8:	4bcd      	ldr	r3, [pc, #820]	; (8009200 <Thread1+0x3c0>)
 8008eca:	0192      	lsls	r2, r2, #6
 8008ecc:	835a      	strh	r2, [r3, #26]
            chThdSleepMilliseconds(10);
 8008ece:	2064      	movs	r0, #100	; 0x64
 8008ed0:	f7fb f81e 	bl	8003f10 <chThdSleep>
    pll_lock_failed = false;
 8008ed4:	2300      	movs	r3, #0
 8008ed6:	4acb      	ldr	r2, [pc, #812]	; (8009204 <Thread1+0x3c4>)
 8008ed8:	7013      	strb	r3, [r2, #0]
    for (int i = 0; i < sweep_points; i++) {
 8008eda:	4bcb      	ldr	r3, [pc, #812]	; (8009208 <Thread1+0x3c8>)
 8008edc:	220c      	movs	r2, #12
 8008ede:	5e9b      	ldrsh	r3, [r3, r2]
 8008ee0:	2b00      	cmp	r3, #0
 8008ee2:	dd65      	ble.n	8008fb0 <Thread1+0x170>
 8008ee4:	2210      	movs	r2, #16
 8008ee6:	4694      	mov	ip, r2
 8008ee8:	22ca      	movs	r2, #202	; 0xca
 8008eea:	4bc7      	ldr	r3, [pc, #796]	; (8009208 <Thread1+0x3c8>)
 8008eec:	0092      	lsls	r2, r2, #2
 8008eee:	4463      	add	r3, ip
 8008ef0:	4694      	mov	ip, r2
 8008ef2:	469a      	mov	sl, r3
 8008ef4:	4bc5      	ldr	r3, [pc, #788]	; (800920c <Thread1+0x3cc>)
 8008ef6:	4699      	mov	r9, r3
 8008ef8:	4463      	add	r3, ip
 8008efa:	469b      	mov	fp, r3
 8008efc:	2300      	movs	r3, #0
 8008efe:	465d      	mov	r5, fp
 8008f00:	46cb      	mov	fp, r9
 8008f02:	9300      	str	r3, [sp, #0]
        int delay = set_frequency(frequencies[i]);
 8008f04:	4653      	mov	r3, sl
 8008f06:	6818      	ldr	r0, [r3, #0]
    if (frequency == freq)
 8008f08:	4bc1      	ldr	r3, [pc, #772]	; (8009210 <Thread1+0x3d0>)
 8008f0a:	681b      	ldr	r3, [r3, #0]
 8008f0c:	9302      	str	r3, [sp, #8]
 8008f0e:	4298      	cmp	r0, r3
 8008f10:	d100      	bne.n	8008f14 <Thread1+0xd4>
 8008f12:	e2ca      	b.n	80094aa <Thread1+0x66a>
 8008f14:	f7ff fe5c 	bl	8008bd0 <set_frequency.part.4>
 8008f18:	2803      	cmp	r0, #3
 8008f1a:	db00      	blt.n	8008f1e <Thread1+0xde>
 8008f1c:	e2b5      	b.n	800948a <Thread1+0x64a>
 8008f1e:	2003      	movs	r0, #3
 8008f20:	b204      	sxth	r4, r0
        tlv320aic3204_select(0); // CH0:REFLECT
 8008f22:	2000      	movs	r0, #0
 8008f24:	f002 fb14 	bl	800b550 <tlv320aic3204_select>
  wait_count = count;
 8008f28:	4bba      	ldr	r3, [pc, #744]	; (8009214 <Thread1+0x3d4>)
 8008f2a:	801c      	strh	r4, [r3, #0]
  while (wait_count)
 8008f2c:	881b      	ldrh	r3, [r3, #0]
 8008f2e:	2b00      	cmp	r3, #0
 8008f30:	d004      	beq.n	8008f3c <Thread1+0xfc>
 8008f32:	bf30      	wfi
 8008f34:	4bb7      	ldr	r3, [pc, #732]	; (8009214 <Thread1+0x3d4>)
 8008f36:	881b      	ldrh	r3, [r3, #0]
 8008f38:	2b00      	cmp	r3, #0
 8008f3a:	d1fa      	bne.n	8008f32 <Thread1+0xf2>
        (*sample_func)(measured[0][i]);
 8008f3c:	4bb6      	ldr	r3, [pc, #728]	; (8009218 <Thread1+0x3d8>)
 8008f3e:	4658      	mov	r0, fp
 8008f40:	681b      	ldr	r3, [r3, #0]
 8008f42:	9302      	str	r3, [sp, #8]
 8008f44:	4798      	blx	r3
        tlv320aic3204_select(1); // CH1:TRANSMISSION
 8008f46:	2001      	movs	r0, #1
 8008f48:	f002 fb02 	bl	800b550 <tlv320aic3204_select>
  wait_count = count;
 8008f4c:	4bb1      	ldr	r3, [pc, #708]	; (8009214 <Thread1+0x3d4>)
 8008f4e:	801c      	strh	r4, [r3, #0]
  while (wait_count)
 8008f50:	881b      	ldrh	r3, [r3, #0]
 8008f52:	2b00      	cmp	r3, #0
 8008f54:	d004      	beq.n	8008f60 <Thread1+0x120>
 8008f56:	bf30      	wfi
 8008f58:	4bae      	ldr	r3, [pc, #696]	; (8009214 <Thread1+0x3d4>)
 8008f5a:	881b      	ldrh	r3, [r3, #0]
 8008f5c:	2b00      	cmp	r3, #0
 8008f5e:	d1fa      	bne.n	8008f56 <Thread1+0x116>
        (*sample_func)(measured[1][i]);
 8008f60:	4bad      	ldr	r3, [pc, #692]	; (8009218 <Thread1+0x3d8>)
 8008f62:	0028      	movs	r0, r5
 8008f64:	681b      	ldr	r3, [r3, #0]
 8008f66:	9302      	str	r3, [sp, #8]
 8008f68:	4798      	blx	r3
        if (cal_status & CALSTAT_APPLY)
 8008f6a:	4ba7      	ldr	r3, [pc, #668]	; (8009208 <Thread1+0x3c8>)
 8008f6c:	89db      	ldrh	r3, [r3, #14]
 8008f6e:	05db      	lsls	r3, r3, #23
 8008f70:	d500      	bpl.n	8008f74 <Thread1+0x134>
 8008f72:	e32d      	b.n	80095d0 <Thread1+0x790>
        if (electrical_delay != 0)
 8008f74:	4ba9      	ldr	r3, [pc, #676]	; (800921c <Thread1+0x3dc>)
 8008f76:	4aa4      	ldr	r2, [pc, #656]	; (8009208 <Thread1+0x3c8>)
 8008f78:	2100      	movs	r1, #0
 8008f7a:	58d4      	ldr	r4, [r2, r3]
 8008f7c:	1c20      	adds	r0, r4, #0
 8008f7e:	f7f7 fafb 	bl	8000578 <__aeabi_fcmpeq>
 8008f82:	2800      	cmp	r0, #0
 8008f84:	d100      	bne.n	8008f88 <Thread1+0x148>
 8008f86:	e292      	b.n	80094ae <Thread1+0x66e>
        if (operation_requested && break_on_operation)
 8008f88:	4ba5      	ldr	r3, [pc, #660]	; (8009220 <Thread1+0x3e0>)
 8008f8a:	781b      	ldrb	r3, [r3, #0]
 8008f8c:	2b00      	cmp	r3, #0
 8008f8e:	d000      	beq.n	8008f92 <Thread1+0x152>
 8008f90:	e280      	b.n	8009494 <Thread1+0x654>
 8008f92:	3304      	adds	r3, #4
 8008f94:	469c      	mov	ip, r3
 8008f96:	3304      	adds	r3, #4
 8008f98:	44e2      	add	sl, ip
 8008f9a:	469c      	mov	ip, r3
    for (int i = 0; i < sweep_points; i++) {
 8008f9c:	9a00      	ldr	r2, [sp, #0]
 8008f9e:	4b9a      	ldr	r3, [pc, #616]	; (8009208 <Thread1+0x3c8>)
 8008fa0:	3201      	adds	r2, #1
 8008fa2:	9200      	str	r2, [sp, #0]
 8008fa4:	210c      	movs	r1, #12
 8008fa6:	5e5b      	ldrsh	r3, [r3, r1]
 8008fa8:	44e3      	add	fp, ip
 8008faa:	3508      	adds	r5, #8
 8008fac:	429a      	cmp	r2, r3
 8008fae:	dba9      	blt.n	8008f04 <Thread1+0xc4>
    if ((domain_mode & DOMAIN_MODE) != DOMAIN_TIME) return; // nothing to do for freq domain
 8008fb0:	4c9c      	ldr	r4, [pc, #624]	; (8009224 <Thread1+0x3e4>)
 8008fb2:	4b95      	ldr	r3, [pc, #596]	; (8009208 <Thread1+0x3c8>)
 8008fb4:	5d1b      	ldrb	r3, [r3, r4]
 8008fb6:	07db      	lsls	r3, r3, #31
 8008fb8:	d400      	bmi.n	8008fbc <Thread1+0x17c>
 8008fba:	e236      	b.n	800942a <Thread1+0x5ea>
    chMtxLock(&mutex_ili9341); // [protect spi_buffer]
 8008fbc:	489a      	ldr	r0, [pc, #616]	; (8009228 <Thread1+0x3e8>)
 8008fbe:	f7fb f87f 	bl	80040c0 <chMtxLock>
    switch (domain_mode & TD_FUNC) {
 8008fc2:	2206      	movs	r2, #6
 8008fc4:	4b90      	ldr	r3, [pc, #576]	; (8009208 <Thread1+0x3c8>)
 8008fc6:	5d19      	ldrb	r1, [r3, r4]
 8008fc8:	400a      	ands	r2, r1
 8008fca:	2a02      	cmp	r2, #2
 8008fcc:	d100      	bne.n	8008fd0 <Thread1+0x190>
 8008fce:	e3f3      	b.n	80097b8 <Thread1+0x978>
 8008fd0:	2a04      	cmp	r2, #4
 8008fd2:	d100      	bne.n	8008fd6 <Thread1+0x196>
 8008fd4:	e3f0      	b.n	80097b8 <Thread1+0x978>
 8008fd6:	2300      	movs	r3, #0
 8008fd8:	9311      	str	r3, [sp, #68]	; 0x44
    uint8_t is_lowpass = FALSE;
 8008fda:	930d      	str	r3, [sp, #52]	; 0x34
    uint8_t window_size = POINT_COUNT, offset = 0;
 8008fdc:	3365      	adds	r3, #101	; 0x65
 8008fde:	9310      	str	r3, [sp, #64]	; 0x40
    switch (domain_mode & TD_WINDOW) {
 8008fe0:	2318      	movs	r3, #24
 8008fe2:	400b      	ands	r3, r1
 8008fe4:	d100      	bne.n	8008fe8 <Thread1+0x1a8>
 8008fe6:	e3f1      	b.n	80097cc <Thread1+0x98c>
 8008fe8:	2b10      	cmp	r3, #16
 8008fea:	d000      	beq.n	8008fee <Thread1+0x1ae>
 8008fec:	e3e1      	b.n	80097b2 <Thread1+0x972>
            beta = 13;
 8008fee:	4b8f      	ldr	r3, [pc, #572]	; (800922c <Thread1+0x3ec>)
 8008ff0:	930f      	str	r3, [sp, #60]	; 0x3c
    for (int ch = 0; ch < 2; ch++) {
 8008ff2:	22c8      	movs	r2, #200	; 0xc8
 8008ff4:	0092      	lsls	r2, r2, #2
 8008ff6:	4694      	mov	ip, r2
 8008ff8:	4b84      	ldr	r3, [pc, #528]	; (800920c <Thread1+0x3cc>)
 8008ffa:	3208      	adds	r2, #8
 8008ffc:	4463      	add	r3, ip
 8008ffe:	4694      	mov	ip, r2
 8009000:	930b      	str	r3, [sp, #44]	; 0x2c
 8009002:	4b82      	ldr	r3, [pc, #520]	; (800920c <Thread1+0x3cc>)
 8009004:	4463      	add	r3, ip
 8009006:	930c      	str	r3, [sp, #48]	; 0x30
        memcpy(tmp, measured[ch], sizeof(measured[0]));
 8009008:	4a89      	ldr	r2, [pc, #548]	; (8009230 <Thread1+0x3f0>)
 800900a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800900c:	4694      	mov	ip, r2
 800900e:	22ca      	movs	r2, #202	; 0xca
 8009010:	4463      	add	r3, ip
 8009012:	469b      	mov	fp, r3
 8009014:	0019      	movs	r1, r3
 8009016:	0092      	lsls	r2, r2, #2
 8009018:	4872      	ldr	r0, [pc, #456]	; (80091e4 <Thread1+0x3a4>)
 800901a:	f00a f859 	bl	80130d0 <memcpy>
        for (int i = 0; i < POINT_COUNT; i++) {
 800901e:	9810      	ldr	r0, [sp, #64]	; 0x40
 8009020:	f7f8 fb2e 	bl	8001680 <__aeabi_ui2f>
 8009024:	9b11      	ldr	r3, [sp, #68]	; 0x44
        memcpy(tmp, measured[ch], sizeof(measured[0]));
 8009026:	4e6f      	ldr	r6, [pc, #444]	; (80091e4 <Thread1+0x3a4>)
 8009028:	4698      	mov	r8, r3
 800902a:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800902c:	9000      	str	r0, [sp, #0]
 800902e:	4699      	mov	r9, r3
 8009030:	465b      	mov	r3, fp
 8009032:	9302      	str	r3, [sp, #8]
	if (beta == 0.0) return 1.0;
 8009034:	2100      	movs	r1, #0
 8009036:	4648      	mov	r0, r9
 8009038:	f7f7 fa9e 	bl	8000578 <__aeabi_fcmpeq>
 800903c:	2800      	cmp	r0, #0
 800903e:	d000      	beq.n	8009042 <Thread1+0x202>
 8009040:	e220      	b.n	8009484 <Thread1+0x644>
            float w = kaiser_window(i+offset, window_size, beta);
 8009042:	4640      	mov	r0, r8
 8009044:	f7f8 facc 	bl	80015e0 <__aeabi_i2f>
	float r = (2 * k) / (n - 1) - 1;
 8009048:	1c01      	adds	r1, r0, #0
 800904a:	f7f7 fc71 	bl	8000930 <__aeabi_fadd>
 800904e:	21fe      	movs	r1, #254	; 0xfe
 8009050:	1c04      	adds	r4, r0, #0
 8009052:	0589      	lsls	r1, r1, #22
 8009054:	9800      	ldr	r0, [sp, #0]
 8009056:	f7f8 f8e3 	bl	8001220 <__aeabi_fsub>
 800905a:	1c01      	adds	r1, r0, #0
 800905c:	1c20      	adds	r0, r4, #0
 800905e:	f7f7 fde7 	bl	8000c30 <__aeabi_fdiv>
 8009062:	21fe      	movs	r1, #254	; 0xfe
 8009064:	0589      	lsls	r1, r1, #22
 8009066:	f7f8 f8db 	bl	8001220 <__aeabi_fsub>
	return bessel0(beta * sqrt(1 - r * r)) / bessel0(beta);
 800906a:	1c01      	adds	r1, r0, #0
 800906c:	f7f7 ffc0 	bl	8000ff0 <__aeabi_fmul>
 8009070:	1c01      	adds	r1, r0, #0
 8009072:	20fe      	movs	r0, #254	; 0xfe
 8009074:	0580      	lsls	r0, r0, #22
 8009076:	f7f8 f8d3 	bl	8001220 <__aeabi_fsub>
 800907a:	f7fa f9b1 	bl	80033e0 <__aeabi_f2d>
 800907e:	f008 f8cf 	bl	8011220 <sqrt>
 8009082:	0004      	movs	r4, r0
 8009084:	000d      	movs	r5, r1
 8009086:	4648      	mov	r0, r9
 8009088:	f7fa f9aa 	bl	80033e0 <__aeabi_f2d>
 800908c:	0022      	movs	r2, r4
 800908e:	002b      	movs	r3, r5
 8009090:	f7f9 fab6 	bl	8002600 <__aeabi_dmul>
 8009094:	f7fa f9fc 	bl	8003490 <__aeabi_d2f>
		term *= (x*x) / (4*m*m);
 8009098:	1c01      	adds	r1, r0, #0
 800909a:	f7f7 ffa9 	bl	8000ff0 <__aeabi_fmul>
	float m = 0;
 800909e:	2400      	movs	r4, #0
	float term = 1;
 80090a0:	27fe      	movs	r7, #254	; 0xfe
		term *= (x*x) / (4*m*m);
 80090a2:	4682      	mov	sl, r0
	float term = 1;
 80090a4:	05bf      	lsls	r7, r7, #22
	float ret = 0;
 80090a6:	1c25      	adds	r5, r4, #0
		ret += term;
 80090a8:	1c39      	adds	r1, r7, #0
 80090aa:	1c28      	adds	r0, r5, #0
 80090ac:	f7f7 fc40 	bl	8000930 <__aeabi_fadd>
		++m;
 80090b0:	21fe      	movs	r1, #254	; 0xfe
		ret += term;
 80090b2:	1c05      	adds	r5, r0, #0
		++m;
 80090b4:	0589      	lsls	r1, r1, #22
 80090b6:	1c20      	adds	r0, r4, #0
 80090b8:	f7f7 fc3a 	bl	8000930 <__aeabi_fadd>
		term *= (x*x) / (4*m*m);
 80090bc:	2181      	movs	r1, #129	; 0x81
		++m;
 80090be:	1c04      	adds	r4, r0, #0
		term *= (x*x) / (4*m*m);
 80090c0:	05c9      	lsls	r1, r1, #23
 80090c2:	f7f7 ff95 	bl	8000ff0 <__aeabi_fmul>
 80090c6:	1c21      	adds	r1, r4, #0
 80090c8:	f7f7 ff92 	bl	8000ff0 <__aeabi_fmul>
 80090cc:	1c01      	adds	r1, r0, #0
 80090ce:	4650      	mov	r0, sl
 80090d0:	f7f7 fdae 	bl	8000c30 <__aeabi_fdiv>
 80090d4:	1c01      	adds	r1, r0, #0
 80090d6:	1c38      	adds	r0, r7, #0
 80090d8:	f7f7 ff8a 	bl	8000ff0 <__aeabi_fmul>
	while (term  > eps * ret) {
 80090dc:	4955      	ldr	r1, [pc, #340]	; (8009234 <Thread1+0x3f4>)
		term *= (x*x) / (4*m*m);
 80090de:	1c07      	adds	r7, r0, #0
	while (term  > eps * ret) {
 80090e0:	1c28      	adds	r0, r5, #0
 80090e2:	f7f7 ff85 	bl	8000ff0 <__aeabi_fmul>
 80090e6:	1c01      	adds	r1, r0, #0
 80090e8:	1c38      	adds	r0, r7, #0
 80090ea:	f7f7 fa5f 	bl	80005ac <__aeabi_fcmpgt>
 80090ee:	2800      	cmp	r0, #0
 80090f0:	d1da      	bne.n	80090a8 <Thread1+0x268>
		term *= (x*x) / (4*m*m);
 80090f2:	4649      	mov	r1, r9
 80090f4:	4648      	mov	r0, r9
 80090f6:	f7f7 ff7b 	bl	8000ff0 <__aeabi_fmul>
	float term = 1;
 80090fa:	23fe      	movs	r3, #254	; 0xfe
	float m = 0;
 80090fc:	2400      	movs	r4, #0
		term *= (x*x) / (4*m*m);
 80090fe:	4683      	mov	fp, r0
	float term = 1;
 8009100:	059b      	lsls	r3, r3, #22
 8009102:	46aa      	mov	sl, r5
	float ret = 0;
 8009104:	1c27      	adds	r7, r4, #0
	float term = 1;
 8009106:	1c1d      	adds	r5, r3, #0
		ret += term;
 8009108:	1c29      	adds	r1, r5, #0
 800910a:	1c38      	adds	r0, r7, #0
 800910c:	f7f7 fc10 	bl	8000930 <__aeabi_fadd>
		++m;
 8009110:	21fe      	movs	r1, #254	; 0xfe
		ret += term;
 8009112:	1c07      	adds	r7, r0, #0
		++m;
 8009114:	0589      	lsls	r1, r1, #22
 8009116:	1c20      	adds	r0, r4, #0
 8009118:	f7f7 fc0a 	bl	8000930 <__aeabi_fadd>
		term *= (x*x) / (4*m*m);
 800911c:	2181      	movs	r1, #129	; 0x81
		++m;
 800911e:	1c04      	adds	r4, r0, #0
		term *= (x*x) / (4*m*m);
 8009120:	05c9      	lsls	r1, r1, #23
 8009122:	f7f7 ff65 	bl	8000ff0 <__aeabi_fmul>
 8009126:	1c21      	adds	r1, r4, #0
 8009128:	f7f7 ff62 	bl	8000ff0 <__aeabi_fmul>
 800912c:	1c01      	adds	r1, r0, #0
 800912e:	4658      	mov	r0, fp
 8009130:	f7f7 fd7e 	bl	8000c30 <__aeabi_fdiv>
 8009134:	1c01      	adds	r1, r0, #0
 8009136:	1c28      	adds	r0, r5, #0
 8009138:	f7f7 ff5a 	bl	8000ff0 <__aeabi_fmul>
	while (term  > eps * ret) {
 800913c:	493d      	ldr	r1, [pc, #244]	; (8009234 <Thread1+0x3f4>)
		term *= (x*x) / (4*m*m);
 800913e:	1c05      	adds	r5, r0, #0
	while (term  > eps * ret) {
 8009140:	1c38      	adds	r0, r7, #0
 8009142:	f7f7 ff55 	bl	8000ff0 <__aeabi_fmul>
 8009146:	1c01      	adds	r1, r0, #0
 8009148:	1c28      	adds	r0, r5, #0
 800914a:	f7f7 fa2f 	bl	80005ac <__aeabi_fcmpgt>
 800914e:	2800      	cmp	r0, #0
 8009150:	d1da      	bne.n	8009108 <Thread1+0x2c8>
	return bessel0(beta * sqrt(1 - r * r)) / bessel0(beta);
 8009152:	1c39      	adds	r1, r7, #0
 8009154:	4650      	mov	r0, sl
 8009156:	f7f7 fd6b 	bl	8000c30 <__aeabi_fdiv>
 800915a:	1c04      	adds	r4, r0, #0
            tmp[i*2+0] *= w;
 800915c:	6830      	ldr	r0, [r6, #0]
 800915e:	1c21      	adds	r1, r4, #0
 8009160:	f7f7 ff46 	bl	8000ff0 <__aeabi_fmul>
            tmp[i*2+1] *= w;
 8009164:	1c21      	adds	r1, r4, #0
            tmp[i*2+0] *= w;
 8009166:	6030      	str	r0, [r6, #0]
            tmp[i*2+1] *= w;
 8009168:	6870      	ldr	r0, [r6, #4]
 800916a:	f7f7 ff41 	bl	8000ff0 <__aeabi_fmul>
 800916e:	2301      	movs	r3, #1
 8009170:	469c      	mov	ip, r3
        for (int i = 0; i < POINT_COUNT; i++) {
 8009172:	4b31      	ldr	r3, [pc, #196]	; (8009238 <Thread1+0x3f8>)
            tmp[i*2+1] *= w;
 8009174:	6070      	str	r0, [r6, #4]
 8009176:	3608      	adds	r6, #8
 8009178:	44e0      	add	r8, ip
        for (int i = 0; i < POINT_COUNT; i++) {
 800917a:	42b3      	cmp	r3, r6
 800917c:	d000      	beq.n	8009180 <Thread1+0x340>
 800917e:	e759      	b.n	8009034 <Thread1+0x1f4>
            tmp[i*2+0] = 0.0;
 8009180:	2200      	movs	r2, #0
 8009182:	9b02      	ldr	r3, [sp, #8]
 8009184:	469b      	mov	fp, r3
 8009186:	4b2c      	ldr	r3, [pc, #176]	; (8009238 <Thread1+0x3f8>)
        for (int i = POINT_COUNT; i < FFT_SIZE; i++) {
 8009188:	492c      	ldr	r1, [pc, #176]	; (800923c <Thread1+0x3fc>)
            tmp[i*2+0] = 0.0;
 800918a:	601a      	str	r2, [r3, #0]
            tmp[i*2+1] = 0.0;
 800918c:	605a      	str	r2, [r3, #4]
 800918e:	3308      	adds	r3, #8
        for (int i = POINT_COUNT; i < FFT_SIZE; i++) {
 8009190:	4299      	cmp	r1, r3
 8009192:	d1f9      	bne.n	8009188 <Thread1+0x348>
        if (is_lowpass) {
 8009194:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8009196:	2b00      	cmp	r3, #0
 8009198:	d000      	beq.n	800919c <Thread1+0x35c>
 800919a:	e31a      	b.n	80097d2 <Thread1+0x992>
	const uint8_t levels = 8; // log2(n)

	const uint8_t real =   dir & 1;
	const uint8_t imag = ~real & 1;

	for (uint16_t i = 0; i < n; i++) {
 800919c:	2680      	movs	r6, #128	; 0x80
	uint16_t result = 0;
 800919e:	2200      	movs	r2, #0
		result = (result << 1) | (x & 1U);
 80091a0:	2701      	movs	r7, #1
	uint16_t result = 0;
 80091a2:	4910      	ldr	r1, [pc, #64]	; (80091e4 <Thread1+0x3a4>)
	for (uint16_t i = 0; i < n; i++) {
 80091a4:	0076      	lsls	r6, r6, #1
	if (beta == 0.0) return 1.0;
 80091a6:	0010      	movs	r0, r2
 80091a8:	2408      	movs	r4, #8
	uint16_t result = 0;
 80091aa:	2300      	movs	r3, #0
		result = (result << 1) | (x & 1U);
 80091ac:	003d      	movs	r5, r7
 80091ae:	005b      	lsls	r3, r3, #1
 80091b0:	4005      	ands	r5, r0
 80091b2:	b29b      	uxth	r3, r3
	for (int i = 0; i < n; i++, x >>= 1)
 80091b4:	0840      	lsrs	r0, r0, #1
 80091b6:	3c01      	subs	r4, #1
		result = (result << 1) | (x & 1U);
 80091b8:	432b      	orrs	r3, r5
	for (int i = 0; i < n; i++, x >>= 1)
 80091ba:	b280      	uxth	r0, r0
 80091bc:	2c00      	cmp	r4, #0
 80091be:	d1f5      	bne.n	80091ac <Thread1+0x36c>
		uint16_t j = reverse_bits(i, levels);
		if (j > i) {
 80091c0:	4293      	cmp	r3, r2
 80091c2:	d93f      	bls.n	8009244 <Thread1+0x404>
			float temp = array[i][real];
			array[i][real] = array[j][real];
 80091c4:	4c07      	ldr	r4, [pc, #28]	; (80091e4 <Thread1+0x3a4>)
 80091c6:	00db      	lsls	r3, r3, #3
 80091c8:	46a4      	mov	ip, r4
 80091ca:	4463      	add	r3, ip
			float temp = array[i][real];
 80091cc:	6848      	ldr	r0, [r1, #4]
			array[i][real] = array[j][real];
 80091ce:	685c      	ldr	r4, [r3, #4]
 80091d0:	604c      	str	r4, [r1, #4]
			array[j][real] = temp;
 80091d2:	6058      	str	r0, [r3, #4]
			temp = array[i][imag];
 80091d4:	6808      	ldr	r0, [r1, #0]
			array[i][imag] = array[j][imag];
 80091d6:	681c      	ldr	r4, [r3, #0]
 80091d8:	e032      	b.n	8009240 <Thread1+0x400>
 80091da:	46c0      	nop			; (mov r8, r8)
 80091dc:	20001798 	.word	0x20001798
 80091e0:	08013e88 	.word	0x08013e88
 80091e4:	200030ac 	.word	0x200030ac
 80091e8:	00000804 	.word	0x00000804
 80091ec:	200023c4 	.word	0x200023c4
 80091f0:	20001630 	.word	0x20001630
 80091f4:	20002220 	.word	0x20002220
 80091f8:	40012400 	.word	0x40012400
 80091fc:	200023c6 	.word	0x200023c6
 8009200:	48000800 	.word	0x48000800
 8009204:	20002234 	.word	0x20002234
 8009208:	20000454 	.word	0x20000454
 800920c:	20001bbc 	.word	0x20001bbc
 8009210:	20001624 	.word	0x20001624
 8009214:	200029e8 	.word	0x200029e8
 8009218:	2000162c 	.word	0x2000162c
 800921c:	0000116c 	.word	0x0000116c
 8009220:	200030a3 	.word	0x200030a3
 8009224:	000011c4 	.word	0x000011c4
 8009228:	2000220c 	.word	0x2000220c
 800922c:	41500000 	.word	0x41500000
 8009230:	fffffce0 	.word	0xfffffce0
 8009234:	38d1b717 	.word	0x38d1b717
 8009238:	200033d4 	.word	0x200033d4
 800923c:	200038ac 	.word	0x200038ac
 8009240:	600c      	str	r4, [r1, #0]
			array[j][imag] = temp;
 8009242:	6018      	str	r0, [r3, #0]
	for (uint16_t i = 0; i < n; i++) {
 8009244:	3201      	adds	r2, #1
 8009246:	b292      	uxth	r2, r2
 8009248:	3108      	adds	r1, #8
 800924a:	42b2      	cmp	r2, r6
 800924c:	d1ab      	bne.n	80091a6 <Thread1+0x366>
 800924e:	2308      	movs	r3, #8
 8009250:	930a      	str	r3, [sp, #40]	; 0x28
		}
	}

	// Cooley-Tukey decimation-in-time radix-2 FFT
	for (uint16_t size = 2; size <= n; size *= 2) {
 8009252:	3b06      	subs	r3, #6
 8009254:	9308      	str	r3, [sp, #32]
 8009256:	465b      	mov	r3, fp
 8009258:	930e      	str	r3, [sp, #56]	; 0x38
		uint16_t halfsize = size / 2;
		uint16_t tablestep = n / size;
 800925a:	2080      	movs	r0, #128	; 0x80
		uint16_t halfsize = size / 2;
 800925c:	9908      	ldr	r1, [sp, #32]
		uint16_t tablestep = n / size;
 800925e:	0040      	lsls	r0, r0, #1
		uint16_t halfsize = size / 2;
 8009260:	084b      	lsrs	r3, r1, #1
 8009262:	9304      	str	r3, [sp, #16]
		uint16_t tablestep = n / size;
 8009264:	f7f6 ffb4 	bl	80001d0 <__udivsi3>
 8009268:	b283      	uxth	r3, r0
 800926a:	9309      	str	r3, [sp, #36]	; 0x24
		for (uint16_t i = 0; i < n; i += size) {
 800926c:	2300      	movs	r3, #0
 800926e:	469b      	mov	fp, r3
			for (uint16_t j = i, k = 0; j < i + halfsize; j++, k += tablestep) {
 8009270:	9b04      	ldr	r3, [sp, #16]
 8009272:	445b      	add	r3, fp
 8009274:	9306      	str	r3, [sp, #24]
 8009276:	459b      	cmp	fp, r3
 8009278:	db00      	blt.n	800927c <Thread1+0x43c>
 800927a:	e08c      	b.n	8009396 <Thread1+0x556>
 800927c:	2300      	movs	r3, #0
 800927e:	4cc1      	ldr	r4, [pc, #772]	; (8009584 <Thread1+0x744>)
 8009280:	46da      	mov	sl, fp
 8009282:	9300      	str	r3, [sp, #0]
 8009284:	9401      	str	r4, [sp, #4]
 8009286:	2300      	movs	r3, #0
 8009288:	2600      	movs	r6, #0
 800928a:	2700      	movs	r7, #0
 800928c:	4699      	mov	r9, r3
 800928e:	e016      	b.n	80092be <Thread1+0x47e>
 8009290:	4648      	mov	r0, r9
 8009292:	f7fa f82d 	bl	80032f0 <__aeabi_i2d>
 8009296:	4abc      	ldr	r2, [pc, #752]	; (8009588 <Thread1+0x748>)
 8009298:	4bbc      	ldr	r3, [pc, #752]	; (800958c <Thread1+0x74c>)
 800929a:	f7f9 f9b1 	bl	8002600 <__aeabi_dmul>
 800929e:	2200      	movs	r2, #0
 80092a0:	4bbb      	ldr	r3, [pc, #748]	; (8009590 <Thread1+0x750>)
 80092a2:	f7f9 f9ad 	bl	8002600 <__aeabi_dmul>
 80092a6:	0004      	movs	r4, r0
 80092a8:	000d      	movs	r5, r1
 80092aa:	f007 ff29 	bl	8011100 <cos>
 80092ae:	9000      	str	r0, [sp, #0]
 80092b0:	9101      	str	r1, [sp, #4]
 80092b2:	0020      	movs	r0, r4
 80092b4:	0029      	movs	r1, r5
 80092b6:	f007 ff6b 	bl	8011190 <sin>
 80092ba:	0006      	movs	r6, r0
 80092bc:	000f      	movs	r7, r1
				uint16_t l = j + halfsize;
				float tpre =  array[l][real] * cos(2 * M_PI * k / 256) + array[l][imag] * sin(2 * M_PI * k / 256);
 80092be:	4ab5      	ldr	r2, [pc, #724]	; (8009594 <Thread1+0x754>)
				uint16_t l = j + halfsize;
 80092c0:	9b04      	ldr	r3, [sp, #16]
				float tpre =  array[l][real] * cos(2 * M_PI * k / 256) + array[l][imag] * sin(2 * M_PI * k / 256);
 80092c2:	4690      	mov	r8, r2
				uint16_t l = j + halfsize;
 80092c4:	4453      	add	r3, sl
				float tpre =  array[l][real] * cos(2 * M_PI * k / 256) + array[l][imag] * sin(2 * M_PI * k / 256);
 80092c6:	b29b      	uxth	r3, r3
 80092c8:	00db      	lsls	r3, r3, #3
 80092ca:	4498      	add	r8, r3
 80092cc:	4643      	mov	r3, r8
 80092ce:	6818      	ldr	r0, [r3, #0]
 80092d0:	685c      	ldr	r4, [r3, #4]
 80092d2:	f7fa f885 	bl	80033e0 <__aeabi_f2d>
 80092d6:	9002      	str	r0, [sp, #8]
 80092d8:	9103      	str	r1, [sp, #12]
 80092da:	1c20      	adds	r0, r4, #0
 80092dc:	9405      	str	r4, [sp, #20]
 80092de:	f7fa f87f 	bl	80033e0 <__aeabi_f2d>
 80092e2:	9a00      	ldr	r2, [sp, #0]
 80092e4:	9b01      	ldr	r3, [sp, #4]
 80092e6:	f7f9 f98b 	bl	8002600 <__aeabi_dmul>
 80092ea:	0032      	movs	r2, r6
 80092ec:	0004      	movs	r4, r0
 80092ee:	000d      	movs	r5, r1
 80092f0:	9802      	ldr	r0, [sp, #8]
 80092f2:	9903      	ldr	r1, [sp, #12]
 80092f4:	003b      	movs	r3, r7
 80092f6:	f7f9 f983 	bl	8002600 <__aeabi_dmul>
 80092fa:	0002      	movs	r2, r0
 80092fc:	000b      	movs	r3, r1
 80092fe:	0020      	movs	r0, r4
 8009300:	0029      	movs	r1, r5
 8009302:	f7f8 f9fd 	bl	8001700 <__aeabi_dadd>
 8009306:	f7fa f8c3 	bl	8003490 <__aeabi_d2f>
				float tpim = -array[l][real] * sin(2 * M_PI * k / 256) + array[l][imag] * cos(2 * M_PI * k / 256);
 800930a:	2180      	movs	r1, #128	; 0x80
 800930c:	0609      	lsls	r1, r1, #24
 800930e:	468c      	mov	ip, r1
 8009310:	9b05      	ldr	r3, [sp, #20]
				float tpre =  array[l][real] * cos(2 * M_PI * k / 256) + array[l][imag] * sin(2 * M_PI * k / 256);
 8009312:	9007      	str	r0, [sp, #28]
				float tpim = -array[l][real] * sin(2 * M_PI * k / 256) + array[l][imag] * cos(2 * M_PI * k / 256);
 8009314:	4463      	add	r3, ip
 8009316:	0018      	movs	r0, r3
 8009318:	f7fa f862 	bl	80033e0 <__aeabi_f2d>
 800931c:	0032      	movs	r2, r6
 800931e:	003b      	movs	r3, r7
 8009320:	f7f9 f96e 	bl	8002600 <__aeabi_dmul>
 8009324:	9a00      	ldr	r2, [sp, #0]
 8009326:	9b01      	ldr	r3, [sp, #4]
 8009328:	0004      	movs	r4, r0
 800932a:	000d      	movs	r5, r1
 800932c:	9802      	ldr	r0, [sp, #8]
 800932e:	9903      	ldr	r1, [sp, #12]
 8009330:	f7f9 f966 	bl	8002600 <__aeabi_dmul>
 8009334:	0002      	movs	r2, r0
 8009336:	000b      	movs	r3, r1
 8009338:	0020      	movs	r0, r4
 800933a:	0029      	movs	r1, r5
 800933c:	f7f8 f9e0 	bl	8001700 <__aeabi_dadd>
 8009340:	f7fa f8a6 	bl	8003490 <__aeabi_d2f>
				array[l][real] = array[j][real] - tpre;
 8009344:	4653      	mov	r3, sl
 8009346:	00dc      	lsls	r4, r3, #3
 8009348:	4b92      	ldr	r3, [pc, #584]	; (8009594 <Thread1+0x754>)
 800934a:	9e07      	ldr	r6, [sp, #28]
 800934c:	469c      	mov	ip, r3
 800934e:	4464      	add	r4, ip
				float tpim = -array[l][real] * sin(2 * M_PI * k / 256) + array[l][imag] * cos(2 * M_PI * k / 256);
 8009350:	1c05      	adds	r5, r0, #0
				array[l][real] = array[j][real] - tpre;
 8009352:	1c31      	adds	r1, r6, #0
 8009354:	6860      	ldr	r0, [r4, #4]
 8009356:	f7f7 ff63 	bl	8001220 <__aeabi_fsub>
 800935a:	4643      	mov	r3, r8
 800935c:	6058      	str	r0, [r3, #4]
				array[l][imag] = array[j][imag] - tpim;
 800935e:	6820      	ldr	r0, [r4, #0]
 8009360:	1c29      	adds	r1, r5, #0
 8009362:	f7f7 ff5d 	bl	8001220 <__aeabi_fsub>
 8009366:	4643      	mov	r3, r8
 8009368:	6018      	str	r0, [r3, #0]
				array[j][real] += tpre;
 800936a:	6860      	ldr	r0, [r4, #4]
 800936c:	1c31      	adds	r1, r6, #0
 800936e:	f7f7 fadf 	bl	8000930 <__aeabi_fadd>
				array[j][imag] += tpim;
 8009372:	1c29      	adds	r1, r5, #0
				array[j][real] += tpre;
 8009374:	6060      	str	r0, [r4, #4]
				array[j][imag] += tpim;
 8009376:	6820      	ldr	r0, [r4, #0]
 8009378:	f7f7 fada 	bl	8000930 <__aeabi_fadd>
			for (uint16_t j = i, k = 0; j < i + halfsize; j++, k += tablestep) {
 800937c:	4653      	mov	r3, sl
 800937e:	3301      	adds	r3, #1
 8009380:	b29b      	uxth	r3, r3
 8009382:	469a      	mov	sl, r3
 8009384:	9b09      	ldr	r3, [sp, #36]	; 0x24
				array[j][imag] += tpim;
 8009386:	6020      	str	r0, [r4, #0]
			for (uint16_t j = i, k = 0; j < i + halfsize; j++, k += tablestep) {
 8009388:	444b      	add	r3, r9
 800938a:	b29b      	uxth	r3, r3
 800938c:	4699      	mov	r9, r3
 800938e:	9b06      	ldr	r3, [sp, #24]
 8009390:	459a      	cmp	sl, r3
 8009392:	da00      	bge.n	8009396 <Thread1+0x556>
 8009394:	e77c      	b.n	8009290 <Thread1+0x450>
		for (uint16_t i = 0; i < n; i += size) {
 8009396:	9b08      	ldr	r3, [sp, #32]
 8009398:	445b      	add	r3, fp
 800939a:	b29b      	uxth	r3, r3
 800939c:	469b      	mov	fp, r3
 800939e:	2bff      	cmp	r3, #255	; 0xff
 80093a0:	d800      	bhi.n	80093a4 <Thread1+0x564>
 80093a2:	e765      	b.n	8009270 <Thread1+0x430>
			}
		}
		if (size == n)  // Prevent overflow in 'size *= 2'
 80093a4:	2180      	movs	r1, #128	; 0x80
 80093a6:	9b08      	ldr	r3, [sp, #32]
 80093a8:	0049      	lsls	r1, r1, #1
 80093aa:	428b      	cmp	r3, r1
 80093ac:	d008      	beq.n	80093c0 <Thread1+0x580>
	for (uint16_t size = 2; size <= n; size *= 2) {
 80093ae:	005b      	lsls	r3, r3, #1
 80093b0:	b29b      	uxth	r3, r3
 80093b2:	9308      	str	r3, [sp, #32]
 80093b4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80093b6:	3b01      	subs	r3, #1
 80093b8:	930a      	str	r3, [sp, #40]	; 0x28
 80093ba:	2b00      	cmp	r3, #0
 80093bc:	d000      	beq.n	80093c0 <Thread1+0x580>
 80093be:	e74c      	b.n	800925a <Thread1+0x41a>
 80093c0:	9b0e      	ldr	r3, [sp, #56]	; 0x38
        memcpy(measured[ch], tmp, sizeof(measured[0]));
 80093c2:	22ca      	movs	r2, #202	; 0xca
 80093c4:	469b      	mov	fp, r3
 80093c6:	465c      	mov	r4, fp
 80093c8:	0092      	lsls	r2, r2, #2
 80093ca:	4972      	ldr	r1, [pc, #456]	; (8009594 <Thread1+0x754>)
 80093cc:	0018      	movs	r0, r3
 80093ce:	f009 fe7f 	bl	80130d0 <memcpy>
 80093d2:	9d0d      	ldr	r5, [sp, #52]	; 0x34
 80093d4:	9e0c      	ldr	r6, [sp, #48]	; 0x30
            measured[ch][i][0] /= (float)FFT_SIZE;
 80093d6:	21ee      	movs	r1, #238	; 0xee
 80093d8:	6820      	ldr	r0, [r4, #0]
 80093da:	0589      	lsls	r1, r1, #22
 80093dc:	f7f7 fe08 	bl	8000ff0 <__aeabi_fmul>
 80093e0:	6020      	str	r0, [r4, #0]
                measured[ch][i][1] = 0.0;
 80093e2:	2000      	movs	r0, #0
            if (is_lowpass) {
 80093e4:	2d00      	cmp	r5, #0
 80093e6:	d104      	bne.n	80093f2 <Thread1+0x5b2>
                measured[ch][i][1] /= (float)FFT_SIZE;
 80093e8:	21ee      	movs	r1, #238	; 0xee
 80093ea:	6860      	ldr	r0, [r4, #4]
 80093ec:	0589      	lsls	r1, r1, #22
 80093ee:	f7f7 fdff 	bl	8000ff0 <__aeabi_fmul>
 80093f2:	6060      	str	r0, [r4, #4]
 80093f4:	3408      	adds	r4, #8
        for (int i = 0; i < POINT_COUNT; i++) {
 80093f6:	42a6      	cmp	r6, r4
 80093f8:	d1ed      	bne.n	80093d6 <Thread1+0x596>
        if ( (domain_mode & TD_FUNC) == TD_FUNC_LOWPASS_STEP ) {
 80093fa:	4b67      	ldr	r3, [pc, #412]	; (8009598 <Thread1+0x758>)
 80093fc:	4a67      	ldr	r2, [pc, #412]	; (800959c <Thread1+0x75c>)
 80093fe:	5cd2      	ldrb	r2, [r2, r3]
 8009400:	2306      	movs	r3, #6
 8009402:	4013      	ands	r3, r2
 8009404:	2b04      	cmp	r3, #4
 8009406:	d100      	bne.n	800940a <Thread1+0x5ca>
 8009408:	e1f5      	b.n	80097f6 <Thread1+0x9b6>
 800940a:	22ca      	movs	r2, #202	; 0xca
 800940c:	0092      	lsls	r2, r2, #2
 800940e:	4694      	mov	ip, r2
 8009410:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8009412:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8009414:	4462      	add	r2, ip
 8009416:	920c      	str	r2, [sp, #48]	; 0x30
    for (int ch = 0; ch < 2; ch++) {
 8009418:	4a61      	ldr	r2, [pc, #388]	; (80095a0 <Thread1+0x760>)
 800941a:	4463      	add	r3, ip
 800941c:	930b      	str	r3, [sp, #44]	; 0x2c
 800941e:	429a      	cmp	r2, r3
 8009420:	d000      	beq.n	8009424 <Thread1+0x5e4>
 8009422:	e5f1      	b.n	8009008 <Thread1+0x1c8>
    chMtxUnlock(&mutex_ili9341); // [/protect spi_buffer]
 8009424:	485f      	ldr	r0, [pc, #380]	; (80095a4 <Thread1+0x764>)
 8009426:	f7fa fe53 	bl	80040d0 <chMtxUnlock>
            sweep_once = FALSE;
 800942a:	2300      	movs	r3, #0
 800942c:	4a5e      	ldr	r2, [pc, #376]	; (80095a8 <Thread1+0x768>)
            chMtxUnlock(&mutex_sweep);
 800942e:	485f      	ldr	r0, [pc, #380]	; (80095ac <Thread1+0x76c>)
            sweep_once = FALSE;
 8009430:	7013      	strb	r3, [r2, #0]
            palSetPad(GPIOC, GPIOC_LED);
 8009432:	2280      	movs	r2, #128	; 0x80
 8009434:	4b5e      	ldr	r3, [pc, #376]	; (80095b0 <Thread1+0x770>)
 8009436:	0192      	lsls	r2, r2, #6
 8009438:	831a      	strh	r2, [r3, #24]
            chMtxUnlock(&mutex_sweep);
 800943a:	f7fa fe49 	bl	80040d0 <chMtxUnlock>
        chMtxLock(&mutex_sweep);
 800943e:	485b      	ldr	r0, [pc, #364]	; (80095ac <Thread1+0x76c>)
 8009440:	f7fa fe3e 	bl	80040c0 <chMtxLock>
        ui_process();
 8009444:	f006 fd3c 	bl	800fec0 <ui_process>
        if (sweep_enabled) {
 8009448:	4b5a      	ldr	r3, [pc, #360]	; (80095b4 <Thread1+0x774>)
 800944a:	2001      	movs	r0, #1
 800944c:	781b      	ldrb	r3, [r3, #0]
 800944e:	b25b      	sxtb	r3, r3
 8009450:	2b00      	cmp	r3, #0
 8009452:	d100      	bne.n	8009456 <Thread1+0x616>
 8009454:	e529      	b.n	8008eaa <Thread1+0x6a>
            adc_stop(ADC1);
 8009456:	4858      	ldr	r0, [pc, #352]	; (80095b8 <Thread1+0x778>)
 8009458:	f007 fe32 	bl	80110c0 <adc_stop>
            vbat = adc_vbat_read(ADC1);
 800945c:	4856      	ldr	r0, [pc, #344]	; (80095b8 <Thread1+0x778>)
 800945e:	f007 fda7 	bl	8010fb0 <adc_vbat_read>
 8009462:	4b56      	ldr	r3, [pc, #344]	; (80095bc <Thread1+0x77c>)
 8009464:	8018      	strh	r0, [r3, #0]
            touch_start_watchdog();
 8009466:	f006 facb 	bl	800fa00 <touch_start_watchdog>
            draw_battery_status();
 800946a:	f004 fe99 	bl	800e1a0 <draw_battery_status>
                plot_into_index(measured);
 800946e:	4854      	ldr	r0, [pc, #336]	; (80095c0 <Thread1+0x780>)
 8009470:	f004 f946 	bl	800d700 <plot_into_index>
                redraw_request |= REDRAW_CELLS;
 8009474:	2201      	movs	r2, #1
 8009476:	4b53      	ldr	r3, [pc, #332]	; (80095c4 <Thread1+0x784>)
            completed = sweep(true);
 8009478:	2001      	movs	r0, #1
                redraw_request |= REDRAW_CELLS;
 800947a:	881b      	ldrh	r3, [r3, #0]
 800947c:	4313      	orrs	r3, r2
 800947e:	4a51      	ldr	r2, [pc, #324]	; (80095c4 <Thread1+0x784>)
 8009480:	8013      	strh	r3, [r2, #0]
 8009482:	e512      	b.n	8008eaa <Thread1+0x6a>
	if (beta == 0.0) return 1.0;
 8009484:	24fe      	movs	r4, #254	; 0xfe
 8009486:	05a4      	lsls	r4, r4, #22
 8009488:	e668      	b.n	800915c <Thread1+0x31c>
 800948a:	2808      	cmp	r0, #8
 800948c:	dc00      	bgt.n	8009490 <Thread1+0x650>
 800948e:	e547      	b.n	8008f20 <Thread1+0xe0>
 8009490:	2008      	movs	r0, #8
 8009492:	e545      	b.n	8008f20 <Thread1+0xe0>
            sweep_once = FALSE;
 8009494:	2300      	movs	r3, #0
 8009496:	4a44      	ldr	r2, [pc, #272]	; (80095a8 <Thread1+0x768>)
            chMtxUnlock(&mutex_sweep);
 8009498:	4844      	ldr	r0, [pc, #272]	; (80095ac <Thread1+0x76c>)
            sweep_once = FALSE;
 800949a:	7013      	strb	r3, [r2, #0]
            palSetPad(GPIOC, GPIOC_LED);
 800949c:	2280      	movs	r2, #128	; 0x80
 800949e:	4b44      	ldr	r3, [pc, #272]	; (80095b0 <Thread1+0x770>)
 80094a0:	0192      	lsls	r2, r2, #6
 80094a2:	831a      	strh	r2, [r3, #24]
            chMtxUnlock(&mutex_sweep);
 80094a4:	f7fa fe14 	bl	80040d0 <chMtxUnlock>
        chMtxLock(&mutex_sweep);
 80094a8:	e4e8      	b.n	8008e7c <Thread1+0x3c>
    if (frequency == freq)
 80094aa:	2403      	movs	r4, #3
 80094ac:	e539      	b.n	8008f22 <Thread1+0xe2>
  float w = 2 * M_PI * electrical_delay * frequencies[i] * 1E-12;
 80094ae:	4653      	mov	r3, sl
 80094b0:	6818      	ldr	r0, [r3, #0]
 80094b2:	f7f9 ff5d 	bl	8003370 <__aeabi_ui2d>
 80094b6:	0006      	movs	r6, r0
 80094b8:	1c20      	adds	r0, r4, #0
 80094ba:	000f      	movs	r7, r1
 80094bc:	f7f9 ff90 	bl	80033e0 <__aeabi_f2d>
 80094c0:	4a31      	ldr	r2, [pc, #196]	; (8009588 <Thread1+0x748>)
 80094c2:	4b32      	ldr	r3, [pc, #200]	; (800958c <Thread1+0x74c>)
 80094c4:	f7f9 f89c 	bl	8002600 <__aeabi_dmul>
 80094c8:	0002      	movs	r2, r0
 80094ca:	000b      	movs	r3, r1
 80094cc:	0030      	movs	r0, r6
 80094ce:	0039      	movs	r1, r7
 80094d0:	f7f9 f896 	bl	8002600 <__aeabi_dmul>
 80094d4:	4a3c      	ldr	r2, [pc, #240]	; (80095c8 <Thread1+0x788>)
 80094d6:	4b3d      	ldr	r3, [pc, #244]	; (80095cc <Thread1+0x78c>)
 80094d8:	f7f9 f892 	bl	8002600 <__aeabi_dmul>
 80094dc:	f7f9 ffd8 	bl	8003490 <__aeabi_d2f>
  float s = sin(w);
 80094e0:	f7f9 ff7e 	bl	80033e0 <__aeabi_f2d>
 80094e4:	0006      	movs	r6, r0
 80094e6:	000f      	movs	r7, r1
 80094e8:	f007 fe52 	bl	8011190 <sin>
 80094ec:	f7f9 ffd0 	bl	8003490 <__aeabi_d2f>
  float c = cos(w);
 80094f0:	0039      	movs	r1, r7
  float s = sin(w);
 80094f2:	1c04      	adds	r4, r0, #0
  float c = cos(w);
 80094f4:	0030      	movs	r0, r6
 80094f6:	f007 fe03 	bl	8011100 <cos>
 80094fa:	f7f9 ffc9 	bl	8003490 <__aeabi_d2f>
  float real = measured[0][i][0];
 80094fe:	465b      	mov	r3, fp
 8009500:	681f      	ldr	r7, [r3, #0]
  float imag = measured[0][i][1];
 8009502:	685b      	ldr	r3, [r3, #4]
  measured[0][i][0] = real * c - imag * s;
 8009504:	1c39      	adds	r1, r7, #0
  float imag = measured[0][i][1];
 8009506:	4698      	mov	r8, r3
  float c = cos(w);
 8009508:	1c06      	adds	r6, r0, #0
  measured[0][i][0] = real * c - imag * s;
 800950a:	f7f7 fd71 	bl	8000ff0 <__aeabi_fmul>
 800950e:	4641      	mov	r1, r8
 8009510:	4681      	mov	r9, r0
 8009512:	1c20      	adds	r0, r4, #0
 8009514:	f7f7 fd6c 	bl	8000ff0 <__aeabi_fmul>
 8009518:	1c01      	adds	r1, r0, #0
 800951a:	4648      	mov	r0, r9
 800951c:	f7f7 fe80 	bl	8001220 <__aeabi_fsub>
 8009520:	465b      	mov	r3, fp
  measured[0][i][1] = imag * c + real * s;
 8009522:	4641      	mov	r1, r8
  measured[0][i][0] = real * c - imag * s;
 8009524:	6018      	str	r0, [r3, #0]
  measured[0][i][1] = imag * c + real * s;
 8009526:	1c30      	adds	r0, r6, #0
 8009528:	f7f7 fd62 	bl	8000ff0 <__aeabi_fmul>
 800952c:	1c39      	adds	r1, r7, #0
 800952e:	4680      	mov	r8, r0
 8009530:	1c20      	adds	r0, r4, #0
 8009532:	f7f7 fd5d 	bl	8000ff0 <__aeabi_fmul>
 8009536:	1c01      	adds	r1, r0, #0
 8009538:	4640      	mov	r0, r8
 800953a:	f7f7 f9f9 	bl	8000930 <__aeabi_fadd>
 800953e:	465b      	mov	r3, fp
 8009540:	6058      	str	r0, [r3, #4]
  real = measured[1][i][0];
 8009542:	682f      	ldr	r7, [r5, #0]
  imag = measured[1][i][1];
 8009544:	686b      	ldr	r3, [r5, #4]
  measured[1][i][0] = real * c - imag * s;
 8009546:	1c39      	adds	r1, r7, #0
 8009548:	1c30      	adds	r0, r6, #0
  imag = measured[1][i][1];
 800954a:	4698      	mov	r8, r3
  measured[1][i][0] = real * c - imag * s;
 800954c:	f7f7 fd50 	bl	8000ff0 <__aeabi_fmul>
 8009550:	4641      	mov	r1, r8
 8009552:	4681      	mov	r9, r0
 8009554:	1c20      	adds	r0, r4, #0
 8009556:	f7f7 fd4b 	bl	8000ff0 <__aeabi_fmul>
 800955a:	1c01      	adds	r1, r0, #0
 800955c:	4648      	mov	r0, r9
 800955e:	f7f7 fe5f 	bl	8001220 <__aeabi_fsub>
  measured[1][i][1] = imag * c + real * s;
 8009562:	4641      	mov	r1, r8
  measured[1][i][0] = real * c - imag * s;
 8009564:	6028      	str	r0, [r5, #0]
  measured[1][i][1] = imag * c + real * s;
 8009566:	1c30      	adds	r0, r6, #0
 8009568:	f7f7 fd42 	bl	8000ff0 <__aeabi_fmul>
 800956c:	1c39      	adds	r1, r7, #0
 800956e:	1c06      	adds	r6, r0, #0
 8009570:	1c20      	adds	r0, r4, #0
 8009572:	f7f7 fd3d 	bl	8000ff0 <__aeabi_fmul>
 8009576:	1c01      	adds	r1, r0, #0
 8009578:	1c30      	adds	r0, r6, #0
 800957a:	f7f7 f9d9 	bl	8000930 <__aeabi_fadd>
 800957e:	6068      	str	r0, [r5, #4]
 8009580:	e502      	b.n	8008f88 <Thread1+0x148>
 8009582:	46c0      	nop			; (mov r8, r8)
 8009584:	3ff00000 	.word	0x3ff00000
 8009588:	54442d18 	.word	0x54442d18
 800958c:	401921fb 	.word	0x401921fb
 8009590:	3f700000 	.word	0x3f700000
 8009594:	200030ac 	.word	0x200030ac
 8009598:	000011c4 	.word	0x000011c4
 800959c:	20000454 	.word	0x20000454
 80095a0:	2000252c 	.word	0x2000252c
 80095a4:	2000220c 	.word	0x2000220c
 80095a8:	200023c4 	.word	0x200023c4
 80095ac:	20002220 	.word	0x20002220
 80095b0:	48000800 	.word	0x48000800
 80095b4:	20001630 	.word	0x20001630
 80095b8:	40012400 	.word	0x40012400
 80095bc:	200023c6 	.word	0x200023c6
 80095c0:	20001bbc 	.word	0x20001bbc
 80095c4:	20002236 	.word	0x20002236
 80095c8:	812dea11 	.word	0x812dea11
 80095cc:	3d719799 	.word	0x3d719799
    float s11mr = measured[0][i][0] - cal_data[ETERM_ED][i][0];
 80095d0:	4b8e      	ldr	r3, [pc, #568]	; (800980c <Thread1+0x9cc>)
 80095d2:	681b      	ldr	r3, [r3, #0]
 80095d4:	9302      	str	r3, [sp, #8]
 80095d6:	9b00      	ldr	r3, [sp, #0]
 80095d8:	00dc      	lsls	r4, r3, #3
 80095da:	9b02      	ldr	r3, [sp, #8]
 80095dc:	469c      	mov	ip, r3
 80095de:	23d2      	movs	r3, #210	; 0xd2
 80095e0:	4464      	add	r4, ip
 80095e2:	005b      	lsls	r3, r3, #1
 80095e4:	58e1      	ldr	r1, [r4, r3]
 80095e6:	465b      	mov	r3, fp
 80095e8:	6818      	ldr	r0, [r3, #0]
 80095ea:	f7f7 fe19 	bl	8001220 <__aeabi_fsub>
    float s11mi = measured[0][i][1] - cal_data[ETERM_ED][i][1];
 80095ee:	0023      	movs	r3, r4
 80095f0:	33a9      	adds	r3, #169	; 0xa9
 80095f2:	33ff      	adds	r3, #255	; 0xff
 80095f4:	6819      	ldr	r1, [r3, #0]
 80095f6:	465b      	mov	r3, fp
    float s11mr = measured[0][i][0] - cal_data[ETERM_ED][i][0];
 80095f8:	1c06      	adds	r6, r0, #0
    float s11mi = measured[0][i][1] - cal_data[ETERM_ED][i][1];
 80095fa:	6858      	ldr	r0, [r3, #4]
 80095fc:	f7f7 fe10 	bl	8001220 <__aeabi_fsub>
    float err = cal_data[ETERM_ER][i][0] + s11mr * cal_data[ETERM_ES][i][0] - s11mi * cal_data[ETERM_ES][i][1];
 8009600:	4b83      	ldr	r3, [pc, #524]	; (8009810 <Thread1+0x9d0>)
    float s11mi = measured[0][i][1] - cal_data[ETERM_ED][i][1];
 8009602:	4680      	mov	r8, r0
    float err = cal_data[ETERM_ER][i][0] + s11mr * cal_data[ETERM_ES][i][0] - s11mi * cal_data[ETERM_ES][i][1];
 8009604:	58e2      	ldr	r2, [r4, r3]
 8009606:	3304      	adds	r3, #4
 8009608:	18e3      	adds	r3, r4, r3
 800960a:	681b      	ldr	r3, [r3, #0]
 800960c:	1c11      	adds	r1, r2, #0
 800960e:	1c30      	adds	r0, r6, #0
 8009610:	9202      	str	r2, [sp, #8]
 8009612:	9304      	str	r3, [sp, #16]
 8009614:	f7f7 fcec 	bl	8000ff0 <__aeabi_fmul>
 8009618:	4b7e      	ldr	r3, [pc, #504]	; (8009814 <Thread1+0x9d4>)
 800961a:	58e1      	ldr	r1, [r4, r3]
 800961c:	f7f7 f988 	bl	8000930 <__aeabi_fadd>
 8009620:	9904      	ldr	r1, [sp, #16]
 8009622:	1c07      	adds	r7, r0, #0
 8009624:	4640      	mov	r0, r8
 8009626:	f7f7 fce3 	bl	8000ff0 <__aeabi_fmul>
 800962a:	1c01      	adds	r1, r0, #0
 800962c:	1c38      	adds	r0, r7, #0
 800962e:	f7f7 fdf7 	bl	8001220 <__aeabi_fsub>
    float eri = cal_data[ETERM_ER][i][1] + s11mr * cal_data[ETERM_ES][i][1] + s11mi * cal_data[ETERM_ES][i][0];
 8009632:	21ff      	movs	r1, #255	; 0xff
 8009634:	00c9      	lsls	r1, r1, #3
    float err = cal_data[ETERM_ER][i][0] + s11mr * cal_data[ETERM_ES][i][0] - s11mi * cal_data[ETERM_ES][i][1];
 8009636:	4681      	mov	r9, r0
    float eri = cal_data[ETERM_ER][i][1] + s11mr * cal_data[ETERM_ES][i][1] + s11mi * cal_data[ETERM_ES][i][0];
 8009638:	1867      	adds	r7, r4, r1
 800963a:	1c30      	adds	r0, r6, #0
 800963c:	9904      	ldr	r1, [sp, #16]
 800963e:	f7f7 fcd7 	bl	8000ff0 <__aeabi_fmul>
 8009642:	6839      	ldr	r1, [r7, #0]
 8009644:	f7f7 f974 	bl	8000930 <__aeabi_fadd>
 8009648:	9902      	ldr	r1, [sp, #8]
 800964a:	1c07      	adds	r7, r0, #0
 800964c:	4640      	mov	r0, r8
 800964e:	f7f7 fccf 	bl	8000ff0 <__aeabi_fmul>
 8009652:	1c01      	adds	r1, r0, #0
 8009654:	1c38      	adds	r0, r7, #0
 8009656:	f7f7 f96b 	bl	8000930 <__aeabi_fadd>
    float sq = err*err + eri*eri;
 800965a:	4649      	mov	r1, r9
    float eri = cal_data[ETERM_ER][i][1] + s11mr * cal_data[ETERM_ES][i][1] + s11mi * cal_data[ETERM_ES][i][0];
 800965c:	1c07      	adds	r7, r0, #0
    float sq = err*err + eri*eri;
 800965e:	4648      	mov	r0, r9
 8009660:	f7f7 fcc6 	bl	8000ff0 <__aeabi_fmul>
 8009664:	1c39      	adds	r1, r7, #0
 8009666:	9005      	str	r0, [sp, #20]
 8009668:	1c38      	adds	r0, r7, #0
 800966a:	f7f7 fcc1 	bl	8000ff0 <__aeabi_fmul>
 800966e:	1c01      	adds	r1, r0, #0
 8009670:	9805      	ldr	r0, [sp, #20]
 8009672:	f7f7 f95d 	bl	8000930 <__aeabi_fadd>
    float s11ar = (s11mr * err + s11mi * eri) / sq;
 8009676:	4649      	mov	r1, r9
    float sq = err*err + eri*eri;
 8009678:	9006      	str	r0, [sp, #24]
    float s11ar = (s11mr * err + s11mi * eri) / sq;
 800967a:	1c30      	adds	r0, r6, #0
 800967c:	f7f7 fcb8 	bl	8000ff0 <__aeabi_fmul>
 8009680:	1c39      	adds	r1, r7, #0
 8009682:	9005      	str	r0, [sp, #20]
 8009684:	4640      	mov	r0, r8
 8009686:	f7f7 fcb3 	bl	8000ff0 <__aeabi_fmul>
 800968a:	1c01      	adds	r1, r0, #0
 800968c:	9805      	ldr	r0, [sp, #20]
 800968e:	f7f7 f94f 	bl	8000930 <__aeabi_fadd>
 8009692:	9906      	ldr	r1, [sp, #24]
 8009694:	f7f7 facc 	bl	8000c30 <__aeabi_fdiv>
    float s11ai = (s11mi * err - s11mr * eri) / sq;
 8009698:	4649      	mov	r1, r9
    float s11ar = (s11mr * err + s11mi * eri) / sq;
 800969a:	9005      	str	r0, [sp, #20]
    float s11ai = (s11mi * err - s11mr * eri) / sq;
 800969c:	4640      	mov	r0, r8
 800969e:	f7f7 fca7 	bl	8000ff0 <__aeabi_fmul>
 80096a2:	1c39      	adds	r1, r7, #0
 80096a4:	4680      	mov	r8, r0
 80096a6:	1c30      	adds	r0, r6, #0
 80096a8:	f7f7 fca2 	bl	8000ff0 <__aeabi_fmul>
 80096ac:	1c01      	adds	r1, r0, #0
 80096ae:	4640      	mov	r0, r8
 80096b0:	f7f7 fdb6 	bl	8001220 <__aeabi_fsub>
 80096b4:	9906      	ldr	r1, [sp, #24]
 80096b6:	f7f7 fabb 	bl	8000c30 <__aeabi_fdiv>
    measured[0][i][0] = s11ar;
 80096ba:	4659      	mov	r1, fp
 80096bc:	9b05      	ldr	r3, [sp, #20]
    measured[0][i][1] = s11ai;
 80096be:	6048      	str	r0, [r1, #4]
    measured[0][i][0] = s11ar;
 80096c0:	600b      	str	r3, [r1, #0]
    float s21mr = measured[1][i][0] - cal_data[ETERM_EX][i][0];
 80096c2:	4b55      	ldr	r3, [pc, #340]	; (8009818 <Thread1+0x9d8>)
    float s11ai = (s11mi * err - s11mr * eri) / sq;
 80096c4:	1c06      	adds	r6, r0, #0
    float s21mr = measured[1][i][0] - cal_data[ETERM_EX][i][0];
 80096c6:	58e1      	ldr	r1, [r4, r3]
 80096c8:	6828      	ldr	r0, [r5, #0]
 80096ca:	f7f7 fda9 	bl	8001220 <__aeabi_fsub>
    float s21mi = measured[1][i][1] - cal_data[ETERM_EX][i][1];
 80096ce:	4953      	ldr	r1, [pc, #332]	; (800981c <Thread1+0x9dc>)
    float s21mr = measured[1][i][0] - cal_data[ETERM_EX][i][0];
 80096d0:	9006      	str	r0, [sp, #24]
    float s21mi = measured[1][i][1] - cal_data[ETERM_EX][i][1];
 80096d2:	1863      	adds	r3, r4, r1
 80096d4:	6819      	ldr	r1, [r3, #0]
 80096d6:	6868      	ldr	r0, [r5, #4]
 80096d8:	f7f7 fda2 	bl	8001220 <__aeabi_fsub>
    float esr = 1 - (cal_data[ETERM_ES][i][0] * s11ar - cal_data[ETERM_ES][i][1] * s11ai);
 80096dc:	9905      	ldr	r1, [sp, #20]
    float s21mi = measured[1][i][1] - cal_data[ETERM_EX][i][1];
 80096de:	1c07      	adds	r7, r0, #0
    float esr = 1 - (cal_data[ETERM_ES][i][0] * s11ar - cal_data[ETERM_ES][i][1] * s11ai);
 80096e0:	9802      	ldr	r0, [sp, #8]
 80096e2:	f7f7 fc85 	bl	8000ff0 <__aeabi_fmul>
 80096e6:	9b04      	ldr	r3, [sp, #16]
 80096e8:	4680      	mov	r8, r0
 80096ea:	1c31      	adds	r1, r6, #0
 80096ec:	1c18      	adds	r0, r3, #0
 80096ee:	4699      	mov	r9, r3
 80096f0:	f7f7 fc7e 	bl	8000ff0 <__aeabi_fmul>
 80096f4:	1c01      	adds	r1, r0, #0
 80096f6:	4640      	mov	r0, r8
 80096f8:	f7f7 fd92 	bl	8001220 <__aeabi_fsub>
 80096fc:	1c01      	adds	r1, r0, #0
 80096fe:	20fe      	movs	r0, #254	; 0xfe
 8009700:	0580      	lsls	r0, r0, #22
 8009702:	f7f7 fd8d 	bl	8001220 <__aeabi_fsub>
    float esi = - (cal_data[ETERM_ES][i][1] * s11ar + cal_data[ETERM_ES][i][0] * s11ai);
 8009706:	9905      	ldr	r1, [sp, #20]
    float esr = 1 - (cal_data[ETERM_ES][i][0] * s11ar - cal_data[ETERM_ES][i][1] * s11ai);
 8009708:	4680      	mov	r8, r0
    float esi = - (cal_data[ETERM_ES][i][1] * s11ar + cal_data[ETERM_ES][i][0] * s11ai);
 800970a:	4648      	mov	r0, r9
 800970c:	f7f7 fc70 	bl	8000ff0 <__aeabi_fmul>
 8009710:	1c31      	adds	r1, r6, #0
 8009712:	4681      	mov	r9, r0
 8009714:	9802      	ldr	r0, [sp, #8]
 8009716:	f7f7 fc6b 	bl	8000ff0 <__aeabi_fmul>
 800971a:	1c01      	adds	r1, r0, #0
 800971c:	4648      	mov	r0, r9
 800971e:	f7f7 f907 	bl	8000930 <__aeabi_fadd>
 8009722:	2380      	movs	r3, #128	; 0x80
 8009724:	061b      	lsls	r3, r3, #24
 8009726:	18c6      	adds	r6, r0, r3
    float etr = esr * cal_data[ETERM_ET][i][0] - esi * cal_data[ETERM_ET][i][1];
 8009728:	4b3d      	ldr	r3, [pc, #244]	; (8009820 <Thread1+0x9e0>)
 800972a:	4640      	mov	r0, r8
 800972c:	58e3      	ldr	r3, [r4, r3]
 800972e:	4699      	mov	r9, r3
 8009730:	23b2      	movs	r3, #178	; 0xb2
 8009732:	011b      	lsls	r3, r3, #4
 8009734:	469c      	mov	ip, r3
 8009736:	4464      	add	r4, ip
 8009738:	6823      	ldr	r3, [r4, #0]
 800973a:	4649      	mov	r1, r9
 800973c:	9302      	str	r3, [sp, #8]
 800973e:	f7f7 fc57 	bl	8000ff0 <__aeabi_fmul>
 8009742:	9902      	ldr	r1, [sp, #8]
 8009744:	1c04      	adds	r4, r0, #0
 8009746:	1c30      	adds	r0, r6, #0
 8009748:	f7f7 fc52 	bl	8000ff0 <__aeabi_fmul>
 800974c:	1c01      	adds	r1, r0, #0
 800974e:	1c20      	adds	r0, r4, #0
 8009750:	f7f7 fd66 	bl	8001220 <__aeabi_fsub>
    float eti = esr * cal_data[ETERM_ET][i][1] + esi * cal_data[ETERM_ET][i][0];
 8009754:	9902      	ldr	r1, [sp, #8]
    float etr = esr * cal_data[ETERM_ET][i][0] - esi * cal_data[ETERM_ET][i][1];
 8009756:	1c04      	adds	r4, r0, #0
    float eti = esr * cal_data[ETERM_ET][i][1] + esi * cal_data[ETERM_ET][i][0];
 8009758:	4640      	mov	r0, r8
 800975a:	f7f7 fc49 	bl	8000ff0 <__aeabi_fmul>
 800975e:	4649      	mov	r1, r9
 8009760:	4680      	mov	r8, r0
 8009762:	1c30      	adds	r0, r6, #0
 8009764:	f7f7 fc44 	bl	8000ff0 <__aeabi_fmul>
 8009768:	1c01      	adds	r1, r0, #0
 800976a:	4640      	mov	r0, r8
 800976c:	f7f7 f8e0 	bl	8000930 <__aeabi_fadd>
    float s21ar = s21mr * etr - s21mi * eti;
 8009770:	9b06      	ldr	r3, [sp, #24]
    float eti = esr * cal_data[ETERM_ET][i][1] + esi * cal_data[ETERM_ET][i][0];
 8009772:	1c06      	adds	r6, r0, #0
    float s21ar = s21mr * etr - s21mi * eti;
 8009774:	1c21      	adds	r1, r4, #0
 8009776:	1c18      	adds	r0, r3, #0
 8009778:	4699      	mov	r9, r3
 800977a:	f7f7 fc39 	bl	8000ff0 <__aeabi_fmul>
 800977e:	1c31      	adds	r1, r6, #0
 8009780:	4680      	mov	r8, r0
 8009782:	1c38      	adds	r0, r7, #0
 8009784:	f7f7 fc34 	bl	8000ff0 <__aeabi_fmul>
 8009788:	1c01      	adds	r1, r0, #0
 800978a:	4640      	mov	r0, r8
 800978c:	f7f7 fd48 	bl	8001220 <__aeabi_fsub>
    float s21ai = s21mi * etr + s21mr * eti;
 8009790:	1c21      	adds	r1, r4, #0
    measured[1][i][0] = s21ar;
 8009792:	6028      	str	r0, [r5, #0]
    float s21ai = s21mi * etr + s21mr * eti;
 8009794:	1c38      	adds	r0, r7, #0
 8009796:	f7f7 fc2b 	bl	8000ff0 <__aeabi_fmul>
 800979a:	1c31      	adds	r1, r6, #0
 800979c:	1c04      	adds	r4, r0, #0
 800979e:	4648      	mov	r0, r9
 80097a0:	f7f7 fc26 	bl	8000ff0 <__aeabi_fmul>
 80097a4:	1c01      	adds	r1, r0, #0
 80097a6:	1c20      	adds	r0, r4, #0
 80097a8:	f7f7 f8c2 	bl	8000930 <__aeabi_fadd>
    measured[1][i][1] = s21ai;
 80097ac:	6068      	str	r0, [r5, #4]
 80097ae:	f7ff fbe1 	bl	8008f74 <Thread1+0x134>
    float beta = 0.0;
 80097b2:	2300      	movs	r3, #0
 80097b4:	930f      	str	r3, [sp, #60]	; 0x3c
 80097b6:	e41c      	b.n	8008ff2 <Thread1+0x1b2>
    switch (domain_mode & TD_FUNC) {
 80097b8:	2365      	movs	r3, #101	; 0x65
 80097ba:	9311      	str	r3, [sp, #68]	; 0x44
            is_lowpass = TRUE;
 80097bc:	3b64      	subs	r3, #100	; 0x64
 80097be:	930d      	str	r3, [sp, #52]	; 0x34
            window_size = POINT_COUNT * 2;
 80097c0:	33c9      	adds	r3, #201	; 0xc9
 80097c2:	9310      	str	r3, [sp, #64]	; 0x40
    switch (domain_mode & TD_WINDOW) {
 80097c4:	2318      	movs	r3, #24
 80097c6:	400b      	ands	r3, r1
 80097c8:	d000      	beq.n	80097cc <Thread1+0x98c>
 80097ca:	e40d      	b.n	8008fe8 <Thread1+0x1a8>
            beta = 6.0;
 80097cc:	4b15      	ldr	r3, [pc, #84]	; (8009824 <Thread1+0x9e4>)
 80097ce:	930f      	str	r3, [sp, #60]	; 0x3c
 80097d0:	e40f      	b.n	8008ff2 <Thread1+0x1b2>
 80097d2:	4b15      	ldr	r3, [pc, #84]	; (8009828 <Thread1+0x9e8>)
 80097d4:	9812      	ldr	r0, [sp, #72]	; 0x48
 80097d6:	9c13      	ldr	r4, [sp, #76]	; 0x4c
                tmp[(FFT_SIZE-i)*2+1] = -tmp[i*2+1];
 80097d8:	2580      	movs	r5, #128	; 0x80
 80097da:	062d      	lsls	r5, r5, #24
 80097dc:	46ac      	mov	ip, r5
                tmp[(FFT_SIZE-i)*2+0] =  tmp[i*2+0];
 80097de:	6819      	ldr	r1, [r3, #0]
 80097e0:	1ac2      	subs	r2, r0, r3
 80097e2:	6011      	str	r1, [r2, #0]
                tmp[(FFT_SIZE-i)*2+1] = -tmp[i*2+1];
 80097e4:	685a      	ldr	r2, [r3, #4]
 80097e6:	1ae1      	subs	r1, r4, r3
 80097e8:	4462      	add	r2, ip
 80097ea:	600a      	str	r2, [r1, #0]
            for (int i = 1; i < POINT_COUNT; i++) {
 80097ec:	4a0f      	ldr	r2, [pc, #60]	; (800982c <Thread1+0x9ec>)
 80097ee:	3308      	adds	r3, #8
 80097f0:	429a      	cmp	r2, r3
 80097f2:	d1f1      	bne.n	80097d8 <Thread1+0x998>
 80097f4:	e4d2      	b.n	800919c <Thread1+0x35c>
 80097f6:	465c      	mov	r4, fp
 80097f8:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
                measured[ch][i][0] += measured[ch][i-1][0];
 80097fa:	68a0      	ldr	r0, [r4, #8]
 80097fc:	6821      	ldr	r1, [r4, #0]
 80097fe:	f7f7 f897 	bl	8000930 <__aeabi_fadd>
 8009802:	3408      	adds	r4, #8
 8009804:	6020      	str	r0, [r4, #0]
            for (int i = 1; i < POINT_COUNT; i++) {
 8009806:	42a5      	cmp	r5, r4
 8009808:	d1f7      	bne.n	80097fa <Thread1+0x9ba>
 800980a:	e5fe      	b.n	800940a <Thread1+0x5ca>
 800980c:	20000428 	.word	0x20000428
 8009810:	000004cc 	.word	0x000004cc
 8009814:	000007f4 	.word	0x000007f4
 8009818:	00000e44 	.word	0x00000e44
 800981c:	00000e48 	.word	0x00000e48
 8009820:	00000b1c 	.word	0x00000b1c
 8009824:	40c00000 	.word	0x40c00000
 8009828:	200030b4 	.word	0x200030b4
 800982c:	200033d4 	.word	0x200033d4

08009830 <toggle_sweep>:
  sweep_enabled = !sweep_enabled;
 8009830:	2300      	movs	r3, #0
 8009832:	4a03      	ldr	r2, [pc, #12]	; (8009840 <toggle_sweep+0x10>)
 8009834:	56d3      	ldrsb	r3, [r2, r3]
 8009836:	4259      	negs	r1, r3
 8009838:	414b      	adcs	r3, r1
 800983a:	7013      	strb	r3, [r2, #0]
}
 800983c:	4770      	bx	lr
 800983e:	46c0      	nop			; (mov r8, r8)
 8009840:	20001630 	.word	0x20001630
	...

08009850 <set_sweep_frequency>:
{
 8009850:	b5f0      	push	{r4, r5, r6, r7, lr}
 8009852:	46c6      	mov	lr, r8
  chMtxLock(&mutex_sweep);
 8009854:	4b5f      	ldr	r3, [pc, #380]	; (80099d4 <set_sweep_frequency+0x184>)
{
 8009856:	b500      	push	{lr}
 8009858:	0005      	movs	r5, r0
  chMtxLock(&mutex_sweep);
 800985a:	0018      	movs	r0, r3
 800985c:	4698      	mov	r8, r3
{
 800985e:	000c      	movs	r4, r1
  chMtxLock(&mutex_sweep);
 8009860:	f7fa fc2e 	bl	80040c0 <chMtxLock>
  int cal_applied = cal_status & CALSTAT_APPLY;
 8009864:	2380      	movs	r3, #128	; 0x80
 8009866:	4e5c      	ldr	r6, [pc, #368]	; (80099d8 <set_sweep_frequency+0x188>)
 8009868:	005b      	lsls	r3, r3, #1
 800986a:	89f7      	ldrh	r7, [r6, #14]
 800986c:	401f      	ands	r7, r3
  switch (type) {
 800986e:	2d04      	cmp	r5, #4
 8009870:	d817      	bhi.n	80098a2 <set_sweep_frequency+0x52>
 8009872:	4b5a      	ldr	r3, [pc, #360]	; (80099dc <set_sweep_frequency+0x18c>)
 8009874:	00ad      	lsls	r5, r5, #2
 8009876:	595b      	ldr	r3, [r3, r5]
 8009878:	469f      	mov	pc, r3
  if (active_props == &current_props)
 800987a:	4b59      	ldr	r3, [pc, #356]	; (80099e0 <set_sweep_frequency+0x190>)
 800987c:	681a      	ldr	r2, [r3, #0]
 800987e:	42b2      	cmp	r2, r6
 8009880:	d002      	beq.n	8009888 <set_sweep_frequency+0x38>
  active_props = &current_props;
 8009882:	601e      	str	r6, [r3, #0]
  cal_status = 0;
 8009884:	2300      	movs	r3, #0
 8009886:	81f3      	strh	r3, [r6, #14]
    if (freq > STOP_MAX)
 8009888:	4b56      	ldr	r3, [pc, #344]	; (80099e4 <set_sweep_frequency+0x194>)
 800988a:	429c      	cmp	r4, r3
 800988c:	da00      	bge.n	8009890 <set_sweep_frequency+0x40>
 800988e:	001c      	movs	r4, r3
    frequency0 = freq;
 8009890:	4b55      	ldr	r3, [pc, #340]	; (80099e8 <set_sweep_frequency+0x198>)
 8009892:	429c      	cmp	r4, r3
 8009894:	dd00      	ble.n	8009898 <set_sweep_frequency+0x48>
 8009896:	001c      	movs	r4, r3
    frequency1 = 0;
 8009898:	2300      	movs	r3, #0
    frequency0 = freq;
 800989a:	6074      	str	r4, [r6, #4]
    frequency1 = 0;
 800989c:	60b3      	str	r3, [r6, #8]
    update_frequencies();
 800989e:	f7fe fa9f 	bl	8007de0 <update_frequencies>
  if (cal_auto_interpolate && cal_applied)
 80098a2:	2f00      	cmp	r7, #0
 80098a4:	d000      	beq.n	80098a8 <set_sweep_frequency+0x58>
 80098a6:	e086      	b.n	80099b6 <set_sweep_frequency+0x166>
  chMtxUnlock(&mutex_sweep);
 80098a8:	4640      	mov	r0, r8
 80098aa:	f7fa fc11 	bl	80040d0 <chMtxUnlock>
}
 80098ae:	bc04      	pop	{r2}
 80098b0:	4690      	mov	r8, r2
 80098b2:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if (active_props == &current_props)
 80098b4:	4b4a      	ldr	r3, [pc, #296]	; (80099e0 <set_sweep_frequency+0x190>)
 80098b6:	681a      	ldr	r2, [r3, #0]
 80098b8:	42b2      	cmp	r2, r6
 80098ba:	d002      	beq.n	80098c2 <set_sweep_frequency+0x72>
  active_props = &current_props;
 80098bc:	601e      	str	r6, [r3, #0]
  cal_status = 0;
 80098be:	2300      	movs	r3, #0
 80098c0:	81f3      	strh	r3, [r6, #14]
  if (frequency1 > 0) {
 80098c2:	68b3      	ldr	r3, [r6, #8]
 80098c4:	6872      	ldr	r2, [r6, #4]
 80098c6:	2b00      	cmp	r3, #0
 80098c8:	dd04      	ble.n	80098d4 <set_sweep_frequency+0x84>
    frequency0 = (start + stop)/2; // center
 80098ca:	18d3      	adds	r3, r2, r3
 80098cc:	0fda      	lsrs	r2, r3, #31
 80098ce:	18d2      	adds	r2, r2, r3
 80098d0:	1052      	asrs	r2, r2, #1
 80098d2:	6072      	str	r2, [r6, #4]
    if (freq > STOP_MAX-START_MIN)
 80098d4:	43e3      	mvns	r3, r4
 80098d6:	17db      	asrs	r3, r3, #31
 80098d8:	401c      	ands	r4, r3
 80098da:	4b44      	ldr	r3, [pc, #272]	; (80099ec <set_sweep_frequency+0x19c>)
 80098dc:	429c      	cmp	r4, r3
 80098de:	dd00      	ble.n	80098e2 <set_sweep_frequency+0x92>
 80098e0:	001c      	movs	r4, r3
    frequency1 = -freq;
 80098e2:	4263      	negs	r3, r4
 80098e4:	60b3      	str	r3, [r6, #8]
    if (center-span/2 < START_MIN) {
 80098e6:	0fe3      	lsrs	r3, r4, #31
 80098e8:	191b      	adds	r3, r3, r4
 80098ea:	105b      	asrs	r3, r3, #1
 80098ec:	425b      	negs	r3, r3
 80098ee:	4940      	ldr	r1, [pc, #256]	; (80099f0 <set_sweep_frequency+0x1a0>)
 80098f0:	1898      	adds	r0, r3, r2
 80098f2:	1064      	asrs	r4, r4, #1
 80098f4:	4288      	cmp	r0, r1
 80098f6:	dc64      	bgt.n	80099c2 <set_sweep_frequency+0x172>
      center = START_MIN + span/2;
 80098f8:	4b3a      	ldr	r3, [pc, #232]	; (80099e4 <set_sweep_frequency+0x194>)
 80098fa:	469c      	mov	ip, r3
 80098fc:	4464      	add	r4, ip
      frequency0 = center;
 80098fe:	6074      	str	r4, [r6, #4]
    if (center+span/2 > STOP_MAX) {
 8009900:	e7cd      	b.n	800989e <set_sweep_frequency+0x4e>
  if (active_props == &current_props)
 8009902:	4b37      	ldr	r3, [pc, #220]	; (80099e0 <set_sweep_frequency+0x190>)
 8009904:	681a      	ldr	r2, [r3, #0]
 8009906:	42b2      	cmp	r2, r6
 8009908:	d002      	beq.n	8009910 <set_sweep_frequency+0xc0>
  active_props = &current_props;
 800990a:	601e      	str	r6, [r3, #0]
  cal_status = 0;
 800990c:	2300      	movs	r3, #0
 800990e:	81f3      	strh	r3, [r6, #14]
    freq_mode_startstop();
 8009910:	f7fe f94e 	bl	8007bb0 <freq_mode_startstop>
    if (freq < START_MIN)
 8009914:	4b34      	ldr	r3, [pc, #208]	; (80099e8 <set_sweep_frequency+0x198>)
 8009916:	429c      	cmp	r4, r3
 8009918:	dd00      	ble.n	800991c <set_sweep_frequency+0xcc>
 800991a:	001c      	movs	r4, r3
 800991c:	4b31      	ldr	r3, [pc, #196]	; (80099e4 <set_sweep_frequency+0x194>)
 800991e:	429c      	cmp	r4, r3
 8009920:	da00      	bge.n	8009924 <set_sweep_frequency+0xd4>
 8009922:	001c      	movs	r4, r3
    if (frequency1 < freq)
 8009924:	68b3      	ldr	r3, [r6, #8]
    frequency0 = freq;
 8009926:	6074      	str	r4, [r6, #4]
    if (frequency1 < freq)
 8009928:	42a3      	cmp	r3, r4
 800992a:	dab8      	bge.n	800989e <set_sweep_frequency+0x4e>
      frequency1 = -span;
 800992c:	60b4      	str	r4, [r6, #8]
 800992e:	e7b6      	b.n	800989e <set_sweep_frequency+0x4e>
  if (active_props == &current_props)
 8009930:	4b2b      	ldr	r3, [pc, #172]	; (80099e0 <set_sweep_frequency+0x190>)
 8009932:	681a      	ldr	r2, [r3, #0]
 8009934:	42b2      	cmp	r2, r6
 8009936:	d002      	beq.n	800993e <set_sweep_frequency+0xee>
  active_props = &current_props;
 8009938:	601e      	str	r6, [r3, #0]
  cal_status = 0;
 800993a:	2300      	movs	r3, #0
 800993c:	81f3      	strh	r3, [r6, #14]
    freq_mode_startstop();
 800993e:	f7fe f937 	bl	8007bb0 <freq_mode_startstop>
    if (freq > STOP_MAX)
 8009942:	4b28      	ldr	r3, [pc, #160]	; (80099e4 <set_sweep_frequency+0x194>)
 8009944:	429c      	cmp	r4, r3
 8009946:	da00      	bge.n	800994a <set_sweep_frequency+0xfa>
 8009948:	001c      	movs	r4, r3
 800994a:	4b27      	ldr	r3, [pc, #156]	; (80099e8 <set_sweep_frequency+0x198>)
 800994c:	429c      	cmp	r4, r3
 800994e:	dd00      	ble.n	8009952 <set_sweep_frequency+0x102>
 8009950:	001c      	movs	r4, r3
    if (frequency0 > freq)
 8009952:	6873      	ldr	r3, [r6, #4]
    frequency1 = freq;
 8009954:	60b4      	str	r4, [r6, #8]
    if (frequency0 > freq)
 8009956:	42a3      	cmp	r3, r4
 8009958:	dda1      	ble.n	800989e <set_sweep_frequency+0x4e>
      frequency0 = center;
 800995a:	6074      	str	r4, [r6, #4]
    if (center+span/2 > STOP_MAX) {
 800995c:	e79f      	b.n	800989e <set_sweep_frequency+0x4e>
  if (active_props == &current_props)
 800995e:	4b20      	ldr	r3, [pc, #128]	; (80099e0 <set_sweep_frequency+0x190>)
 8009960:	681a      	ldr	r2, [r3, #0]
 8009962:	42b2      	cmp	r2, r6
 8009964:	d002      	beq.n	800996c <set_sweep_frequency+0x11c>
  active_props = &current_props;
 8009966:	601e      	str	r6, [r3, #0]
  cal_status = 0;
 8009968:	2300      	movs	r3, #0
 800996a:	81f3      	strh	r3, [r6, #14]
  if (frequency1 > 0) {
 800996c:	68b3      	ldr	r3, [r6, #8]
 800996e:	2b00      	cmp	r3, #0
 8009970:	dd02      	ble.n	8009978 <set_sweep_frequency+0x128>
    frequency1 = -(stop - start); // span
 8009972:	6872      	ldr	r2, [r6, #4]
 8009974:	1ad3      	subs	r3, r2, r3
 8009976:	60b3      	str	r3, [r6, #8]
    if (freq > STOP_MAX)
 8009978:	4a1a      	ldr	r2, [pc, #104]	; (80099e4 <set_sweep_frequency+0x194>)
 800997a:	4294      	cmp	r4, r2
 800997c:	da00      	bge.n	8009980 <set_sweep_frequency+0x130>
 800997e:	0014      	movs	r4, r2
 8009980:	4a19      	ldr	r2, [pc, #100]	; (80099e8 <set_sweep_frequency+0x198>)
 8009982:	4294      	cmp	r4, r2
 8009984:	dd00      	ble.n	8009988 <set_sweep_frequency+0x138>
 8009986:	0014      	movs	r4, r2
    span = -frequency1;
 8009988:	425a      	negs	r2, r3
    if (center-span/2 < START_MIN) {
 800998a:	0fd3      	lsrs	r3, r2, #31
 800998c:	189b      	adds	r3, r3, r2
 800998e:	4a18      	ldr	r2, [pc, #96]	; (80099f0 <set_sweep_frequency+0x1a0>)
 8009990:	105b      	asrs	r3, r3, #1
    frequency0 = freq;
 8009992:	6074      	str	r4, [r6, #4]
    if (center-span/2 < START_MIN) {
 8009994:	1ae1      	subs	r1, r4, r3
 8009996:	4291      	cmp	r1, r2
 8009998:	dc04      	bgt.n	80099a4 <set_sweep_frequency+0x154>
      span = (center - START_MIN) * 2;
 800999a:	4b16      	ldr	r3, [pc, #88]	; (80099f4 <set_sweep_frequency+0x1a4>)
 800999c:	18e3      	adds	r3, r4, r3
 800999e:	005a      	lsls	r2, r3, #1
      frequency1 = -span;
 80099a0:	4252      	negs	r2, r2
 80099a2:	60b2      	str	r2, [r6, #8]
    if (center+span/2 > STOP_MAX) {
 80099a4:	4a10      	ldr	r2, [pc, #64]	; (80099e8 <set_sweep_frequency+0x198>)
 80099a6:	191b      	adds	r3, r3, r4
 80099a8:	4293      	cmp	r3, r2
 80099aa:	dc00      	bgt.n	80099ae <set_sweep_frequency+0x15e>
 80099ac:	e777      	b.n	800989e <set_sweep_frequency+0x4e>
      span = (STOP_MAX - center) * 2;
 80099ae:	1aa4      	subs	r4, r4, r2
      frequency1 = -span;
 80099b0:	0064      	lsls	r4, r4, #1
 80099b2:	60b4      	str	r4, [r6, #8]
 80099b4:	e773      	b.n	800989e <set_sweep_frequency+0x4e>
    cal_interpolate(lastsaveid);
 80099b6:	4b10      	ldr	r3, [pc, #64]	; (80099f8 <set_sweep_frequency+0x1a8>)
 80099b8:	2000      	movs	r0, #0
 80099ba:	5e18      	ldrsh	r0, [r3, r0]
 80099bc:	f7fe fa90 	bl	8007ee0 <cal_interpolate>
 80099c0:	e772      	b.n	80098a8 <set_sweep_frequency+0x58>
    if (center+span/2 > STOP_MAX) {
 80099c2:	18a4      	adds	r4, r4, r2
 80099c4:	4a08      	ldr	r2, [pc, #32]	; (80099e8 <set_sweep_frequency+0x198>)
 80099c6:	4294      	cmp	r4, r2
 80099c8:	dc00      	bgt.n	80099cc <set_sweep_frequency+0x17c>
 80099ca:	e768      	b.n	800989e <set_sweep_frequency+0x4e>
      center = STOP_MAX - span/2;
 80099cc:	4694      	mov	ip, r2
 80099ce:	4463      	add	r3, ip
      frequency0 = center;
 80099d0:	6073      	str	r3, [r6, #4]
 80099d2:	e764      	b.n	800989e <set_sweep_frequency+0x4e>
 80099d4:	20002220 	.word	0x20002220
 80099d8:	20000454 	.word	0x20000454
 80099dc:	08013e30 	.word	0x08013e30
 80099e0:	20000428 	.word	0x20000428
 80099e4:	00002710 	.word	0x00002710
 80099e8:	59682f00 	.word	0x59682f00
 80099ec:	596807f0 	.word	0x596807f0
 80099f0:	0000270f 	.word	0x0000270f
 80099f4:	ffffd8f0 	.word	0xffffd8f0
 80099f8:	200038b0 	.word	0x200038b0
 80099fc:	00000000 	.word	0x00000000

08009a00 <cmd_sweep>:
{
 8009a00:	b570      	push	{r4, r5, r6, lr}
 8009a02:	0004      	movs	r4, r0
 8009a04:	b082      	sub	sp, #8
 8009a06:	0015      	movs	r5, r2
  if (argc == 0) {
 8009a08:	2900      	cmp	r1, #0
 8009a0a:	d043      	beq.n	8009a94 <cmd_sweep+0x94>
  } else if (argc > 3) {
 8009a0c:	2903      	cmp	r1, #3
 8009a0e:	dc38      	bgt.n	8009a82 <cmd_sweep+0x82>
  if (argc >= 2) {
 8009a10:	2901      	cmp	r1, #1
 8009a12:	dd2f      	ble.n	8009a74 <cmd_sweep+0x74>
    if (strcmp(argv[0], "start") == 0) {
 8009a14:	6816      	ldr	r6, [r2, #0]
 8009a16:	4937      	ldr	r1, [pc, #220]	; (8009af4 <cmd_sweep+0xf4>)
 8009a18:	0030      	movs	r0, r6
 8009a1a:	f7f9 fed9 	bl	80037d0 <strcmp>
 8009a1e:	2800      	cmp	r0, #0
 8009a20:	d043      	beq.n	8009aaa <cmd_sweep+0xaa>
    } else if (strcmp(argv[0], "stop") == 0) {
 8009a22:	4935      	ldr	r1, [pc, #212]	; (8009af8 <cmd_sweep+0xf8>)
 8009a24:	0030      	movs	r0, r6
 8009a26:	f7f9 fed3 	bl	80037d0 <strcmp>
 8009a2a:	2800      	cmp	r0, #0
 8009a2c:	d019      	beq.n	8009a62 <cmd_sweep+0x62>
    } else if (strcmp(argv[0], "center") == 0) {
 8009a2e:	4933      	ldr	r1, [pc, #204]	; (8009afc <cmd_sweep+0xfc>)
 8009a30:	0030      	movs	r0, r6
 8009a32:	f7f9 fecd 	bl	80037d0 <strcmp>
 8009a36:	2800      	cmp	r0, #0
 8009a38:	d03f      	beq.n	8009aba <cmd_sweep+0xba>
    } else if (strcmp(argv[0], "span") == 0) {
 8009a3a:	4931      	ldr	r1, [pc, #196]	; (8009b00 <cmd_sweep+0x100>)
 8009a3c:	0030      	movs	r0, r6
 8009a3e:	f7f9 fec7 	bl	80037d0 <strcmp>
 8009a42:	2800      	cmp	r0, #0
 8009a44:	d041      	beq.n	8009aca <cmd_sweep+0xca>
    } else if (strcmp(argv[0], "cw") == 0) {
 8009a46:	492f      	ldr	r1, [pc, #188]	; (8009b04 <cmd_sweep+0x104>)
 8009a48:	0030      	movs	r0, r6
 8009a4a:	f7f9 fec1 	bl	80037d0 <strcmp>
 8009a4e:	2800      	cmp	r0, #0
 8009a50:	d043      	beq.n	8009ada <cmd_sweep+0xda>
    int32_t value = atoi(argv[0]);
 8009a52:	0030      	movs	r0, r6
 8009a54:	f009 fb2c 	bl	80130b0 <atoi>
 8009a58:	1e01      	subs	r1, r0, #0
    if (value == 0)
 8009a5a:	d012      	beq.n	8009a82 <cmd_sweep+0x82>
    set_sweep_frequency(ST_START, value);
 8009a5c:	2000      	movs	r0, #0
 8009a5e:	f7ff fef7 	bl	8009850 <set_sweep_frequency>
    int32_t value = atoi(argv[1]);
 8009a62:	6868      	ldr	r0, [r5, #4]
 8009a64:	f009 fb24 	bl	80130b0 <atoi>
 8009a68:	0001      	movs	r1, r0
    set_sweep_frequency(ST_STOP, value);
 8009a6a:	2001      	movs	r0, #1
 8009a6c:	f7ff fef0 	bl	8009850 <set_sweep_frequency>
}
 8009a70:	b002      	add	sp, #8
 8009a72:	bd70      	pop	{r4, r5, r6, pc}
  if (argc >= 1) {
 8009a74:	2901      	cmp	r1, #1
 8009a76:	d1fb      	bne.n	8009a70 <cmd_sweep+0x70>
    int32_t value = atoi(argv[0]);
 8009a78:	6810      	ldr	r0, [r2, #0]
 8009a7a:	f009 fb19 	bl	80130b0 <atoi>
    if (value == 0)
 8009a7e:	2800      	cmp	r0, #0
 8009a80:	d133      	bne.n	8009aea <cmd_sweep+0xea>
  chprintf(chp, "usage: sweep {start(Hz)} [stop(Hz)]\r\n");
 8009a82:	4921      	ldr	r1, [pc, #132]	; (8009b08 <cmd_sweep+0x108>)
 8009a84:	0020      	movs	r0, r4
 8009a86:	f7fd fd43 	bl	8007510 <chprintf>
  chprintf(chp, "\tsweep {start|stop|center|span|cw} {freq(Hz)}\r\n");
 8009a8a:	4920      	ldr	r1, [pc, #128]	; (8009b0c <cmd_sweep+0x10c>)
 8009a8c:	0020      	movs	r0, r4
 8009a8e:	f7fd fd3f 	bl	8007510 <chprintf>
 8009a92:	e7ed      	b.n	8009a70 <cmd_sweep+0x70>
    chprintf(chp, "%d %d %d\r\n", frequency0, frequency1, sweep_points);
 8009a94:	491e      	ldr	r1, [pc, #120]	; (8009b10 <cmd_sweep+0x110>)
 8009a96:	688b      	ldr	r3, [r1, #8]
 8009a98:	684a      	ldr	r2, [r1, #4]
 8009a9a:	200c      	movs	r0, #12
 8009a9c:	5e09      	ldrsh	r1, [r1, r0]
 8009a9e:	0020      	movs	r0, r4
 8009aa0:	9100      	str	r1, [sp, #0]
 8009aa2:	491c      	ldr	r1, [pc, #112]	; (8009b14 <cmd_sweep+0x114>)
 8009aa4:	f7fd fd34 	bl	8007510 <chprintf>
    return;
 8009aa8:	e7e2      	b.n	8009a70 <cmd_sweep+0x70>
      int32_t value = atoi(argv[1]);
 8009aaa:	6868      	ldr	r0, [r5, #4]
 8009aac:	f009 fb00 	bl	80130b0 <atoi>
 8009ab0:	0001      	movs	r1, r0
      set_sweep_frequency(ST_START, value);
 8009ab2:	2000      	movs	r0, #0
 8009ab4:	f7ff fecc 	bl	8009850 <set_sweep_frequency>
      return;
 8009ab8:	e7da      	b.n	8009a70 <cmd_sweep+0x70>
      int32_t value = atoi(argv[1]);
 8009aba:	6868      	ldr	r0, [r5, #4]
 8009abc:	f009 faf8 	bl	80130b0 <atoi>
 8009ac0:	0001      	movs	r1, r0
      set_sweep_frequency(ST_CENTER, value);
 8009ac2:	2002      	movs	r0, #2
 8009ac4:	f7ff fec4 	bl	8009850 <set_sweep_frequency>
      return;
 8009ac8:	e7d2      	b.n	8009a70 <cmd_sweep+0x70>
      int32_t value = atoi(argv[1]);
 8009aca:	6868      	ldr	r0, [r5, #4]
 8009acc:	f009 faf0 	bl	80130b0 <atoi>
 8009ad0:	0001      	movs	r1, r0
      set_sweep_frequency(ST_SPAN, value);
 8009ad2:	2003      	movs	r0, #3
 8009ad4:	f7ff febc 	bl	8009850 <set_sweep_frequency>
      return;
 8009ad8:	e7ca      	b.n	8009a70 <cmd_sweep+0x70>
      int32_t value = atoi(argv[1]);
 8009ada:	6868      	ldr	r0, [r5, #4]
 8009adc:	f009 fae8 	bl	80130b0 <atoi>
 8009ae0:	0001      	movs	r1, r0
      set_sweep_frequency(ST_CW, value);
 8009ae2:	2004      	movs	r0, #4
 8009ae4:	f7ff feb4 	bl	8009850 <set_sweep_frequency>
      return;
 8009ae8:	e7c2      	b.n	8009a70 <cmd_sweep+0x70>
    set_sweep_frequency(ST_START, value);
 8009aea:	0001      	movs	r1, r0
 8009aec:	2000      	movs	r0, #0
 8009aee:	f7ff feaf 	bl	8009850 <set_sweep_frequency>
  if (argc >= 2) {
 8009af2:	e7bd      	b.n	8009a70 <cmd_sweep+0x70>
 8009af4:	080141b0 	.word	0x080141b0
 8009af8:	080141b8 	.word	0x080141b8
 8009afc:	080141c0 	.word	0x080141c0
 8009b00:	080141c8 	.word	0x080141c8
 8009b04:	080141d0 	.word	0x080141d0
 8009b08:	080141d4 	.word	0x080141d4
 8009b0c:	080141fc 	.word	0x080141fc
 8009b10:	20000454 	.word	0x20000454
 8009b14:	08013fc0 	.word	0x08013fc0
	...

08009b20 <get_sweep_frequency>:
  if (frequency1 >= 0) {
 8009b20:	4a16      	ldr	r2, [pc, #88]	; (8009b7c <get_sweep_frequency+0x5c>)
 8009b22:	6893      	ldr	r3, [r2, #8]
 8009b24:	2b00      	cmp	r3, #0
 8009b26:	db07      	blt.n	8009b38 <get_sweep_frequency+0x18>
    switch (type) {
 8009b28:	2804      	cmp	r0, #4
 8009b2a:	d824      	bhi.n	8009b76 <get_sweep_frequency+0x56>
 8009b2c:	4914      	ldr	r1, [pc, #80]	; (8009b80 <get_sweep_frequency+0x60>)
 8009b2e:	0080      	lsls	r0, r0, #2
 8009b30:	5809      	ldr	r1, [r1, r0]
 8009b32:	468f      	mov	pc, r1
    case ST_START: return frequency0;
 8009b34:	6850      	ldr	r0, [r2, #4]
}
 8009b36:	4770      	bx	lr
    switch (type) {
 8009b38:	2804      	cmp	r0, #4
 8009b3a:	d81c      	bhi.n	8009b76 <get_sweep_frequency+0x56>
 8009b3c:	4911      	ldr	r1, [pc, #68]	; (8009b84 <get_sweep_frequency+0x64>)
 8009b3e:	0080      	lsls	r0, r0, #2
 8009b40:	5809      	ldr	r1, [r1, r0]
 8009b42:	468f      	mov	pc, r1
    case ST_CW: return (frequency0 + frequency1)/2;
 8009b44:	6850      	ldr	r0, [r2, #4]
 8009b46:	1818      	adds	r0, r3, r0
 8009b48:	0fc3      	lsrs	r3, r0, #31
 8009b4a:	1818      	adds	r0, r3, r0
 8009b4c:	1040      	asrs	r0, r0, #1
 8009b4e:	e7f2      	b.n	8009b36 <get_sweep_frequency+0x16>
    case ST_SPAN: return frequency1 - frequency0;
 8009b50:	6850      	ldr	r0, [r2, #4]
 8009b52:	1a18      	subs	r0, r3, r0
 8009b54:	e7ef      	b.n	8009b36 <get_sweep_frequency+0x16>
    case ST_STOP: return frequency1;
 8009b56:	0018      	movs	r0, r3
 8009b58:	e7ed      	b.n	8009b36 <get_sweep_frequency+0x16>
    case ST_STOP: return frequency0 - frequency1/2;
 8009b5a:	0fd8      	lsrs	r0, r3, #31
 8009b5c:	18c3      	adds	r3, r0, r3
 8009b5e:	6850      	ldr	r0, [r2, #4]
 8009b60:	105b      	asrs	r3, r3, #1
 8009b62:	1ac0      	subs	r0, r0, r3
 8009b64:	e7e7      	b.n	8009b36 <get_sweep_frequency+0x16>
    case ST_START: return frequency0 + frequency1/2;
 8009b66:	0fd8      	lsrs	r0, r3, #31
 8009b68:	18c0      	adds	r0, r0, r3
 8009b6a:	6853      	ldr	r3, [r2, #4]
 8009b6c:	1040      	asrs	r0, r0, #1
 8009b6e:	18c0      	adds	r0, r0, r3
 8009b70:	e7e1      	b.n	8009b36 <get_sweep_frequency+0x16>
    case ST_SPAN: return -frequency1;
 8009b72:	4258      	negs	r0, r3
 8009b74:	e7df      	b.n	8009b36 <get_sweep_frequency+0x16>
  return 0;
 8009b76:	2000      	movs	r0, #0
 8009b78:	e7dd      	b.n	8009b36 <get_sweep_frequency+0x16>
 8009b7a:	46c0      	nop			; (mov r8, r8)
 8009b7c:	20000454 	.word	0x20000454
 8009b80:	08013e44 	.word	0x08013e44
 8009b84:	08013e58 	.word	0x08013e58
	...

08009b90 <cal_collect>:
{
 8009b90:	b570      	push	{r4, r5, r6, lr}
  chMtxLock(&mutex_sweep);
 8009b92:	4d2b      	ldr	r5, [pc, #172]	; (8009c40 <cal_collect+0xb0>)
{
 8009b94:	0004      	movs	r4, r0
  chMtxLock(&mutex_sweep);
 8009b96:	0028      	movs	r0, r5
 8009b98:	f7fa fa92 	bl	80040c0 <chMtxLock>
  if (active_props == &current_props)
 8009b9c:	4a29      	ldr	r2, [pc, #164]	; (8009c44 <cal_collect+0xb4>)
 8009b9e:	4b2a      	ldr	r3, [pc, #168]	; (8009c48 <cal_collect+0xb8>)
 8009ba0:	6811      	ldr	r1, [r2, #0]
 8009ba2:	4299      	cmp	r1, r3
 8009ba4:	d002      	beq.n	8009bac <cal_collect+0x1c>
  cal_status = 0;
 8009ba6:	2100      	movs	r1, #0
  active_props = &current_props;
 8009ba8:	6013      	str	r3, [r2, #0]
  cal_status = 0;
 8009baa:	81d9      	strh	r1, [r3, #14]
  switch (type) {
 8009bac:	2c04      	cmp	r4, #4
 8009bae:	d810      	bhi.n	8009bd2 <cal_collect+0x42>
 8009bb0:	4926      	ldr	r1, [pc, #152]	; (8009c4c <cal_collect+0xbc>)
 8009bb2:	00a4      	lsls	r4, r4, #2
 8009bb4:	5909      	ldr	r1, [r1, r4]
 8009bb6:	468f      	mov	pc, r1
    cal_status |= CALSTAT_THRU;
 8009bb8:	2008      	movs	r0, #8
 8009bba:	89d9      	ldrh	r1, [r3, #14]
 8009bbc:	4301      	orrs	r1, r0
 8009bbe:	81d9      	strh	r1, [r3, #14]
    memcpy(cal_data[CAL_THRU], measured[1], sizeof measured[0]);
 8009bc0:	6810      	ldr	r0, [r2, #0]
 8009bc2:	4b23      	ldr	r3, [pc, #140]	; (8009c50 <cal_collect+0xc0>)
    memcpy(cal_data[CAL_ISOLN], measured[1], sizeof measured[0]);
 8009bc4:	469c      	mov	ip, r3
 8009bc6:	22ca      	movs	r2, #202	; 0xca
 8009bc8:	4460      	add	r0, ip
 8009bca:	0092      	lsls	r2, r2, #2
 8009bcc:	4921      	ldr	r1, [pc, #132]	; (8009c54 <cal_collect+0xc4>)
 8009bce:	f009 fa7f 	bl	80130d0 <memcpy>
  redraw_request |= REDRAW_CAL_STATUS;
 8009bd2:	2104      	movs	r1, #4
 8009bd4:	4a20      	ldr	r2, [pc, #128]	; (8009c58 <cal_collect+0xc8>)
  chMtxUnlock(&mutex_sweep);
 8009bd6:	0028      	movs	r0, r5
  redraw_request |= REDRAW_CAL_STATUS;
 8009bd8:	8813      	ldrh	r3, [r2, #0]
 8009bda:	430b      	orrs	r3, r1
 8009bdc:	8013      	strh	r3, [r2, #0]
  chMtxUnlock(&mutex_sweep);
 8009bde:	f7fa fa77 	bl	80040d0 <chMtxUnlock>
}
 8009be2:	bd70      	pop	{r4, r5, r6, pc}
    cal_status |= CALSTAT_ISOLN;
 8009be4:	2010      	movs	r0, #16
 8009be6:	89d9      	ldrh	r1, [r3, #14]
 8009be8:	4301      	orrs	r1, r0
 8009bea:	81d9      	strh	r1, [r3, #14]
    memcpy(cal_data[CAL_ISOLN], measured[1], sizeof measured[0]);
 8009bec:	6810      	ldr	r0, [r2, #0]
 8009bee:	4b1b      	ldr	r3, [pc, #108]	; (8009c5c <cal_collect+0xcc>)
 8009bf0:	e7e8      	b.n	8009bc4 <cal_collect+0x34>
    cal_status |= CALSTAT_LOAD;
 8009bf2:	2001      	movs	r0, #1
 8009bf4:	89d9      	ldrh	r1, [r3, #14]
 8009bf6:	4301      	orrs	r1, r0
    memcpy(cal_data[CAL_LOAD], measured[0], sizeof measured[0]);
 8009bf8:	6810      	ldr	r0, [r2, #0]
 8009bfa:	22ca      	movs	r2, #202	; 0xca
 8009bfc:	30a5      	adds	r0, #165	; 0xa5
    cal_status |= CALSTAT_LOAD;
 8009bfe:	81d9      	strh	r1, [r3, #14]
    memcpy(cal_data[CAL_LOAD], measured[0], sizeof measured[0]);
 8009c00:	0092      	lsls	r2, r2, #2
 8009c02:	4917      	ldr	r1, [pc, #92]	; (8009c60 <cal_collect+0xd0>)
 8009c04:	30ff      	adds	r0, #255	; 0xff
 8009c06:	f009 fa63 	bl	80130d0 <memcpy>
    break;
 8009c0a:	e7e2      	b.n	8009bd2 <cal_collect+0x42>
    cal_status &= ~(CALSTAT_ES|CALSTAT_APPLY);
 8009c0c:	89d9      	ldrh	r1, [r3, #14]
 8009c0e:	4815      	ldr	r0, [pc, #84]	; (8009c64 <cal_collect+0xd4>)
 8009c10:	4001      	ands	r1, r0
 8009c12:	2002      	movs	r0, #2
 8009c14:	4301      	orrs	r1, r0
 8009c16:	81d9      	strh	r1, [r3, #14]
    memcpy(cal_data[CAL_OPEN], measured[0], sizeof measured[0]);
 8009c18:	6810      	ldr	r0, [r2, #0]
 8009c1a:	4b13      	ldr	r3, [pc, #76]	; (8009c68 <cal_collect+0xd8>)
    memcpy(cal_data[CAL_SHORT], measured[0], sizeof measured[0]);
 8009c1c:	469c      	mov	ip, r3
 8009c1e:	22ca      	movs	r2, #202	; 0xca
 8009c20:	4460      	add	r0, ip
 8009c22:	0092      	lsls	r2, r2, #2
 8009c24:	490e      	ldr	r1, [pc, #56]	; (8009c60 <cal_collect+0xd0>)
 8009c26:	f009 fa53 	bl	80130d0 <memcpy>
    break;
 8009c2a:	e7d2      	b.n	8009bd2 <cal_collect+0x42>
    cal_status &= ~(CALSTAT_ER|CALSTAT_APPLY);
 8009c2c:	89d9      	ldrh	r1, [r3, #14]
 8009c2e:	480f      	ldr	r0, [pc, #60]	; (8009c6c <cal_collect+0xdc>)
 8009c30:	4001      	ands	r1, r0
 8009c32:	2004      	movs	r0, #4
 8009c34:	4301      	orrs	r1, r0
 8009c36:	81d9      	strh	r1, [r3, #14]
    memcpy(cal_data[CAL_SHORT], measured[0], sizeof measured[0]);
 8009c38:	6810      	ldr	r0, [r2, #0]
 8009c3a:	4b0d      	ldr	r3, [pc, #52]	; (8009c70 <cal_collect+0xe0>)
 8009c3c:	e7ee      	b.n	8009c1c <cal_collect+0x8c>
 8009c3e:	46c0      	nop			; (mov r8, r8)
 8009c40:	20002220 	.word	0x20002220
 8009c44:	20000428 	.word	0x20000428
 8009c48:	20000454 	.word	0x20000454
 8009c4c:	08013e6c 	.word	0x08013e6c
 8009c50:	00000b1c 	.word	0x00000b1c
 8009c54:	20001ee4 	.word	0x20001ee4
 8009c58:	20002236 	.word	0x20002236
 8009c5c:	00000e44 	.word	0x00000e44
 8009c60:	20001bbc 	.word	0x20001bbc
 8009c64:	fffffedf 	.word	0xfffffedf
 8009c68:	000004cc 	.word	0x000004cc
 8009c6c:	fffffebf 	.word	0xfffffebf
 8009c70:	000007f4 	.word	0x000007f4
	...

08009c80 <cal_done>:
{
 8009c80:	b5f0      	push	{r4, r5, r6, r7, lr}
 8009c82:	46de      	mov	lr, fp
 8009c84:	464e      	mov	r6, r9
 8009c86:	4657      	mov	r7, sl
 8009c88:	4645      	mov	r5, r8
 8009c8a:	b5e0      	push	{r5, r6, r7, lr}
  chMtxLock(&mutex_sweep);
 8009c8c:	48a0      	ldr	r0, [pc, #640]	; (8009f10 <cal_done+0x290>)
{
 8009c8e:	b089      	sub	sp, #36	; 0x24
  chMtxLock(&mutex_sweep);
 8009c90:	f7fa fa16 	bl	80040c0 <chMtxLock>
  if (active_props == &current_props)
 8009c94:	4b9f      	ldr	r3, [pc, #636]	; (8009f14 <cal_done+0x294>)
 8009c96:	4aa0      	ldr	r2, [pc, #640]	; (8009f18 <cal_done+0x298>)
 8009c98:	4699      	mov	r9, r3
 8009c9a:	681b      	ldr	r3, [r3, #0]
 8009c9c:	4293      	cmp	r3, r2
 8009c9e:	d100      	bne.n	8009ca2 <cal_done+0x22>
 8009ca0:	e083      	b.n	8009daa <cal_done+0x12a>
  active_props = &current_props;
 8009ca2:	464b      	mov	r3, r9
 8009ca4:	601a      	str	r2, [r3, #0]
  cal_status = 0;
 8009ca6:	2300      	movs	r3, #0
 8009ca8:	81d3      	strh	r3, [r2, #14]
  for (i = 0; i < sweep_points; i++) {
 8009caa:	0013      	movs	r3, r2
 8009cac:	240c      	movs	r4, #12
 8009cae:	5f1c      	ldrsh	r4, [r3, r4]
  if (!(cal_status & CALSTAT_LOAD))
 8009cb0:	2300      	movs	r3, #0
  for (i = 0; i < sweep_points; i++) {
 8009cb2:	2600      	movs	r6, #0
  if (!(cal_status & CALSTAT_LOAD))
 8009cb4:	9306      	str	r3, [sp, #24]
  for (i = 0; i < sweep_points; i++) {
 8009cb6:	2c00      	cmp	r4, #0
 8009cb8:	dc00      	bgt.n	8009cbc <cal_done+0x3c>
 8009cba:	e21b      	b.n	800a0f4 <cal_done+0x474>
    cal_data[term][i][0] = re;
 8009cbc:	464b      	mov	r3, r9
 8009cbe:	681d      	ldr	r5, [r3, #0]
  for (i = 0; i < sweep_points; i++) {
 8009cc0:	2200      	movs	r2, #0
 8009cc2:	0028      	movs	r0, r5
 8009cc4:	30a5      	adds	r0, #165	; 0xa5
 8009cc6:	30ff      	adds	r0, #255	; 0xff
 8009cc8:	0003      	movs	r3, r0
    cal_data[term][i][0] = re;
 8009cca:	2100      	movs	r1, #0
  for (i = 0; i < sweep_points; i++) {
 8009ccc:	3201      	adds	r2, #1
    cal_data[term][i][0] = re;
 8009cce:	6019      	str	r1, [r3, #0]
    cal_data[term][i][1] = im;
 8009cd0:	6059      	str	r1, [r3, #4]
 8009cd2:	3308      	adds	r3, #8
  for (i = 0; i < sweep_points; i++) {
 8009cd4:	42a2      	cmp	r2, r4
 8009cd6:	dbf9      	blt.n	8009ccc <cal_done+0x4c>
  if ((cal_status & CALSTAT_SHORT) && (cal_status & CALSTAT_OPEN)) {
 8009cd8:	2e06      	cmp	r6, #6
 8009cda:	d100      	bne.n	8009cde <cal_done+0x5e>
 8009cdc:	e12f      	b.n	8009f3e <cal_done+0x2be>
  } else if (cal_status & CALSTAT_OPEN) {
 8009cde:	9b06      	ldr	r3, [sp, #24]
 8009ce0:	079b      	lsls	r3, r3, #30
 8009ce2:	d500      	bpl.n	8009ce6 <cal_done+0x66>
 8009ce4:	e1f6      	b.n	800a0d4 <cal_done+0x454>
  } else if (cal_status & CALSTAT_SHORT) {
 8009ce6:	9b06      	ldr	r3, [sp, #24]
 8009ce8:	075b      	lsls	r3, r3, #29
 8009cea:	d400      	bmi.n	8009cee <cal_done+0x6e>
 8009cec:	e0ea      	b.n	8009ec4 <cal_done+0x244>
  for (i = 0; i < sweep_points; i++) {
 8009cee:	2c00      	cmp	r4, #0
 8009cf0:	dd0c      	ble.n	8009d0c <cal_done+0x8c>
 8009cf2:	4a8a      	ldr	r2, [pc, #552]	; (8009f1c <cal_done+0x29c>)
 8009cf4:	464b      	mov	r3, r9
 8009cf6:	4694      	mov	ip, r2
    cal_data[term][i][0] = re;
 8009cf8:	2200      	movs	r2, #0
 8009cfa:	681b      	ldr	r3, [r3, #0]
 8009cfc:	00e4      	lsls	r4, r4, #3
 8009cfe:	4463      	add	r3, ip
 8009d00:	191c      	adds	r4, r3, r4
 8009d02:	601a      	str	r2, [r3, #0]
    cal_data[term][i][1] = im;
 8009d04:	605a      	str	r2, [r3, #4]
 8009d06:	3308      	adds	r3, #8
  for (i = 0; i < sweep_points; i++) {
 8009d08:	429c      	cmp	r4, r3
 8009d0a:	d1fa      	bne.n	8009d02 <cal_done+0x82>
    cal_status &= ~CALSTAT_SHORT;
 8009d0c:	2304      	movs	r3, #4
 8009d0e:	9a06      	ldr	r2, [sp, #24]
 8009d10:	439a      	bics	r2, r3
 8009d12:	0013      	movs	r3, r2
    eterm_calc_er(-1);
 8009d14:	2001      	movs	r0, #1
 8009d16:	2608      	movs	r6, #8
    cal_status &= ~CALSTAT_SHORT;
 8009d18:	4a7f      	ldr	r2, [pc, #508]	; (8009f18 <cal_done+0x298>)
    eterm_calc_er(-1);
 8009d1a:	4240      	negs	r0, r0
    cal_status &= ~CALSTAT_SHORT;
 8009d1c:	81d3      	strh	r3, [r2, #14]
    eterm_calc_er(-1);
 8009d1e:	f7fd ff67 	bl	8007bf0 <eterm_calc_er>
 8009d22:	4b7d      	ldr	r3, [pc, #500]	; (8009f18 <cal_done+0x298>)
 8009d24:	240c      	movs	r4, #12
 8009d26:	5f1c      	ldrsh	r4, [r3, r4]
  if (!(cal_status & CALSTAT_ISOLN))
 8009d28:	4b7b      	ldr	r3, [pc, #492]	; (8009f18 <cal_done+0x298>)
 8009d2a:	89db      	ldrh	r3, [r3, #14]
 8009d2c:	469a      	mov	sl, r3
 8009d2e:	401e      	ands	r6, r3
 8009d30:	06db      	lsls	r3, r3, #27
 8009d32:	d500      	bpl.n	8009d36 <cal_done+0xb6>
 8009d34:	e071      	b.n	8009e1a <cal_done+0x19a>
  for (i = 0; i < sweep_points; i++) {
 8009d36:	2c00      	cmp	r4, #0
 8009d38:	dc00      	bgt.n	8009d3c <cal_done+0xbc>
 8009d3a:	e1d7      	b.n	800a0ec <cal_done+0x46c>
 8009d3c:	464b      	mov	r3, r9
 8009d3e:	681d      	ldr	r5, [r3, #0]
 8009d40:	4b77      	ldr	r3, [pc, #476]	; (8009f20 <cal_done+0x2a0>)
  for (i = 0; i < sweep_points; i++) {
 8009d42:	2200      	movs	r2, #0
 8009d44:	18ef      	adds	r7, r5, r3
 8009d46:	003b      	movs	r3, r7
    cal_data[term][i][0] = re;
 8009d48:	2100      	movs	r1, #0
  for (i = 0; i < sweep_points; i++) {
 8009d4a:	3201      	adds	r2, #1
    cal_data[term][i][0] = re;
 8009d4c:	6019      	str	r1, [r3, #0]
    cal_data[term][i][1] = im;
 8009d4e:	6059      	str	r1, [r3, #4]
 8009d50:	3308      	adds	r3, #8
  for (i = 0; i < sweep_points; i++) {
 8009d52:	42a2      	cmp	r2, r4
 8009d54:	dbf9      	blt.n	8009d4a <cal_done+0xca>
  if (cal_status & CALSTAT_THRU) {
 8009d56:	2e00      	cmp	r6, #0
 8009d58:	d000      	beq.n	8009d5c <cal_done+0xdc>
 8009d5a:	e06d      	b.n	8009e38 <cal_done+0x1b8>
 8009d5c:	00e0      	lsls	r0, r4, #3
 8009d5e:	4b6e      	ldr	r3, [pc, #440]	; (8009f18 <cal_done+0x298>)
 8009d60:	89db      	ldrh	r3, [r3, #14]
 8009d62:	469a      	mov	sl, r3
 8009d64:	4a6f      	ldr	r2, [pc, #444]	; (8009f24 <cal_done+0x2a4>)
    cal_data[term][i][0] = re;
 8009d66:	464b      	mov	r3, r9
 8009d68:	4694      	mov	ip, r2
 8009d6a:	21fe      	movs	r1, #254	; 0xfe
    cal_data[term][i][1] = im;
 8009d6c:	2200      	movs	r2, #0
    cal_data[term][i][0] = re;
 8009d6e:	681b      	ldr	r3, [r3, #0]
 8009d70:	0589      	lsls	r1, r1, #22
 8009d72:	4463      	add	r3, ip
 8009d74:	1818      	adds	r0, r3, r0
 8009d76:	6019      	str	r1, [r3, #0]
    cal_data[term][i][1] = im;
 8009d78:	605a      	str	r2, [r3, #4]
 8009d7a:	3308      	adds	r3, #8
  for (i = 0; i < sweep_points; i++) {
 8009d7c:	4298      	cmp	r0, r3
 8009d7e:	d1fa      	bne.n	8009d76 <cal_done+0xf6>
  cal_status |= CALSTAT_APPLY;
 8009d80:	2380      	movs	r3, #128	; 0x80
 8009d82:	4652      	mov	r2, sl
  redraw_request |= REDRAW_CAL_STATUS;
 8009d84:	2104      	movs	r1, #4
  cal_status |= CALSTAT_APPLY;
 8009d86:	005b      	lsls	r3, r3, #1
 8009d88:	4313      	orrs	r3, r2
 8009d8a:	4a63      	ldr	r2, [pc, #396]	; (8009f18 <cal_done+0x298>)
  chMtxUnlock(&mutex_sweep);
 8009d8c:	4860      	ldr	r0, [pc, #384]	; (8009f10 <cal_done+0x290>)
  cal_status |= CALSTAT_APPLY;
 8009d8e:	81d3      	strh	r3, [r2, #14]
  redraw_request |= REDRAW_CAL_STATUS;
 8009d90:	4a65      	ldr	r2, [pc, #404]	; (8009f28 <cal_done+0x2a8>)
 8009d92:	8813      	ldrh	r3, [r2, #0]
 8009d94:	430b      	orrs	r3, r1
 8009d96:	8013      	strh	r3, [r2, #0]
  chMtxUnlock(&mutex_sweep);
 8009d98:	f7fa f99a 	bl	80040d0 <chMtxUnlock>
}
 8009d9c:	b009      	add	sp, #36	; 0x24
 8009d9e:	bc3c      	pop	{r2, r3, r4, r5}
 8009da0:	4690      	mov	r8, r2
 8009da2:	4699      	mov	r9, r3
 8009da4:	46a2      	mov	sl, r4
 8009da6:	46ab      	mov	fp, r5
 8009da8:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if (!(cal_status & CALSTAT_LOAD))
 8009daa:	2606      	movs	r6, #6
 8009dac:	4b5a      	ldr	r3, [pc, #360]	; (8009f18 <cal_done+0x298>)
 8009dae:	4a5a      	ldr	r2, [pc, #360]	; (8009f18 <cal_done+0x298>)
 8009db0:	89db      	ldrh	r3, [r3, #14]
 8009db2:	9306      	str	r3, [sp, #24]
 8009db4:	401e      	ands	r6, r3
 8009db6:	240c      	movs	r4, #12
 8009db8:	5f14      	ldrsh	r4, [r2, r4]
 8009dba:	07db      	lsls	r3, r3, #31
 8009dbc:	d574      	bpl.n	8009ea8 <cal_done+0x228>
  if ((cal_status & CALSTAT_SHORT) && (cal_status & CALSTAT_OPEN)) {
 8009dbe:	2e06      	cmp	r6, #6
 8009dc0:	d100      	bne.n	8009dc4 <cal_done+0x144>
 8009dc2:	e0b5      	b.n	8009f30 <cal_done+0x2b0>
  } else if (cal_status & CALSTAT_OPEN) {
 8009dc4:	9b06      	ldr	r3, [sp, #24]
 8009dc6:	079b      	lsls	r3, r3, #30
 8009dc8:	d400      	bmi.n	8009dcc <cal_done+0x14c>
 8009dca:	e78c      	b.n	8009ce6 <cal_done+0x66>
  memcpy(cal_data[dst], cal_data[src], sizeof cal_data[dst]);
 8009dcc:	4a57      	ldr	r2, [pc, #348]	; (8009f2c <cal_done+0x2ac>)
 8009dce:	4b52      	ldr	r3, [pc, #328]	; (8009f18 <cal_done+0x298>)
 8009dd0:	4694      	mov	ip, r2
 8009dd2:	4a52      	ldr	r2, [pc, #328]	; (8009f1c <cal_done+0x29c>)
 8009dd4:	4463      	add	r3, ip
 8009dd6:	4694      	mov	ip, r2
 8009dd8:	0018      	movs	r0, r3
 8009dda:	4b4f      	ldr	r3, [pc, #316]	; (8009f18 <cal_done+0x298>)
 8009ddc:	3aa5      	subs	r2, #165	; 0xa5
 8009dde:	4463      	add	r3, ip
 8009de0:	3aff      	subs	r2, #255	; 0xff
 8009de2:	0019      	movs	r1, r3
 8009de4:	001d      	movs	r5, r3
 8009de6:	f009 f973 	bl	80130d0 <memcpy>
  for (i = 0; i < sweep_points; i++) {
 8009dea:	2c00      	cmp	r4, #0
 8009dec:	dd07      	ble.n	8009dfe <cal_done+0x17e>
    cal_data[term][i][0] = re;
 8009dee:	2300      	movs	r3, #0
 8009df0:	00e4      	lsls	r4, r4, #3
 8009df2:	192c      	adds	r4, r5, r4
 8009df4:	602b      	str	r3, [r5, #0]
    cal_data[term][i][1] = im;
 8009df6:	606b      	str	r3, [r5, #4]
 8009df8:	3508      	adds	r5, #8
  for (i = 0; i < sweep_points; i++) {
 8009dfa:	42ac      	cmp	r4, r5
 8009dfc:	d1fa      	bne.n	8009df4 <cal_done+0x174>
    eterm_calc_er(1);
 8009dfe:	2608      	movs	r6, #8
 8009e00:	2001      	movs	r0, #1
 8009e02:	f7fd fef5 	bl	8007bf0 <eterm_calc_er>
 8009e06:	4b44      	ldr	r3, [pc, #272]	; (8009f18 <cal_done+0x298>)
 8009e08:	240c      	movs	r4, #12
 8009e0a:	5f1c      	ldrsh	r4, [r3, r4]
  if (!(cal_status & CALSTAT_ISOLN))
 8009e0c:	4b42      	ldr	r3, [pc, #264]	; (8009f18 <cal_done+0x298>)
 8009e0e:	89db      	ldrh	r3, [r3, #14]
 8009e10:	469a      	mov	sl, r3
 8009e12:	401e      	ands	r6, r3
 8009e14:	06db      	lsls	r3, r3, #27
 8009e16:	d400      	bmi.n	8009e1a <cal_done+0x19a>
 8009e18:	e78d      	b.n	8009d36 <cal_done+0xb6>
  if (cal_status & CALSTAT_THRU) {
 8009e1a:	2e00      	cmp	r6, #0
 8009e1c:	d106      	bne.n	8009e2c <cal_done+0x1ac>
 8009e1e:	4b3e      	ldr	r3, [pc, #248]	; (8009f18 <cal_done+0x298>)
 8009e20:	00e0      	lsls	r0, r4, #3
 8009e22:	89db      	ldrh	r3, [r3, #14]
 8009e24:	469a      	mov	sl, r3
  for (i = 0; i < sweep_points; i++) {
 8009e26:	2c00      	cmp	r4, #0
 8009e28:	dc9c      	bgt.n	8009d64 <cal_done+0xe4>
 8009e2a:	e7a9      	b.n	8009d80 <cal_done+0x100>
  for (i = 0; i < sweep_points; i++) {
 8009e2c:	2c00      	cmp	r4, #0
 8009e2e:	dd34      	ble.n	8009e9a <cal_done+0x21a>
 8009e30:	464b      	mov	r3, r9
 8009e32:	681d      	ldr	r5, [r3, #0]
 8009e34:	4b3a      	ldr	r3, [pc, #232]	; (8009f20 <cal_done+0x2a0>)
 8009e36:	18ef      	adds	r7, r5, r3
 8009e38:	4b3a      	ldr	r3, [pc, #232]	; (8009f24 <cal_done+0x2a4>)
 8009e3a:	469c      	mov	ip, r3
  for (i = 0; i < sweep_points; i++) {
 8009e3c:	2300      	movs	r3, #0
 8009e3e:	4699      	mov	r9, r3
 8009e40:	0023      	movs	r3, r4
 8009e42:	464c      	mov	r4, r9
 8009e44:	4699      	mov	r9, r3
 8009e46:	4465      	add	r5, ip
    float etr = cal_data[CAL_THRU][i][0] - cal_data[CAL_ISOLN][i][0];
 8009e48:	6839      	ldr	r1, [r7, #0]
 8009e4a:	6828      	ldr	r0, [r5, #0]
 8009e4c:	f7f7 f9e8 	bl	8001220 <__aeabi_fsub>
    float eti = cal_data[CAL_THRU][i][1] - cal_data[CAL_ISOLN][i][1];
 8009e50:	6879      	ldr	r1, [r7, #4]
    float etr = cal_data[CAL_THRU][i][0] - cal_data[CAL_ISOLN][i][0];
 8009e52:	4683      	mov	fp, r0
    float eti = cal_data[CAL_THRU][i][1] - cal_data[CAL_ISOLN][i][1];
 8009e54:	6868      	ldr	r0, [r5, #4]
 8009e56:	f7f7 f9e3 	bl	8001220 <__aeabi_fsub>
    float sq = etr*etr + eti*eti;
 8009e5a:	4659      	mov	r1, fp
    float eti = cal_data[CAL_THRU][i][1] - cal_data[CAL_ISOLN][i][1];
 8009e5c:	1c06      	adds	r6, r0, #0
    float sq = etr*etr + eti*eti;
 8009e5e:	4658      	mov	r0, fp
 8009e60:	f7f7 f8c6 	bl	8000ff0 <__aeabi_fmul>
 8009e64:	1c31      	adds	r1, r6, #0
 8009e66:	4680      	mov	r8, r0
 8009e68:	1c30      	adds	r0, r6, #0
 8009e6a:	f7f7 f8c1 	bl	8000ff0 <__aeabi_fmul>
 8009e6e:	1c01      	adds	r1, r0, #0
 8009e70:	4640      	mov	r0, r8
 8009e72:	f7f6 fd5d 	bl	8000930 <__aeabi_fadd>
    float invr = etr / sq;
 8009e76:	1c01      	adds	r1, r0, #0
    float sq = etr*etr + eti*eti;
 8009e78:	4680      	mov	r8, r0
    float invr = etr / sq;
 8009e7a:	4658      	mov	r0, fp
 8009e7c:	f7f6 fed8 	bl	8000c30 <__aeabi_fdiv>
    float invi = -eti / sq;
 8009e80:	2380      	movs	r3, #128	; 0x80
 8009e82:	061b      	lsls	r3, r3, #24
    cal_data[ETERM_ET][i][0] = invr;
 8009e84:	6028      	str	r0, [r5, #0]
    float invi = -eti / sq;
 8009e86:	4641      	mov	r1, r8
 8009e88:	18f0      	adds	r0, r6, r3
 8009e8a:	f7f6 fed1 	bl	8000c30 <__aeabi_fdiv>
  for (i = 0; i < sweep_points; i++) {
 8009e8e:	3401      	adds	r4, #1
    cal_data[ETERM_ET][i][1] = invi;
 8009e90:	6068      	str	r0, [r5, #4]
 8009e92:	3708      	adds	r7, #8
 8009e94:	3508      	adds	r5, #8
  for (i = 0; i < sweep_points; i++) {
 8009e96:	454c      	cmp	r4, r9
 8009e98:	dbd6      	blt.n	8009e48 <cal_done+0x1c8>
  cal_status &= ~CALSTAT_THRU;
 8009e9a:	2308      	movs	r3, #8
 8009e9c:	4652      	mov	r2, sl
 8009e9e:	439a      	bics	r2, r3
  cal_status |= CALSTAT_ET;
 8009ea0:	2380      	movs	r3, #128	; 0x80
 8009ea2:	431a      	orrs	r2, r3
 8009ea4:	4692      	mov	sl, r2
 8009ea6:	e76b      	b.n	8009d80 <cal_done+0x100>
  for (i = 0; i < sweep_points; i++) {
 8009ea8:	2c00      	cmp	r4, #0
 8009eaa:	dd00      	ble.n	8009eae <cal_done+0x22e>
 8009eac:	e706      	b.n	8009cbc <cal_done+0x3c>
  if ((cal_status & CALSTAT_SHORT) && (cal_status & CALSTAT_OPEN)) {
 8009eae:	2e06      	cmp	r6, #6
 8009eb0:	d100      	bne.n	8009eb4 <cal_done+0x234>
 8009eb2:	e108      	b.n	800a0c6 <cal_done+0x446>
  } else if (cal_status & CALSTAT_OPEN) {
 8009eb4:	9b06      	ldr	r3, [sp, #24]
 8009eb6:	079b      	lsls	r3, r3, #30
 8009eb8:	d500      	bpl.n	8009ebc <cal_done+0x23c>
 8009eba:	e126      	b.n	800a10a <cal_done+0x48a>
  } else if (cal_status & CALSTAT_SHORT) {
 8009ebc:	9b06      	ldr	r3, [sp, #24]
 8009ebe:	075b      	lsls	r3, r3, #29
 8009ec0:	d500      	bpl.n	8009ec4 <cal_done+0x244>
 8009ec2:	e723      	b.n	8009d0c <cal_done+0x8c>
  for (i = 0; i < sweep_points; i++) {
 8009ec4:	2c00      	cmp	r4, #0
 8009ec6:	dc00      	bgt.n	8009eca <cal_done+0x24a>
 8009ec8:	e114      	b.n	800a0f4 <cal_done+0x474>
    cal_data[term][i][0] = re;
 8009eca:	464b      	mov	r3, r9
 8009ecc:	21fe      	movs	r1, #254	; 0xfe
    cal_data[term][i][1] = im;
 8009ece:	2200      	movs	r2, #0
    cal_data[term][i][0] = re;
 8009ed0:	681d      	ldr	r5, [r3, #0]
 8009ed2:	4b16      	ldr	r3, [pc, #88]	; (8009f2c <cal_done+0x2ac>)
 8009ed4:	00e0      	lsls	r0, r4, #3
 8009ed6:	18eb      	adds	r3, r5, r3
 8009ed8:	181e      	adds	r6, r3, r0
 8009eda:	0589      	lsls	r1, r1, #22
 8009edc:	6019      	str	r1, [r3, #0]
    cal_data[term][i][1] = im;
 8009ede:	605a      	str	r2, [r3, #4]
 8009ee0:	3308      	adds	r3, #8
  for (i = 0; i < sweep_points; i++) {
 8009ee2:	429e      	cmp	r6, r3
 8009ee4:	d1fa      	bne.n	8009edc <cal_done+0x25c>
    cal_data[term][i][0] = re;
 8009ee6:	2200      	movs	r2, #0
 8009ee8:	4b0c      	ldr	r3, [pc, #48]	; (8009f1c <cal_done+0x29c>)
 8009eea:	18eb      	adds	r3, r5, r3
 8009eec:	1819      	adds	r1, r3, r0
 8009eee:	601a      	str	r2, [r3, #0]
    cal_data[term][i][1] = im;
 8009ef0:	605a      	str	r2, [r3, #4]
 8009ef2:	3308      	adds	r3, #8
  for (i = 0; i < sweep_points; i++) {
 8009ef4:	4299      	cmp	r1, r3
 8009ef6:	d1fa      	bne.n	8009eee <cal_done+0x26e>
  if (!(cal_status & CALSTAT_ISOLN))
 8009ef8:	2608      	movs	r6, #8
 8009efa:	4b07      	ldr	r3, [pc, #28]	; (8009f18 <cal_done+0x298>)
 8009efc:	89db      	ldrh	r3, [r3, #14]
 8009efe:	469a      	mov	sl, r3
 8009f00:	401e      	ands	r6, r3
 8009f02:	06db      	lsls	r3, r3, #27
 8009f04:	d400      	bmi.n	8009f08 <cal_done+0x288>
 8009f06:	e71b      	b.n	8009d40 <cal_done+0xc0>
  if (cal_status & CALSTAT_THRU) {
 8009f08:	2e00      	cmp	r6, #0
 8009f0a:	d100      	bne.n	8009f0e <cal_done+0x28e>
 8009f0c:	e727      	b.n	8009d5e <cal_done+0xde>
 8009f0e:	e78f      	b.n	8009e30 <cal_done+0x1b0>
 8009f10:	20002220 	.word	0x20002220
 8009f14:	20000428 	.word	0x20000428
 8009f18:	20000454 	.word	0x20000454
 8009f1c:	000004cc 	.word	0x000004cc
 8009f20:	00000e44 	.word	0x00000e44
 8009f24:	00000b1c 	.word	0x00000b1c
 8009f28:	20002236 	.word	0x20002236
 8009f2c:	000007f4 	.word	0x000007f4
  for (i = 0; i < sweep_points; i++) {
 8009f30:	2c00      	cmp	r4, #0
 8009f32:	dc00      	bgt.n	8009f36 <cal_done+0x2b6>
 8009f34:	e0c7      	b.n	800a0c6 <cal_done+0x446>
 8009f36:	4d7c      	ldr	r5, [pc, #496]	; (800a128 <cal_done+0x4a8>)
 8009f38:	0028      	movs	r0, r5
 8009f3a:	30a5      	adds	r0, #165	; 0xa5
 8009f3c:	30ff      	adds	r0, #255	; 0xff
 8009f3e:	4b7b      	ldr	r3, [pc, #492]	; (800a12c <cal_done+0x4ac>)
 8009f40:	4680      	mov	r8, r0
 8009f42:	9305      	str	r3, [sp, #20]
 8009f44:	4b7a      	ldr	r3, [pc, #488]	; (800a130 <cal_done+0x4b0>)
 8009f46:	9407      	str	r4, [sp, #28]
 8009f48:	469a      	mov	sl, r3
 8009f4a:	4b7a      	ldr	r3, [pc, #488]	; (800a134 <cal_done+0x4b4>)
 8009f4c:	44aa      	add	sl, r5
 8009f4e:	469b      	mov	fp, r3
 8009f50:	2300      	movs	r3, #0
 8009f52:	9304      	str	r3, [sp, #16]
 8009f54:	4653      	mov	r3, sl
 8009f56:	44ab      	add	fp, r5
 8009f58:	46da      	mov	sl, fp
 8009f5a:	469b      	mov	fp, r3
    float z = 6.2832 * frequencies[i] * c * z0;
 8009f5c:	9b05      	ldr	r3, [sp, #20]
 8009f5e:	cb01      	ldmia	r3!, {r0}
 8009f60:	9305      	str	r3, [sp, #20]
 8009f62:	f7f9 fa05 	bl	8003370 <__aeabi_ui2d>
 8009f66:	4a74      	ldr	r2, [pc, #464]	; (800a138 <cal_done+0x4b8>)
 8009f68:	4b74      	ldr	r3, [pc, #464]	; (800a13c <cal_done+0x4bc>)
 8009f6a:	f7f8 fb49 	bl	8002600 <__aeabi_dmul>
 8009f6e:	22c0      	movs	r2, #192	; 0xc0
 8009f70:	4b73      	ldr	r3, [pc, #460]	; (800a140 <cal_done+0x4c0>)
 8009f72:	05d2      	lsls	r2, r2, #23
 8009f74:	f7f8 fb44 	bl	8002600 <__aeabi_dmul>
 8009f78:	2200      	movs	r2, #0
 8009f7a:	4b72      	ldr	r3, [pc, #456]	; (800a144 <cal_done+0x4c4>)
 8009f7c:	f7f8 fb40 	bl	8002600 <__aeabi_dmul>
 8009f80:	f7f9 fa86 	bl	8003490 <__aeabi_d2f>
    float sq = 1 + z*z;
 8009f84:	1c01      	adds	r1, r0, #0
    float z = 6.2832 * frequencies[i] * c * z0;
 8009f86:	1c04      	adds	r4, r0, #0
    float sq = 1 + z*z;
 8009f88:	f7f7 f832 	bl	8000ff0 <__aeabi_fmul>
 8009f8c:	21fe      	movs	r1, #254	; 0xfe
 8009f8e:	0589      	lsls	r1, r1, #22
 8009f90:	1c06      	adds	r6, r0, #0
 8009f92:	f7f6 fccd 	bl	8000930 <__aeabi_fadd>
 8009f96:	1c05      	adds	r5, r0, #0
    float s11aor = (1 - z*z) / sq;
 8009f98:	20fe      	movs	r0, #254	; 0xfe
 8009f9a:	1c31      	adds	r1, r6, #0
 8009f9c:	0580      	lsls	r0, r0, #22
 8009f9e:	f7f7 f93f 	bl	8001220 <__aeabi_fsub>
 8009fa2:	1c29      	adds	r1, r5, #0
 8009fa4:	f7f6 fe44 	bl	8000c30 <__aeabi_fdiv>
    float s11aoi = 2*z / sq;
 8009fa8:	1c21      	adds	r1, r4, #0
    float s11aor = (1 - z*z) / sq;
 8009faa:	9001      	str	r0, [sp, #4]
    float s11aoi = 2*z / sq;
 8009fac:	1c20      	adds	r0, r4, #0
 8009fae:	f7f6 fcbf 	bl	8000930 <__aeabi_fadd>
 8009fb2:	1c29      	adds	r1, r5, #0
 8009fb4:	f7f6 fe3c 	bl	8000c30 <__aeabi_fdiv>
    float s11or = cal_data[CAL_OPEN][i][0] - cal_data[ETERM_ED][i][0];
 8009fb8:	4643      	mov	r3, r8
 8009fba:	681f      	ldr	r7, [r3, #0]
 8009fbc:	465b      	mov	r3, fp
 8009fbe:	1c39      	adds	r1, r7, #0
    float s11aoi = 2*z / sq;
 8009fc0:	9002      	str	r0, [sp, #8]
    float s11or = cal_data[CAL_OPEN][i][0] - cal_data[ETERM_ED][i][0];
 8009fc2:	6818      	ldr	r0, [r3, #0]
 8009fc4:	f7f7 f92c 	bl	8001220 <__aeabi_fsub>
    float s11oi = cal_data[CAL_OPEN][i][1] - cal_data[ETERM_ED][i][1];
 8009fc8:	4643      	mov	r3, r8
 8009fca:	685e      	ldr	r6, [r3, #4]
 8009fcc:	465b      	mov	r3, fp
    float s11or = cal_data[CAL_OPEN][i][0] - cal_data[ETERM_ED][i][0];
 8009fce:	1c05      	adds	r5, r0, #0
    float s11oi = cal_data[CAL_OPEN][i][1] - cal_data[ETERM_ED][i][1];
 8009fd0:	1c31      	adds	r1, r6, #0
 8009fd2:	6858      	ldr	r0, [r3, #4]
 8009fd4:	f7f7 f924 	bl	8001220 <__aeabi_fsub>
    float s11sr = cal_data[CAL_SHORT][i][0] - cal_data[ETERM_ED][i][0];
 8009fd8:	4653      	mov	r3, sl
    float s11oi = cal_data[CAL_OPEN][i][1] - cal_data[ETERM_ED][i][1];
 8009fda:	1c04      	adds	r4, r0, #0
    float s11sr = cal_data[CAL_SHORT][i][0] - cal_data[ETERM_ED][i][0];
 8009fdc:	1c39      	adds	r1, r7, #0
 8009fde:	6818      	ldr	r0, [r3, #0]
 8009fe0:	f7f7 f91e 	bl	8001220 <__aeabi_fsub>
    float s11si = cal_data[CAL_SHORT][i][1] - cal_data[ETERM_ED][i][1];
 8009fe4:	4653      	mov	r3, sl
    float s11sr = cal_data[CAL_SHORT][i][0] - cal_data[ETERM_ED][i][0];
 8009fe6:	1c07      	adds	r7, r0, #0
    float s11si = cal_data[CAL_SHORT][i][1] - cal_data[ETERM_ED][i][1];
 8009fe8:	1c31      	adds	r1, r6, #0
 8009fea:	6858      	ldr	r0, [r3, #4]
 8009fec:	f7f7 f918 	bl	8001220 <__aeabi_fsub>
    float numr = s11sr + s11or * s11aor - s11oi * s11aoi;
 8009ff0:	1c29      	adds	r1, r5, #0
    float s11si = cal_data[CAL_SHORT][i][1] - cal_data[ETERM_ED][i][1];
 8009ff2:	1c06      	adds	r6, r0, #0
    float numr = s11sr + s11or * s11aor - s11oi * s11aoi;
 8009ff4:	9801      	ldr	r0, [sp, #4]
 8009ff6:	f7f6 fffb 	bl	8000ff0 <__aeabi_fmul>
 8009ffa:	1c39      	adds	r1, r7, #0
 8009ffc:	f7f6 fc98 	bl	8000930 <__aeabi_fadd>
 800a000:	1c21      	adds	r1, r4, #0
 800a002:	9003      	str	r0, [sp, #12]
 800a004:	9802      	ldr	r0, [sp, #8]
 800a006:	f7f6 fff3 	bl	8000ff0 <__aeabi_fmul>
 800a00a:	1c01      	adds	r1, r0, #0
 800a00c:	9803      	ldr	r0, [sp, #12]
 800a00e:	f7f7 f907 	bl	8001220 <__aeabi_fsub>
    float numi = s11si + s11oi * s11aor + s11or * s11aoi;
 800a012:	1c21      	adds	r1, r4, #0
    float numr = s11sr + s11or * s11aor - s11oi * s11aoi;
 800a014:	9003      	str	r0, [sp, #12]
    float numi = s11si + s11oi * s11aor + s11or * s11aoi;
 800a016:	9801      	ldr	r0, [sp, #4]
 800a018:	f7f6 ffea 	bl	8000ff0 <__aeabi_fmul>
 800a01c:	1c31      	adds	r1, r6, #0
 800a01e:	f7f6 fc87 	bl	8000930 <__aeabi_fadd>
 800a022:	1c29      	adds	r1, r5, #0
 800a024:	9001      	str	r0, [sp, #4]
 800a026:	9802      	ldr	r0, [sp, #8]
 800a028:	f7f6 ffe2 	bl	8000ff0 <__aeabi_fmul>
 800a02c:	1c01      	adds	r1, r0, #0
 800a02e:	9801      	ldr	r0, [sp, #4]
 800a030:	f7f6 fc7e 	bl	8000930 <__aeabi_fadd>
    float denomr = s11or - s11sr;
 800a034:	1c39      	adds	r1, r7, #0
    float numi = s11si + s11oi * s11aor + s11or * s11aoi;
 800a036:	9001      	str	r0, [sp, #4]
    float denomr = s11or - s11sr;
 800a038:	1c28      	adds	r0, r5, #0
 800a03a:	f7f7 f8f1 	bl	8001220 <__aeabi_fsub>
    float denomi = s11oi - s11si;
 800a03e:	1c31      	adds	r1, r6, #0
    float denomr = s11or - s11sr;
 800a040:	1c05      	adds	r5, r0, #0
    float denomi = s11oi - s11si;
 800a042:	1c20      	adds	r0, r4, #0
 800a044:	f7f7 f8ec 	bl	8001220 <__aeabi_fsub>
    sq = denomr*denomr+denomi*denomi;
 800a048:	1c29      	adds	r1, r5, #0
    float denomi = s11oi - s11si;
 800a04a:	1c04      	adds	r4, r0, #0
    sq = denomr*denomr+denomi*denomi;
 800a04c:	1c28      	adds	r0, r5, #0
 800a04e:	f7f6 ffcf 	bl	8000ff0 <__aeabi_fmul>
 800a052:	1c21      	adds	r1, r4, #0
 800a054:	1c06      	adds	r6, r0, #0
 800a056:	1c20      	adds	r0, r4, #0
 800a058:	f7f6 ffca 	bl	8000ff0 <__aeabi_fmul>
 800a05c:	1c01      	adds	r1, r0, #0
 800a05e:	1c30      	adds	r0, r6, #0
 800a060:	f7f6 fc66 	bl	8000930 <__aeabi_fadd>
    cal_data[ETERM_ES][i][0] = (numr*denomr + numi*denomi)/sq;
 800a064:	1c29      	adds	r1, r5, #0
    sq = denomr*denomr+denomi*denomi;
 800a066:	1c06      	adds	r6, r0, #0
    cal_data[ETERM_ES][i][0] = (numr*denomr + numi*denomi)/sq;
 800a068:	9803      	ldr	r0, [sp, #12]
 800a06a:	f7f6 ffc1 	bl	8000ff0 <__aeabi_fmul>
 800a06e:	1c21      	adds	r1, r4, #0
 800a070:	1c07      	adds	r7, r0, #0
 800a072:	9801      	ldr	r0, [sp, #4]
 800a074:	f7f6 ffbc 	bl	8000ff0 <__aeabi_fmul>
 800a078:	1c01      	adds	r1, r0, #0
 800a07a:	1c38      	adds	r0, r7, #0
 800a07c:	f7f6 fc58 	bl	8000930 <__aeabi_fadd>
 800a080:	1c31      	adds	r1, r6, #0
 800a082:	f7f6 fdd5 	bl	8000c30 <__aeabi_fdiv>
 800a086:	465b      	mov	r3, fp
    cal_data[ETERM_ES][i][1] = (numi*denomr - numr*denomi)/sq;
 800a088:	1c29      	adds	r1, r5, #0
    cal_data[ETERM_ES][i][0] = (numr*denomr + numi*denomi)/sq;
 800a08a:	6018      	str	r0, [r3, #0]
    cal_data[ETERM_ES][i][1] = (numi*denomr - numr*denomi)/sq;
 800a08c:	9801      	ldr	r0, [sp, #4]
 800a08e:	f7f6 ffaf 	bl	8000ff0 <__aeabi_fmul>
 800a092:	1c21      	adds	r1, r4, #0
 800a094:	1c05      	adds	r5, r0, #0
 800a096:	9803      	ldr	r0, [sp, #12]
 800a098:	f7f6 ffaa 	bl	8000ff0 <__aeabi_fmul>
 800a09c:	1c01      	adds	r1, r0, #0
 800a09e:	1c28      	adds	r0, r5, #0
 800a0a0:	f7f7 f8be 	bl	8001220 <__aeabi_fsub>
 800a0a4:	1c31      	adds	r1, r6, #0
 800a0a6:	f7f6 fdc3 	bl	8000c30 <__aeabi_fdiv>
 800a0aa:	2208      	movs	r2, #8
 800a0ac:	465b      	mov	r3, fp
 800a0ae:	4694      	mov	ip, r2
 800a0b0:	6058      	str	r0, [r3, #4]
  for (i = 0; i < sweep_points; i++) {
 800a0b2:	9b04      	ldr	r3, [sp, #16]
 800a0b4:	9a07      	ldr	r2, [sp, #28]
 800a0b6:	3301      	adds	r3, #1
 800a0b8:	9304      	str	r3, [sp, #16]
 800a0ba:	44e0      	add	r8, ip
 800a0bc:	44e3      	add	fp, ip
 800a0be:	44e2      	add	sl, ip
 800a0c0:	4293      	cmp	r3, r2
 800a0c2:	da00      	bge.n	800a0c6 <cal_done+0x446>
 800a0c4:	e74a      	b.n	8009f5c <cal_done+0x2dc>
  cal_status &= ~CALSTAT_OPEN;
 800a0c6:	2302      	movs	r3, #2
 800a0c8:	9a06      	ldr	r2, [sp, #24]
 800a0ca:	439a      	bics	r2, r3
 800a0cc:	0013      	movs	r3, r2
  cal_status |= CALSTAT_ES;
 800a0ce:	2220      	movs	r2, #32
 800a0d0:	4313      	orrs	r3, r2
 800a0d2:	e61f      	b.n	8009d14 <cal_done+0x94>
  memcpy(cal_data[dst], cal_data[src], sizeof cal_data[dst]);
 800a0d4:	464b      	mov	r3, r9
 800a0d6:	22ca      	movs	r2, #202	; 0xca
 800a0d8:	6819      	ldr	r1, [r3, #0]
 800a0da:	4b16      	ldr	r3, [pc, #88]	; (800a134 <cal_done+0x4b4>)
 800a0dc:	0092      	lsls	r2, r2, #2
 800a0de:	18c8      	adds	r0, r1, r3
 800a0e0:	4b13      	ldr	r3, [pc, #76]	; (800a130 <cal_done+0x4b0>)
 800a0e2:	18cd      	adds	r5, r1, r3
 800a0e4:	0029      	movs	r1, r5
 800a0e6:	f008 fff3 	bl	80130d0 <memcpy>
 800a0ea:	e680      	b.n	8009dee <cal_done+0x16e>
  if (cal_status & CALSTAT_THRU) {
 800a0ec:	2e00      	cmp	r6, #0
 800a0ee:	d100      	bne.n	800a0f2 <cal_done+0x472>
 800a0f0:	e646      	b.n	8009d80 <cal_done+0x100>
 800a0f2:	e6d2      	b.n	8009e9a <cal_done+0x21a>
  if (!(cal_status & CALSTAT_ISOLN))
 800a0f4:	2608      	movs	r6, #8
 800a0f6:	4b0c      	ldr	r3, [pc, #48]	; (800a128 <cal_done+0x4a8>)
 800a0f8:	89db      	ldrh	r3, [r3, #14]
 800a0fa:	469a      	mov	sl, r3
 800a0fc:	401e      	ands	r6, r3
 800a0fe:	06db      	lsls	r3, r3, #27
 800a100:	d5f4      	bpl.n	800a0ec <cal_done+0x46c>
  if (cal_status & CALSTAT_THRU) {
 800a102:	2e00      	cmp	r6, #0
 800a104:	d100      	bne.n	800a108 <cal_done+0x488>
 800a106:	e68a      	b.n	8009e1e <cal_done+0x19e>
 800a108:	e6c7      	b.n	8009e9a <cal_done+0x21a>
  memcpy(cal_data[dst], cal_data[src], sizeof cal_data[dst]);
 800a10a:	4a0a      	ldr	r2, [pc, #40]	; (800a134 <cal_done+0x4b4>)
 800a10c:	4b06      	ldr	r3, [pc, #24]	; (800a128 <cal_done+0x4a8>)
 800a10e:	4694      	mov	ip, r2
 800a110:	4a07      	ldr	r2, [pc, #28]	; (800a130 <cal_done+0x4b0>)
 800a112:	4463      	add	r3, ip
 800a114:	4694      	mov	ip, r2
 800a116:	0018      	movs	r0, r3
 800a118:	4b03      	ldr	r3, [pc, #12]	; (800a128 <cal_done+0x4a8>)
 800a11a:	3aa5      	subs	r2, #165	; 0xa5
 800a11c:	4463      	add	r3, ip
 800a11e:	0019      	movs	r1, r3
 800a120:	3aff      	subs	r2, #255	; 0xff
 800a122:	f008 ffd5 	bl	80130d0 <memcpy>
 800a126:	e66a      	b.n	8009dfe <cal_done+0x17e>
 800a128:	20000454 	.word	0x20000454
 800a12c:	20000464 	.word	0x20000464
 800a130:	000004cc 	.word	0x000004cc
 800a134:	000007f4 	.word	0x000007f4
 800a138:	2e48e8a7 	.word	0x2e48e8a7
 800a13c:	401921ff 	.word	0x401921ff
 800a140:	3d2c25c2 	.word	0x3d2c25c2
 800a144:	40490000 	.word	0x40490000
	...

0800a150 <cmd_cal>:
{
 800a150:	b5f0      	push	{r4, r5, r6, r7, lr}
 800a152:	4647      	mov	r7, r8
 800a154:	46ce      	mov	lr, r9
 800a156:	b580      	push	{r7, lr}
 800a158:	b08d      	sub	sp, #52	; 0x34
  const char *items[] = { "load", "open", "short", "thru", "isoln", "Es", "Er", "Et", "cal'ed" };
 800a15a:	ad03      	add	r5, sp, #12
{
 800a15c:	4690      	mov	r8, r2
  const char *items[] = { "load", "open", "short", "thru", "isoln", "Es", "Er", "Et", "cal'ed" };
 800a15e:	002a      	movs	r2, r5
 800a160:	4ba1      	ldr	r3, [pc, #644]	; (800a3e8 <cmd_cal+0x298>)
{
 800a162:	0006      	movs	r6, r0
 800a164:	000c      	movs	r4, r1
  const char *items[] = { "load", "open", "short", "thru", "isoln", "Es", "Er", "Et", "cal'ed" };
 800a166:	cb83      	ldmia	r3!, {r0, r1, r7}
 800a168:	c283      	stmia	r2!, {r0, r1, r7}
 800a16a:	cb83      	ldmia	r3!, {r0, r1, r7}
 800a16c:	c283      	stmia	r2!, {r0, r1, r7}
 800a16e:	cb83      	ldmia	r3!, {r0, r1, r7}
 800a170:	c283      	stmia	r2!, {r0, r1, r7}
  if (argc == 0) {
 800a172:	2c00      	cmp	r4, #0
 800a174:	d04f      	beq.n	800a216 <cmd_cal+0xc6>
  char *cmd = argv[0];
 800a176:	4643      	mov	r3, r8
 800a178:	681d      	ldr	r5, [r3, #0]
  if (strcmp(cmd, "load") == 0) {
 800a17a:	499c      	ldr	r1, [pc, #624]	; (800a3ec <cmd_cal+0x29c>)
 800a17c:	0028      	movs	r0, r5
 800a17e:	f7f9 fb27 	bl	80037d0 <strcmp>
 800a182:	2800      	cmp	r0, #0
 800a184:	d040      	beq.n	800a208 <cmd_cal+0xb8>
  } else if (strcmp(cmd, "open") == 0) {
 800a186:	499a      	ldr	r1, [pc, #616]	; (800a3f0 <cmd_cal+0x2a0>)
 800a188:	0028      	movs	r0, r5
 800a18a:	f7f9 fb21 	bl	80037d0 <strcmp>
 800a18e:	2800      	cmp	r0, #0
 800a190:	d039      	beq.n	800a206 <cmd_cal+0xb6>
  } else if (strcmp(cmd, "short") == 0) {
 800a192:	4998      	ldr	r1, [pc, #608]	; (800a3f4 <cmd_cal+0x2a4>)
 800a194:	0028      	movs	r0, r5
 800a196:	f7f9 fb1b 	bl	80037d0 <strcmp>
 800a19a:	2800      	cmp	r0, #0
 800a19c:	d057      	beq.n	800a24e <cmd_cal+0xfe>
  } else if (strcmp(cmd, "thru") == 0) {
 800a19e:	4996      	ldr	r1, [pc, #600]	; (800a3f8 <cmd_cal+0x2a8>)
 800a1a0:	0028      	movs	r0, r5
 800a1a2:	f7f9 fb15 	bl	80037d0 <strcmp>
 800a1a6:	2800      	cmp	r0, #0
 800a1a8:	d055      	beq.n	800a256 <cmd_cal+0x106>
  } else if (strcmp(cmd, "isoln") == 0) {
 800a1aa:	4994      	ldr	r1, [pc, #592]	; (800a3fc <cmd_cal+0x2ac>)
 800a1ac:	0028      	movs	r0, r5
 800a1ae:	f7f9 fb0f 	bl	80037d0 <strcmp>
 800a1b2:	2800      	cmp	r0, #0
 800a1b4:	d100      	bne.n	800a1b8 <cmd_cal+0x68>
 800a1b6:	e068      	b.n	800a28a <cmd_cal+0x13a>
  } else if (strcmp(cmd, "done") == 0) {
 800a1b8:	4991      	ldr	r1, [pc, #580]	; (800a400 <cmd_cal+0x2b0>)
 800a1ba:	0028      	movs	r0, r5
 800a1bc:	f7f9 fb08 	bl	80037d0 <strcmp>
 800a1c0:	2800      	cmp	r0, #0
 800a1c2:	d066      	beq.n	800a292 <cmd_cal+0x142>
  } else if (strcmp(cmd, "on") == 0) {
 800a1c4:	498f      	ldr	r1, [pc, #572]	; (800a404 <cmd_cal+0x2b4>)
 800a1c6:	0028      	movs	r0, r5
 800a1c8:	f7f9 fb02 	bl	80037d0 <strcmp>
 800a1cc:	2800      	cmp	r0, #0
 800a1ce:	d046      	beq.n	800a25e <cmd_cal+0x10e>
  } else if (strcmp(cmd, "off") == 0) {
 800a1d0:	498d      	ldr	r1, [pc, #564]	; (800a408 <cmd_cal+0x2b8>)
 800a1d2:	0028      	movs	r0, r5
 800a1d4:	f7f9 fafc 	bl	80037d0 <strcmp>
 800a1d8:	2800      	cmp	r0, #0
 800a1da:	d15d      	bne.n	800a298 <cmd_cal+0x148>
    if (!(cal_status & CALSTAT_APPLY)) 
 800a1dc:	4f8b      	ldr	r7, [pc, #556]	; (800a40c <cmd_cal+0x2bc>)
 800a1de:	89fb      	ldrh	r3, [r7, #14]
 800a1e0:	05db      	lsls	r3, r3, #23
 800a1e2:	d513      	bpl.n	800a20c <cmd_cal+0xbc>
    chMtxLock(&mutex_sweep);
 800a1e4:	4c8a      	ldr	r4, [pc, #552]	; (800a410 <cmd_cal+0x2c0>)
 800a1e6:	0020      	movs	r0, r4
 800a1e8:	f7f9 ff6a 	bl	80040c0 <chMtxLock>
    cal_status &= ~CALSTAT_APPLY;
 800a1ec:	89fb      	ldrh	r3, [r7, #14]
 800a1ee:	4a89      	ldr	r2, [pc, #548]	; (800a414 <cmd_cal+0x2c4>)
 800a1f0:	4013      	ands	r3, r2
 800a1f2:	81fb      	strh	r3, [r7, #14]
    redraw_request |= REDRAW_CAL_STATUS;
 800a1f4:	2104      	movs	r1, #4
 800a1f6:	4a88      	ldr	r2, [pc, #544]	; (800a418 <cmd_cal+0x2c8>)
    chMtxUnlock(&mutex_sweep);
 800a1f8:	0020      	movs	r0, r4
    redraw_request |= REDRAW_CAL_STATUS;
 800a1fa:	8813      	ldrh	r3, [r2, #0]
 800a1fc:	430b      	orrs	r3, r1
 800a1fe:	8013      	strh	r3, [r2, #0]
    chMtxUnlock(&mutex_sweep);
 800a200:	f7f9 ff66 	bl	80040d0 <chMtxUnlock>
    return;
 800a204:	e002      	b.n	800a20c <cmd_cal+0xbc>
    cal_collect(CAL_OPEN);
 800a206:	3001      	adds	r0, #1
 800a208:	f7ff fcc2 	bl	8009b90 <cal_collect>
}
 800a20c:	b00d      	add	sp, #52	; 0x34
 800a20e:	bc0c      	pop	{r2, r3}
 800a210:	4690      	mov	r8, r2
 800a212:	4699      	mov	r9, r3
 800a214:	bdf0      	pop	{r4, r5, r6, r7, pc}
      if (cal_status & (1<<i))
 800a216:	2301      	movs	r3, #1
 800a218:	4698      	mov	r8, r3
        chprintf(chp, "%s ", items[i]);
 800a21a:	4b80      	ldr	r3, [pc, #512]	; (800a41c <cmd_cal+0x2cc>)
 800a21c:	4f7b      	ldr	r7, [pc, #492]	; (800a40c <cmd_cal+0x2bc>)
 800a21e:	4699      	mov	r9, r3
 800a220:	e002      	b.n	800a228 <cmd_cal+0xd8>
    for (i = 0; i < 9; i++) {
 800a222:	3401      	adds	r4, #1
 800a224:	2c09      	cmp	r4, #9
 800a226:	d00d      	beq.n	800a244 <cmd_cal+0xf4>
      if (cal_status & (1<<i))
 800a228:	89fb      	ldrh	r3, [r7, #14]
 800a22a:	4642      	mov	r2, r8
 800a22c:	4123      	asrs	r3, r4
 800a22e:	421a      	tst	r2, r3
 800a230:	d0f7      	beq.n	800a222 <cmd_cal+0xd2>
        chprintf(chp, "%s ", items[i]);
 800a232:	00a3      	lsls	r3, r4, #2
 800a234:	58ea      	ldr	r2, [r5, r3]
 800a236:	4649      	mov	r1, r9
 800a238:	0030      	movs	r0, r6
    for (i = 0; i < 9; i++) {
 800a23a:	3401      	adds	r4, #1
        chprintf(chp, "%s ", items[i]);
 800a23c:	f7fd f968 	bl	8007510 <chprintf>
    for (i = 0; i < 9; i++) {
 800a240:	2c09      	cmp	r4, #9
 800a242:	d1f1      	bne.n	800a228 <cmd_cal+0xd8>
    chprintf(chp, "\r\n");
 800a244:	4976      	ldr	r1, [pc, #472]	; (800a420 <cmd_cal+0x2d0>)
 800a246:	0030      	movs	r0, r6
 800a248:	f7fd f962 	bl	8007510 <chprintf>
    return;
 800a24c:	e7de      	b.n	800a20c <cmd_cal+0xbc>
    cal_collect(CAL_SHORT);
 800a24e:	3002      	adds	r0, #2
 800a250:	f7ff fc9e 	bl	8009b90 <cal_collect>
 800a254:	e7da      	b.n	800a20c <cmd_cal+0xbc>
    cal_collect(CAL_THRU);
 800a256:	3003      	adds	r0, #3
 800a258:	f7ff fc9a 	bl	8009b90 <cal_collect>
 800a25c:	e7d6      	b.n	800a20c <cmd_cal+0xbc>
    if (cal_status & CALSTAT_APPLY) 
 800a25e:	2480      	movs	r4, #128	; 0x80
 800a260:	4d6a      	ldr	r5, [pc, #424]	; (800a40c <cmd_cal+0x2bc>)
 800a262:	0064      	lsls	r4, r4, #1
 800a264:	89eb      	ldrh	r3, [r5, #14]
 800a266:	4223      	tst	r3, r4
 800a268:	d1d0      	bne.n	800a20c <cmd_cal+0xbc>
    chMtxLock(&mutex_sweep);
 800a26a:	4e69      	ldr	r6, [pc, #420]	; (800a410 <cmd_cal+0x2c0>)
 800a26c:	0030      	movs	r0, r6
 800a26e:	f7f9 ff27 	bl	80040c0 <chMtxLock>
    redraw_request |= REDRAW_CAL_STATUS;
 800a272:	2104      	movs	r1, #4
    cal_status |= CALSTAT_APPLY;
 800a274:	89eb      	ldrh	r3, [r5, #14]
    redraw_request |= REDRAW_CAL_STATUS;
 800a276:	4a68      	ldr	r2, [pc, #416]	; (800a418 <cmd_cal+0x2c8>)
    cal_status |= CALSTAT_APPLY;
 800a278:	431c      	orrs	r4, r3
    redraw_request |= REDRAW_CAL_STATUS;
 800a27a:	8813      	ldrh	r3, [r2, #0]
    chMtxUnlock(&mutex_sweep);
 800a27c:	0030      	movs	r0, r6
    redraw_request |= REDRAW_CAL_STATUS;
 800a27e:	430b      	orrs	r3, r1
    cal_status |= CALSTAT_APPLY;
 800a280:	81ec      	strh	r4, [r5, #14]
    redraw_request |= REDRAW_CAL_STATUS;
 800a282:	8013      	strh	r3, [r2, #0]
    chMtxUnlock(&mutex_sweep);
 800a284:	f7f9 ff24 	bl	80040d0 <chMtxUnlock>
    return;
 800a288:	e7c0      	b.n	800a20c <cmd_cal+0xbc>
    cal_collect(CAL_ISOLN);
 800a28a:	3004      	adds	r0, #4
 800a28c:	f7ff fc80 	bl	8009b90 <cal_collect>
 800a290:	e7bc      	b.n	800a20c <cmd_cal+0xbc>
    cal_done();
 800a292:	f7ff fcf5 	bl	8009c80 <cal_done>
    return;
 800a296:	e7b9      	b.n	800a20c <cmd_cal+0xbc>
  } else if (strcmp(cmd, "reset") == 0) {
 800a298:	4962      	ldr	r1, [pc, #392]	; (800a424 <cmd_cal+0x2d4>)
 800a29a:	0028      	movs	r0, r5
 800a29c:	f7f9 fa98 	bl	80037d0 <strcmp>
 800a2a0:	2800      	cmp	r0, #0
 800a2a2:	d01e      	beq.n	800a2e2 <cmd_cal+0x192>
  } else if (strcmp(cmd, "data") == 0) {
 800a2a4:	4960      	ldr	r1, [pc, #384]	; (800a428 <cmd_cal+0x2d8>)
 800a2a6:	0028      	movs	r0, r5
 800a2a8:	f7f9 fa92 	bl	80037d0 <strcmp>
 800a2ac:	2800      	cmp	r0, #0
 800a2ae:	d020      	beq.n	800a2f2 <cmd_cal+0x1a2>
  } else if (strcmp(cmd, "in") == 0) {
 800a2b0:	495e      	ldr	r1, [pc, #376]	; (800a42c <cmd_cal+0x2dc>)
 800a2b2:	0028      	movs	r0, r5
 800a2b4:	f7f9 fa8c 	bl	80037d0 <strcmp>
 800a2b8:	2800      	cmp	r0, #0
 800a2ba:	d10d      	bne.n	800a2d8 <cmd_cal+0x188>
    if (argc > 1)
 800a2bc:	2c01      	cmp	r4, #1
 800a2be:	dd03      	ble.n	800a2c8 <cmd_cal+0x178>
      s = atoi(argv[1]);
 800a2c0:	4643      	mov	r3, r8
 800a2c2:	6858      	ldr	r0, [r3, #4]
 800a2c4:	f008 fef4 	bl	80130b0 <atoi>
    cal_interpolate(s);
 800a2c8:	f7fd fe0a 	bl	8007ee0 <cal_interpolate>
    redraw_request |= REDRAW_CAL_STATUS;
 800a2cc:	2104      	movs	r1, #4
 800a2ce:	4a52      	ldr	r2, [pc, #328]	; (800a418 <cmd_cal+0x2c8>)
 800a2d0:	8813      	ldrh	r3, [r2, #0]
 800a2d2:	430b      	orrs	r3, r1
 800a2d4:	8013      	strh	r3, [r2, #0]
    return;
 800a2d6:	e799      	b.n	800a20c <cmd_cal+0xbc>
    chprintf(chp, "usage: cal [load|open|short|thru|isoln|done|reset|on|off|in]\r\n");
 800a2d8:	4955      	ldr	r1, [pc, #340]	; (800a430 <cmd_cal+0x2e0>)
 800a2da:	0030      	movs	r0, r6
 800a2dc:	f7fd f918 	bl	8007510 <chprintf>
    return;
 800a2e0:	e794      	b.n	800a20c <cmd_cal+0xbc>
    chMtxLock(&mutex_sweep);
 800a2e2:	4c4b      	ldr	r4, [pc, #300]	; (800a410 <cmd_cal+0x2c0>)
 800a2e4:	0020      	movs	r0, r4
 800a2e6:	f7f9 feeb 	bl	80040c0 <chMtxLock>
    cal_status = 0;
 800a2ea:	2200      	movs	r2, #0
 800a2ec:	4b47      	ldr	r3, [pc, #284]	; (800a40c <cmd_cal+0x2bc>)
 800a2ee:	81da      	strh	r2, [r3, #14]
 800a2f0:	e780      	b.n	800a1f4 <cmd_cal+0xa4>
    chprintf(chp, "%f %f\r\n", cal_data[CAL_LOAD][0][0], cal_data[CAL_LOAD][0][1]);
 800a2f2:	4b50      	ldr	r3, [pc, #320]	; (800a434 <cmd_cal+0x2e4>)
 800a2f4:	4698      	mov	r8, r3
 800a2f6:	681b      	ldr	r3, [r3, #0]
 800a2f8:	4699      	mov	r9, r3
 800a2fa:	23d2      	movs	r3, #210	; 0xd2
 800a2fc:	464a      	mov	r2, r9
 800a2fe:	005b      	lsls	r3, r3, #1
 800a300:	58d0      	ldr	r0, [r2, r3]
 800a302:	f7f9 f86d 	bl	80033e0 <__aeabi_f2d>
 800a306:	23d4      	movs	r3, #212	; 0xd4
 800a308:	464a      	mov	r2, r9
 800a30a:	005b      	lsls	r3, r3, #1
 800a30c:	0004      	movs	r4, r0
 800a30e:	58d0      	ldr	r0, [r2, r3]
 800a310:	000d      	movs	r5, r1
 800a312:	f7f9 f865 	bl	80033e0 <__aeabi_f2d>
 800a316:	4f48      	ldr	r7, [pc, #288]	; (800a438 <cmd_cal+0x2e8>)
 800a318:	9000      	str	r0, [sp, #0]
 800a31a:	9101      	str	r1, [sp, #4]
 800a31c:	0022      	movs	r2, r4
 800a31e:	002b      	movs	r3, r5
 800a320:	0039      	movs	r1, r7
 800a322:	0030      	movs	r0, r6
 800a324:	f7fd f8f4 	bl	8007510 <chprintf>
    chprintf(chp, "%f %f\r\n", cal_data[CAL_OPEN][0][0], cal_data[CAL_OPEN][0][1]);
 800a328:	4643      	mov	r3, r8
 800a32a:	681b      	ldr	r3, [r3, #0]
 800a32c:	4699      	mov	r9, r3
 800a32e:	464a      	mov	r2, r9
 800a330:	4b42      	ldr	r3, [pc, #264]	; (800a43c <cmd_cal+0x2ec>)
 800a332:	58d0      	ldr	r0, [r2, r3]
 800a334:	f7f9 f854 	bl	80033e0 <__aeabi_f2d>
 800a338:	239a      	movs	r3, #154	; 0x9a
 800a33a:	464a      	mov	r2, r9
 800a33c:	00db      	lsls	r3, r3, #3
 800a33e:	0004      	movs	r4, r0
 800a340:	58d0      	ldr	r0, [r2, r3]
 800a342:	000d      	movs	r5, r1
 800a344:	f7f9 f84c 	bl	80033e0 <__aeabi_f2d>
 800a348:	0022      	movs	r2, r4
 800a34a:	9000      	str	r0, [sp, #0]
 800a34c:	9101      	str	r1, [sp, #4]
 800a34e:	002b      	movs	r3, r5
 800a350:	0039      	movs	r1, r7
 800a352:	0030      	movs	r0, r6
 800a354:	f7fd f8dc 	bl	8007510 <chprintf>
    chprintf(chp, "%f %f\r\n", cal_data[CAL_SHORT][0][0], cal_data[CAL_SHORT][0][1]);
 800a358:	4643      	mov	r3, r8
 800a35a:	681b      	ldr	r3, [r3, #0]
 800a35c:	4699      	mov	r9, r3
 800a35e:	464a      	mov	r2, r9
 800a360:	4b37      	ldr	r3, [pc, #220]	; (800a440 <cmd_cal+0x2f0>)
 800a362:	58d0      	ldr	r0, [r2, r3]
 800a364:	f7f9 f83c 	bl	80033e0 <__aeabi_f2d>
 800a368:	23ff      	movs	r3, #255	; 0xff
 800a36a:	464a      	mov	r2, r9
 800a36c:	00db      	lsls	r3, r3, #3
 800a36e:	0004      	movs	r4, r0
 800a370:	58d0      	ldr	r0, [r2, r3]
 800a372:	000d      	movs	r5, r1
 800a374:	f7f9 f834 	bl	80033e0 <__aeabi_f2d>
 800a378:	0022      	movs	r2, r4
 800a37a:	9000      	str	r0, [sp, #0]
 800a37c:	9101      	str	r1, [sp, #4]
 800a37e:	002b      	movs	r3, r5
 800a380:	0039      	movs	r1, r7
 800a382:	0030      	movs	r0, r6
 800a384:	f7fd f8c4 	bl	8007510 <chprintf>
    chprintf(chp, "%f %f\r\n", cal_data[CAL_THRU][0][0], cal_data[CAL_THRU][0][1]);
 800a388:	4643      	mov	r3, r8
 800a38a:	681b      	ldr	r3, [r3, #0]
 800a38c:	4699      	mov	r9, r3
 800a38e:	464a      	mov	r2, r9
 800a390:	4b2c      	ldr	r3, [pc, #176]	; (800a444 <cmd_cal+0x2f4>)
 800a392:	58d0      	ldr	r0, [r2, r3]
 800a394:	f7f9 f824 	bl	80033e0 <__aeabi_f2d>
 800a398:	23b2      	movs	r3, #178	; 0xb2
 800a39a:	464a      	mov	r2, r9
 800a39c:	011b      	lsls	r3, r3, #4
 800a39e:	0004      	movs	r4, r0
 800a3a0:	58d0      	ldr	r0, [r2, r3]
 800a3a2:	000d      	movs	r5, r1
 800a3a4:	f7f9 f81c 	bl	80033e0 <__aeabi_f2d>
 800a3a8:	0022      	movs	r2, r4
 800a3aa:	9000      	str	r0, [sp, #0]
 800a3ac:	9101      	str	r1, [sp, #4]
 800a3ae:	002b      	movs	r3, r5
 800a3b0:	0039      	movs	r1, r7
 800a3b2:	0030      	movs	r0, r6
 800a3b4:	f7fd f8ac 	bl	8007510 <chprintf>
    chprintf(chp, "%f %f\r\n", cal_data[CAL_ISOLN][0][0], cal_data[CAL_ISOLN][0][1]);
 800a3b8:	4643      	mov	r3, r8
 800a3ba:	681b      	ldr	r3, [r3, #0]
 800a3bc:	4698      	mov	r8, r3
 800a3be:	4642      	mov	r2, r8
 800a3c0:	4b21      	ldr	r3, [pc, #132]	; (800a448 <cmd_cal+0x2f8>)
 800a3c2:	58d0      	ldr	r0, [r2, r3]
 800a3c4:	f7f9 f80c 	bl	80033e0 <__aeabi_f2d>
 800a3c8:	4642      	mov	r2, r8
 800a3ca:	4b20      	ldr	r3, [pc, #128]	; (800a44c <cmd_cal+0x2fc>)
 800a3cc:	0004      	movs	r4, r0
 800a3ce:	58d0      	ldr	r0, [r2, r3]
 800a3d0:	000d      	movs	r5, r1
 800a3d2:	f7f9 f805 	bl	80033e0 <__aeabi_f2d>
 800a3d6:	0022      	movs	r2, r4
 800a3d8:	9000      	str	r0, [sp, #0]
 800a3da:	9101      	str	r1, [sp, #4]
 800a3dc:	002b      	movs	r3, r5
 800a3de:	0039      	movs	r1, r7
 800a3e0:	0030      	movs	r0, r6
 800a3e2:	f7fd f895 	bl	8007510 <chprintf>
    return;
 800a3e6:	e711      	b.n	800a20c <cmd_cal+0xbc>
 800a3e8:	080132a8 	.word	0x080132a8
 800a3ec:	080145b4 	.word	0x080145b4
 800a3f0:	080145bc 	.word	0x080145bc
 800a3f4:	080145c4 	.word	0x080145c4
 800a3f8:	080145cc 	.word	0x080145cc
 800a3fc:	080145d4 	.word	0x080145d4
 800a400:	08013e90 	.word	0x08013e90
 800a404:	080143c4 	.word	0x080143c4
 800a408:	080143c8 	.word	0x080143c8
 800a40c:	20000454 	.word	0x20000454
 800a410:	20002220 	.word	0x20002220
 800a414:	fffffeff 	.word	0xfffffeff
 800a418:	20002236 	.word	0x20002236
 800a41c:	08013a14 	.word	0x08013a14
 800a420:	08013f50 	.word	0x08013f50
 800a424:	08013e98 	.word	0x08013e98
 800a428:	08013ea0 	.word	0x08013ea0
 800a42c:	08013ea8 	.word	0x08013ea8
 800a430:	08013eac 	.word	0x08013eac
 800a434:	20000428 	.word	0x20000428
 800a438:	08013f6c 	.word	0x08013f6c
 800a43c:	000004cc 	.word	0x000004cc
 800a440:	000007f4 	.word	0x000007f4
 800a444:	00000b1c 	.word	0x00000b1c
 800a448:	00000e44 	.word	0x00000e44
 800a44c:	00000e48 	.word	0x00000e48

0800a450 <get_trace_typename>:
  return trace_info[trace[t].type].name;
 800a450:	0043      	lsls	r3, r0, #1
 800a452:	181b      	adds	r3, r3, r0
 800a454:	4806      	ldr	r0, [pc, #24]	; (800a470 <get_trace_typename+0x20>)
 800a456:	009b      	lsls	r3, r3, #2
 800a458:	18c0      	adds	r0, r0, r3
 800a45a:	4b06      	ldr	r3, [pc, #24]	; (800a474 <get_trace_typename+0x24>)
 800a45c:	469c      	mov	ip, r3
 800a45e:	4460      	add	r0, ip
 800a460:	7802      	ldrb	r2, [r0, #0]
 800a462:	0053      	lsls	r3, r2, #1
 800a464:	189b      	adds	r3, r3, r2
 800a466:	4a04      	ldr	r2, [pc, #16]	; (800a478 <get_trace_typename+0x28>)
 800a468:	009b      	lsls	r3, r3, #2
 800a46a:	5898      	ldr	r0, [r3, r2]
}
 800a46c:	4770      	bx	lr
 800a46e:	46c0      	nop			; (mov r8, r8)
 800a470:	20000454 	.word	0x20000454
 800a474:	00001171 	.word	0x00001171
 800a478:	08014738 	.word	0x08014738
 800a47c:	00000000 	.word	0x00000000

0800a480 <set_trace_type>:
{
 800a480:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  int polar = type == TRC_SMITH || type == TRC_POLAR;
 800a482:	2201      	movs	r2, #1
 800a484:	2300      	movs	r3, #0
 800a486:	1ecd      	subs	r5, r1, #3
  int enabled = type != TRC_OFF;
 800a488:	000c      	movs	r4, r1
  int polar = type == TRC_SMITH || type == TRC_POLAR;
 800a48a:	42aa      	cmp	r2, r5
 800a48c:	415b      	adcs	r3, r3
{
 800a48e:	46ce      	mov	lr, r9
 800a490:	4647      	mov	r7, r8
  int enabled = type != TRC_OFF;
 800a492:	3c0b      	subs	r4, #11
 800a494:	b2da      	uxtb	r2, r3
 800a496:	1e63      	subs	r3, r4, #1
 800a498:	419c      	sbcs	r4, r3
  if (trace[t].polar != polar) {
 800a49a:	4b2c      	ldr	r3, [pc, #176]	; (800a54c <set_trace_type+0xcc>)
 800a49c:	4e2c      	ldr	r6, [pc, #176]	; (800a550 <set_trace_type+0xd0>)
 800a49e:	4699      	mov	r9, r3
 800a4a0:	46b4      	mov	ip, r6
{
 800a4a2:	b580      	push	{r7, lr}
  if (trace[t].polar != polar) {
 800a4a4:	0047      	lsls	r7, r0, #1
 800a4a6:	183b      	adds	r3, r7, r0
 800a4a8:	009b      	lsls	r3, r3, #2
 800a4aa:	444b      	add	r3, r9
 800a4ac:	449c      	add	ip, r3
 800a4ae:	4666      	mov	r6, ip
 800a4b0:	7836      	ldrb	r6, [r6, #0]
 800a4b2:	b2e4      	uxtb	r4, r4
 800a4b4:	4296      	cmp	r6, r2
 800a4b6:	d02f      	beq.n	800a518 <set_trace_type+0x98>
    trace[t].polar = polar;
 800a4b8:	4665      	mov	r5, ip
 800a4ba:	702a      	strb	r2, [r5, #0]
  if (trace[t].enabled != enabled) {
 800a4bc:	4a25      	ldr	r2, [pc, #148]	; (800a554 <set_trace_type+0xd4>)
 800a4be:	189a      	adds	r2, r3, r2
 800a4c0:	7812      	ldrb	r2, [r2, #0]
 800a4c2:	42a2      	cmp	r2, r4
 800a4c4:	d01f      	beq.n	800a506 <set_trace_type+0x86>
    trace[t].enabled = enabled;
 800a4c6:	1838      	adds	r0, r7, r0
 800a4c8:	0080      	lsls	r0, r0, #2
 800a4ca:	4b22      	ldr	r3, [pc, #136]	; (800a554 <set_trace_type+0xd4>)
 800a4cc:	4448      	add	r0, r9
 800a4ce:	18c3      	adds	r3, r0, r3
 800a4d0:	701c      	strb	r4, [r3, #0]
  if (trace[t].type != type) {
 800a4d2:	4b21      	ldr	r3, [pc, #132]	; (800a558 <set_trace_type+0xd8>)
 800a4d4:	18c3      	adds	r3, r0, r3
 800a4d6:	781a      	ldrb	r2, [r3, #0]
 800a4d8:	4291      	cmp	r1, r2
 800a4da:	d00b      	beq.n	800a4f4 <set_trace_type+0x74>
    trace[t].type = type;
 800a4dc:	7019      	strb	r1, [r3, #0]
    trace[t].refpos = trace_info[type].refpos;
 800a4de:	4b1f      	ldr	r3, [pc, #124]	; (800a55c <set_trace_type+0xdc>)
 800a4e0:	18c4      	adds	r4, r0, r3
 800a4e2:	004b      	lsls	r3, r1, #1
 800a4e4:	1859      	adds	r1, r3, r1
 800a4e6:	4b1e      	ldr	r3, [pc, #120]	; (800a560 <set_trace_type+0xe0>)
 800a4e8:	0089      	lsls	r1, r1, #2
 800a4ea:	1859      	adds	r1, r3, r1
 800a4ec:	8888      	ldrh	r0, [r1, #4]
 800a4ee:	f7f7 f8c7 	bl	8001680 <__aeabi_ui2f>
 800a4f2:	6020      	str	r0, [r4, #0]
    plot_into_index(measured);
 800a4f4:	481b      	ldr	r0, [pc, #108]	; (800a564 <set_trace_type+0xe4>)
 800a4f6:	f003 f903 	bl	800d700 <plot_into_index>
    force_set_markmap();
 800a4fa:	f003 f8f1 	bl	800d6e0 <force_set_markmap>
}
 800a4fe:	bc0c      	pop	{r2, r3}
 800a500:	4690      	mov	r8, r2
 800a502:	4699      	mov	r9, r3
 800a504:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if (trace[t].type != type) {
 800a506:	4a14      	ldr	r2, [pc, #80]	; (800a558 <set_trace_type+0xd8>)
 800a508:	189a      	adds	r2, r3, r2
 800a50a:	7810      	ldrb	r0, [r2, #0]
 800a50c:	4281      	cmp	r1, r0
 800a50e:	d0f1      	beq.n	800a4f4 <set_trace_type+0x74>
    trace[t].type = type;
 800a510:	7011      	strb	r1, [r2, #0]
    trace[t].refpos = trace_info[type].refpos;
 800a512:	4a12      	ldr	r2, [pc, #72]	; (800a55c <set_trace_type+0xdc>)
 800a514:	189c      	adds	r4, r3, r2
 800a516:	e7e4      	b.n	800a4e2 <set_trace_type+0x62>
  if (trace[t].enabled != enabled) {
 800a518:	4a0e      	ldr	r2, [pc, #56]	; (800a554 <set_trace_type+0xd4>)
 800a51a:	189a      	adds	r2, r3, r2
 800a51c:	7812      	ldrb	r2, [r2, #0]
 800a51e:	42a2      	cmp	r2, r4
 800a520:	d1d1      	bne.n	800a4c6 <set_trace_type+0x46>
  if (trace[t].type != type) {
 800a522:	4a0d      	ldr	r2, [pc, #52]	; (800a558 <set_trace_type+0xd8>)
 800a524:	189a      	adds	r2, r3, r2
 800a526:	7810      	ldrb	r0, [r2, #0]
 800a528:	4281      	cmp	r1, r0
 800a52a:	d0e8      	beq.n	800a4fe <set_trace_type+0x7e>
    trace[t].type = type;
 800a52c:	7011      	strb	r1, [r2, #0]
    trace[t].refpos = trace_info[type].refpos;
 800a52e:	4a0b      	ldr	r2, [pc, #44]	; (800a55c <set_trace_type+0xdc>)
 800a530:	189c      	adds	r4, r3, r2
 800a532:	004b      	lsls	r3, r1, #1
 800a534:	1859      	adds	r1, r3, r1
 800a536:	4b0a      	ldr	r3, [pc, #40]	; (800a560 <set_trace_type+0xe0>)
 800a538:	0089      	lsls	r1, r1, #2
 800a53a:	1859      	adds	r1, r3, r1
 800a53c:	8888      	ldrh	r0, [r1, #4]
 800a53e:	f7f7 f89f 	bl	8001680 <__aeabi_ui2f>
 800a542:	6020      	str	r0, [r4, #0]
    if (polar)
 800a544:	2d01      	cmp	r5, #1
 800a546:	d8da      	bhi.n	800a4fe <set_trace_type+0x7e>
 800a548:	e7d4      	b.n	800a4f4 <set_trace_type+0x74>
 800a54a:	46c0      	nop			; (mov r8, r8)
 800a54c:	20000454 	.word	0x20000454
 800a550:	00001173 	.word	0x00001173
 800a554:	00001170 	.word	0x00001170
 800a558:	00001171 	.word	0x00001171
 800a55c:	00001178 	.word	0x00001178
 800a560:	08014738 	.word	0x08014738
 800a564:	20001bbc 	.word	0x20001bbc
	...

0800a570 <set_trace_channel>:
  if (trace[t].channel != channel) {
 800a570:	0043      	lsls	r3, r0, #1
 800a572:	181b      	adds	r3, r3, r0
 800a574:	4806      	ldr	r0, [pc, #24]	; (800a590 <set_trace_channel+0x20>)
 800a576:	009b      	lsls	r3, r3, #2
 800a578:	18c0      	adds	r0, r0, r3
 800a57a:	4b06      	ldr	r3, [pc, #24]	; (800a594 <set_trace_channel+0x24>)
{
 800a57c:	b510      	push	{r4, lr}
  if (trace[t].channel != channel) {
 800a57e:	469c      	mov	ip, r3
 800a580:	4460      	add	r0, ip
 800a582:	7803      	ldrb	r3, [r0, #0]
 800a584:	428b      	cmp	r3, r1
 800a586:	d002      	beq.n	800a58e <set_trace_channel+0x1e>
    trace[t].channel = channel;
 800a588:	7001      	strb	r1, [r0, #0]
    force_set_markmap();
 800a58a:	f003 f8a9 	bl	800d6e0 <force_set_markmap>
}
 800a58e:	bd10      	pop	{r4, pc}
 800a590:	20000454 	.word	0x20000454
 800a594:	00001172 	.word	0x00001172
	...

0800a5a0 <set_trace_scale>:
{
 800a5a0:	b570      	push	{r4, r5, r6, lr}
  scale /= trace_info[trace[t].type].scale_unit;
 800a5a2:	0044      	lsls	r4, r0, #1
 800a5a4:	1824      	adds	r4, r4, r0
 800a5a6:	480f      	ldr	r0, [pc, #60]	; (800a5e4 <set_trace_scale+0x44>)
 800a5a8:	00a4      	lsls	r4, r4, #2
 800a5aa:	4b0f      	ldr	r3, [pc, #60]	; (800a5e8 <set_trace_scale+0x48>)
 800a5ac:	1904      	adds	r4, r0, r4
 800a5ae:	18e3      	adds	r3, r4, r3
 800a5b0:	781a      	ldrb	r2, [r3, #0]
{
 800a5b2:	1c0d      	adds	r5, r1, #0
  scale /= trace_info[trace[t].type].scale_unit;
 800a5b4:	0053      	lsls	r3, r2, #1
 800a5b6:	189b      	adds	r3, r3, r2
 800a5b8:	4a0c      	ldr	r2, [pc, #48]	; (800a5ec <set_trace_scale+0x4c>)
 800a5ba:	009b      	lsls	r3, r3, #2
 800a5bc:	18d3      	adds	r3, r2, r3
 800a5be:	6899      	ldr	r1, [r3, #8]
 800a5c0:	1c28      	adds	r0, r5, #0
 800a5c2:	f7f6 fb35 	bl	8000c30 <__aeabi_fdiv>
  if (trace[t].scale != scale) {
 800a5c6:	4b0a      	ldr	r3, [pc, #40]	; (800a5f0 <set_trace_scale+0x50>)
  scale /= trace_info[trace[t].type].scale_unit;
 800a5c8:	1c05      	adds	r5, r0, #0
  if (trace[t].scale != scale) {
 800a5ca:	469c      	mov	ip, r3
 800a5cc:	4464      	add	r4, ip
 800a5ce:	1c01      	adds	r1, r0, #0
 800a5d0:	6820      	ldr	r0, [r4, #0]
 800a5d2:	f7f5 ffd1 	bl	8000578 <__aeabi_fcmpeq>
 800a5d6:	2800      	cmp	r0, #0
 800a5d8:	d000      	beq.n	800a5dc <set_trace_scale+0x3c>
}
 800a5da:	bd70      	pop	{r4, r5, r6, pc}
    trace[t].scale = scale;
 800a5dc:	6025      	str	r5, [r4, #0]
    force_set_markmap();
 800a5de:	f003 f87f 	bl	800d6e0 <force_set_markmap>
}
 800a5e2:	e7fa      	b.n	800a5da <set_trace_scale+0x3a>
 800a5e4:	20000454 	.word	0x20000454
 800a5e8:	00001171 	.word	0x00001171
 800a5ec:	08014738 	.word	0x08014738
 800a5f0:	00001174 	.word	0x00001174
	...

0800a600 <get_trace_scale>:
  return trace[t].scale * trace_info[trace[t].type].scale_unit;
 800a600:	0043      	lsls	r3, r0, #1
 800a602:	181b      	adds	r3, r3, r0
 800a604:	4809      	ldr	r0, [pc, #36]	; (800a62c <get_trace_scale+0x2c>)
 800a606:	009b      	lsls	r3, r3, #2
 800a608:	18c0      	adds	r0, r0, r3
 800a60a:	4b09      	ldr	r3, [pc, #36]	; (800a630 <get_trace_scale+0x30>)
{
 800a60c:	b510      	push	{r4, lr}
  return trace[t].scale * trace_info[trace[t].type].scale_unit;
 800a60e:	18c3      	adds	r3, r0, r3
 800a610:	781a      	ldrb	r2, [r3, #0]
 800a612:	0053      	lsls	r3, r2, #1
 800a614:	189b      	adds	r3, r3, r2
 800a616:	4a07      	ldr	r2, [pc, #28]	; (800a634 <get_trace_scale+0x34>)
 800a618:	009b      	lsls	r3, r3, #2
 800a61a:	18d3      	adds	r3, r2, r3
 800a61c:	4a06      	ldr	r2, [pc, #24]	; (800a638 <get_trace_scale+0x38>)
 800a61e:	4694      	mov	ip, r2
 800a620:	4460      	add	r0, ip
 800a622:	6801      	ldr	r1, [r0, #0]
 800a624:	6898      	ldr	r0, [r3, #8]
 800a626:	f7f6 fce3 	bl	8000ff0 <__aeabi_fmul>
}
 800a62a:	bd10      	pop	{r4, pc}
 800a62c:	20000454 	.word	0x20000454
 800a630:	00001171 	.word	0x00001171
 800a634:	08014738 	.word	0x08014738
 800a638:	00001174 	.word	0x00001174
 800a63c:	00000000 	.word	0x00000000

0800a640 <set_trace_refpos>:
  if (trace[t].refpos != refpos) {
 800a640:	4b09      	ldr	r3, [pc, #36]	; (800a668 <set_trace_refpos+0x28>)
{
 800a642:	b570      	push	{r4, r5, r6, lr}
  if (trace[t].refpos != refpos) {
 800a644:	469c      	mov	ip, r3
 800a646:	0044      	lsls	r4, r0, #1
 800a648:	1820      	adds	r0, r4, r0
 800a64a:	4c08      	ldr	r4, [pc, #32]	; (800a66c <set_trace_refpos+0x2c>)
 800a64c:	0080      	lsls	r0, r0, #2
 800a64e:	1824      	adds	r4, r4, r0
 800a650:	4464      	add	r4, ip
 800a652:	6820      	ldr	r0, [r4, #0]
{
 800a654:	1c0d      	adds	r5, r1, #0
  if (trace[t].refpos != refpos) {
 800a656:	f7f5 ff8f 	bl	8000578 <__aeabi_fcmpeq>
 800a65a:	2800      	cmp	r0, #0
 800a65c:	d000      	beq.n	800a660 <set_trace_refpos+0x20>
}
 800a65e:	bd70      	pop	{r4, r5, r6, pc}
    trace[t].refpos = refpos;
 800a660:	6025      	str	r5, [r4, #0]
    force_set_markmap();
 800a662:	f003 f83d 	bl	800d6e0 <force_set_markmap>
}
 800a666:	e7fa      	b.n	800a65e <set_trace_refpos+0x1e>
 800a668:	00001178 	.word	0x00001178
 800a66c:	20000454 	.word	0x20000454

0800a670 <get_trace_refpos>:
  return trace[t].refpos;
 800a670:	0043      	lsls	r3, r0, #1
 800a672:	181b      	adds	r3, r3, r0
 800a674:	4803      	ldr	r0, [pc, #12]	; (800a684 <get_trace_refpos+0x14>)
 800a676:	009b      	lsls	r3, r3, #2
 800a678:	18c0      	adds	r0, r0, r3
 800a67a:	4b03      	ldr	r3, [pc, #12]	; (800a688 <get_trace_refpos+0x18>)
 800a67c:	469c      	mov	ip, r3
 800a67e:	4460      	add	r0, ip
 800a680:	6800      	ldr	r0, [r0, #0]
}
 800a682:	4770      	bx	lr
 800a684:	20000454 	.word	0x20000454
 800a688:	00001178 	.word	0x00001178
 800a68c:	00000000 	.word	0x00000000

0800a690 <my_atof>:
{
 800a690:	b5f0      	push	{r4, r5, r6, r7, lr}
 800a692:	4646      	mov	r6, r8
 800a694:	46de      	mov	lr, fp
 800a696:	4657      	mov	r7, sl
 800a698:	b5c0      	push	{r6, r7, lr}
  if (*p == '-')
 800a69a:	7803      	ldrb	r3, [r0, #0]
{
 800a69c:	b082      	sub	sp, #8
 800a69e:	0006      	movs	r6, r0
  if (*p == '-')
 800a6a0:	2b2d      	cmp	r3, #45	; 0x2d
 800a6a2:	d04f      	beq.n	800a744 <my_atof+0xb4>
  if (*p == '-' || *p == '+')
 800a6a4:	2b2b      	cmp	r3, #43	; 0x2b
 800a6a6:	d02c      	beq.n	800a702 <my_atof+0x72>
  int neg = FALSE;
 800a6a8:	2300      	movs	r3, #0
 800a6aa:	4698      	mov	r8, r3
    double x = atoi(p);
 800a6ac:	0030      	movs	r0, r6
 800a6ae:	f008 fcff 	bl	80130b0 <atoi>
 800a6b2:	f7f8 fe1d 	bl	80032f0 <__aeabi_i2d>
  while (isdigit((int)*p))
 800a6b6:	4a3c      	ldr	r2, [pc, #240]	; (800a7a8 <my_atof+0x118>)
 800a6b8:	7833      	ldrb	r3, [r6, #0]
 800a6ba:	4692      	mov	sl, r2
 800a6bc:	5cd2      	ldrb	r2, [r2, r3]
    double x = atoi(p);
 800a6be:	0005      	movs	r5, r0
 800a6c0:	000c      	movs	r4, r1
  while (isdigit((int)*p))
 800a6c2:	0752      	lsls	r2, r2, #29
 800a6c4:	d506      	bpl.n	800a6d4 <my_atof+0x44>
 800a6c6:	2104      	movs	r1, #4
 800a6c8:	4652      	mov	r2, sl
    p++;
 800a6ca:	3601      	adds	r6, #1
  while (isdigit((int)*p))
 800a6cc:	7833      	ldrb	r3, [r6, #0]
 800a6ce:	5cd2      	ldrb	r2, [r2, r3]
 800a6d0:	4211      	tst	r1, r2
 800a6d2:	d1f9      	bne.n	800a6c8 <my_atof+0x38>
  if (*p == '.') {
 800a6d4:	2b2e      	cmp	r3, #46	; 0x2e
 800a6d6:	d039      	beq.n	800a74c <my_atof+0xbc>
 800a6d8:	7837      	ldrb	r7, [r6, #0]
  if (*p == 'e' || *p == 'E') {
 800a6da:	2320      	movs	r3, #32
 800a6dc:	0038      	movs	r0, r7
 800a6de:	4398      	bics	r0, r3
 800a6e0:	2845      	cmp	r0, #69	; 0x45
 800a6e2:	d012      	beq.n	800a70a <my_atof+0x7a>
  if (neg)
 800a6e4:	4643      	mov	r3, r8
 800a6e6:	2b00      	cmp	r3, #0
 800a6e8:	d003      	beq.n	800a6f2 <my_atof+0x62>
    x = -x;
 800a6ea:	2380      	movs	r3, #128	; 0x80
 800a6ec:	061b      	lsls	r3, r3, #24
 800a6ee:	469c      	mov	ip, r3
 800a6f0:	4464      	add	r4, ip
}
 800a6f2:	0028      	movs	r0, r5
 800a6f4:	0021      	movs	r1, r4
 800a6f6:	b002      	add	sp, #8
 800a6f8:	bc1c      	pop	{r2, r3, r4}
 800a6fa:	4690      	mov	r8, r2
 800a6fc:	469a      	mov	sl, r3
 800a6fe:	46a3      	mov	fp, r4
 800a700:	bdf0      	pop	{r4, r5, r6, r7, pc}
  int neg = FALSE;
 800a702:	2300      	movs	r3, #0
    p++;
 800a704:	3601      	adds	r6, #1
  int neg = FALSE;
 800a706:	4698      	mov	r8, r3
    p++;
 800a708:	e7d0      	b.n	800a6ac <my_atof+0x1c>
    p++;
 800a70a:	1c70      	adds	r0, r6, #1
    int exp = atoi(p);
 800a70c:	f008 fcd0 	bl	80130b0 <atoi>
 800a710:	1e06      	subs	r6, r0, #0
    while (exp > 0) {
 800a712:	dd14      	ble.n	800a73e <my_atof+0xae>
      x *= 10;
 800a714:	0028      	movs	r0, r5
 800a716:	0021      	movs	r1, r4
 800a718:	2200      	movs	r2, #0
 800a71a:	4b24      	ldr	r3, [pc, #144]	; (800a7ac <my_atof+0x11c>)
 800a71c:	f7f7 ff70 	bl	8002600 <__aeabi_dmul>
      exp--;
 800a720:	3e01      	subs	r6, #1
      x *= 10;
 800a722:	0005      	movs	r5, r0
 800a724:	000c      	movs	r4, r1
    while (exp > 0) {
 800a726:	2e00      	cmp	r6, #0
 800a728:	d1f4      	bne.n	800a714 <my_atof+0x84>
 800a72a:	e7db      	b.n	800a6e4 <my_atof+0x54>
      x /= 10;
 800a72c:	0028      	movs	r0, r5
 800a72e:	0021      	movs	r1, r4
 800a730:	2200      	movs	r2, #0
 800a732:	4b1e      	ldr	r3, [pc, #120]	; (800a7ac <my_atof+0x11c>)
 800a734:	f7f7 fb5c 	bl	8001df0 <__aeabi_ddiv>
 800a738:	0005      	movs	r5, r0
 800a73a:	000c      	movs	r4, r1
      exp++;
 800a73c:	3601      	adds	r6, #1
    while (exp < 0) {
 800a73e:	2e00      	cmp	r6, #0
 800a740:	d1f4      	bne.n	800a72c <my_atof+0x9c>
 800a742:	e7cf      	b.n	800a6e4 <my_atof+0x54>
    neg = TRUE;
 800a744:	3b2c      	subs	r3, #44	; 0x2c
 800a746:	4698      	mov	r8, r3
    p++;
 800a748:	3601      	adds	r6, #1
 800a74a:	e7af      	b.n	800a6ac <my_atof+0x1c>
    while (isdigit((int)*p)) {
 800a74c:	4652      	mov	r2, sl
 800a74e:	7877      	ldrb	r7, [r6, #1]
    p++;
 800a750:	1c73      	adds	r3, r6, #1
    while (isdigit((int)*p)) {
 800a752:	5dd2      	ldrb	r2, [r2, r7]
    p++;
 800a754:	001e      	movs	r6, r3
    while (isdigit((int)*p)) {
 800a756:	0752      	lsls	r2, r2, #29
 800a758:	d5bf      	bpl.n	800a6da <my_atof+0x4a>
        double d = 1.0f;
 800a75a:	2200      	movs	r2, #0
 800a75c:	4b14      	ldr	r3, [pc, #80]	; (800a7b0 <my_atof+0x120>)
 800a75e:	9200      	str	r2, [sp, #0]
 800a760:	9301      	str	r3, [sp, #4]
    while (isdigit((int)*p)) {
 800a762:	2304      	movs	r3, #4
 800a764:	469b      	mov	fp, r3
      d /= 10;
 800a766:	9800      	ldr	r0, [sp, #0]
 800a768:	9901      	ldr	r1, [sp, #4]
 800a76a:	2200      	movs	r2, #0
 800a76c:	4b0f      	ldr	r3, [pc, #60]	; (800a7ac <my_atof+0x11c>)
 800a76e:	f7f7 fb3f 	bl	8001df0 <__aeabi_ddiv>
      x += d * (*p - '0');
 800a772:	3f30      	subs	r7, #48	; 0x30
      d /= 10;
 800a774:	9000      	str	r0, [sp, #0]
 800a776:	9101      	str	r1, [sp, #4]
      x += d * (*p - '0');
 800a778:	0038      	movs	r0, r7
 800a77a:	f7f8 fdb9 	bl	80032f0 <__aeabi_i2d>
 800a77e:	9a00      	ldr	r2, [sp, #0]
 800a780:	9b01      	ldr	r3, [sp, #4]
 800a782:	f7f7 ff3d 	bl	8002600 <__aeabi_dmul>
 800a786:	0002      	movs	r2, r0
 800a788:	000b      	movs	r3, r1
 800a78a:	0028      	movs	r0, r5
 800a78c:	0021      	movs	r1, r4
 800a78e:	f7f6 ffb7 	bl	8001700 <__aeabi_dadd>
    while (isdigit((int)*p)) {
 800a792:	4653      	mov	r3, sl
 800a794:	465a      	mov	r2, fp
      p++;
 800a796:	3601      	adds	r6, #1
    while (isdigit((int)*p)) {
 800a798:	7837      	ldrb	r7, [r6, #0]
      x += d * (*p - '0');
 800a79a:	0005      	movs	r5, r0
    while (isdigit((int)*p)) {
 800a79c:	5ddb      	ldrb	r3, [r3, r7]
      x += d * (*p - '0');
 800a79e:	000c      	movs	r4, r1
    while (isdigit((int)*p)) {
 800a7a0:	421a      	tst	r2, r3
 800a7a2:	d1e0      	bne.n	800a766 <my_atof+0xd6>
 800a7a4:	e799      	b.n	800a6da <my_atof+0x4a>
 800a7a6:	46c0      	nop			; (mov r8, r8)
 800a7a8:	08016c51 	.word	0x08016c51
 800a7ac:	40240000 	.word	0x40240000
 800a7b0:	3ff00000 	.word	0x3ff00000
	...

0800a7c0 <cmd_trace>:
{
 800a7c0:	b5f0      	push	{r4, r5, r6, r7, lr}
 800a7c2:	4657      	mov	r7, sl
 800a7c4:	4645      	mov	r5, r8
 800a7c6:	46de      	mov	lr, fp
 800a7c8:	464e      	mov	r6, r9
 800a7ca:	b5e0      	push	{r5, r6, r7, lr}
 800a7cc:	000c      	movs	r4, r1
 800a7ce:	b087      	sub	sp, #28
 800a7d0:	0007      	movs	r7, r0
 800a7d2:	0015      	movs	r5, r2
  if (argc == 0) {
 800a7d4:	2900      	cmp	r1, #0
 800a7d6:	d100      	bne.n	800a7da <cmd_trace+0x1a>
 800a7d8:	e0b2      	b.n	800a940 <cmd_trace+0x180>
  if (strcmp(argv[0], "all") == 0 &&
 800a7da:	6816      	ldr	r6, [r2, #0]
 800a7dc:	49bd      	ldr	r1, [pc, #756]	; (800aad4 <cmd_trace+0x314>)
 800a7de:	0030      	movs	r0, r6
 800a7e0:	f7f8 fff6 	bl	80037d0 <strcmp>
 800a7e4:	2800      	cmp	r0, #0
 800a7e6:	d000      	beq.n	800a7ea <cmd_trace+0x2a>
 800a7e8:	e08e      	b.n	800a908 <cmd_trace+0x148>
 800a7ea:	2c01      	cmp	r4, #1
 800a7ec:	dc00      	bgt.n	800a7f0 <cmd_trace+0x30>
 800a7ee:	e08b      	b.n	800a908 <cmd_trace+0x148>
      argc > 1 && strcmp(argv[1], "off") == 0) {
 800a7f0:	49b9      	ldr	r1, [pc, #740]	; (800aad8 <cmd_trace+0x318>)
 800a7f2:	6868      	ldr	r0, [r5, #4]
 800a7f4:	f7f8 ffec 	bl	80037d0 <strcmp>
 800a7f8:	2800      	cmp	r0, #0
 800a7fa:	d100      	bne.n	800a7fe <cmd_trace+0x3e>
 800a7fc:	e0e6      	b.n	800a9cc <cmd_trace+0x20c>
  t = atoi(argv[0]);
 800a7fe:	0030      	movs	r0, r6
 800a800:	f008 fc56 	bl	80130b0 <atoi>
 800a804:	0006      	movs	r6, r0
  if (t < 0 || t >= 4)
 800a806:	2803      	cmp	r0, #3
 800a808:	d900      	bls.n	800a80c <cmd_trace+0x4c>
 800a80a:	e090      	b.n	800a92e <cmd_trace+0x16e>
    if (strcmp(argv[1], "logmag") == 0) {
 800a80c:	686b      	ldr	r3, [r5, #4]
 800a80e:	49b3      	ldr	r1, [pc, #716]	; (800aadc <cmd_trace+0x31c>)
 800a810:	0018      	movs	r0, r3
 800a812:	4698      	mov	r8, r3
 800a814:	f7f8 ffdc 	bl	80037d0 <strcmp>
 800a818:	2800      	cmp	r0, #0
 800a81a:	d100      	bne.n	800a81e <cmd_trace+0x5e>
 800a81c:	e0c2      	b.n	800a9a4 <cmd_trace+0x1e4>
    } else if (strcmp(argv[1], "phase") == 0) {
 800a81e:	49b0      	ldr	r1, [pc, #704]	; (800aae0 <cmd_trace+0x320>)
 800a820:	4640      	mov	r0, r8
 800a822:	f7f8 ffd5 	bl	80037d0 <strcmp>
 800a826:	2800      	cmp	r0, #0
 800a828:	d100      	bne.n	800a82c <cmd_trace+0x6c>
 800a82a:	e0ff      	b.n	800aa2c <cmd_trace+0x26c>
    } else if (strcmp(argv[1], "polar") == 0) {
 800a82c:	49ad      	ldr	r1, [pc, #692]	; (800aae4 <cmd_trace+0x324>)
 800a82e:	4640      	mov	r0, r8
 800a830:	f7f8 ffce 	bl	80037d0 <strcmp>
 800a834:	2800      	cmp	r0, #0
 800a836:	d100      	bne.n	800a83a <cmd_trace+0x7a>
 800a838:	e0fd      	b.n	800aa36 <cmd_trace+0x276>
    } else if (strcmp(argv[1], "smith") == 0) {
 800a83a:	49ab      	ldr	r1, [pc, #684]	; (800aae8 <cmd_trace+0x328>)
 800a83c:	4640      	mov	r0, r8
 800a83e:	f7f8 ffc7 	bl	80037d0 <strcmp>
 800a842:	2800      	cmp	r0, #0
 800a844:	d100      	bne.n	800a848 <cmd_trace+0x88>
 800a846:	e0d1      	b.n	800a9ec <cmd_trace+0x22c>
    } else if (strcmp(argv[1], "delay") == 0) {
 800a848:	49a8      	ldr	r1, [pc, #672]	; (800aaec <cmd_trace+0x32c>)
 800a84a:	4640      	mov	r0, r8
 800a84c:	f7f8 ffc0 	bl	80037d0 <strcmp>
 800a850:	2800      	cmp	r0, #0
 800a852:	d100      	bne.n	800a856 <cmd_trace+0x96>
 800a854:	e0f4      	b.n	800aa40 <cmd_trace+0x280>
    } else if (strcmp(argv[1], "linear") == 0) {
 800a856:	49a6      	ldr	r1, [pc, #664]	; (800aaf0 <cmd_trace+0x330>)
 800a858:	4640      	mov	r0, r8
 800a85a:	f7f8 ffb9 	bl	80037d0 <strcmp>
 800a85e:	2800      	cmp	r0, #0
 800a860:	d100      	bne.n	800a864 <cmd_trace+0xa4>
 800a862:	e0f2      	b.n	800aa4a <cmd_trace+0x28a>
    } else if (strcmp(argv[1], "swr") == 0) {
 800a864:	49a3      	ldr	r1, [pc, #652]	; (800aaf4 <cmd_trace+0x334>)
 800a866:	4640      	mov	r0, r8
 800a868:	f7f8 ffb2 	bl	80037d0 <strcmp>
 800a86c:	2800      	cmp	r0, #0
 800a86e:	d100      	bne.n	800a872 <cmd_trace+0xb2>
 800a870:	e0f0      	b.n	800aa54 <cmd_trace+0x294>
    } else if (strcmp(argv[1], "real") == 0) {
 800a872:	49a1      	ldr	r1, [pc, #644]	; (800aaf8 <cmd_trace+0x338>)
 800a874:	4640      	mov	r0, r8
 800a876:	f7f8 ffab 	bl	80037d0 <strcmp>
 800a87a:	2800      	cmp	r0, #0
 800a87c:	d100      	bne.n	800a880 <cmd_trace+0xc0>
 800a87e:	e0ee      	b.n	800aa5e <cmd_trace+0x29e>
    } else if (strcmp(argv[1], "imag") == 0) {
 800a880:	499e      	ldr	r1, [pc, #632]	; (800aafc <cmd_trace+0x33c>)
 800a882:	4640      	mov	r0, r8
 800a884:	f7f8 ffa4 	bl	80037d0 <strcmp>
 800a888:	2800      	cmp	r0, #0
 800a88a:	d100      	bne.n	800a88e <cmd_trace+0xce>
 800a88c:	e0ec      	b.n	800aa68 <cmd_trace+0x2a8>
    } else if (strcmp(argv[1], "r") == 0) {
 800a88e:	499c      	ldr	r1, [pc, #624]	; (800ab00 <cmd_trace+0x340>)
 800a890:	4640      	mov	r0, r8
 800a892:	f7f8 ff9d 	bl	80037d0 <strcmp>
 800a896:	2800      	cmp	r0, #0
 800a898:	d100      	bne.n	800a89c <cmd_trace+0xdc>
 800a89a:	e0ea      	b.n	800aa72 <cmd_trace+0x2b2>
    } else if (strcmp(argv[1], "x") == 0) {
 800a89c:	4999      	ldr	r1, [pc, #612]	; (800ab04 <cmd_trace+0x344>)
 800a89e:	4640      	mov	r0, r8
 800a8a0:	f7f8 ff96 	bl	80037d0 <strcmp>
 800a8a4:	2800      	cmp	r0, #0
 800a8a6:	d100      	bne.n	800a8aa <cmd_trace+0xea>
 800a8a8:	e0e8      	b.n	800aa7c <cmd_trace+0x2bc>
    } else if (strcmp(argv[1], "off") == 0) {
 800a8aa:	498b      	ldr	r1, [pc, #556]	; (800aad8 <cmd_trace+0x318>)
 800a8ac:	4640      	mov	r0, r8
 800a8ae:	f7f8 ff8f 	bl	80037d0 <strcmp>
 800a8b2:	2800      	cmp	r0, #0
 800a8b4:	d100      	bne.n	800a8b8 <cmd_trace+0xf8>
 800a8b6:	e107      	b.n	800aac8 <cmd_trace+0x308>
    } else if (strcmp(argv[1], "scale") == 0 && argc >= 3) {
 800a8b8:	4993      	ldr	r1, [pc, #588]	; (800ab08 <cmd_trace+0x348>)
 800a8ba:	4640      	mov	r0, r8
 800a8bc:	f7f8 ff88 	bl	80037d0 <strcmp>
 800a8c0:	2800      	cmp	r0, #0
 800a8c2:	d000      	beq.n	800a8c6 <cmd_trace+0x106>
 800a8c4:	e0df      	b.n	800aa86 <cmd_trace+0x2c6>
 800a8c6:	2c02      	cmp	r4, #2
 800a8c8:	d031      	beq.n	800a92e <cmd_trace+0x16e>
      set_trace_scale(t, my_atof(argv[2]));
 800a8ca:	68a8      	ldr	r0, [r5, #8]
 800a8cc:	f7ff fee0 	bl	800a690 <my_atof>
 800a8d0:	f7f8 fdde 	bl	8003490 <__aeabi_d2f>
  scale /= trace_info[trace[t].type].scale_unit;
 800a8d4:	230c      	movs	r3, #12
 800a8d6:	435e      	muls	r6, r3
 800a8d8:	4a8c      	ldr	r2, [pc, #560]	; (800ab0c <cmd_trace+0x34c>)
 800a8da:	1996      	adds	r6, r2, r6
 800a8dc:	4a8c      	ldr	r2, [pc, #560]	; (800ab10 <cmd_trace+0x350>)
 800a8de:	18b2      	adds	r2, r6, r2
 800a8e0:	7812      	ldrb	r2, [r2, #0]
 800a8e2:	4353      	muls	r3, r2
 800a8e4:	4a8b      	ldr	r2, [pc, #556]	; (800ab14 <cmd_trace+0x354>)
 800a8e6:	18d3      	adds	r3, r2, r3
 800a8e8:	6899      	ldr	r1, [r3, #8]
 800a8ea:	f7f6 f9a1 	bl	8000c30 <__aeabi_fdiv>
  if (trace[t].scale != scale) {
 800a8ee:	4b8a      	ldr	r3, [pc, #552]	; (800ab18 <cmd_trace+0x358>)
  scale /= trace_info[trace[t].type].scale_unit;
 800a8f0:	1c04      	adds	r4, r0, #0
  if (trace[t].scale != scale) {
 800a8f2:	469c      	mov	ip, r3
 800a8f4:	4466      	add	r6, ip
 800a8f6:	6831      	ldr	r1, [r6, #0]
 800a8f8:	f7f5 fe3e 	bl	8000578 <__aeabi_fcmpeq>
 800a8fc:	2800      	cmp	r0, #0
 800a8fe:	d10f      	bne.n	800a920 <cmd_trace+0x160>
    trace[t].scale = scale;
 800a900:	6034      	str	r4, [r6, #0]
    force_set_markmap();
 800a902:	f002 feed 	bl	800d6e0 <force_set_markmap>
 800a906:	e00b      	b.n	800a920 <cmd_trace+0x160>
  t = atoi(argv[0]);
 800a908:	0030      	movs	r0, r6
 800a90a:	f008 fbd1 	bl	80130b0 <atoi>
 800a90e:	0006      	movs	r6, r0
  if (t < 0 || t >= 4)
 800a910:	2803      	cmp	r0, #3
 800a912:	d80c      	bhi.n	800a92e <cmd_trace+0x16e>
  if (argc == 1) {
 800a914:	2c01      	cmp	r4, #1
 800a916:	d06e      	beq.n	800a9f6 <cmd_trace+0x236>
  if (argc > 1) {
 800a918:	dd00      	ble.n	800a91c <cmd_trace+0x15c>
 800a91a:	e777      	b.n	800a80c <cmd_trace+0x4c>
  if (argc > 2) {
 800a91c:	2c02      	cmp	r4, #2
 800a91e:	dc46      	bgt.n	800a9ae <cmd_trace+0x1ee>
}
 800a920:	b007      	add	sp, #28
 800a922:	bc3c      	pop	{r2, r3, r4, r5}
 800a924:	4690      	mov	r8, r2
 800a926:	4699      	mov	r9, r3
 800a928:	46a2      	mov	sl, r4
 800a92a:	46ab      	mov	fp, r5
 800a92c:	bdf0      	pop	{r4, r5, r6, r7, pc}
  chprintf(chp, "trace {0|1|2|3|all} [logmag|phase|smith|linear|delay|swr|real|imag|r|x|off] [src]\r\n");
 800a92e:	497b      	ldr	r1, [pc, #492]	; (800ab1c <cmd_trace+0x35c>)
 800a930:	0038      	movs	r0, r7
 800a932:	f7fc fded 	bl	8007510 <chprintf>
  chprintf(chp, "trace {0|1|2|3} {scale|refpos} {value}\r\n");
 800a936:	497a      	ldr	r1, [pc, #488]	; (800ab20 <cmd_trace+0x360>)
 800a938:	0038      	movs	r0, r7
 800a93a:	f7fc fde9 	bl	8007510 <chprintf>
 800a93e:	e7ef      	b.n	800a920 <cmd_trace+0x160>
        const char *type = trace_info[trace[t].type].name;
 800a940:	4b74      	ldr	r3, [pc, #464]	; (800ab14 <cmd_trace+0x354>)
 800a942:	4d78      	ldr	r5, [pc, #480]	; (800ab24 <cmd_trace+0x364>)
 800a944:	4698      	mov	r8, r3
        chprintf(chp, "%d %s %s %f %f\r\n", t, type, channel, scale, refpos);
 800a946:	4b78      	ldr	r3, [pc, #480]	; (800ab28 <cmd_trace+0x368>)
 800a948:	469a      	mov	sl, r3
        const char *channel = trc_channel_name[trace[t].channel];
 800a94a:	4b78      	ldr	r3, [pc, #480]	; (800ab2c <cmd_trace+0x36c>)
 800a94c:	4699      	mov	r9, r3
      if (trace[t].enabled) {
 800a94e:	782b      	ldrb	r3, [r5, #0]
 800a950:	2b00      	cmp	r3, #0
 800a952:	d106      	bne.n	800a962 <cmd_trace+0x1a2>
    for (t = 0; t < 4; t++) {
 800a954:	3401      	adds	r4, #1
 800a956:	350c      	adds	r5, #12
 800a958:	2c04      	cmp	r4, #4
 800a95a:	d0e1      	beq.n	800a920 <cmd_trace+0x160>
      if (trace[t].enabled) {
 800a95c:	782b      	ldrb	r3, [r5, #0]
 800a95e:	2b00      	cmp	r3, #0
 800a960:	d0f8      	beq.n	800a954 <cmd_trace+0x194>
        const char *type = trace_info[trace[t].type].name;
 800a962:	786b      	ldrb	r3, [r5, #1]
        chprintf(chp, "%d %s %s %f %f\r\n", t, type, channel, scale, refpos);
 800a964:	68a8      	ldr	r0, [r5, #8]
        const char *type = trace_info[trace[t].type].name;
 800a966:	005e      	lsls	r6, r3, #1
 800a968:	18f6      	adds	r6, r6, r3
        chprintf(chp, "%d %s %s %f %f\r\n", t, type, channel, scale, refpos);
 800a96a:	4643      	mov	r3, r8
        const char *type = trace_info[trace[t].type].name;
 800a96c:	00b6      	lsls	r6, r6, #2
        chprintf(chp, "%d %s %s %f %f\r\n", t, type, channel, scale, refpos);
 800a96e:	58f3      	ldr	r3, [r6, r3]
  return trace[t].scale * trace_info[trace[t].type].scale_unit;
 800a970:	4446      	add	r6, r8
        chprintf(chp, "%d %s %s %f %f\r\n", t, type, channel, scale, refpos);
 800a972:	469b      	mov	fp, r3
 800a974:	f7f8 fd34 	bl	80033e0 <__aeabi_f2d>
 800a978:	9004      	str	r0, [sp, #16]
 800a97a:	9105      	str	r1, [sp, #20]
  return trace[t].scale * trace_info[trace[t].type].scale_unit;
 800a97c:	68b1      	ldr	r1, [r6, #8]
 800a97e:	6868      	ldr	r0, [r5, #4]
 800a980:	f7f6 fb36 	bl	8000ff0 <__aeabi_fmul>
        chprintf(chp, "%d %s %s %f %f\r\n", t, type, channel, scale, refpos);
 800a984:	f7f8 fd2c 	bl	80033e0 <__aeabi_f2d>
 800a988:	464a      	mov	r2, r9
 800a98a:	9002      	str	r0, [sp, #8]
 800a98c:	9103      	str	r1, [sp, #12]
        const char *channel = trc_channel_name[trace[t].channel];
 800a98e:	78ab      	ldrb	r3, [r5, #2]
        chprintf(chp, "%d %s %s %f %f\r\n", t, type, channel, scale, refpos);
 800a990:	4651      	mov	r1, sl
        const char *channel = trc_channel_name[trace[t].channel];
 800a992:	009b      	lsls	r3, r3, #2
        chprintf(chp, "%d %s %s %f %f\r\n", t, type, channel, scale, refpos);
 800a994:	589b      	ldr	r3, [r3, r2]
 800a996:	0038      	movs	r0, r7
 800a998:	9300      	str	r3, [sp, #0]
 800a99a:	0022      	movs	r2, r4
 800a99c:	465b      	mov	r3, fp
 800a99e:	f7fc fdb7 	bl	8007510 <chprintf>
 800a9a2:	e7d7      	b.n	800a954 <cmd_trace+0x194>
      set_trace_type(t, TRC_LOGMAG);
 800a9a4:	2100      	movs	r1, #0
 800a9a6:	0030      	movs	r0, r6
 800a9a8:	f7ff fd6a 	bl	800a480 <set_trace_type>
 800a9ac:	e7b6      	b.n	800a91c <cmd_trace+0x15c>
    int src = atoi(argv[2]);
 800a9ae:	68a8      	ldr	r0, [r5, #8]
 800a9b0:	f008 fb7e 	bl	80130b0 <atoi>
    if (src != 0 && src != 1)
 800a9b4:	2801      	cmp	r0, #1
 800a9b6:	d8ba      	bhi.n	800a92e <cmd_trace+0x16e>
    trace[t].channel = src;
 800a9b8:	0073      	lsls	r3, r6, #1
 800a9ba:	199b      	adds	r3, r3, r6
 800a9bc:	4e53      	ldr	r6, [pc, #332]	; (800ab0c <cmd_trace+0x34c>)
 800a9be:	009b      	lsls	r3, r3, #2
 800a9c0:	18f6      	adds	r6, r6, r3
 800a9c2:	4b5b      	ldr	r3, [pc, #364]	; (800ab30 <cmd_trace+0x370>)
 800a9c4:	469c      	mov	ip, r3
 800a9c6:	4466      	add	r6, ip
 800a9c8:	7030      	strb	r0, [r6, #0]
 800a9ca:	e7a9      	b.n	800a920 <cmd_trace+0x160>
    set_trace_type(0, TRC_OFF);
 800a9cc:	210b      	movs	r1, #11
 800a9ce:	f7ff fd57 	bl	800a480 <set_trace_type>
    set_trace_type(1, TRC_OFF);
 800a9d2:	210b      	movs	r1, #11
 800a9d4:	2001      	movs	r0, #1
 800a9d6:	f7ff fd53 	bl	800a480 <set_trace_type>
    set_trace_type(2, TRC_OFF);
 800a9da:	210b      	movs	r1, #11
 800a9dc:	2002      	movs	r0, #2
 800a9de:	f7ff fd4f 	bl	800a480 <set_trace_type>
    set_trace_type(3, TRC_OFF);
 800a9e2:	210b      	movs	r1, #11
 800a9e4:	2003      	movs	r0, #3
 800a9e6:	f7ff fd4b 	bl	800a480 <set_trace_type>
    goto exit;
 800a9ea:	e799      	b.n	800a920 <cmd_trace+0x160>
      set_trace_type(t, TRC_SMITH);
 800a9ec:	2103      	movs	r1, #3
 800a9ee:	0030      	movs	r0, r6
 800a9f0:	f7ff fd46 	bl	800a480 <set_trace_type>
 800a9f4:	e792      	b.n	800a91c <cmd_trace+0x15c>
  return trace_info[trace[t].type].name;
 800a9f6:	0042      	lsls	r2, r0, #1
 800a9f8:	1812      	adds	r2, r2, r0
 800a9fa:	0093      	lsls	r3, r2, #2
 800a9fc:	4a43      	ldr	r2, [pc, #268]	; (800ab0c <cmd_trace+0x34c>)
 800a9fe:	18d2      	adds	r2, r2, r3
 800aa00:	4b43      	ldr	r3, [pc, #268]	; (800ab10 <cmd_trace+0x350>)
 800aa02:	18d3      	adds	r3, r2, r3
 800aa04:	7819      	ldrb	r1, [r3, #0]
 800aa06:	004b      	lsls	r3, r1, #1
 800aa08:	185b      	adds	r3, r3, r1
    chprintf(chp, "%d %s %s\r\n", t, type, channel);
 800aa0a:	4942      	ldr	r1, [pc, #264]	; (800ab14 <cmd_trace+0x354>)
  return trace_info[trace[t].type].name;
 800aa0c:	009b      	lsls	r3, r3, #2
    chprintf(chp, "%d %s %s\r\n", t, type, channel);
 800aa0e:	585b      	ldr	r3, [r3, r1]
    const char *channel = trc_channel_name[trace[t].channel];
 800aa10:	4947      	ldr	r1, [pc, #284]	; (800ab30 <cmd_trace+0x370>)
 800aa12:	468c      	mov	ip, r1
 800aa14:	4462      	add	r2, ip
 800aa16:	7812      	ldrb	r2, [r2, #0]
    chprintf(chp, "%d %s %s\r\n", t, type, channel);
 800aa18:	4944      	ldr	r1, [pc, #272]	; (800ab2c <cmd_trace+0x36c>)
    const char *channel = trc_channel_name[trace[t].channel];
 800aa1a:	0092      	lsls	r2, r2, #2
    chprintf(chp, "%d %s %s\r\n", t, type, channel);
 800aa1c:	5852      	ldr	r2, [r2, r1]
 800aa1e:	4945      	ldr	r1, [pc, #276]	; (800ab34 <cmd_trace+0x374>)
 800aa20:	9200      	str	r2, [sp, #0]
 800aa22:	0002      	movs	r2, r0
 800aa24:	0038      	movs	r0, r7
 800aa26:	f7fc fd73 	bl	8007510 <chprintf>
    return;
 800aa2a:	e779      	b.n	800a920 <cmd_trace+0x160>
      set_trace_type(t, TRC_PHASE);
 800aa2c:	2101      	movs	r1, #1
 800aa2e:	0030      	movs	r0, r6
 800aa30:	f7ff fd26 	bl	800a480 <set_trace_type>
 800aa34:	e772      	b.n	800a91c <cmd_trace+0x15c>
      set_trace_type(t, TRC_POLAR);
 800aa36:	2104      	movs	r1, #4
 800aa38:	0030      	movs	r0, r6
 800aa3a:	f7ff fd21 	bl	800a480 <set_trace_type>
 800aa3e:	e76d      	b.n	800a91c <cmd_trace+0x15c>
      set_trace_type(t, TRC_DELAY);
 800aa40:	2102      	movs	r1, #2
 800aa42:	0030      	movs	r0, r6
 800aa44:	f7ff fd1c 	bl	800a480 <set_trace_type>
 800aa48:	e768      	b.n	800a91c <cmd_trace+0x15c>
      set_trace_type(t, TRC_LINEAR);
 800aa4a:	2105      	movs	r1, #5
 800aa4c:	0030      	movs	r0, r6
 800aa4e:	f7ff fd17 	bl	800a480 <set_trace_type>
 800aa52:	e763      	b.n	800a91c <cmd_trace+0x15c>
      set_trace_type(t, TRC_SWR);
 800aa54:	2106      	movs	r1, #6
 800aa56:	0030      	movs	r0, r6
 800aa58:	f7ff fd12 	bl	800a480 <set_trace_type>
 800aa5c:	e75e      	b.n	800a91c <cmd_trace+0x15c>
      set_trace_type(t, TRC_REAL);
 800aa5e:	2107      	movs	r1, #7
 800aa60:	0030      	movs	r0, r6
 800aa62:	f7ff fd0d 	bl	800a480 <set_trace_type>
 800aa66:	e759      	b.n	800a91c <cmd_trace+0x15c>
      set_trace_type(t, TRC_IMAG);
 800aa68:	2108      	movs	r1, #8
 800aa6a:	0030      	movs	r0, r6
 800aa6c:	f7ff fd08 	bl	800a480 <set_trace_type>
 800aa70:	e754      	b.n	800a91c <cmd_trace+0x15c>
      set_trace_type(t, TRC_R);
 800aa72:	2109      	movs	r1, #9
 800aa74:	0030      	movs	r0, r6
 800aa76:	f7ff fd03 	bl	800a480 <set_trace_type>
 800aa7a:	e74f      	b.n	800a91c <cmd_trace+0x15c>
      set_trace_type(t, TRC_X);
 800aa7c:	210a      	movs	r1, #10
 800aa7e:	0030      	movs	r0, r6
 800aa80:	f7ff fcfe 	bl	800a480 <set_trace_type>
 800aa84:	e74a      	b.n	800a91c <cmd_trace+0x15c>
    } else if (strcmp(argv[1], "refpos") == 0 && argc >= 3) {
 800aa86:	492c      	ldr	r1, [pc, #176]	; (800ab38 <cmd_trace+0x378>)
 800aa88:	4640      	mov	r0, r8
 800aa8a:	f7f8 fea1 	bl	80037d0 <strcmp>
 800aa8e:	2800      	cmp	r0, #0
 800aa90:	d000      	beq.n	800aa94 <cmd_trace+0x2d4>
 800aa92:	e74c      	b.n	800a92e <cmd_trace+0x16e>
 800aa94:	2c02      	cmp	r4, #2
 800aa96:	d100      	bne.n	800aa9a <cmd_trace+0x2da>
 800aa98:	e749      	b.n	800a92e <cmd_trace+0x16e>
  if (trace[t].refpos != refpos) {
 800aa9a:	240c      	movs	r4, #12
      set_trace_refpos(t, my_atof(argv[2]));
 800aa9c:	68a8      	ldr	r0, [r5, #8]
 800aa9e:	f7ff fdf7 	bl	800a690 <my_atof>
 800aaa2:	f7f8 fcf5 	bl	8003490 <__aeabi_d2f>
  if (trace[t].refpos != refpos) {
 800aaa6:	4b25      	ldr	r3, [pc, #148]	; (800ab3c <cmd_trace+0x37c>)
 800aaa8:	4366      	muls	r6, r4
 800aaaa:	469c      	mov	ip, r3
 800aaac:	4c17      	ldr	r4, [pc, #92]	; (800ab0c <cmd_trace+0x34c>)
      set_trace_refpos(t, my_atof(argv[2]));
 800aaae:	1c05      	adds	r5, r0, #0
  if (trace[t].refpos != refpos) {
 800aab0:	19a4      	adds	r4, r4, r6
 800aab2:	4464      	add	r4, ip
 800aab4:	6821      	ldr	r1, [r4, #0]
 800aab6:	f7f5 fd5f 	bl	8000578 <__aeabi_fcmpeq>
 800aaba:	2800      	cmp	r0, #0
 800aabc:	d000      	beq.n	800aac0 <cmd_trace+0x300>
 800aabe:	e72f      	b.n	800a920 <cmd_trace+0x160>
    trace[t].refpos = refpos;
 800aac0:	6025      	str	r5, [r4, #0]
    force_set_markmap();
 800aac2:	f002 fe0d 	bl	800d6e0 <force_set_markmap>
 800aac6:	e72b      	b.n	800a920 <cmd_trace+0x160>
      set_trace_type(t, TRC_OFF);
 800aac8:	210b      	movs	r1, #11
 800aaca:	0030      	movs	r0, r6
 800aacc:	f7ff fcd8 	bl	800a480 <set_trace_type>
 800aad0:	e724      	b.n	800a91c <cmd_trace+0x15c>
 800aad2:	46c0      	nop			; (mov r8, r8)
 800aad4:	080142dc 	.word	0x080142dc
 800aad8:	080143c8 	.word	0x080143c8
 800aadc:	080142ec 	.word	0x080142ec
 800aae0:	080142f4 	.word	0x080142f4
 800aae4:	080142fc 	.word	0x080142fc
 800aae8:	08014304 	.word	0x08014304
 800aaec:	0801430c 	.word	0x0801430c
 800aaf0:	08014314 	.word	0x08014314
 800aaf4:	0801431c 	.word	0x0801431c
 800aaf8:	08014320 	.word	0x08014320
 800aafc:	08014328 	.word	0x08014328
 800ab00:	08014300 	.word	0x08014300
 800ab04:	08014330 	.word	0x08014330
 800ab08:	08014334 	.word	0x08014334
 800ab0c:	20000454 	.word	0x20000454
 800ab10:	00001171 	.word	0x00001171
 800ab14:	08014738 	.word	0x08014738
 800ab18:	00001174 	.word	0x00001174
 800ab1c:	08014344 	.word	0x08014344
 800ab20:	08014398 	.word	0x08014398
 800ab24:	200015c4 	.word	0x200015c4
 800ab28:	080142c8 	.word	0x080142c8
 800ab2c:	080147bc 	.word	0x080147bc
 800ab30:	00001172 	.word	0x00001172
 800ab34:	080142e0 	.word	0x080142e0
 800ab38:	0801433c 	.word	0x0801433c
 800ab3c:	00001178 	.word	0x00001178

0800ab40 <cmd_edelay>:
{
 800ab40:	b570      	push	{r4, r5, r6, lr}
 800ab42:	0004      	movs	r4, r0
  if (argc == 0) {
 800ab44:	2900      	cmp	r1, #0
 800ab46:	d012      	beq.n	800ab6e <cmd_edelay+0x2e>
  if (argc > 0) {
 800ab48:	dc00      	bgt.n	800ab4c <cmd_edelay+0xc>
}
 800ab4a:	bd70      	pop	{r4, r5, r6, pc}
    set_electrical_delay(my_atof(argv[0]));
 800ab4c:	6810      	ldr	r0, [r2, #0]
 800ab4e:	f7ff fd9f 	bl	800a690 <my_atof>
 800ab52:	f7f8 fc9d 	bl	8003490 <__aeabi_d2f>
  if (electrical_delay != picoseconds) {
 800ab56:	4c0c      	ldr	r4, [pc, #48]	; (800ab88 <cmd_edelay+0x48>)
 800ab58:	4d0c      	ldr	r5, [pc, #48]	; (800ab8c <cmd_edelay+0x4c>)
    set_electrical_delay(my_atof(argv[0]));
 800ab5a:	1c06      	adds	r6, r0, #0
  if (electrical_delay != picoseconds) {
 800ab5c:	5929      	ldr	r1, [r5, r4]
 800ab5e:	f7f5 fd0b 	bl	8000578 <__aeabi_fcmpeq>
 800ab62:	2800      	cmp	r0, #0
 800ab64:	d1f1      	bne.n	800ab4a <cmd_edelay+0xa>
    electrical_delay = picoseconds;
 800ab66:	512e      	str	r6, [r5, r4]
    force_set_markmap();
 800ab68:	f002 fdba 	bl	800d6e0 <force_set_markmap>
 800ab6c:	e7ed      	b.n	800ab4a <cmd_edelay+0xa>
    chprintf(chp, "%f\r\n", electrical_delay);
 800ab6e:	4a07      	ldr	r2, [pc, #28]	; (800ab8c <cmd_edelay+0x4c>)
 800ab70:	4b05      	ldr	r3, [pc, #20]	; (800ab88 <cmd_edelay+0x48>)
 800ab72:	58d0      	ldr	r0, [r2, r3]
 800ab74:	f7f8 fc34 	bl	80033e0 <__aeabi_f2d>
 800ab78:	0002      	movs	r2, r0
 800ab7a:	000b      	movs	r3, r1
 800ab7c:	0020      	movs	r0, r4
 800ab7e:	4904      	ldr	r1, [pc, #16]	; (800ab90 <cmd_edelay+0x50>)
 800ab80:	f7fc fcc6 	bl	8007510 <chprintf>
    return;
 800ab84:	e7e1      	b.n	800ab4a <cmd_edelay+0xa>
 800ab86:	46c0      	nop			; (mov r8, r8)
 800ab88:	0000116c 	.word	0x0000116c
 800ab8c:	20000454 	.word	0x20000454
 800ab90:	080142d4 	.word	0x080142d4
	...

0800aba0 <set_electrical_delay>:
{
 800aba0:	b570      	push	{r4, r5, r6, lr}
  if (electrical_delay != picoseconds) {
 800aba2:	4d07      	ldr	r5, [pc, #28]	; (800abc0 <set_electrical_delay+0x20>)
 800aba4:	4c07      	ldr	r4, [pc, #28]	; (800abc4 <set_electrical_delay+0x24>)
{
 800aba6:	1c06      	adds	r6, r0, #0
  if (electrical_delay != picoseconds) {
 800aba8:	1c01      	adds	r1, r0, #0
 800abaa:	5928      	ldr	r0, [r5, r4]
 800abac:	f7f5 fce4 	bl	8000578 <__aeabi_fcmpeq>
 800abb0:	2800      	cmp	r0, #0
 800abb2:	d000      	beq.n	800abb6 <set_electrical_delay+0x16>
}
 800abb4:	bd70      	pop	{r4, r5, r6, pc}
    electrical_delay = picoseconds;
 800abb6:	512e      	str	r6, [r5, r4]
    force_set_markmap();
 800abb8:	f002 fd92 	bl	800d6e0 <force_set_markmap>
}
 800abbc:	e7fa      	b.n	800abb4 <set_electrical_delay+0x14>
 800abbe:	46c0      	nop			; (mov r8, r8)
 800abc0:	20000454 	.word	0x20000454
 800abc4:	0000116c 	.word	0x0000116c
	...

0800abd0 <get_electrical_delay>:
  return electrical_delay;
 800abd0:	4a01      	ldr	r2, [pc, #4]	; (800abd8 <get_electrical_delay+0x8>)
 800abd2:	4b02      	ldr	r3, [pc, #8]	; (800abdc <get_electrical_delay+0xc>)
 800abd4:	58d0      	ldr	r0, [r2, r3]
}
 800abd6:	4770      	bx	lr
 800abd8:	20000454 	.word	0x20000454
 800abdc:	0000116c 	.word	0x0000116c

0800abe0 <main>:
  .datamode =     DAC_DHRM_12BIT_RIGHT
};
#endif

int main(void)
{
 800abe0:	b5f0      	push	{r4, r5, r6, r7, lr}
 800abe2:	46c6      	mov	lr, r8
 800abe4:	b500      	push	{lr}
 800abe6:	b082      	sub	sp, #8
    halInit();
 800abe8:	f7f9 fb0a 	bl	8004200 <halInit>
    chSysInit();
 800abec:	f7f8 fe60 	bl	80038b0 <chSysInit>

    chMtxObjectInit(&mutex_sweep);
 800abf0:	4840      	ldr	r0, [pc, #256]	; (800acf4 <main+0x114>)
 800abf2:	f7f9 fa05 	bl	8004000 <chMtxObjectInit>
    chMtxObjectInit(&mutex_ili9341);
 800abf6:	4840      	ldr	r0, [pc, #256]	; (800acf8 <main+0x118>)
 800abf8:	f7f9 fa02 	bl	8004000 <chMtxObjectInit>

/*
      * SPI LCD Initialize
      */
     ili9341_init();
 800abfc:	f005 fc70 	bl	80104e0 <ili9341_init>
     show_logo();
 800ac00:	f005 f83e 	bl	800fc80 <show_logo>

    //palSetPadMode(GPIOB, 8, PAL_MODE_ALTERNATE(1) | PAL_STM32_OTYPE_OPENDRAIN);
    //palSetPadMode(GPIOB, 9, PAL_MODE_ALTERNATE(1) | PAL_STM32_OTYPE_OPENDRAIN);
    i2cStart(&I2CD1, &i2ccfg);
 800ac04:	493d      	ldr	r1, [pc, #244]	; (800acfc <main+0x11c>)
 800ac06:	483e      	ldr	r0, [pc, #248]	; (800ad00 <main+0x120>)
 800ac08:	f7f9 ff5a 	bl	8004ac0 <i2cStart>
    while (!si5351_init()) {
        ili9341_drawstring_size("error: si5351_init failed", 0, 0, RGBHEX(0xff0000), 0x0000, 2);
 800ac0c:	2402      	movs	r4, #2
 800ac0e:	4d3d      	ldr	r5, [pc, #244]	; (800ad04 <main+0x124>)
    while (!si5351_init()) {
 800ac10:	e007      	b.n	800ac22 <main+0x42>
        ili9341_drawstring_size("error: si5351_init failed", 0, 0, RGBHEX(0xff0000), 0x0000, 2);
 800ac12:	9000      	str	r0, [sp, #0]
 800ac14:	9401      	str	r4, [sp, #4]
 800ac16:	23f8      	movs	r3, #248	; 0xf8
 800ac18:	2200      	movs	r2, #0
 800ac1a:	2100      	movs	r1, #0
 800ac1c:	0028      	movs	r0, r5
 800ac1e:	f005 feaf 	bl	8010980 <ili9341_drawstring_size>
    while (!si5351_init()) {
 800ac22:	f000 fa8d 	bl	800b140 <si5351_init>
 800ac26:	2800      	cmp	r0, #0
 800ac28:	d0f3      	beq.n	800ac12 <main+0x32>
    // MCO on PA8
    //palSetPadMode(GPIOA, 8, PAL_MODE_ALTERNATE(0));
  /*
   * Initializes a serial-over-USB CDC driver.
   */
    sduObjectInit(&SDU1);
 800ac2a:	4c37      	ldr	r4, [pc, #220]	; (800ad08 <main+0x128>)
  /*
   * Activates the USB driver and then the USB bus pull-up on D+.
   * Note, a delay is inserted in order to not have to disconnect the cable
   * after a reset.
   */
    usbDisconnectBus(serusbcfg.usbp);
 800ac2c:	4d37      	ldr	r5, [pc, #220]	; (800ad0c <main+0x12c>)
    sduObjectInit(&SDU1);
 800ac2e:	0020      	movs	r0, r4
 800ac30:	f7fa f93e 	bl	8004eb0 <sduObjectInit>
    sduStart(&SDU1, &serusbcfg);
 800ac34:	4e36      	ldr	r6, [pc, #216]	; (800ad10 <main+0x130>)
 800ac36:	0020      	movs	r0, r4
 800ac38:	0031      	movs	r1, r6
 800ac3a:	f7fa f961 	bl	8004f00 <sduStart>
    chThdSleepMilliseconds(100);
 800ac3e:	20fa      	movs	r0, #250	; 0xfa
    usbDisconnectBus(serusbcfg.usbp);
 800ac40:	4a34      	ldr	r2, [pc, #208]	; (800ad14 <main+0x134>)
 800ac42:	6dab      	ldr	r3, [r5, #88]	; 0x58
    chThdSleepMilliseconds(100);
 800ac44:	0080      	lsls	r0, r0, #2
    usbDisconnectBus(serusbcfg.usbp);
 800ac46:	4013      	ands	r3, r2
 800ac48:	65ab      	str	r3, [r5, #88]	; 0x58
    chThdSleepMilliseconds(100);
 800ac4a:	f7f9 f961 	bl	8003f10 <chThdSleep>
    usbStart(serusbcfg.usbp, &usbcfg);
 800ac4e:	4932      	ldr	r1, [pc, #200]	; (800ad18 <main+0x138>)
 800ac50:	6830      	ldr	r0, [r6, #0]
 800ac52:	f7fa faad 	bl	80051b0 <usbStart>
    usbConnectBus(serusbcfg.usbp);
 800ac56:	2380      	movs	r3, #128	; 0x80
 800ac58:	6daa      	ldr	r2, [r5, #88]	; 0x58
 800ac5a:	021b      	lsls	r3, r3, #8
 800ac5c:	4313      	orrs	r3, r2
 800ac5e:	65ab      	str	r3, [r5, #88]	; 0x58


    /*
    * Initialize graph plotting
    */
    plot_init();
 800ac60:	f003 fb9e 	bl	800e3a0 <plot_init>

  /* restore config */
  config_recall();
 800ac64:	f006 f804 	bl	8010c70 <config_recall>
   */
  dacStart(&DACD2, &dac1cfg1);
#endif

  /* initial frequencies */
  update_frequencies();
 800ac68:	f7fd f8ba 	bl	8007de0 <update_frequencies>

  /* restore frequencies and calibration properties from flash memory */
  if (config.default_loadcal >= 0)
 800ac6c:	201a      	movs	r0, #26
 800ac6e:	4b2b      	ldr	r3, [pc, #172]	; (800ad1c <main+0x13c>)
 800ac70:	5618      	ldrsb	r0, [r3, r0]
 800ac72:	2800      	cmp	r0, #0
 800ac74:	db01      	blt.n	800ac7a <main+0x9a>
    caldata_recall(config.default_loadcal);
 800ac76:	f006 f8b3 	bl	8010de0 <caldata_recall>


  /*
   * I2S Initialize
   */
  tlv320aic3204_init();
 800ac7a:	f000 fc29 	bl	800b4d0 <tlv320aic3204_init>
  i2sInit();
 800ac7e:	f7f9 ff5f 	bl	8004b40 <i2sInit>
  i2sObjectInit(&I2SD2);
 800ac82:	4d27      	ldr	r5, [pc, #156]	; (800ad20 <main+0x140>)
 800ac84:	0028      	movs	r0, r5
 800ac86:	f7f9 ff63 	bl	8004b50 <i2sObjectInit>
  i2sStart(&I2SD2, &i2sconfig);
 800ac8a:	4926      	ldr	r1, [pc, #152]	; (800ad24 <main+0x144>)
 800ac8c:	0028      	movs	r0, r5
 800ac8e:	f7f9 ff67 	bl	8004b60 <i2sStart>
  i2sStartExchange(&I2SD2);
 800ac92:	0028      	movs	r0, r5
 800ac94:	f7f9 ff74 	bl	8004b80 <i2sStartExchange>

  ui_init();
 800ac98:	f005 fb5a 	bl	8010350 <ui_init>

  /*
   * Shell manager initialization.
   */
    shellInit();
 800ac9c:	f7fc fd08 	bl	80076b0 <shellInit>


    // redraw_frame();
     draw_frequencies();
 800aca0:	f003 f8c6 	bl	800de30 <draw_frequencies>
     draw_cal_status();
 800aca4:	f003 f9d4 	bl	800e050 <draw_cal_status>
	 
    chThdSetPriority(HIGHPRIO);
 800aca8:	20ff      	movs	r0, #255	; 0xff
 800acaa:	f7f9 f919 	bl	8003ee0 <chThdSetPriority>
    chThdCreateStatic(waThread1, sizeof(waThread1), NORMALPRIO, Thread1, NULL);
 800acae:	2300      	movs	r3, #0
 800acb0:	21d0      	movs	r1, #208	; 0xd0
 800acb2:	9300      	str	r3, [sp, #0]
 800acb4:	2280      	movs	r2, #128	; 0x80
 800acb6:	4b1c      	ldr	r3, [pc, #112]	; (800ad28 <main+0x148>)
 800acb8:	0089      	lsls	r1, r1, #2
 800acba:	481c      	ldr	r0, [pc, #112]	; (800ad2c <main+0x14c>)
 800acbc:	f7f9 f880 	bl	8003dc0 <chThdCreateStatic>
 800acc0:	4b1b      	ldr	r3, [pc, #108]	; (800ad30 <main+0x150>)

    while (1) {
        if (SDU1.config->usbp->state == USB_ACTIVE) {
 800acc2:	25be      	movs	r5, #190	; 0xbe
 800acc4:	4698      	mov	r8, r3
 800acc6:	4f1b      	ldr	r7, [pc, #108]	; (800ad34 <main+0x154>)
 800acc8:	4e1b      	ldr	r6, [pc, #108]	; (800ad38 <main+0x158>)
 800acca:	006d      	lsls	r5, r5, #1
 800accc:	5963      	ldr	r3, [r4, r5]
 800acce:	681b      	ldr	r3, [r3, #0]
 800acd0:	781b      	ldrb	r3, [r3, #0]
 800acd2:	2b04      	cmp	r3, #4
 800acd4:	d109      	bne.n	800acea <main+0x10a>
            thread_t *shelltp = chThdCreateStatic(
 800acd6:	21b8      	movs	r1, #184	; 0xb8
 800acd8:	4643      	mov	r3, r8
 800acda:	2281      	movs	r2, #129	; 0x81
 800acdc:	0089      	lsls	r1, r1, #2
 800acde:	9600      	str	r6, [sp, #0]
 800ace0:	0038      	movs	r0, r7
 800ace2:	f7f9 f86d 	bl	8003dc0 <chThdCreateStatic>
                waThread2, sizeof(waThread2),
                NORMALPRIO + 1,
                shellThread, (void*)&shell_cfg1);
            chThdWait(shelltp);               /* Waiting termination.             */
 800ace6:	f7f9 f8e3 	bl	8003eb0 <chThdWait>
        }
        chThdSleepMilliseconds(1000);
 800acea:	4814      	ldr	r0, [pc, #80]	; (800ad3c <main+0x15c>)
 800acec:	f7f9 f910 	bl	8003f10 <chThdSleep>
        if (SDU1.config->usbp->state == USB_ACTIVE) {
 800acf0:	e7ec      	b.n	800accc <main+0xec>
 800acf2:	46c0      	nop			; (mov r8, r8)
 800acf4:	20002220 	.word	0x20002220
 800acf8:	2000220c 	.word	0x2000220c
 800acfc:	0801456c 	.word	0x0801456c
 800ad00:	20001844 	.word	0x20001844
 800ad04:	08014590 	.word	0x08014590
 800ad08:	20001a0c 	.word	0x20001a0c
 800ad0c:	40005c00 	.word	0x40005c00
 800ad10:	08013d24 	.word	0x08013d24
 800ad14:	ffff7fff 	.word	0xffff7fff
 800ad18:	08013d2c 	.word	0x08013d2c
 800ad1c:	2000042c 	.word	0x2000042c
 800ad20:	20001880 	.word	0x20001880
 800ad24:	08014578 	.word	0x08014578
 800ad28:	08008e41 	.word	0x08008e41
 800ad2c:	200023c8 	.word	0x200023c8
 800ad30:	080077a1 	.word	0x080077a1
 800ad34:	20002708 	.word	0x20002708
 800ad38:	080145ac 	.word	0x080145ac
 800ad3c:	00002710 	.word	0x00002710

0800ad40 <HardFault_Handler>:
}

// see also ch.dbg.panic_msg
void HardFault_Handler(void)
{
    while (true) {}
 800ad40:	e7fe      	b.n	800ad40 <HardFault_Handler>
 800ad42:	46c0      	nop			; (mov r8, r8)
	...

0800ad50 <si5351_bulk_write>:
  i2cReleaseBus(&I2CD1);
  return mr == MSG_OK;
}

static bool si5351_bulk_write(const uint8_t *buf, int len)
{
 800ad50:	b570      	push	{r4, r5, r6, lr}
  int addr = SI5351_I2C_ADDR>>1;
  i2cAcquireBus(&I2CD1);
 800ad52:	4d0e      	ldr	r5, [pc, #56]	; (800ad8c <si5351_bulk_write+0x3c>)
{
 800ad54:	b084      	sub	sp, #16
 800ad56:	0004      	movs	r4, r0
  i2cAcquireBus(&I2CD1);
 800ad58:	0028      	movs	r0, r5
{
 800ad5a:	000e      	movs	r6, r1
  i2cAcquireBus(&I2CD1);
 800ad5c:	f7f9 fee0 	bl	8004b20 <i2cAcquireBus>
  msg_t mr = i2cMasterTransmitTimeout(&I2CD1, addr, buf, len, NULL, 0, 1000);
 800ad60:	23fa      	movs	r3, #250	; 0xfa
 800ad62:	009b      	lsls	r3, r3, #2
 800ad64:	9302      	str	r3, [sp, #8]
 800ad66:	2300      	movs	r3, #0
 800ad68:	0022      	movs	r2, r4
 800ad6a:	9301      	str	r3, [sp, #4]
 800ad6c:	9300      	str	r3, [sp, #0]
 800ad6e:	2160      	movs	r1, #96	; 0x60
 800ad70:	0033      	movs	r3, r6
 800ad72:	0028      	movs	r0, r5
 800ad74:	f7f9 feb4 	bl	8004ae0 <i2cMasterTransmitTimeout>
 800ad78:	0004      	movs	r4, r0
  i2cReleaseBus(&I2CD1);
 800ad7a:	0028      	movs	r0, r5
 800ad7c:	f7f9 fed8 	bl	8004b30 <i2cReleaseBus>
  return mr == MSG_OK;
 800ad80:	4260      	negs	r0, r4
 800ad82:	4160      	adcs	r0, r4
 800ad84:	b2c0      	uxtb	r0, r0
}
 800ad86:	b004      	add	sp, #16
 800ad88:	bd70      	pop	{r4, r5, r6, pc}
 800ad8a:	46c0      	nop			; (mov r8, r8)
 800ad8c:	20001844 	.word	0x20001844

0800ad90 <si5351_setupPLL>:
static void si5351_setupPLL(
    uint8_t     pll, /* SI5351_PLL_A or SI5351_PLL_B */
    uint8_t     mult,
    uint32_t    num,
    uint32_t    denom)
{
 800ad90:	b5f0      	push	{r4, r5, r6, r7, lr}
 800ad92:	b085      	sub	sp, #20
 800ad94:	000c      	movs	r4, r1
  /* Get the appropriate starting point for the PLL registers */
  const uint8_t pllreg_base[] = {
 800ad96:	4669      	mov	r1, sp
{
 800ad98:	001e      	movs	r6, r3
  const uint8_t pllreg_base[] = {
 800ad9a:	4b1c      	ldr	r3, [pc, #112]	; (800ae0c <si5351_setupPLL+0x7c>)
{
 800ad9c:	0005      	movs	r5, r0
  const uint8_t pllreg_base[] = {
 800ad9e:	800b      	strh	r3, [r1, #0]
   * P3 register is a 20-bit value using the following formula:
   * 	P3[19:0] = denom
   */

  /* Set the main PLL config registers */
  if (num == 0)
 800ada0:	2a00      	cmp	r2, #0
 800ada2:	d11b      	bne.n	800addc <si5351_setupPLL+0x4c>
  {
    /* Integer mode */
    P1 = 128 * mult - 512;
 800ada4:	2300      	movs	r3, #0
 800ada6:	1f22      	subs	r2, r4, #4
 800ada8:	2100      	movs	r1, #0
 800adaa:	2600      	movs	r6, #0
 800adac:	469c      	mov	ip, r3
 800adae:	2701      	movs	r7, #1
 800adb0:	2400      	movs	r4, #0
 800adb2:	01d2      	lsls	r2, r2, #7
    P3 = denom;
  }

  /* The datasheet is a nightmare of typos and inconsistencies here! */
  uint8_t reg[9];
  reg[0] = pllreg_base[pll];
 800adb4:	466b      	mov	r3, sp
 800adb6:	5d5d      	ldrb	r5, [r3, r5]
  reg[1] = (P3 & 0x0000FF00) >> 8;
  reg[2] = (P3 & 0x000000FF);
  reg[3] = (P1 & 0x00030000) >> 16;
  reg[4] = (P1 & 0x0000FF00) >> 8;
  reg[5] = (P1 & 0x000000FF);
  reg[6] = ((P3 & 0x000F0000) >> 12) | ((P2 & 0x000F0000) >> 16);
 800adb8:	4663      	mov	r3, ip
  reg[0] = pllreg_base[pll];
 800adba:	a801      	add	r0, sp, #4
  reg[1] = (P3 & 0x0000FF00) >> 8;
 800adbc:	7044      	strb	r4, [r0, #1]
  reg[3] = (P1 & 0x00030000) >> 16;
 800adbe:	0394      	lsls	r4, r2, #14
  reg[4] = (P1 & 0x0000FF00) >> 8;
 800adc0:	ba52      	rev16	r2, r2
  reg[3] = (P1 & 0x00030000) >> 16;
 800adc2:	0fa4      	lsrs	r4, r4, #30
  reg[4] = (P1 & 0x0000FF00) >> 8;
 800adc4:	8082      	strh	r2, [r0, #4]
  reg[7] = (P2 & 0x0000FF00) >> 8;
  reg[8] = (P2 & 0x000000FF);
 800adc6:	7201      	strb	r1, [r0, #8]
  si5351_bulk_write(reg, 9);
 800adc8:	2109      	movs	r1, #9
  reg[0] = pllreg_base[pll];
 800adca:	7005      	strb	r5, [r0, #0]
  reg[2] = (P3 & 0x000000FF);
 800adcc:	7087      	strb	r7, [r0, #2]
  reg[3] = (P1 & 0x00030000) >> 16;
 800adce:	70c4      	strb	r4, [r0, #3]
  reg[6] = ((P3 & 0x000F0000) >> 12) | ((P2 & 0x000F0000) >> 16);
 800add0:	7183      	strb	r3, [r0, #6]
  reg[7] = (P2 & 0x0000FF00) >> 8;
 800add2:	71c6      	strb	r6, [r0, #7]
  si5351_bulk_write(reg, 9);
 800add4:	f7ff ffbc 	bl	800ad50 <si5351_bulk_write>
}
 800add8:	b005      	add	sp, #20
 800adda:	bdf0      	pop	{r4, r5, r6, r7, pc}
    P1 = 128 * mult + ((128 * num) / denom) - 512;
 800addc:	01d0      	lsls	r0, r2, #7
 800adde:	0031      	movs	r1, r6
 800ade0:	f7f5 fa7c 	bl	80002dc <__aeabi_uidivmod>
 800ade4:	01e4      	lsls	r4, r4, #7
 800ade6:	1824      	adds	r4, r4, r0
 800ade8:	200f      	movs	r0, #15
 800adea:	4b09      	ldr	r3, [pc, #36]	; (800ae10 <si5351_setupPLL+0x80>)
 800adec:	b2f7      	uxtb	r7, r6
 800adee:	18e2      	adds	r2, r4, r3
    P3 = denom;
 800adf0:	0a34      	lsrs	r4, r6, #8
 800adf2:	0b33      	lsrs	r3, r6, #12
 800adf4:	0c0e      	lsrs	r6, r1, #16
 800adf6:	4383      	bics	r3, r0
 800adf8:	4030      	ands	r0, r6
 800adfa:	4303      	orrs	r3, r0
 800adfc:	0a0e      	lsrs	r6, r1, #8
 800adfe:	b2db      	uxtb	r3, r3
 800ae00:	b2e4      	uxtb	r4, r4
 800ae02:	469c      	mov	ip, r3
 800ae04:	b2f6      	uxtb	r6, r6
 800ae06:	b2c9      	uxtb	r1, r1
 800ae08:	e7d4      	b.n	800adb4 <si5351_setupPLL+0x24>
 800ae0a:	46c0      	nop			; (mov r8, r8)
 800ae0c:	0000221a 	.word	0x0000221a
 800ae10:	fffffe00 	.word	0xfffffe00
	...

0800ae20 <si5351_write>:
{
 800ae20:	b530      	push	{r4, r5, lr}
  i2cAcquireBus(&I2CD1);
 800ae22:	4d0e      	ldr	r5, [pc, #56]	; (800ae5c <si5351_write+0x3c>)
{
 800ae24:	b087      	sub	sp, #28
  uint8_t buf[] = { reg, dat };
 800ae26:	ac05      	add	r4, sp, #20
 800ae28:	7020      	strb	r0, [r4, #0]
  i2cAcquireBus(&I2CD1);
 800ae2a:	0028      	movs	r0, r5
  uint8_t buf[] = { reg, dat };
 800ae2c:	7061      	strb	r1, [r4, #1]
  i2cAcquireBus(&I2CD1);
 800ae2e:	f7f9 fe77 	bl	8004b20 <i2cAcquireBus>
  msg_t mr = i2cMasterTransmitTimeout(&I2CD1, addr, buf, 2, NULL, 0, 1000);
 800ae32:	23fa      	movs	r3, #250	; 0xfa
 800ae34:	009b      	lsls	r3, r3, #2
 800ae36:	9302      	str	r3, [sp, #8]
 800ae38:	2300      	movs	r3, #0
 800ae3a:	0022      	movs	r2, r4
 800ae3c:	9301      	str	r3, [sp, #4]
 800ae3e:	9300      	str	r3, [sp, #0]
 800ae40:	2160      	movs	r1, #96	; 0x60
 800ae42:	3302      	adds	r3, #2
 800ae44:	0028      	movs	r0, r5
 800ae46:	f7f9 fe4b 	bl	8004ae0 <i2cMasterTransmitTimeout>
 800ae4a:	0004      	movs	r4, r0
  i2cReleaseBus(&I2CD1);
 800ae4c:	0028      	movs	r0, r5
 800ae4e:	f7f9 fe6f 	bl	8004b30 <i2cReleaseBus>
  return mr == MSG_OK;
 800ae52:	4260      	negs	r0, r4
 800ae54:	4160      	adcs	r0, r4
 800ae56:	b2c0      	uxtb	r0, r0
}
 800ae58:	b007      	add	sp, #28
 800ae5a:	bd30      	pop	{r4, r5, pc}
 800ae5c:	20001844 	.word	0x20001844

0800ae60 <si5351_setupMultisynth>:
    uint32_t    div, // 4,6,8, 8+ ~ 900
    uint32_t    num,
    uint32_t    denom,
    uint32_t    rdiv, // SI5351_R_DIV_1~128
    uint8_t     drive_strength)
{
 800ae60:	b5f0      	push	{r4, r5, r6, r7, lr}
 800ae62:	464e      	mov	r6, r9
 800ae64:	4645      	mov	r5, r8
 800ae66:	4657      	mov	r7, sl
 800ae68:	46de      	mov	lr, fp
 800ae6a:	b5e0      	push	{r5, r6, r7, lr}
 800ae6c:	b08b      	sub	sp, #44	; 0x2c
 800ae6e:	001f      	movs	r7, r3
 800ae70:	ab16      	add	r3, sp, #88	; 0x58
 800ae72:	781b      	ldrb	r3, [r3, #0]
  /* Get the appropriate starting point for the PLL registers */
  const uint8_t msreg_base[] = {
 800ae74:	ad05      	add	r5, sp, #20
{
 800ae76:	9303      	str	r3, [sp, #12]
  const uint8_t msreg_base[] = {
 800ae78:	4b45      	ldr	r3, [pc, #276]	; (800af90 <si5351_setupMultisynth+0x130>)
    SI5351_REG_42_MULTISYNTH0,
    SI5351_REG_50_MULTISYNTH1,
    SI5351_REG_58_MULTISYNTH2,
  };
  const uint8_t clkctrl[] = {
 800ae7a:	ac06      	add	r4, sp, #24
  const uint8_t msreg_base[] = {
 800ae7c:	802b      	strh	r3, [r5, #0]
 800ae7e:	233a      	movs	r3, #58	; 0x3a
 800ae80:	70ab      	strb	r3, [r5, #2]
  const uint8_t clkctrl[] = {
 800ae82:	4b44      	ldr	r3, [pc, #272]	; (800af94 <si5351_setupMultisynth+0x134>)
{
 800ae84:	0006      	movs	r6, r0
  const uint8_t clkctrl[] = {
 800ae86:	8023      	strh	r3, [r4, #0]
 800ae88:	2312      	movs	r3, #18
{
 800ae8a:	4688      	mov	r8, r1
 800ae8c:	4691      	mov	r9, r2
  const uint8_t clkctrl[] = {
 800ae8e:	70a3      	strb	r3, [r4, #2]
   * 	P2[19:0] = 128 * b - c * floor(128*(b/c))
   * P3 register is a 20-bit value using the following formula:
   * 	P3[19:0] = c
   */
  /* Set the main PLL config registers */
  if (div == 4) {
 800ae90:	2a04      	cmp	r2, #4
 800ae92:	d06e      	beq.n	800af72 <si5351_setupMultisynth+0x112>
    div4 = SI5351_DIVBY4;
    P1 = P2 = 0;
    P3 = 1;
  } else if (num == 0) {
 800ae94:	2f00      	cmp	r7, #0
 800ae96:	d053      	beq.n	800af40 <si5351_setupMultisynth+0xe0>
    P1 = 128 * div - 512;
    P2 = 0;
    P3 = 1;
  } else {
    /* Fractional mode */
    P1 = 128 * div + ((128 * num) / denom) - 512;
 800ae98:	01f8      	lsls	r0, r7, #7
 800ae9a:	9914      	ldr	r1, [sp, #80]	; 0x50
 800ae9c:	f7f5 fa1e 	bl	80002dc <__aeabi_uidivmod>
 800aea0:	464b      	mov	r3, r9
 800aea2:	01db      	lsls	r3, r3, #7
 800aea4:	1818      	adds	r0, r3, r0
 800aea6:	4b3c      	ldr	r3, [pc, #240]	; (800af98 <si5351_setupMultisynth+0x138>)
 800aea8:	469c      	mov	ip, r3
 800aeaa:	9b14      	ldr	r3, [sp, #80]	; 0x50
 800aeac:	4460      	add	r0, ip
    P2 = 128 * num - denom * ((128 * num) / denom);
    P3 = denom;
 800aeae:	0a1b      	lsrs	r3, r3, #8
 800aeb0:	b2db      	uxtb	r3, r3
 800aeb2:	4699      	mov	r9, r3
 800aeb4:	9b14      	ldr	r3, [sp, #80]	; 0x50
 800aeb6:	0a02      	lsrs	r2, r0, #8
 800aeb8:	b2db      	uxtb	r3, r3
 800aeba:	b2d2      	uxtb	r2, r2
 800aebc:	469b      	mov	fp, r3
 800aebe:	9201      	str	r2, [sp, #4]
 800aec0:	0383      	lsls	r3, r0, #14
 800aec2:	b2c2      	uxtb	r2, r0
 800aec4:	200f      	movs	r0, #15
 800aec6:	9202      	str	r2, [sp, #8]
 800aec8:	9a14      	ldr	r2, [sp, #80]	; 0x50
 800aeca:	0f9b      	lsrs	r3, r3, #30
 800aecc:	0b12      	lsrs	r2, r2, #12
 800aece:	4382      	bics	r2, r0
 800aed0:	4692      	mov	sl, r2
 800aed2:	0c0a      	lsrs	r2, r1, #16
 800aed4:	4010      	ands	r0, r2
 800aed6:	4652      	mov	r2, sl
 800aed8:	4302      	orrs	r2, r0
 800aeda:	0a08      	lsrs	r0, r1, #8
 800aedc:	b2c0      	uxtb	r0, r0
 800aede:	4684      	mov	ip, r0
    P2 = 128 * num - denom * ((128 * num) / denom);
 800aee0:	2000      	movs	r0, #0
 800aee2:	4682      	mov	sl, r0
 800aee4:	b2d2      	uxtb	r2, r2
 800aee6:	b2c9      	uxtb	r1, r1
  }

  /* Set the MSx config registers */
  uint8_t reg[9];
  reg[0] = msreg_base[output];
 800aee8:	5dad      	ldrb	r5, [r5, r6]
 800aeea:	a807      	add	r0, sp, #28
 800aeec:	7005      	strb	r5, [r0, #0]
  reg[1] = (P3 & 0x0000FF00) >> 8;
 800aeee:	464d      	mov	r5, r9
 800aef0:	7045      	strb	r5, [r0, #1]
  reg[2] = (P3 & 0x000000FF);
 800aef2:	465d      	mov	r5, fp
 800aef4:	7085      	strb	r5, [r0, #2]
  reg[3] = ((P1 & 0x00030000) >> 16) | div4 | rdiv;
 800aef6:	4655      	mov	r5, sl
 800aef8:	432b      	orrs	r3, r5
 800aefa:	9d15      	ldr	r5, [sp, #84]	; 0x54
  reg[4] = (P1 & 0x0000FF00) >> 8;
  reg[5] = (P1 & 0x000000FF);
  reg[6] = ((P3 & 0x000F0000) >> 12) | ((P2 & 0x000F0000) >> 16);
  reg[7] = (P2 & 0x0000FF00) >> 8;
  reg[8] = (P2 & 0x000000FF);
 800aefc:	7201      	strb	r1, [r0, #8]
  reg[3] = ((P1 & 0x00030000) >> 16) | div4 | rdiv;
 800aefe:	432b      	orrs	r3, r5
 800af00:	70c3      	strb	r3, [r0, #3]
  reg[4] = (P1 & 0x0000FF00) >> 8;
 800af02:	9b01      	ldr	r3, [sp, #4]
  si5351_bulk_write(reg, 9);
 800af04:	2109      	movs	r1, #9
  reg[4] = (P1 & 0x0000FF00) >> 8;
 800af06:	7103      	strb	r3, [r0, #4]
  reg[5] = (P1 & 0x000000FF);
 800af08:	9b02      	ldr	r3, [sp, #8]
  reg[6] = ((P3 & 0x000F0000) >> 12) | ((P2 & 0x000F0000) >> 16);
 800af0a:	7182      	strb	r2, [r0, #6]
  reg[5] = (P1 & 0x000000FF);
 800af0c:	7143      	strb	r3, [r0, #5]
  reg[7] = (P2 & 0x0000FF00) >> 8;
 800af0e:	4663      	mov	r3, ip
 800af10:	71c3      	strb	r3, [r0, #7]
  si5351_bulk_write(reg, 9);
 800af12:	f7ff ff1d 	bl	800ad50 <si5351_bulk_write>

  /* Configure the clk control and enable the output */
  dat = drive_strength | SI5351_CLK_INPUT_MULTISYNTH_N;
  if (pllSource == SI5351_PLL_B)
 800af16:	4643      	mov	r3, r8
 800af18:	2b01      	cmp	r3, #1
 800af1a:	d025      	beq.n	800af68 <si5351_setupMultisynth+0x108>
  dat = drive_strength | SI5351_CLK_INPUT_MULTISYNTH_N;
 800af1c:	210c      	movs	r1, #12
 800af1e:	9b03      	ldr	r3, [sp, #12]
 800af20:	430b      	orrs	r3, r1
 800af22:	0019      	movs	r1, r3
    dat |= SI5351_CLK_PLL_SELECT_B;
  if (num == 0)
 800af24:	2f00      	cmp	r7, #0
 800af26:	d101      	bne.n	800af2c <si5351_setupMultisynth+0xcc>
    dat |= SI5351_CLK_INTEGER_MODE;
 800af28:	2340      	movs	r3, #64	; 0x40
 800af2a:	4319      	orrs	r1, r3
  si5351_write(clkctrl[output], dat);
 800af2c:	5da0      	ldrb	r0, [r4, r6]
 800af2e:	f7ff ff77 	bl	800ae20 <si5351_write>
}
 800af32:	b00b      	add	sp, #44	; 0x2c
 800af34:	bc3c      	pop	{r2, r3, r4, r5}
 800af36:	4690      	mov	r8, r2
 800af38:	4699      	mov	r9, r3
 800af3a:	46a2      	mov	sl, r4
 800af3c:	46ab      	mov	fp, r5
 800af3e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    P1 = 128 * div - 512;
 800af40:	4816      	ldr	r0, [pc, #88]	; (800af9c <si5351_setupMultisynth+0x13c>)
 800af42:	2100      	movs	r1, #0
 800af44:	4448      	add	r0, r9
 800af46:	01c0      	lsls	r0, r0, #7
    P3 = 1;
 800af48:	0a02      	lsrs	r2, r0, #8
 800af4a:	b2d2      	uxtb	r2, r2
 800af4c:	0383      	lsls	r3, r0, #14
 800af4e:	9201      	str	r2, [sp, #4]
 800af50:	b2c2      	uxtb	r2, r0
 800af52:	2000      	movs	r0, #0
 800af54:	4682      	mov	sl, r0
 800af56:	3001      	adds	r0, #1
 800af58:	9202      	str	r2, [sp, #8]
 800af5a:	4683      	mov	fp, r0
 800af5c:	2200      	movs	r2, #0
 800af5e:	2000      	movs	r0, #0
 800af60:	0f9b      	lsrs	r3, r3, #30
 800af62:	4694      	mov	ip, r2
 800af64:	4681      	mov	r9, r0
 800af66:	e7bf      	b.n	800aee8 <si5351_setupMultisynth+0x88>
    dat |= SI5351_CLK_PLL_SELECT_B;
 800af68:	212c      	movs	r1, #44	; 0x2c
 800af6a:	9b03      	ldr	r3, [sp, #12]
 800af6c:	430b      	orrs	r3, r1
 800af6e:	0019      	movs	r1, r3
 800af70:	e7d8      	b.n	800af24 <si5351_setupMultisynth+0xc4>
 800af72:	2001      	movs	r0, #1
 800af74:	2300      	movs	r3, #0
 800af76:	4683      	mov	fp, r0
 800af78:	2000      	movs	r0, #0
 800af7a:	469c      	mov	ip, r3
 800af7c:	9302      	str	r3, [sp, #8]
 800af7e:	9301      	str	r3, [sp, #4]
 800af80:	330c      	adds	r3, #12
 800af82:	469a      	mov	sl, r3
 800af84:	2100      	movs	r1, #0
 800af86:	2200      	movs	r2, #0
 800af88:	2300      	movs	r3, #0
 800af8a:	4681      	mov	r9, r0
 800af8c:	e7ac      	b.n	800aee8 <si5351_setupMultisynth+0x88>
 800af8e:	46c0      	nop			; (mov r8, r8)
 800af90:	0000322a 	.word	0x0000322a
 800af94:	00001110 	.word	0x00001110
 800af98:	fffffe00 	.word	0xfffffe00
 800af9c:	01fffffc 	.word	0x01fffffc

0800afa0 <si5351_set_frequency_fixedpll>:
#define PLLFREQ (XTALFREQ * PLL_N)

static void si5351_set_frequency_fixedpll(
    int channel, int pll, int pllfreq, int freq,
    uint32_t rdiv, uint8_t drive_strength)
{
 800afa0:	b5f0      	push	{r4, r5, r6, r7, lr}
 800afa2:	46de      	mov	lr, fp
 800afa4:	4657      	mov	r7, sl
 800afa6:	464e      	mov	r6, r9
 800afa8:	4645      	mov	r5, r8
 800afaa:	b5e0      	push	{r5, r6, r7, lr}
 800afac:	001e      	movs	r6, r3
 800afae:	b087      	sub	sp, #28
 800afb0:	ab10      	add	r3, sp, #64	; 0x40
 800afb2:	4688      	mov	r8, r1
 800afb4:	cb02      	ldmia	r3!, {r1}
 800afb6:	0007      	movs	r7, r0
 800afb8:	781b      	ldrb	r3, [r3, #0]
 800afba:	468a      	mov	sl, r1
 800afbc:	0010      	movs	r0, r2
 800afbe:	0031      	movs	r1, r6
 800afc0:	469b      	mov	fp, r3
 800afc2:	f7f5 fa7b 	bl	80004bc <__aeabi_idivmod>
    int32_t div = pllfreq / freq; // range: 8 ~ 1800
    int32_t num = pllfreq - freq * div;
    int32_t denom = freq;
    //int32_t k = freq / (1<<20) + 1;
    int32_t k = gcd(num, denom);
 800afc6:	0034      	movs	r4, r6
 800afc8:	4681      	mov	r9, r0
 800afca:	000d      	movs	r5, r1
 800afcc:	0008      	movs	r0, r1
  while (y != 0) {
 800afce:	2e00      	cmp	r6, #0
 800afd0:	d101      	bne.n	800afd6 <si5351_set_frequency_fixedpll+0x36>
 800afd2:	e02b      	b.n	800b02c <si5351_set_frequency_fixedpll+0x8c>
 800afd4:	000c      	movs	r4, r1
    z = x % y;
 800afd6:	0021      	movs	r1, r4
 800afd8:	f7f5 f980 	bl	80002dc <__aeabi_uidivmod>
    y = z;
 800afdc:	0020      	movs	r0, r4
  while (y != 0) {
 800afde:	2900      	cmp	r1, #0
 800afe0:	d1f8      	bne.n	800afd4 <si5351_set_frequency_fixedpll+0x34>
    num /= k;
 800afe2:	0021      	movs	r1, r4
 800afe4:	0028      	movs	r0, r5
 800afe6:	f7f5 f983 	bl	80002f0 <__divsi3>
    denom /= k;
 800afea:	0021      	movs	r1, r4
    num /= k;
 800afec:	9005      	str	r0, [sp, #20]
 800afee:	0005      	movs	r5, r0
    denom /= k;
 800aff0:	0030      	movs	r0, r6
 800aff2:	f7f5 f97d 	bl	80002f0 <__divsi3>
    while (denom >= (1<<20)) {
 800aff6:	4b10      	ldr	r3, [pc, #64]	; (800b038 <si5351_set_frequency_fixedpll+0x98>)
    denom /= k;
 800aff8:	0002      	movs	r2, r0
    while (denom >= (1<<20)) {
 800affa:	4298      	cmp	r0, r3
 800affc:	dd19      	ble.n	800b032 <si5351_set_frequency_fixedpll+0x92>
      num >>= 1;
 800affe:	106d      	asrs	r5, r5, #1
      denom >>= 1;
 800b000:	1052      	asrs	r2, r2, #1
    while (denom >= (1<<20)) {
 800b002:	429a      	cmp	r2, r3
 800b004:	dcfb      	bgt.n	800affe <si5351_set_frequency_fixedpll+0x5e>
 800b006:	002b      	movs	r3, r5
    }
    si5351_setupMultisynth(channel, pll, div, num, denom, rdiv, drive_strength);
 800b008:	465c      	mov	r4, fp
 800b00a:	4641      	mov	r1, r8
 800b00c:	9402      	str	r4, [sp, #8]
 800b00e:	4654      	mov	r4, sl
 800b010:	9200      	str	r2, [sp, #0]
 800b012:	b2c9      	uxtb	r1, r1
 800b014:	b2f8      	uxtb	r0, r7
 800b016:	9401      	str	r4, [sp, #4]
 800b018:	464a      	mov	r2, r9
 800b01a:	f7ff ff21 	bl	800ae60 <si5351_setupMultisynth>
}
 800b01e:	b007      	add	sp, #28
 800b020:	bc3c      	pop	{r2, r3, r4, r5}
 800b022:	4690      	mov	r8, r2
 800b024:	4699      	mov	r9, r3
 800b026:	46a2      	mov	sl, r4
 800b028:	46ab      	mov	fp, r5
 800b02a:	bdf0      	pop	{r4, r5, r6, r7, pc}
  while (y != 0) {
 800b02c:	2301      	movs	r3, #1
    denom /= k;
 800b02e:	2200      	movs	r2, #0
 800b030:	e7ea      	b.n	800b008 <si5351_set_frequency_fixedpll+0x68>
 800b032:	9b05      	ldr	r3, [sp, #20]
 800b034:	e7e8      	b.n	800b008 <si5351_set_frequency_fixedpll+0x68>
 800b036:	46c0      	nop			; (mov r8, r8)
 800b038:	000fffff 	.word	0x000fffff
 800b03c:	00000000 	.word	0x00000000

0800b040 <si5351_set_frequency_fixeddiv>:

static void si5351_set_frequency_fixeddiv(
    int channel, int pll, int freq, int div,
    uint8_t     drive_strength)
{
 800b040:	b5f0      	push	{r4, r5, r6, r7, lr}
 800b042:	46d6      	mov	lr, sl
 800b044:	464f      	mov	r7, r9
 800b046:	4646      	mov	r6, r8
 800b048:	4698      	mov	r8, r3
 800b04a:	b5c0      	push	{r6, r7, lr}
    int32_t pllfreq = freq * div;
 800b04c:	4647      	mov	r7, r8
 800b04e:	4357      	muls	r7, r2
{
 800b050:	b084      	sub	sp, #16
 800b052:	ab0c      	add	r3, sp, #48	; 0x30
 800b054:	781b      	ldrb	r3, [r3, #0]
 800b056:	4682      	mov	sl, r0
 800b058:	000e      	movs	r6, r1
    int32_t multi = pllfreq / XTALFREQ;
 800b05a:	0038      	movs	r0, r7
 800b05c:	4922      	ldr	r1, [pc, #136]	; (800b0e8 <si5351_set_frequency_fixeddiv+0xa8>)
{
 800b05e:	4699      	mov	r9, r3
    int32_t multi = pllfreq / XTALFREQ;
 800b060:	f7f5 f946 	bl	80002f0 <__divsi3>
    int32_t num = pllfreq - multi * XTALFREQ;
 800b064:	0143      	lsls	r3, r0, #5
 800b066:	1a1b      	subs	r3, r3, r0
 800b068:	009b      	lsls	r3, r3, #2
 800b06a:	181b      	adds	r3, r3, r0
 800b06c:	009a      	lsls	r2, r3, #2
 800b06e:	189b      	adds	r3, r3, r2
 800b070:	009a      	lsls	r2, r3, #2
 800b072:	189b      	adds	r3, r3, r2
 800b074:	019a      	lsls	r2, r3, #6
 800b076:	189b      	adds	r3, r3, r2
 800b078:	01db      	lsls	r3, r3, #7
 800b07a:	1aff      	subs	r7, r7, r3
    int32_t multi = pllfreq / XTALFREQ;
 800b07c:	0005      	movs	r5, r0
    int32_t denom = XTALFREQ;
    int32_t k = gcd(num, denom);
 800b07e:	4c1a      	ldr	r4, [pc, #104]	; (800b0e8 <si5351_set_frequency_fixeddiv+0xa8>)
 800b080:	0038      	movs	r0, r7
  while (y != 0) {
 800b082:	e000      	b.n	800b086 <si5351_set_frequency_fixeddiv+0x46>
 800b084:	000c      	movs	r4, r1
    z = x % y;
 800b086:	0021      	movs	r1, r4
 800b088:	f7f5 f928 	bl	80002dc <__aeabi_uidivmod>
    y = z;
 800b08c:	0020      	movs	r0, r4
  while (y != 0) {
 800b08e:	2900      	cmp	r1, #0
 800b090:	d1f8      	bne.n	800b084 <si5351_set_frequency_fixeddiv+0x44>
    num /= k;
 800b092:	0021      	movs	r1, r4
 800b094:	0038      	movs	r0, r7
 800b096:	f7f5 f92b 	bl	80002f0 <__divsi3>
    denom /= k;
 800b09a:	0021      	movs	r1, r4
    num /= k;
 800b09c:	0007      	movs	r7, r0
    denom /= k;
 800b09e:	4812      	ldr	r0, [pc, #72]	; (800b0e8 <si5351_set_frequency_fixeddiv+0xa8>)
 800b0a0:	f7f5 f926 	bl	80002f0 <__divsi3>
    while (denom >= (1<<20)) {
 800b0a4:	4a11      	ldr	r2, [pc, #68]	; (800b0ec <si5351_set_frequency_fixeddiv+0xac>)
    denom /= k;
 800b0a6:	0003      	movs	r3, r0
    while (denom >= (1<<20)) {
 800b0a8:	4290      	cmp	r0, r2
 800b0aa:	dd03      	ble.n	800b0b4 <si5351_set_frequency_fixeddiv+0x74>
      num >>= 1;
 800b0ac:	107f      	asrs	r7, r7, #1
      denom >>= 1;
 800b0ae:	105b      	asrs	r3, r3, #1
    while (denom >= (1<<20)) {
 800b0b0:	4293      	cmp	r3, r2
 800b0b2:	dcfb      	bgt.n	800b0ac <si5351_set_frequency_fixeddiv+0x6c>
    }
    si5351_setupPLL(pll, multi, num, denom);
 800b0b4:	b2f6      	uxtb	r6, r6
 800b0b6:	b2e9      	uxtb	r1, r5
 800b0b8:	003a      	movs	r2, r7
 800b0ba:	0030      	movs	r0, r6
 800b0bc:	f7ff fe68 	bl	800ad90 <si5351_setupPLL>
    si5351_setupMultisynth(channel, pll, div, 0, 1, SI5351_R_DIV_1, drive_strength);
 800b0c0:	4653      	mov	r3, sl
 800b0c2:	b2d8      	uxtb	r0, r3
 800b0c4:	464b      	mov	r3, r9
 800b0c6:	9302      	str	r3, [sp, #8]
 800b0c8:	2300      	movs	r3, #0
 800b0ca:	9301      	str	r3, [sp, #4]
 800b0cc:	3301      	adds	r3, #1
 800b0ce:	9300      	str	r3, [sp, #0]
 800b0d0:	4642      	mov	r2, r8
 800b0d2:	2300      	movs	r3, #0
 800b0d4:	0031      	movs	r1, r6
 800b0d6:	f7ff fec3 	bl	800ae60 <si5351_setupMultisynth>
}
 800b0da:	b004      	add	sp, #16
 800b0dc:	bc1c      	pop	{r2, r3, r4}
 800b0de:	4690      	mov	r8, r2
 800b0e0:	4699      	mov	r9, r3
 800b0e2:	46a2      	mov	sl, r4
 800b0e4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800b0e6:	46c0      	nop			; (mov r8, r8)
 800b0e8:	018cba80 	.word	0x018cba80
 800b0ec:	000fffff 	.word	0x000fffff

0800b0f0 <si5351_bulk_read.constprop.0>:
static bool si5351_bulk_read(uint8_t reg, uint8_t* buf, int len)
 800b0f0:	b570      	push	{r4, r5, r6, lr}
 800b0f2:	2417      	movs	r4, #23
 800b0f4:	2300      	movs	r3, #0
    i2cAcquireBus(&I2CD1);
 800b0f6:	4d0e      	ldr	r5, [pc, #56]	; (800b130 <si5351_bulk_read.constprop.0+0x40>)
static bool si5351_bulk_read(uint8_t reg, uint8_t* buf, int len)
 800b0f8:	b086      	sub	sp, #24
 800b0fa:	446c      	add	r4, sp
 800b0fc:	0006      	movs	r6, r0
    i2cAcquireBus(&I2CD1);
 800b0fe:	0028      	movs	r0, r5
 800b100:	7023      	strb	r3, [r4, #0]
 800b102:	f7f9 fd0d 	bl	8004b20 <i2cAcquireBus>
    msg_t mr = i2cMasterTransmitTimeout(&I2CD1, addr, &reg, 1, buf, len, 1000);
 800b106:	23fa      	movs	r3, #250	; 0xfa
 800b108:	009b      	lsls	r3, r3, #2
 800b10a:	9302      	str	r3, [sp, #8]
 800b10c:	2301      	movs	r3, #1
 800b10e:	0022      	movs	r2, r4
 800b110:	9301      	str	r3, [sp, #4]
 800b112:	2160      	movs	r1, #96	; 0x60
 800b114:	9600      	str	r6, [sp, #0]
 800b116:	0028      	movs	r0, r5
 800b118:	f7f9 fce2 	bl	8004ae0 <i2cMasterTransmitTimeout>
 800b11c:	0004      	movs	r4, r0
    i2cReleaseBus(&I2CD1);
 800b11e:	0028      	movs	r0, r5
 800b120:	f7f9 fd06 	bl	8004b30 <i2cReleaseBus>
    return mr == MSG_OK;
 800b124:	4260      	negs	r0, r4
 800b126:	4160      	adcs	r0, r4
 800b128:	b2c0      	uxtb	r0, r0
}
 800b12a:	b006      	add	sp, #24
 800b12c:	bd70      	pop	{r4, r5, r6, pc}
 800b12e:	46c0      	nop			; (mov r8, r8)
 800b130:	20001844 	.word	0x20001844
	...

0800b140 <si5351_init>:
{
 800b140:	b5f0      	push	{r4, r5, r6, r7, lr}
 800b142:	46c6      	mov	lr, r8
 800b144:	b500      	push	{lr}
 800b146:	b082      	sub	sp, #8
    uint8_t status = 0xff;
 800b148:	466b      	mov	r3, sp
 800b14a:	1ddc      	adds	r4, r3, #7
 800b14c:	23ff      	movs	r3, #255	; 0xff
 800b14e:	7023      	strb	r3, [r4, #0]
  __ASM volatile ("cpsid i" : : : "memory");
 800b150:	b672      	cpsid	i
 800b152:	2580      	movs	r5, #128	; 0x80
 800b154:	05ed      	lsls	r5, r5, #23
 800b156:	6a6f      	ldr	r7, [r5, #36]	; 0x24
  __ASM volatile ("cpsie i" : : : "memory");
 800b158:	b662      	cpsie	i
            status = 0xff;  // comm timeout
 800b15a:	4698      	mov	r8, r3
    while (chVTIsSystemTimeWithin(start, end))
 800b15c:	4e15      	ldr	r6, [pc, #84]	; (800b1b4 <si5351_init+0x74>)
  __ASM volatile ("cpsid i" : : : "memory");
 800b15e:	b672      	cpsid	i
 800b160:	6a6b      	ldr	r3, [r5, #36]	; 0x24
  __ASM volatile ("cpsie i" : : : "memory");
 800b162:	b662      	cpsie	i
 800b164:	1bdb      	subs	r3, r3, r7
 800b166:	42b3      	cmp	r3, r6
 800b168:	d80c      	bhi.n	800b184 <si5351_init+0x44>
        if(!si5351_bulk_read(0, &status, 1))
 800b16a:	0020      	movs	r0, r4
 800b16c:	f7ff ffc0 	bl	800b0f0 <si5351_bulk_read.constprop.0>
 800b170:	2800      	cmp	r0, #0
 800b172:	d10c      	bne.n	800b18e <si5351_init+0x4e>
            status = 0xff;  // comm timeout
 800b174:	4643      	mov	r3, r8
 800b176:	7023      	strb	r3, [r4, #0]
  __ASM volatile ("cpsid i" : : : "memory");
 800b178:	b672      	cpsid	i
 800b17a:	6a6b      	ldr	r3, [r5, #36]	; 0x24
  __ASM volatile ("cpsie i" : : : "memory");
 800b17c:	b662      	cpsie	i
 800b17e:	1bdb      	subs	r3, r3, r7
    while (chVTIsSystemTimeWithin(start, end))
 800b180:	42b3      	cmp	r3, r6
 800b182:	d9f2      	bls.n	800b16a <si5351_init+0x2a>
      return false;
 800b184:	2000      	movs	r0, #0
}
 800b186:	b002      	add	sp, #8
 800b188:	bc04      	pop	{r2}
 800b18a:	4690      	mov	r8, r2
 800b18c:	bdf0      	pop	{r4, r5, r6, r7, pc}
        if ((status & 0x80) == 0) 
 800b18e:	7823      	ldrb	r3, [r4, #0]
 800b190:	2b7f      	cmp	r3, #127	; 0x7f
 800b192:	d8e4      	bhi.n	800b15e <si5351_init+0x1e>
  const uint8_t *p = si5351_configs;
 800b194:	4c08      	ldr	r4, [pc, #32]	; (800b1b8 <si5351_init+0x78>)
  while (*p) {
 800b196:	2502      	movs	r5, #2
 800b198:	e003      	b.n	800b1a2 <si5351_init+0x62>
    p += len;
 800b19a:	1964      	adds	r4, r4, r5
  while (*p) {
 800b19c:	7825      	ldrb	r5, [r4, #0]
 800b19e:	2d00      	cmp	r5, #0
 800b1a0:	d0f1      	beq.n	800b186 <si5351_init+0x46>
    uint8_t len = *p++;
 800b1a2:	3401      	adds	r4, #1
    if (!si5351_bulk_write(p, len))
 800b1a4:	0029      	movs	r1, r5
 800b1a6:	0020      	movs	r0, r4
 800b1a8:	f7ff fdd2 	bl	800ad50 <si5351_bulk_write>
 800b1ac:	2800      	cmp	r0, #0
 800b1ae:	d1f4      	bne.n	800b19a <si5351_init+0x5a>
 800b1b0:	e7e9      	b.n	800b186 <si5351_init+0x46>
 800b1b2:	46c0      	nop			; (mov r8, r8)
 800b1b4:	0000270f 	.word	0x0000270f
 800b1b8:	080147c4 	.word	0x080147c4
 800b1bc:	00000000 	.word	0x00000000

0800b1c0 <si5351_set_frequency_with_offset>:
 * CLK1: frequency
 * CLK2: fixed 8MHz
 */
#define CLK2_FREQUENCY 8000000L
int si5351_set_frequency_with_offset(uint32_t freq, int offset, uint8_t drive_strength)
{
 800b1c0:	b5f0      	push	{r4, r5, r6, r7, lr}
 800b1c2:	464f      	mov	r7, r9
 800b1c4:	46d6      	mov	lr, sl
 800b1c6:	4646      	mov	r6, r8
  uint32_t rdiv = SI5351_R_DIV_1;
 /* if (freq > config.harmonic_freq_threshold * 5 ) {
	    freq /= 7;
	    ofreq /= 9;
  }else */
	  if (freq > config.harmonic_freq_threshold * 3) {
 800b1c8:	4ba6      	ldr	r3, [pc, #664]	; (800b464 <si5351_set_frequency_with_offset+0x2a4>)
{
 800b1ca:	b5c0      	push	{r6, r7, lr}
 800b1cc:	0017      	movs	r7, r2
	  if (freq > config.harmonic_freq_threshold * 3) {
 800b1ce:	69da      	ldr	r2, [r3, #28]
{
 800b1d0:	b084      	sub	sp, #16
	  if (freq > config.harmonic_freq_threshold * 3) {
 800b1d2:	0053      	lsls	r3, r2, #1
 800b1d4:	189b      	adds	r3, r3, r2
{
 800b1d6:	0004      	movs	r4, r0
  uint32_t ofreq = freq + offset;
 800b1d8:	180d      	adds	r5, r1, r0
	  if (freq > config.harmonic_freq_threshold * 3) {
 800b1da:	4283      	cmp	r3, r0
 800b1dc:	d300      	bcc.n	800b1e0 <si5351_set_frequency_with_offset+0x20>
 800b1de:	e0c6      	b.n	800b36e <si5351_set_frequency_with_offset+0x1ae>
    freq /= 5;
 800b1e0:	2105      	movs	r1, #5
 800b1e2:	f7f4 fff5 	bl	80001d0 <__udivsi3>
    ofreq /= 7;
 800b1e6:	2107      	movs	r1, #7
    freq /= 5;
 800b1e8:	0004      	movs	r4, r0
    ofreq /= 7;
 800b1ea:	0028      	movs	r0, r5
 800b1ec:	f7f4 fff0 	bl	80001d0 <__udivsi3>
 800b1f0:	0005      	movs	r5, r0
  } else if (freq > config.harmonic_freq_threshold) {
    freq /= 3;
    ofreq /= 5;
  }
  if (freq <= 100000000) {
 800b1f2:	4b9d      	ldr	r3, [pc, #628]	; (800b468 <si5351_set_frequency_with_offset+0x2a8>)
 800b1f4:	429c      	cmp	r4, r3
 800b1f6:	d946      	bls.n	800b286 <si5351_set_frequency_with_offset+0xc6>
    band = 0;
  } else if (freq <= 150000000) {
 800b1f8:	4b9c      	ldr	r3, [pc, #624]	; (800b46c <si5351_set_frequency_with_offset+0x2ac>)
 800b1fa:	429c      	cmp	r4, r3
 800b1fc:	d850      	bhi.n	800b2a0 <si5351_set_frequency_with_offset+0xe0>
  } else if (freq <= 4000000) {
    rdiv = SI5351_R_DIV_8;
  }

#if 1
  if (current_band != band)
 800b1fe:	4e9c      	ldr	r6, [pc, #624]	; (800b470 <si5351_set_frequency_with_offset+0x2b0>)
 800b200:	6833      	ldr	r3, [r6, #0]
 800b202:	2b01      	cmp	r3, #1
 800b204:	d01a      	beq.n	800b23c <si5351_set_frequency_with_offset+0x7c>
  si5351_write(SI5351_REG_3_OUTPUT_ENABLE_CONTROL, 0xff);
 800b206:	21ff      	movs	r1, #255	; 0xff
 800b208:	2003      	movs	r0, #3
 800b20a:	f7ff fe09 	bl	800ae20 <si5351_write>
  reg[0] = SI5351_REG_16_CLK0_CONTROL;
 800b20e:	4b99      	ldr	r3, [pc, #612]	; (800b474 <si5351_set_frequency_with_offset+0x2b4>)
  si5351_bulk_write(reg, 4);
 800b210:	2104      	movs	r1, #4
 800b212:	a803      	add	r0, sp, #12
  reg[0] = SI5351_REG_16_CLK0_CONTROL;
 800b214:	9303      	str	r3, [sp, #12]
  si5351_bulk_write(reg, 4);
 800b216:	f7ff fd9b 	bl	800ad50 <si5351_bulk_write>
                                    SI5351_R_DIV_1, SI5351_CLK_DRIVE_STRENGTH_2MA);
    break;

  case 1:
    // Set PLL twice on changing from band 2
    if (current_band == 2) {
 800b21a:	6833      	ldr	r3, [r6, #0]
 800b21c:	2b02      	cmp	r3, #2
 800b21e:	d10d      	bne.n	800b23c <si5351_set_frequency_with_offset+0x7c>
      si5351_set_frequency_fixeddiv(0, SI5351_PLL_A, ofreq, 6, drive_strength);
 800b220:	2306      	movs	r3, #6
 800b222:	002a      	movs	r2, r5
 800b224:	2100      	movs	r1, #0
 800b226:	2000      	movs	r0, #0
 800b228:	9700      	str	r7, [sp, #0]
 800b22a:	f7ff ff09 	bl	800b040 <si5351_set_frequency_fixeddiv>
      si5351_set_frequency_fixeddiv(1, SI5351_PLL_B, freq, 6, drive_strength);
 800b22e:	9700      	str	r7, [sp, #0]
 800b230:	2306      	movs	r3, #6
 800b232:	0022      	movs	r2, r4
 800b234:	2101      	movs	r1, #1
 800b236:	2001      	movs	r0, #1
 800b238:	f7ff ff02 	bl	800b040 <si5351_set_frequency_fixeddiv>
    }

    // div by 6 mode. both PLL A and B are dedicated for CLK0, CLK1
    si5351_set_frequency_fixeddiv(0, SI5351_PLL_A, ofreq, 6, drive_strength);
 800b23c:	002a      	movs	r2, r5
 800b23e:	2306      	movs	r3, #6
 800b240:	2100      	movs	r1, #0
 800b242:	2000      	movs	r0, #0
 800b244:	9700      	str	r7, [sp, #0]
 800b246:	f7ff fefb 	bl	800b040 <si5351_set_frequency_fixeddiv>
    si5351_set_frequency_fixeddiv(1, SI5351_PLL_B, freq, 6, drive_strength);
 800b24a:	2306      	movs	r3, #6
 800b24c:	0022      	movs	r2, r4
 800b24e:	2101      	movs	r1, #1
 800b250:	2001      	movs	r0, #1
 800b252:	9700      	str	r7, [sp, #0]
 800b254:	f7ff fef4 	bl	800b040 <si5351_set_frequency_fixeddiv>
    si5351_set_frequency_fixedpll(2, SI5351_PLL_B, freq * 6, CLK2_FREQUENCY,
 800b258:	2300      	movs	r3, #0
                                  SI5351_R_DIV_1, SI5351_CLK_DRIVE_STRENGTH_2MA);
    break;
 800b25a:	2501      	movs	r5, #1
    si5351_set_frequency_fixedpll(2, SI5351_PLL_B, freq * 6, CLK2_FREQUENCY,
 800b25c:	0062      	lsls	r2, r4, #1
 800b25e:	1912      	adds	r2, r2, r4
 800b260:	9301      	str	r3, [sp, #4]
 800b262:	9300      	str	r3, [sp, #0]
 800b264:	2002      	movs	r0, #2
 800b266:	4b84      	ldr	r3, [pc, #528]	; (800b478 <si5351_set_frequency_with_offset+0x2b8>)
 800b268:	0052      	lsls	r2, r2, #1
 800b26a:	2101      	movs	r1, #1
 800b26c:	f7ff fe98 	bl	800afa0 <si5351_set_frequency_fixedpll>
    si5351_set_frequency_fixedpll(2, SI5351_PLL_B, freq * 4, CLK2_FREQUENCY,
                                  SI5351_R_DIV_1, SI5351_CLK_DRIVE_STRENGTH_2MA);
    break;
  }

  if (current_band != band) {
 800b270:	6833      	ldr	r3, [r6, #0]
  int delay = 3;
 800b272:	2003      	movs	r0, #3
  if (current_band != band) {
 800b274:	42ab      	cmp	r3, r5
 800b276:	d134      	bne.n	800b2e2 <si5351_set_frequency_with_offset+0x122>
    si5351_enable_output();
#endif
    delay += 10;
  }

  current_band = band;
 800b278:	6035      	str	r5, [r6, #0]
  return delay;
}
 800b27a:	b004      	add	sp, #16
 800b27c:	bc1c      	pop	{r2, r3, r4}
 800b27e:	4690      	mov	r8, r2
 800b280:	4699      	mov	r9, r3
 800b282:	46a2      	mov	sl, r4
 800b284:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if (freq <= 500000) {
 800b286:	4b7d      	ldr	r3, [pc, #500]	; (800b47c <si5351_set_frequency_with_offset+0x2bc>)
 800b288:	429c      	cmp	r4, r3
 800b28a:	d900      	bls.n	800b28e <si5351_set_frequency_with_offset+0xce>
 800b28c:	e07c      	b.n	800b388 <si5351_set_frequency_with_offset+0x1c8>
  if (current_band != band)
 800b28e:	4e78      	ldr	r6, [pc, #480]	; (800b470 <si5351_set_frequency_with_offset+0x2b0>)
 800b290:	6833      	ldr	r3, [r6, #0]
 800b292:	2b00      	cmp	r3, #0
 800b294:	d150      	bne.n	800b338 <si5351_set_frequency_with_offset+0x178>
      ofreq *= 64;
 800b296:	2360      	movs	r3, #96	; 0x60
      freq *= 64;
 800b298:	01a4      	lsls	r4, r4, #6
      ofreq *= 64;
 800b29a:	01ad      	lsls	r5, r5, #6
 800b29c:	4698      	mov	r8, r3
 800b29e:	e07e      	b.n	800b39e <si5351_set_frequency_with_offset+0x1de>
  if (current_band != band)
 800b2a0:	4e73      	ldr	r6, [pc, #460]	; (800b470 <si5351_set_frequency_with_offset+0x2b0>)
 800b2a2:	6833      	ldr	r3, [r6, #0]
 800b2a4:	2b02      	cmp	r3, #2
 800b2a6:	d000      	beq.n	800b2aa <si5351_set_frequency_with_offset+0xea>
 800b2a8:	e0c1      	b.n	800b42e <si5351_set_frequency_with_offset+0x26e>
    si5351_set_frequency_fixeddiv(0, SI5351_PLL_A, ofreq, 4, drive_strength);
 800b2aa:	002a      	movs	r2, r5
 800b2ac:	2304      	movs	r3, #4
 800b2ae:	2100      	movs	r1, #0
 800b2b0:	2000      	movs	r0, #0
 800b2b2:	9700      	str	r7, [sp, #0]
 800b2b4:	f7ff fec4 	bl	800b040 <si5351_set_frequency_fixeddiv>
    si5351_set_frequency_fixeddiv(1, SI5351_PLL_B, freq, 4, drive_strength);
 800b2b8:	2304      	movs	r3, #4
 800b2ba:	0022      	movs	r2, r4
 800b2bc:	2101      	movs	r1, #1
 800b2be:	2001      	movs	r0, #1
 800b2c0:	9700      	str	r7, [sp, #0]
 800b2c2:	f7ff febd 	bl	800b040 <si5351_set_frequency_fixeddiv>
    si5351_set_frequency_fixedpll(2, SI5351_PLL_B, freq * 4, CLK2_FREQUENCY,
 800b2c6:	2300      	movs	r3, #0
 800b2c8:	00a2      	lsls	r2, r4, #2
 800b2ca:	9301      	str	r3, [sp, #4]
 800b2cc:	9300      	str	r3, [sp, #0]
 800b2ce:	2101      	movs	r1, #1
 800b2d0:	4b69      	ldr	r3, [pc, #420]	; (800b478 <si5351_set_frequency_with_offset+0x2b8>)
 800b2d2:	2002      	movs	r0, #2
 800b2d4:	f7ff fe64 	bl	800afa0 <si5351_set_frequency_fixedpll>
    break;
 800b2d8:	2502      	movs	r5, #2
  if (current_band != band) {
 800b2da:	6833      	ldr	r3, [r6, #0]
  int delay = 3;
 800b2dc:	2003      	movs	r0, #3
  if (current_band != band) {
 800b2de:	42ab      	cmp	r3, r5
 800b2e0:	d0ca      	beq.n	800b278 <si5351_set_frequency_with_offset+0xb8>
  si5351_write(SI5351_REG_177_PLL_RESET, 0xAC);
 800b2e2:	21ac      	movs	r1, #172	; 0xac
 800b2e4:	30ae      	adds	r0, #174	; 0xae
 800b2e6:	f7ff fd9b 	bl	800ae20 <si5351_write>
  __ASM volatile ("cpsid i" : : : "memory");
 800b2ea:	b672      	cpsid	i
 800b2ec:	2380      	movs	r3, #128	; 0x80
 800b2ee:	05db      	lsls	r3, r3, #23
 800b2f0:	6a5f      	ldr	r7, [r3, #36]	; 0x24
  __ASM volatile ("cpsie i" : : : "memory");
 800b2f2:	b662      	cpsie	i
    uint8_t status = 0xff;
 800b2f4:	23ff      	movs	r3, #255	; 0xff
 800b2f6:	ac03      	add	r4, sp, #12
    if(!si5351_bulk_read(0, &status, 1))
 800b2f8:	0020      	movs	r0, r4
    uint8_t status = 0xff;
 800b2fa:	4698      	mov	r8, r3
 800b2fc:	7023      	strb	r3, [r4, #0]
    if(!si5351_bulk_read(0, &status, 1))
 800b2fe:	f7ff fef7 	bl	800b0f0 <si5351_bulk_read.constprop.0>
 800b302:	2800      	cmp	r0, #0
 800b304:	d168      	bne.n	800b3d8 <si5351_set_frequency_with_offset+0x218>
        status = 0xff;  // comm timeout
 800b306:	4643      	mov	r3, r8
 800b308:	7023      	strb	r3, [r4, #0]
 800b30a:	2380      	movs	r3, #128	; 0x80
 800b30c:	05db      	lsls	r3, r3, #23
 800b30e:	469a      	mov	sl, r3
    while (chVTIsSystemTimeWithin(start, end))
 800b310:	4b5b      	ldr	r3, [pc, #364]	; (800b480 <si5351_set_frequency_with_offset+0x2c0>)
 800b312:	4699      	mov	r9, r3
        if ((status & 0x60) == 0)
 800b314:	2360      	movs	r3, #96	; 0x60
 800b316:	4698      	mov	r8, r3
  __ASM volatile ("cpsid i" : : : "memory");
 800b318:	b672      	cpsid	i
 800b31a:	4653      	mov	r3, sl
 800b31c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  __ASM volatile ("cpsie i" : : : "memory");
 800b31e:	b662      	cpsie	i
 800b320:	1bdb      	subs	r3, r3, r7
    while (chVTIsSystemTimeWithin(start, end))
 800b322:	454b      	cmp	r3, r9
 800b324:	d900      	bls.n	800b328 <si5351_set_frequency_with_offset+0x168>
 800b326:	e08d      	b.n	800b444 <si5351_set_frequency_with_offset+0x284>
        if(!si5351_bulk_read(0, &status, 1))
 800b328:	0020      	movs	r0, r4
 800b32a:	f7ff fee1 	bl	800b0f0 <si5351_bulk_read.constprop.0>
 800b32e:	2800      	cmp	r0, #0
 800b330:	d113      	bne.n	800b35a <si5351_set_frequency_with_offset+0x19a>
            status = 0xff;  // comm timeout
 800b332:	23ff      	movs	r3, #255	; 0xff
 800b334:	7023      	strb	r3, [r4, #0]
        if ((status & 0x60) == 0)
 800b336:	e7ef      	b.n	800b318 <si5351_set_frequency_with_offset+0x158>
    rdiv = SI5351_R_DIV_64;
 800b338:	2360      	movs	r3, #96	; 0x60
 800b33a:	4698      	mov	r8, r3
  si5351_write(SI5351_REG_3_OUTPUT_ENABLE_CONTROL, 0xff);
 800b33c:	21ff      	movs	r1, #255	; 0xff
 800b33e:	2003      	movs	r0, #3
 800b340:	f7ff fd6e 	bl	800ae20 <si5351_write>
  reg[0] = SI5351_REG_16_CLK0_CONTROL;
 800b344:	4b4b      	ldr	r3, [pc, #300]	; (800b474 <si5351_set_frequency_with_offset+0x2b4>)
  si5351_bulk_write(reg, 4);
 800b346:	2104      	movs	r1, #4
 800b348:	a803      	add	r0, sp, #12
  reg[0] = SI5351_REG_16_CLK0_CONTROL;
 800b34a:	9303      	str	r3, [sp, #12]
  si5351_bulk_write(reg, 4);
 800b34c:	f7ff fd00 	bl	800ad50 <si5351_bulk_write>
	if (current_band == 1 || current_band == 2){
 800b350:	6833      	ldr	r3, [r6, #0]
 800b352:	3b01      	subs	r3, #1
 800b354:	2b01      	cmp	r3, #1
 800b356:	d959      	bls.n	800b40c <si5351_set_frequency_with_offset+0x24c>
 800b358:	e065      	b.n	800b426 <si5351_set_frequency_with_offset+0x266>
        if ((status & 0x60) == 0)
 800b35a:	4642      	mov	r2, r8
 800b35c:	7823      	ldrb	r3, [r4, #0]
 800b35e:	421a      	tst	r2, r3
 800b360:	d1da      	bne.n	800b318 <si5351_set_frequency_with_offset+0x158>
  si5351_write(SI5351_REG_3_OUTPUT_ENABLE_CONTROL, 0x00);
 800b362:	2100      	movs	r1, #0
 800b364:	2003      	movs	r0, #3
 800b366:	f7ff fd5b 	bl	800ae20 <si5351_write>
    delay += 10;
 800b36a:	200d      	movs	r0, #13
 800b36c:	e784      	b.n	800b278 <si5351_set_frequency_with_offset+0xb8>
  } else if (freq > config.harmonic_freq_threshold) {
 800b36e:	4282      	cmp	r2, r0
 800b370:	d300      	bcc.n	800b374 <si5351_set_frequency_with_offset+0x1b4>
 800b372:	e73e      	b.n	800b1f2 <si5351_set_frequency_with_offset+0x32>
    freq /= 3;
 800b374:	2103      	movs	r1, #3
 800b376:	f7f4 ff2b 	bl	80001d0 <__udivsi3>
    ofreq /= 5;
 800b37a:	2105      	movs	r1, #5
    freq /= 3;
 800b37c:	0004      	movs	r4, r0
    ofreq /= 5;
 800b37e:	0028      	movs	r0, r5
 800b380:	f7f4 ff26 	bl	80001d0 <__udivsi3>
 800b384:	0005      	movs	r5, r0
 800b386:	e734      	b.n	800b1f2 <si5351_set_frequency_with_offset+0x32>
  } else if (freq <= 4000000) {
 800b388:	4b3e      	ldr	r3, [pc, #248]	; (800b484 <si5351_set_frequency_with_offset+0x2c4>)
  if (current_band != band)
 800b38a:	4e39      	ldr	r6, [pc, #228]	; (800b470 <si5351_set_frequency_with_offset+0x2b0>)
  } else if (freq <= 4000000) {
 800b38c:	429c      	cmp	r4, r3
 800b38e:	d862      	bhi.n	800b456 <si5351_set_frequency_with_offset+0x296>
  if (current_band != band)
 800b390:	6833      	ldr	r3, [r6, #0]
 800b392:	2b00      	cmp	r3, #0
 800b394:	d12a      	bne.n	800b3ec <si5351_set_frequency_with_offset+0x22c>
      freq *= 8;
 800b396:	2330      	movs	r3, #48	; 0x30
 800b398:	4698      	mov	r8, r3
 800b39a:	00e4      	lsls	r4, r4, #3
      ofreq *= 8;
 800b39c:	00ed      	lsls	r5, r5, #3
    si5351_set_frequency_fixedpll(0, SI5351_PLL_A, PLLFREQ, ofreq,
 800b39e:	4643      	mov	r3, r8
 800b3a0:	4a39      	ldr	r2, [pc, #228]	; (800b488 <si5351_set_frequency_with_offset+0x2c8>)
 800b3a2:	9300      	str	r3, [sp, #0]
 800b3a4:	2100      	movs	r1, #0
 800b3a6:	002b      	movs	r3, r5
 800b3a8:	2000      	movs	r0, #0
 800b3aa:	9701      	str	r7, [sp, #4]
 800b3ac:	f7ff fdf8 	bl	800afa0 <si5351_set_frequency_fixedpll>
    si5351_set_frequency_fixedpll(1, SI5351_PLL_A, PLLFREQ, freq,
 800b3b0:	4643      	mov	r3, r8
 800b3b2:	4a35      	ldr	r2, [pc, #212]	; (800b488 <si5351_set_frequency_with_offset+0x2c8>)
 800b3b4:	9300      	str	r3, [sp, #0]
 800b3b6:	2100      	movs	r1, #0
 800b3b8:	0023      	movs	r3, r4
 800b3ba:	2001      	movs	r0, #1
 800b3bc:	9701      	str	r7, [sp, #4]
 800b3be:	f7ff fdef 	bl	800afa0 <si5351_set_frequency_fixedpll>
      si5351_set_frequency_fixedpll(2, SI5351_PLL_A, PLLFREQ, CLK2_FREQUENCY,
 800b3c2:	2300      	movs	r3, #0
 800b3c4:	4a30      	ldr	r2, [pc, #192]	; (800b488 <si5351_set_frequency_with_offset+0x2c8>)
 800b3c6:	9301      	str	r3, [sp, #4]
 800b3c8:	9300      	str	r3, [sp, #0]
 800b3ca:	2100      	movs	r1, #0
 800b3cc:	4b2a      	ldr	r3, [pc, #168]	; (800b478 <si5351_set_frequency_with_offset+0x2b8>)
 800b3ce:	2002      	movs	r0, #2
 800b3d0:	f7ff fde6 	bl	800afa0 <si5351_set_frequency_fixedpll>
    break;
 800b3d4:	2500      	movs	r5, #0
 800b3d6:	e780      	b.n	800b2da <si5351_set_frequency_with_offset+0x11a>
    if ((status & 0x60) == 0)
 800b3d8:	2260      	movs	r2, #96	; 0x60
 800b3da:	7823      	ldrb	r3, [r4, #0]
 800b3dc:	421a      	tst	r2, r3
 800b3de:	d194      	bne.n	800b30a <si5351_set_frequency_with_offset+0x14a>
  si5351_write(SI5351_REG_3_OUTPUT_ENABLE_CONTROL, 0x00);
 800b3e0:	2100      	movs	r1, #0
 800b3e2:	2003      	movs	r0, #3
 800b3e4:	f7ff fd1c 	bl	800ae20 <si5351_write>
    delay += 10;
 800b3e8:	200d      	movs	r0, #13
 800b3ea:	e745      	b.n	800b278 <si5351_set_frequency_with_offset+0xb8>
  si5351_write(SI5351_REG_3_OUTPUT_ENABLE_CONTROL, 0xff);
 800b3ec:	21ff      	movs	r1, #255	; 0xff
 800b3ee:	2003      	movs	r0, #3
 800b3f0:	f7ff fd16 	bl	800ae20 <si5351_write>
  reg[0] = SI5351_REG_16_CLK0_CONTROL;
 800b3f4:	4b1f      	ldr	r3, [pc, #124]	; (800b474 <si5351_set_frequency_with_offset+0x2b4>)
  si5351_bulk_write(reg, 4);
 800b3f6:	2104      	movs	r1, #4
 800b3f8:	a803      	add	r0, sp, #12
  reg[0] = SI5351_REG_16_CLK0_CONTROL;
 800b3fa:	9303      	str	r3, [sp, #12]
  si5351_bulk_write(reg, 4);
 800b3fc:	f7ff fca8 	bl	800ad50 <si5351_bulk_write>
    rdiv = SI5351_R_DIV_8;
 800b400:	2230      	movs	r2, #48	; 0x30
	if (current_band == 1 || current_band == 2){
 800b402:	6833      	ldr	r3, [r6, #0]
    rdiv = SI5351_R_DIV_8;
 800b404:	4690      	mov	r8, r2
	if (current_band == 1 || current_band == 2){
 800b406:	3b01      	subs	r3, #1
 800b408:	2b01      	cmp	r3, #1
 800b40a:	d8c4      	bhi.n	800b396 <si5351_set_frequency_with_offset+0x1d6>
  si5351_write(SI5351_REG_177_PLL_RESET, 0xAC);
 800b40c:	21ac      	movs	r1, #172	; 0xac
 800b40e:	20b1      	movs	r0, #177	; 0xb1
 800b410:	f7ff fd06 	bl	800ae20 <si5351_write>
	  si5351_setupPLL(SI5351_PLL_A, 32, 0, 1);
 800b414:	2301      	movs	r3, #1
 800b416:	2200      	movs	r2, #0
 800b418:	2120      	movs	r1, #32
 800b41a:	2000      	movs	r0, #0
 800b41c:	f7ff fcb8 	bl	800ad90 <si5351_setupPLL>
    if (rdiv == SI5351_R_DIV_8) {
 800b420:	4643      	mov	r3, r8
 800b422:	2b30      	cmp	r3, #48	; 0x30
 800b424:	d0b7      	beq.n	800b396 <si5351_set_frequency_with_offset+0x1d6>
    } else if (rdiv == SI5351_R_DIV_64) {
 800b426:	4643      	mov	r3, r8
 800b428:	2b60      	cmp	r3, #96	; 0x60
 800b42a:	d1b8      	bne.n	800b39e <si5351_set_frequency_with_offset+0x1de>
 800b42c:	e733      	b.n	800b296 <si5351_set_frequency_with_offset+0xd6>
  si5351_write(SI5351_REG_3_OUTPUT_ENABLE_CONTROL, 0xff);
 800b42e:	21ff      	movs	r1, #255	; 0xff
 800b430:	2003      	movs	r0, #3
 800b432:	f7ff fcf5 	bl	800ae20 <si5351_write>
  reg[0] = SI5351_REG_16_CLK0_CONTROL;
 800b436:	4b0f      	ldr	r3, [pc, #60]	; (800b474 <si5351_set_frequency_with_offset+0x2b4>)
  si5351_bulk_write(reg, 4);
 800b438:	2104      	movs	r1, #4
 800b43a:	a803      	add	r0, sp, #12
  reg[0] = SI5351_REG_16_CLK0_CONTROL;
 800b43c:	9303      	str	r3, [sp, #12]
  si5351_bulk_write(reg, 4);
 800b43e:	f7ff fc87 	bl	800ad50 <si5351_bulk_write>
  switch (band) {
 800b442:	e732      	b.n	800b2aa <si5351_set_frequency_with_offset+0xea>
    pll_lock_failed = true;
 800b444:	2201      	movs	r2, #1
 800b446:	4b11      	ldr	r3, [pc, #68]	; (800b48c <si5351_set_frequency_with_offset+0x2cc>)
  si5351_write(SI5351_REG_3_OUTPUT_ENABLE_CONTROL, 0x00);
 800b448:	2100      	movs	r1, #0
 800b44a:	2003      	movs	r0, #3
    pll_lock_failed = true;
 800b44c:	701a      	strb	r2, [r3, #0]
  si5351_write(SI5351_REG_3_OUTPUT_ENABLE_CONTROL, 0x00);
 800b44e:	f7ff fce7 	bl	800ae20 <si5351_write>
    delay += 10;
 800b452:	200d      	movs	r0, #13
 800b454:	e710      	b.n	800b278 <si5351_set_frequency_with_offset+0xb8>
  if (current_band != band)
 800b456:	6833      	ldr	r3, [r6, #0]
 800b458:	2b00      	cmp	r3, #0
 800b45a:	d100      	bne.n	800b45e <si5351_set_frequency_with_offset+0x29e>
 800b45c:	e71e      	b.n	800b29c <si5351_set_frequency_with_offset+0xdc>
  uint32_t rdiv = SI5351_R_DIV_1;
 800b45e:	2300      	movs	r3, #0
 800b460:	4698      	mov	r8, r3
 800b462:	e76b      	b.n	800b33c <si5351_set_frequency_with_offset+0x17c>
 800b464:	2000042c 	.word	0x2000042c
 800b468:	05f5e100 	.word	0x05f5e100
 800b46c:	08f0d180 	.word	0x08f0d180
 800b470:	20001634 	.word	0x20001634
 800b474:	80808010 	.word	0x80808010
 800b478:	007a1200 	.word	0x007a1200
 800b47c:	0007a120 	.word	0x0007a120
 800b480:	000003e7 	.word	0x000003e7
 800b484:	003d0900 	.word	0x003d0900
 800b488:	31975000 	.word	0x31975000
 800b48c:	20002234 	.word	0x20002234

0800b490 <tlv320aic3204_bulk_write>:
  2, 0x52, 0x00, /* Unmute Left and Right ADC Digital Volume Control */    
  0 // sentinel
};

static void tlv320aic3204_bulk_write(const uint8_t *buf, int len)
{
 800b490:	b570      	push	{r4, r5, r6, lr}
  int addr = AIC3204_ADDR;
  i2cAcquireBus(&I2CD1);
 800b492:	4c0c      	ldr	r4, [pc, #48]	; (800b4c4 <tlv320aic3204_bulk_write+0x34>)
{
 800b494:	b084      	sub	sp, #16
 800b496:	0005      	movs	r5, r0
  i2cAcquireBus(&I2CD1);
 800b498:	0020      	movs	r0, r4
{
 800b49a:	000e      	movs	r6, r1
  i2cAcquireBus(&I2CD1);
 800b49c:	f7f9 fb40 	bl	8004b20 <i2cAcquireBus>
  (void)i2cMasterTransmitTimeout(&I2CD1, addr, buf, len, NULL, 0, 1000);
 800b4a0:	23fa      	movs	r3, #250	; 0xfa
 800b4a2:	009b      	lsls	r3, r3, #2
 800b4a4:	9302      	str	r3, [sp, #8]
 800b4a6:	2300      	movs	r3, #0
 800b4a8:	002a      	movs	r2, r5
 800b4aa:	9301      	str	r3, [sp, #4]
 800b4ac:	9300      	str	r3, [sp, #0]
 800b4ae:	2118      	movs	r1, #24
 800b4b0:	0033      	movs	r3, r6
 800b4b2:	0020      	movs	r0, r4
 800b4b4:	f7f9 fb14 	bl	8004ae0 <i2cMasterTransmitTimeout>
  i2cReleaseBus(&I2CD1);
 800b4b8:	0020      	movs	r0, r4
 800b4ba:	f7f9 fb39 	bl	8004b30 <i2cReleaseBus>
}
 800b4be:	b004      	add	sp, #16
 800b4c0:	bd70      	pop	{r4, r5, r6, pc}
 800b4c2:	46c0      	nop			; (mov r8, r8)
 800b4c4:	20001844 	.word	0x20001844
	...

0800b4d0 <tlv320aic3204_init>:
    p += len;
  }
}

void tlv320aic3204_init(void)
{
 800b4d0:	b570      	push	{r4, r5, r6, lr}
  while (*p) {
 800b4d2:	2502      	movs	r5, #2
  const uint8_t *p = data;
 800b4d4:	4c17      	ldr	r4, [pc, #92]	; (800b534 <tlv320aic3204_init+0x64>)
    uint8_t len = *p++;
 800b4d6:	3401      	adds	r4, #1
    tlv320aic3204_bulk_write(p, len);
 800b4d8:	0029      	movs	r1, r5
 800b4da:	0020      	movs	r0, r4
    p += len;
 800b4dc:	1964      	adds	r4, r4, r5
    tlv320aic3204_bulk_write(p, len);
 800b4de:	f7ff ffd7 	bl	800b490 <tlv320aic3204_bulk_write>
  while (*p) {
 800b4e2:	7825      	ldrb	r5, [r4, #0]
 800b4e4:	2d00      	cmp	r5, #0
 800b4e6:	d1f6      	bne.n	800b4d6 <tlv320aic3204_init+0x6>
  const uint8_t *p = data;
 800b4e8:	4c13      	ldr	r4, [pc, #76]	; (800b538 <tlv320aic3204_init+0x68>)
  while (*p) {
 800b4ea:	3502      	adds	r5, #2
    uint8_t len = *p++;
 800b4ec:	3401      	adds	r4, #1
    tlv320aic3204_bulk_write(p, len);
 800b4ee:	0029      	movs	r1, r5
 800b4f0:	0020      	movs	r0, r4
    p += len;
 800b4f2:	1964      	adds	r4, r4, r5
    tlv320aic3204_bulk_write(p, len);
 800b4f4:	f7ff ffcc 	bl	800b490 <tlv320aic3204_bulk_write>
  while (*p) {
 800b4f8:	7825      	ldrb	r5, [r4, #0]
 800b4fa:	2d00      	cmp	r5, #0
 800b4fc:	d1f6      	bne.n	800b4ec <tlv320aic3204_init+0x1c>
  const uint8_t *p = data;
 800b4fe:	4c0f      	ldr	r4, [pc, #60]	; (800b53c <tlv320aic3204_init+0x6c>)
  while (*p) {
 800b500:	3502      	adds	r5, #2
    uint8_t len = *p++;
 800b502:	3401      	adds	r4, #1
    tlv320aic3204_bulk_write(p, len);
 800b504:	0029      	movs	r1, r5
 800b506:	0020      	movs	r0, r4
    p += len;
 800b508:	1964      	adds	r4, r4, r5
    tlv320aic3204_bulk_write(p, len);
 800b50a:	f7ff ffc1 	bl	800b490 <tlv320aic3204_bulk_write>
  while (*p) {
 800b50e:	7825      	ldrb	r5, [r4, #0]
 800b510:	2d00      	cmp	r5, #0
 800b512:	d1f6      	bne.n	800b502 <tlv320aic3204_init+0x32>
  tlv320aic3204_config(conf_data_pll);
  tlv320aic3204_config(conf_data_clk);
  tlv320aic3204_config(conf_data_routing);
  wait_ms(40);
 800b514:	20c8      	movs	r0, #200	; 0xc8
 800b516:	0040      	lsls	r0, r0, #1
 800b518:	f7f8 fcfa 	bl	8003f10 <chThdSleep>
  const uint8_t *p = data;
 800b51c:	4c08      	ldr	r4, [pc, #32]	; (800b540 <tlv320aic3204_init+0x70>)
  while (*p) {
 800b51e:	3502      	adds	r5, #2
    uint8_t len = *p++;
 800b520:	3401      	adds	r4, #1
    tlv320aic3204_bulk_write(p, len);
 800b522:	0029      	movs	r1, r5
 800b524:	0020      	movs	r0, r4
    p += len;
 800b526:	1964      	adds	r4, r4, r5
    tlv320aic3204_bulk_write(p, len);
 800b528:	f7ff ffb2 	bl	800b490 <tlv320aic3204_bulk_write>
  while (*p) {
 800b52c:	7825      	ldrb	r5, [r4, #0]
 800b52e:	2d00      	cmp	r5, #0
 800b530:	d1f6      	bne.n	800b520 <tlv320aic3204_init+0x50>
  tlv320aic3204_config(conf_data_unmute);
}
 800b532:	bd70      	pop	{r4, r5, r6, pc}
 800b534:	08014818 	.word	0x08014818
 800b538:	080147f0 	.word	0x080147f0
 800b53c:	08014830 	.word	0x08014830
 800b540:	08014860 	.word	0x08014860
	...

0800b550 <tlv320aic3204_select>:

void tlv320aic3204_select(int channel)
{
 800b550:	b570      	push	{r4, r5, r6, lr}
 800b552:	b086      	sub	sp, #24
    const uint8_t ch3[] = {
 800b554:	4669      	mov	r1, sp
 800b556:	4a0f      	ldr	r2, [pc, #60]	; (800b594 <tlv320aic3204_select+0x44>)
 800b558:	000b      	movs	r3, r1
 800b55a:	0014      	movs	r4, r2
 800b55c:	cc60      	ldmia	r4!, {r5, r6}
 800b55e:	c360      	stmia	r3!, {r5, r6}
 800b560:	8824      	ldrh	r4, [r4, #0]
        2, 0x00, 0x01, /* Select Page 1 */
        2, 0x37, 0x04, /* Route IN3R to RIGHT_P with input impedance of 10K */
        2, 0x39, 0x04, /* Route IN3L to RIGHT_N with input impedance of 10K */    
        0 // sentinel
    };
    const uint8_t ch1[] = {
 800b562:	320c      	adds	r2, #12
    const uint8_t ch3[] = {
 800b564:	801c      	strh	r4, [r3, #0]
    const uint8_t ch1[] = {
 800b566:	ab03      	add	r3, sp, #12
 800b568:	001c      	movs	r4, r3
 800b56a:	ca60      	ldmia	r2!, {r5, r6}
 800b56c:	c460      	stmia	r4!, {r5, r6}
 800b56e:	8812      	ldrh	r2, [r2, #0]
 800b570:	8022      	strh	r2, [r4, #0]
        2, 0x00, 0x01, /* Select Page 1 */
        2, 0x37, 0x40, /* Route IN1R to RIGHT_P with input impedance of 10K */
        2, 0x39, 0x10, /* Route IN1L to RIGHT_N with input impedance of 10K */    
        0 // sentinel
    };
    tlv320aic3204_config(channel ? ch1 : ch3);
 800b572:	001c      	movs	r4, r3
 800b574:	2800      	cmp	r0, #0
 800b576:	d107      	bne.n	800b588 <tlv320aic3204_select+0x38>
 800b578:	000c      	movs	r4, r1
 800b57a:	e005      	b.n	800b588 <tlv320aic3204_select+0x38>
    uint8_t len = *p++;
 800b57c:	3401      	adds	r4, #1
    tlv320aic3204_bulk_write(p, len);
 800b57e:	0020      	movs	r0, r4
 800b580:	0029      	movs	r1, r5
 800b582:	f7ff ff85 	bl	800b490 <tlv320aic3204_bulk_write>
    p += len;
 800b586:	1964      	adds	r4, r4, r5
  while (*p) {
 800b588:	7825      	ldrb	r5, [r4, #0]
 800b58a:	2d00      	cmp	r5, #0
 800b58c:	d1f6      	bne.n	800b57c <tlv320aic3204_select+0x2c>
}
 800b58e:	b006      	add	sp, #24
 800b590:	bd70      	pop	{r4, r5, r6, pc}
 800b592:	46c0      	nop			; (mov r8, r8)
 800b594:	080132cc 	.word	0x080132cc
	...

0800b5a0 <tlv320aic3204_set_gain>:

void tlv320aic3204_set_gain(int lgain, int rgain)
{
    uint8_t data[] = {
 800b5a0:	223b      	movs	r2, #59	; 0x3b
{
 800b5a2:	b530      	push	{r4, r5, lr}
    uint8_t data[] = {
 800b5a4:	4b0b      	ldr	r3, [pc, #44]	; (800b5d4 <tlv320aic3204_set_gain+0x34>)
{
 800b5a6:	b085      	sub	sp, #20
    uint8_t data[] = {
 800b5a8:	9301      	str	r3, [sp, #4]
 800b5aa:	ab01      	add	r3, sp, #4
 800b5ac:	711a      	strb	r2, [r3, #4]
 800b5ae:	4a0a      	ldr	r2, [pc, #40]	; (800b5d8 <tlv320aic3204_set_gain+0x38>)
  while (*p) {
 800b5b0:	2502      	movs	r5, #2
    uint8_t data[] = {
 800b5b2:	80da      	strh	r2, [r3, #6]
 800b5b4:	2200      	movs	r2, #0
  const uint8_t *p = data;
 800b5b6:	001c      	movs	r4, r3
    uint8_t data[] = {
 800b5b8:	7158      	strb	r0, [r3, #5]
 800b5ba:	7219      	strb	r1, [r3, #8]
 800b5bc:	725a      	strb	r2, [r3, #9]
    uint8_t len = *p++;
 800b5be:	3401      	adds	r4, #1
    tlv320aic3204_bulk_write(p, len);
 800b5c0:	0029      	movs	r1, r5
 800b5c2:	0020      	movs	r0, r4
    p += len;
 800b5c4:	1964      	adds	r4, r4, r5
    tlv320aic3204_bulk_write(p, len);
 800b5c6:	f7ff ff63 	bl	800b490 <tlv320aic3204_bulk_write>
  while (*p) {
 800b5ca:	7825      	ldrb	r5, [r4, #0]
 800b5cc:	2d00      	cmp	r5, #0
 800b5ce:	d1f6      	bne.n	800b5be <tlv320aic3204_set_gain+0x1e>
        2, 0x3b, lgain, /* Unmute Left MICPGA, set gain */
        2, 0x3c, rgain, /* Unmute Right MICPGA, set gain */    
        0 // sentinel
    };
    tlv320aic3204_config(data);
}
 800b5d0:	b005      	add	sp, #20
 800b5d2:	bd30      	pop	{r4, r5, pc}
 800b5d4:	02010002 	.word	0x02010002
 800b5d8:	00003c02 	.word	0x00003c02
 800b5dc:	00000000 	.word	0x00000000

0800b5e0 <dsp_process>:
static int32_t acc_samp_c;
static int32_t acc_ref_s;
static int32_t acc_ref_c;

void dsp_process(int16_t *capture, size_t length)
{
 800b5e0:	b5f0      	push	{r4, r5, r6, r7, lr}
 800b5e2:	46de      	mov	lr, fp
 800b5e4:	4657      	mov	r7, sl
 800b5e6:	464e      	mov	r6, r9
 800b5e8:	4645      	mov	r5, r8
 800b5ea:	b5e0      	push	{r5, r6, r7, lr}
  uint32_t *p = (uint32_t*)capture;
  uint32_t len = length / 2;
 800b5ec:	0849      	lsrs	r1, r1, #1
{
 800b5ee:	b083      	sub	sp, #12
  int32_t samp_s = 0;
  int32_t samp_c = 0;
  int32_t ref_s = 0;
  int32_t ref_c = 0;

  for (i = 0; i < len; i++) {
 800b5f0:	2900      	cmp	r1, #0
 800b5f2:	d048      	beq.n	800b686 <dsp_process+0xa6>
 800b5f4:	0089      	lsls	r1, r1, #2
 800b5f6:	1843      	adds	r3, r0, r1
 800b5f8:	9301      	str	r3, [sp, #4]
  int32_t ref_c = 0;
 800b5fa:	2300      	movs	r3, #0
  for (i = 0; i < len; i++) {
 800b5fc:	4a25      	ldr	r2, [pc, #148]	; (800b694 <dsp_process+0xb4>)
 800b5fe:	4f26      	ldr	r7, [pc, #152]	; (800b698 <dsp_process+0xb8>)
 800b600:	4d26      	ldr	r5, [pc, #152]	; (800b69c <dsp_process+0xbc>)
  int32_t ref_c = 0;
 800b602:	4698      	mov	r8, r3
  int32_t ref_s = 0;
 800b604:	4699      	mov	r9, r3
  int32_t samp_c = 0;
 800b606:	469a      	mov	sl, r3
  int32_t samp_s = 0;
 800b608:	469b      	mov	fp, r3
    ref_buf[i] = ref;
    samp_buf[i] = smp;
#endif //__DUMP_CMD__
    int32_t s = sincos_tbl[i][0];
    int32_t c = sincos_tbl[i][1];
    samp_s += smp * s / 16;
 800b60a:	260f      	movs	r6, #15
 800b60c:	4694      	mov	ip, r2
 800b60e:	e005      	b.n	800b61c <dsp_process+0x3c>
 800b610:	2300      	movs	r3, #0
 800b612:	5efd      	ldrsh	r5, [r7, r3]
 800b614:	2202      	movs	r2, #2
 800b616:	5ebb      	ldrsh	r3, [r7, r2]
 800b618:	3704      	adds	r7, #4
 800b61a:	469c      	mov	ip, r3
 800b61c:	002a      	movs	r2, r5
    uint32_t sr = *p++;
 800b61e:	c808      	ldmia	r0!, {r3}
    samp_s += smp * s / 16;
 800b620:	141c      	asrs	r4, r3, #16
 800b622:	4362      	muls	r2, r4
 800b624:	17d1      	asrs	r1, r2, #31
 800b626:	4031      	ands	r1, r6
 800b628:	1889      	adds	r1, r1, r2
    samp_c += smp * c / 16;
 800b62a:	4662      	mov	r2, ip
 800b62c:	4362      	muls	r2, r4
 800b62e:	17d4      	asrs	r4, r2, #31
 800b630:	4034      	ands	r4, r6
 800b632:	18a4      	adds	r4, r4, r2
    ref_s += ref * s / 16;
 800b634:	002a      	movs	r2, r5
 800b636:	b21b      	sxth	r3, r3
 800b638:	435a      	muls	r2, r3
 800b63a:	17d5      	asrs	r5, r2, #31
 800b63c:	4035      	ands	r5, r6
 800b63e:	18ad      	adds	r5, r5, r2
    ref_c += ref * c / 16;
 800b640:	4662      	mov	r2, ip
 800b642:	435a      	muls	r2, r3
 800b644:	17d3      	asrs	r3, r2, #31
 800b646:	4033      	ands	r3, r6
 800b648:	189b      	adds	r3, r3, r2
 800b64a:	111b      	asrs	r3, r3, #4
 800b64c:	4498      	add	r8, r3
  for (i = 0; i < len; i++) {
 800b64e:	9b01      	ldr	r3, [sp, #4]
    samp_s += smp * s / 16;
 800b650:	1109      	asrs	r1, r1, #4
    samp_c += smp * c / 16;
 800b652:	1124      	asrs	r4, r4, #4
    ref_s += ref * s / 16;
 800b654:	112d      	asrs	r5, r5, #4
    samp_s += smp * s / 16;
 800b656:	448b      	add	fp, r1
    samp_c += smp * c / 16;
 800b658:	44a2      	add	sl, r4
    ref_s += ref * s / 16;
 800b65a:	44a9      	add	r9, r5
  for (i = 0; i < len; i++) {
 800b65c:	4283      	cmp	r3, r0
 800b65e:	d1d7      	bne.n	800b610 <dsp_process+0x30>
    samp_c = __SMLABT(sr, sc, samp_c);
    ref_s = __SMLATB(sr, sc, ref_s);
    ref_c = __SMLATT(sr, sc, ref_c);
#endif
  }
  acc_samp_s = samp_s;
 800b660:	465a      	mov	r2, fp
 800b662:	4b0f      	ldr	r3, [pc, #60]	; (800b6a0 <dsp_process+0xc0>)
 800b664:	601a      	str	r2, [r3, #0]
  acc_samp_c = samp_c;
 800b666:	4652      	mov	r2, sl
 800b668:	4b0e      	ldr	r3, [pc, #56]	; (800b6a4 <dsp_process+0xc4>)
 800b66a:	601a      	str	r2, [r3, #0]
  acc_ref_s = ref_s;
 800b66c:	464a      	mov	r2, r9
 800b66e:	4b0e      	ldr	r3, [pc, #56]	; (800b6a8 <dsp_process+0xc8>)
 800b670:	601a      	str	r2, [r3, #0]
  acc_ref_c = ref_c;
 800b672:	4642      	mov	r2, r8
 800b674:	4b0d      	ldr	r3, [pc, #52]	; (800b6ac <dsp_process+0xcc>)
 800b676:	601a      	str	r2, [r3, #0]
}
 800b678:	b003      	add	sp, #12
 800b67a:	bc3c      	pop	{r2, r3, r4, r5}
 800b67c:	4690      	mov	r8, r2
 800b67e:	4699      	mov	r9, r3
 800b680:	46a2      	mov	sl, r4
 800b682:	46ab      	mov	fp, r5
 800b684:	bdf0      	pop	{r4, r5, r6, r7, pc}
  int32_t ref_c = 0;
 800b686:	2300      	movs	r3, #0
 800b688:	4698      	mov	r8, r3
  int32_t ref_s = 0;
 800b68a:	4699      	mov	r9, r3
  int32_t samp_c = 0;
 800b68c:	469a      	mov	sl, r3
  int32_t samp_s = 0;
 800b68e:	469b      	mov	fp, r3
 800b690:	e7e6      	b.n	800b660 <dsp_process+0x80>
 800b692:	46c0      	nop			; (mov r8, r8)
 800b694:	00007935 	.word	0x00007935
 800b698:	08014870 	.word	0x08014870
 800b69c:	00002925 	.word	0x00002925
 800b6a0:	200029f8 	.word	0x200029f8
 800b6a4:	200029f4 	.word	0x200029f4
 800b6a8:	200029f0 	.word	0x200029f0
 800b6ac:	200029ec 	.word	0x200029ec

0800b6b0 <calculate_gamma>:

void calculate_gamma(float gamma[2])
{
 800b6b0:	b5f0      	push	{r4, r5, r6, r7, lr}
 800b6b2:	46d6      	mov	lr, sl
 800b6b4:	464f      	mov	r7, r9
 800b6b6:	4646      	mov	r6, r8
#if 1
  // calculate reflection coeff. by samp divide by ref
  float rs = acc_ref_s;
 800b6b8:	4b25      	ldr	r3, [pc, #148]	; (800b750 <calculate_gamma+0xa0>)
{
 800b6ba:	b5c0      	push	{r6, r7, lr}
 800b6bc:	0006      	movs	r6, r0
  float rs = acc_ref_s;
 800b6be:	6818      	ldr	r0, [r3, #0]
 800b6c0:	f7f5 ff8e 	bl	80015e0 <__aeabi_i2f>
  float rc = acc_ref_c;
 800b6c4:	4b23      	ldr	r3, [pc, #140]	; (800b754 <calculate_gamma+0xa4>)
  float rs = acc_ref_s;
 800b6c6:	1c04      	adds	r4, r0, #0
  float rc = acc_ref_c;
 800b6c8:	6818      	ldr	r0, [r3, #0]
 800b6ca:	f7f5 ff89 	bl	80015e0 <__aeabi_i2f>
  float rr = rs * rs + rc * rc;
 800b6ce:	1c21      	adds	r1, r4, #0
  float rc = acc_ref_c;
 800b6d0:	1c05      	adds	r5, r0, #0
  float rr = rs * rs + rc * rc;
 800b6d2:	1c20      	adds	r0, r4, #0
 800b6d4:	f7f5 fc8c 	bl	8000ff0 <__aeabi_fmul>
 800b6d8:	1c29      	adds	r1, r5, #0
 800b6da:	1c07      	adds	r7, r0, #0
 800b6dc:	1c28      	adds	r0, r5, #0
 800b6de:	f7f5 fc87 	bl	8000ff0 <__aeabi_fmul>
 800b6e2:	1c01      	adds	r1, r0, #0
 800b6e4:	1c38      	adds	r0, r7, #0
 800b6e6:	f7f5 f923 	bl	8000930 <__aeabi_fadd>
  //rr = sqrtf(rr) * 1e8;
  float ss = acc_samp_s;
 800b6ea:	4b1b      	ldr	r3, [pc, #108]	; (800b758 <calculate_gamma+0xa8>)
  float rr = rs * rs + rc * rc;
 800b6ec:	1c07      	adds	r7, r0, #0
  float ss = acc_samp_s;
 800b6ee:	6818      	ldr	r0, [r3, #0]
 800b6f0:	f7f5 ff76 	bl	80015e0 <__aeabi_i2f>
  float sc = acc_samp_c;
 800b6f4:	4b19      	ldr	r3, [pc, #100]	; (800b75c <calculate_gamma+0xac>)
  float ss = acc_samp_s;
 800b6f6:	4681      	mov	r9, r0
  float sc = acc_samp_c;
 800b6f8:	6818      	ldr	r0, [r3, #0]
 800b6fa:	f7f5 ff71 	bl	80015e0 <__aeabi_i2f>
 800b6fe:	4680      	mov	r8, r0
  gamma[0] =  (sc * rc + ss * rs) / rr;
 800b700:	1c01      	adds	r1, r0, #0
 800b702:	1c28      	adds	r0, r5, #0
 800b704:	f7f5 fc74 	bl	8000ff0 <__aeabi_fmul>
 800b708:	4649      	mov	r1, r9
 800b70a:	4682      	mov	sl, r0
 800b70c:	1c20      	adds	r0, r4, #0
 800b70e:	f7f5 fc6f 	bl	8000ff0 <__aeabi_fmul>
 800b712:	1c01      	adds	r1, r0, #0
 800b714:	4650      	mov	r0, sl
 800b716:	f7f5 f90b 	bl	8000930 <__aeabi_fadd>
 800b71a:	1c39      	adds	r1, r7, #0
 800b71c:	f7f5 fa88 	bl	8000c30 <__aeabi_fdiv>
  gamma[1] =  (ss * rc - sc * rs) / rr;
 800b720:	4649      	mov	r1, r9
  gamma[0] =  (sc * rc + ss * rs) / rr;
 800b722:	6030      	str	r0, [r6, #0]
  gamma[1] =  (ss * rc - sc * rs) / rr;
 800b724:	1c28      	adds	r0, r5, #0
 800b726:	f7f5 fc63 	bl	8000ff0 <__aeabi_fmul>
 800b72a:	4641      	mov	r1, r8
 800b72c:	1c05      	adds	r5, r0, #0
 800b72e:	1c20      	adds	r0, r4, #0
 800b730:	f7f5 fc5e 	bl	8000ff0 <__aeabi_fmul>
 800b734:	1c01      	adds	r1, r0, #0
 800b736:	1c28      	adds	r0, r5, #0
 800b738:	f7f5 fd72 	bl	8001220 <__aeabi_fsub>
 800b73c:	1c39      	adds	r1, r7, #0
 800b73e:	f7f5 fa77 	bl	8000c30 <__aeabi_fdiv>
 800b742:	6070      	str	r0, [r6, #4]
  gamma[1] =  acc_samp_c;
#else
  gamma[0] =  acc_ref_s;
  gamma[1] =  acc_ref_c;
#endif
}
 800b744:	bc1c      	pop	{r2, r3, r4}
 800b746:	4690      	mov	r8, r2
 800b748:	4699      	mov	r9, r3
 800b74a:	46a2      	mov	sl, r4
 800b74c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800b74e:	46c0      	nop			; (mov r8, r8)
 800b750:	200029f0 	.word	0x200029f0
 800b754:	200029ec 	.word	0x200029ec
 800b758:	200029f8 	.word	0x200029f8
 800b75c:	200029f4 	.word	0x200029f4

0800b760 <fetch_amplitude>:

void fetch_amplitude(float gamma[2])
{
  gamma[0] =  acc_samp_s * 1e-9;
 800b760:	4b0c      	ldr	r3, [pc, #48]	; (800b794 <fetch_amplitude+0x34>)
{
 800b762:	b510      	push	{r4, lr}
 800b764:	0004      	movs	r4, r0
  gamma[0] =  acc_samp_s * 1e-9;
 800b766:	6818      	ldr	r0, [r3, #0]
 800b768:	f7f7 fdc2 	bl	80032f0 <__aeabi_i2d>
 800b76c:	4a0a      	ldr	r2, [pc, #40]	; (800b798 <fetch_amplitude+0x38>)
 800b76e:	4b0b      	ldr	r3, [pc, #44]	; (800b79c <fetch_amplitude+0x3c>)
 800b770:	f7f6 ff46 	bl	8002600 <__aeabi_dmul>
 800b774:	f7f7 fe8c 	bl	8003490 <__aeabi_d2f>
  gamma[1] =  acc_samp_c * 1e-9;
 800b778:	4b09      	ldr	r3, [pc, #36]	; (800b7a0 <fetch_amplitude+0x40>)
  gamma[0] =  acc_samp_s * 1e-9;
 800b77a:	6020      	str	r0, [r4, #0]
  gamma[1] =  acc_samp_c * 1e-9;
 800b77c:	6818      	ldr	r0, [r3, #0]
 800b77e:	f7f7 fdb7 	bl	80032f0 <__aeabi_i2d>
 800b782:	4a05      	ldr	r2, [pc, #20]	; (800b798 <fetch_amplitude+0x38>)
 800b784:	4b05      	ldr	r3, [pc, #20]	; (800b79c <fetch_amplitude+0x3c>)
 800b786:	f7f6 ff3b 	bl	8002600 <__aeabi_dmul>
 800b78a:	f7f7 fe81 	bl	8003490 <__aeabi_d2f>
 800b78e:	6060      	str	r0, [r4, #4]
}
 800b790:	bd10      	pop	{r4, pc}
 800b792:	46c0      	nop			; (mov r8, r8)
 800b794:	200029f8 	.word	0x200029f8
 800b798:	e826d695 	.word	0xe826d695
 800b79c:	3e112e0b 	.word	0x3e112e0b
 800b7a0:	200029f4 	.word	0x200029f4
	...

0800b7b0 <fetch_amplitude_ref>:

void fetch_amplitude_ref(float gamma[2])
{
  gamma[0] =  acc_ref_s * 1e-9;
 800b7b0:	4b0c      	ldr	r3, [pc, #48]	; (800b7e4 <fetch_amplitude_ref+0x34>)
{
 800b7b2:	b510      	push	{r4, lr}
 800b7b4:	0004      	movs	r4, r0
  gamma[0] =  acc_ref_s * 1e-9;
 800b7b6:	6818      	ldr	r0, [r3, #0]
 800b7b8:	f7f7 fd9a 	bl	80032f0 <__aeabi_i2d>
 800b7bc:	4a0a      	ldr	r2, [pc, #40]	; (800b7e8 <fetch_amplitude_ref+0x38>)
 800b7be:	4b0b      	ldr	r3, [pc, #44]	; (800b7ec <fetch_amplitude_ref+0x3c>)
 800b7c0:	f7f6 ff1e 	bl	8002600 <__aeabi_dmul>
 800b7c4:	f7f7 fe64 	bl	8003490 <__aeabi_d2f>
  gamma[1] =  acc_ref_c * 1e-9;
 800b7c8:	4b09      	ldr	r3, [pc, #36]	; (800b7f0 <fetch_amplitude_ref+0x40>)
  gamma[0] =  acc_ref_s * 1e-9;
 800b7ca:	6020      	str	r0, [r4, #0]
  gamma[1] =  acc_ref_c * 1e-9;
 800b7cc:	6818      	ldr	r0, [r3, #0]
 800b7ce:	f7f7 fd8f 	bl	80032f0 <__aeabi_i2d>
 800b7d2:	4a05      	ldr	r2, [pc, #20]	; (800b7e8 <fetch_amplitude_ref+0x38>)
 800b7d4:	4b05      	ldr	r3, [pc, #20]	; (800b7ec <fetch_amplitude_ref+0x3c>)
 800b7d6:	f7f6 ff13 	bl	8002600 <__aeabi_dmul>
 800b7da:	f7f7 fe59 	bl	8003490 <__aeabi_d2f>
 800b7de:	6060      	str	r0, [r4, #4]
}
 800b7e0:	bd10      	pop	{r4, pc}
 800b7e2:	46c0      	nop			; (mov r8, r8)
 800b7e4:	200029f0 	.word	0x200029f0
 800b7e8:	e826d695 	.word	0xe826d695
 800b7ec:	3e112e0b 	.word	0x3e112e0b
 800b7f0:	200029ec 	.word	0x200029ec
	...

0800b800 <string_value_with_prefix>:
  y = (int)(v * GRIDY);
  return INDEX(x +CELLOFFSETX, y, i);
}

static int string_value_with_prefix(char *buf, int len, float val, char unit)
{
 800b800:	b5f0      	push	{r4, r5, r6, r7, lr}
 800b802:	46ce      	mov	lr, r9
 800b804:	4647      	mov	r7, r8
 800b806:	b580      	push	{r7, lr}
 800b808:	0005      	movs	r5, r0
 800b80a:	b083      	sub	sp, #12
 800b80c:	4689      	mov	r9, r1
  char prefix;
  int n;
  if (val < 0) {
 800b80e:	1c10      	adds	r0, r2, #0
 800b810:	2100      	movs	r1, #0
{
 800b812:	1c14      	adds	r4, r2, #0
 800b814:	4698      	mov	r8, r3
  if (val < 0) {
 800b816:	f7f4 feb5 	bl	8000584 <__aeabi_fcmplt>
 800b81a:	2800      	cmp	r0, #0
 800b81c:	d009      	beq.n	800b832 <string_value_with_prefix+0x32>
    val = -val;
 800b81e:	2380      	movs	r3, #128	; 0x80
 800b820:	061b      	lsls	r3, r3, #24
 800b822:	469c      	mov	ip, r3
    *buf++ = '-';
 800b824:	232d      	movs	r3, #45	; 0x2d
 800b826:	702b      	strb	r3, [r5, #0]
    len--;
 800b828:	3b2e      	subs	r3, #46	; 0x2e
    val = -val;
 800b82a:	4464      	add	r4, ip
    len--;
 800b82c:	469c      	mov	ip, r3
    *buf++ = '-';
 800b82e:	3501      	adds	r5, #1
    len--;
 800b830:	44e1      	add	r9, ip
  }
  if (val < 1e-12) {
 800b832:	1c20      	adds	r0, r4, #0
 800b834:	f7f7 fdd4 	bl	80033e0 <__aeabi_f2d>
 800b838:	4a5e      	ldr	r2, [pc, #376]	; (800b9b4 <string_value_with_prefix+0x1b4>)
 800b83a:	4b5f      	ldr	r3, [pc, #380]	; (800b9b8 <string_value_with_prefix+0x1b8>)
 800b83c:	0006      	movs	r6, r0
 800b83e:	000f      	movs	r7, r1
 800b840:	f7f4 fe64 	bl	800050c <__aeabi_dcmplt>
 800b844:	2800      	cmp	r0, #0
 800b846:	d03c      	beq.n	800b8c2 <string_value_with_prefix+0xc2>
    prefix = 'f';
    val *= 1e15;
 800b848:	4a5c      	ldr	r2, [pc, #368]	; (800b9bc <string_value_with_prefix+0x1bc>)
 800b84a:	4b5d      	ldr	r3, [pc, #372]	; (800b9c0 <string_value_with_prefix+0x1c0>)
 800b84c:	0030      	movs	r0, r6
 800b84e:	0039      	movs	r1, r7
 800b850:	f7f6 fed6 	bl	8002600 <__aeabi_dmul>
 800b854:	f7f7 fe1c 	bl	8003490 <__aeabi_d2f>
    prefix = 'f';
 800b858:	2666      	movs	r6, #102	; 0x66
    val *= 1e15;
 800b85a:	1c04      	adds	r4, r0, #0
  } else {
    prefix = 'G';
    val /= 1e9;
  }

  if (val < 10) {
 800b85c:	4959      	ldr	r1, [pc, #356]	; (800b9c4 <string_value_with_prefix+0x1c4>)
 800b85e:	1c20      	adds	r0, r4, #0
 800b860:	f7f4 fe90 	bl	8000584 <__aeabi_fcmplt>
 800b864:	2800      	cmp	r0, #0
 800b866:	d145      	bne.n	800b8f4 <string_value_with_prefix+0xf4>
    n = chsnprintf(buf, len, "%.2f", val);
  } else if (val < 100) {
 800b868:	4957      	ldr	r1, [pc, #348]	; (800b9c8 <string_value_with_prefix+0x1c8>)
 800b86a:	1c20      	adds	r0, r4, #0
 800b86c:	f7f4 fe8a 	bl	8000584 <__aeabi_fcmplt>
 800b870:	2800      	cmp	r0, #0
 800b872:	d11b      	bne.n	800b8ac <string_value_with_prefix+0xac>
    n = chsnprintf(buf, len, "%.1f", val);
  } else {
    n = chsnprintf(buf, len, "%d", (int)val);
 800b874:	1c20      	adds	r0, r4, #0
 800b876:	f7f5 fe93 	bl	80015a0 <__aeabi_f2iz>
 800b87a:	4a54      	ldr	r2, [pc, #336]	; (800b9cc <string_value_with_prefix+0x1cc>)
 800b87c:	0003      	movs	r3, r0
 800b87e:	4649      	mov	r1, r9
 800b880:	0028      	movs	r0, r5
 800b882:	f7fb fe55 	bl	8007530 <chsnprintf>
  }

  if (prefix)
 800b886:	1c43      	adds	r3, r0, #1
 800b888:	1829      	adds	r1, r5, r0
 800b88a:	18ea      	adds	r2, r5, r3
 800b88c:	2e00      	cmp	r6, #0
 800b88e:	d003      	beq.n	800b898 <string_value_with_prefix+0x98>
    buf[n++] = prefix;
 800b890:	1c83      	adds	r3, r0, #2
 800b892:	700e      	strb	r6, [r1, #0]
 800b894:	0011      	movs	r1, r2
 800b896:	18ea      	adds	r2, r5, r3
  if (unit)
    buf[n++] = unit;
 800b898:	4640      	mov	r0, r8
 800b89a:	7008      	strb	r0, [r1, #0]
  buf[n] = '\0';
 800b89c:	2100      	movs	r1, #0
  return n;
}
 800b89e:	0018      	movs	r0, r3
  buf[n] = '\0';
 800b8a0:	7011      	strb	r1, [r2, #0]
}
 800b8a2:	b003      	add	sp, #12
 800b8a4:	bc0c      	pop	{r2, r3}
 800b8a6:	4690      	mov	r8, r2
 800b8a8:	4699      	mov	r9, r3
 800b8aa:	bdf0      	pop	{r4, r5, r6, r7, pc}
    n = chsnprintf(buf, len, "%.1f", val);
 800b8ac:	1c20      	adds	r0, r4, #0
 800b8ae:	f7f7 fd97 	bl	80033e0 <__aeabi_f2d>
 800b8b2:	4a47      	ldr	r2, [pc, #284]	; (800b9d0 <string_value_with_prefix+0x1d0>)
 800b8b4:	9000      	str	r0, [sp, #0]
 800b8b6:	9101      	str	r1, [sp, #4]
 800b8b8:	4649      	mov	r1, r9
 800b8ba:	0028      	movs	r0, r5
 800b8bc:	f7fb fe38 	bl	8007530 <chsnprintf>
 800b8c0:	e7e1      	b.n	800b886 <string_value_with_prefix+0x86>
  } else if (val < 1e-9) {
 800b8c2:	4a44      	ldr	r2, [pc, #272]	; (800b9d4 <string_value_with_prefix+0x1d4>)
 800b8c4:	4b44      	ldr	r3, [pc, #272]	; (800b9d8 <string_value_with_prefix+0x1d8>)
 800b8c6:	0030      	movs	r0, r6
 800b8c8:	0039      	movs	r1, r7
 800b8ca:	f7f4 fe1f 	bl	800050c <__aeabi_dcmplt>
 800b8ce:	2800      	cmp	r0, #0
 800b8d0:	d01b      	beq.n	800b90a <string_value_with_prefix+0x10a>
    val *= 1e12;
 800b8d2:	22a2      	movs	r2, #162	; 0xa2
 800b8d4:	4b41      	ldr	r3, [pc, #260]	; (800b9dc <string_value_with_prefix+0x1dc>)
 800b8d6:	0612      	lsls	r2, r2, #24
 800b8d8:	0030      	movs	r0, r6
 800b8da:	0039      	movs	r1, r7
 800b8dc:	f7f6 fe90 	bl	8002600 <__aeabi_dmul>
 800b8e0:	f7f7 fdd6 	bl	8003490 <__aeabi_d2f>
 800b8e4:	1c04      	adds	r4, r0, #0
  if (val < 10) {
 800b8e6:	4937      	ldr	r1, [pc, #220]	; (800b9c4 <string_value_with_prefix+0x1c4>)
 800b8e8:	1c20      	adds	r0, r4, #0
    prefix = 'p';
 800b8ea:	2670      	movs	r6, #112	; 0x70
  if (val < 10) {
 800b8ec:	f7f4 fe4a 	bl	8000584 <__aeabi_fcmplt>
 800b8f0:	2800      	cmp	r0, #0
 800b8f2:	d0b9      	beq.n	800b868 <string_value_with_prefix+0x68>
    n = chsnprintf(buf, len, "%.2f", val);
 800b8f4:	1c20      	adds	r0, r4, #0
 800b8f6:	f7f7 fd73 	bl	80033e0 <__aeabi_f2d>
 800b8fa:	4a39      	ldr	r2, [pc, #228]	; (800b9e0 <string_value_with_prefix+0x1e0>)
 800b8fc:	9000      	str	r0, [sp, #0]
 800b8fe:	9101      	str	r1, [sp, #4]
 800b900:	4649      	mov	r1, r9
 800b902:	0028      	movs	r0, r5
 800b904:	f7fb fe14 	bl	8007530 <chsnprintf>
 800b908:	e7bd      	b.n	800b886 <string_value_with_prefix+0x86>
  } else if (val < 1e-6) {
 800b90a:	4a36      	ldr	r2, [pc, #216]	; (800b9e4 <string_value_with_prefix+0x1e4>)
 800b90c:	4b36      	ldr	r3, [pc, #216]	; (800b9e8 <string_value_with_prefix+0x1e8>)
 800b90e:	0030      	movs	r0, r6
 800b910:	0039      	movs	r1, r7
 800b912:	f7f4 fdfb 	bl	800050c <__aeabi_dcmplt>
 800b916:	2800      	cmp	r0, #0
 800b918:	d10e      	bne.n	800b938 <string_value_with_prefix+0x138>
  } else if (val < 1e-3) {
 800b91a:	4a34      	ldr	r2, [pc, #208]	; (800b9ec <string_value_with_prefix+0x1ec>)
 800b91c:	4b34      	ldr	r3, [pc, #208]	; (800b9f0 <string_value_with_prefix+0x1f0>)
 800b91e:	0030      	movs	r0, r6
 800b920:	0039      	movs	r1, r7
 800b922:	f7f4 fdf3 	bl	800050c <__aeabi_dcmplt>
 800b926:	2800      	cmp	r0, #0
 800b928:	d00d      	beq.n	800b946 <string_value_with_prefix+0x146>
    val *= 1e6;
 800b92a:	1c20      	adds	r0, r4, #0
 800b92c:	4931      	ldr	r1, [pc, #196]	; (800b9f4 <string_value_with_prefix+0x1f4>)
 800b92e:	f7f5 fb5f 	bl	8000ff0 <__aeabi_fmul>
    prefix = S_MICRO[0];
 800b932:	261d      	movs	r6, #29
    val *= 1e6;
 800b934:	1c04      	adds	r4, r0, #0
 800b936:	e791      	b.n	800b85c <string_value_with_prefix+0x5c>
    val *= 1e9;
 800b938:	1c20      	adds	r0, r4, #0
 800b93a:	492f      	ldr	r1, [pc, #188]	; (800b9f8 <string_value_with_prefix+0x1f8>)
 800b93c:	f7f5 fb58 	bl	8000ff0 <__aeabi_fmul>
    prefix = 'n';
 800b940:	266e      	movs	r6, #110	; 0x6e
    val *= 1e9;
 800b942:	1c04      	adds	r4, r0, #0
 800b944:	e78a      	b.n	800b85c <string_value_with_prefix+0x5c>
  } else if (val < 1) {
 800b946:	21fe      	movs	r1, #254	; 0xfe
 800b948:	1c20      	adds	r0, r4, #0
 800b94a:	0589      	lsls	r1, r1, #22
 800b94c:	f7f4 fe1a 	bl	8000584 <__aeabi_fcmplt>
    val *= 1e3;
 800b950:	492a      	ldr	r1, [pc, #168]	; (800b9fc <string_value_with_prefix+0x1fc>)
  } else if (val < 1) {
 800b952:	2800      	cmp	r0, #0
 800b954:	d113      	bne.n	800b97e <string_value_with_prefix+0x17e>
  } else if (val < 1e3) {
 800b956:	1c20      	adds	r0, r4, #0
 800b958:	f7f4 fe14 	bl	8000584 <__aeabi_fcmplt>
    prefix = 0;
 800b95c:	2600      	movs	r6, #0
  } else if (val < 1e3) {
 800b95e:	2800      	cmp	r0, #0
 800b960:	d000      	beq.n	800b964 <string_value_with_prefix+0x164>
 800b962:	e77b      	b.n	800b85c <string_value_with_prefix+0x5c>
  } else if (val < 1e6) {
 800b964:	4923      	ldr	r1, [pc, #140]	; (800b9f4 <string_value_with_prefix+0x1f4>)
 800b966:	1c20      	adds	r0, r4, #0
 800b968:	f7f4 fe0c 	bl	8000584 <__aeabi_fcmplt>
 800b96c:	2800      	cmp	r0, #0
 800b96e:	d00c      	beq.n	800b98a <string_value_with_prefix+0x18a>
    val /= 1e3;
 800b970:	1c20      	adds	r0, r4, #0
 800b972:	4922      	ldr	r1, [pc, #136]	; (800b9fc <string_value_with_prefix+0x1fc>)
 800b974:	f7f5 f95c 	bl	8000c30 <__aeabi_fdiv>
    prefix = 'k';
 800b978:	366b      	adds	r6, #107	; 0x6b
    val /= 1e3;
 800b97a:	1c04      	adds	r4, r0, #0
 800b97c:	e76e      	b.n	800b85c <string_value_with_prefix+0x5c>
    val *= 1e3;
 800b97e:	1c20      	adds	r0, r4, #0
 800b980:	f7f5 fb36 	bl	8000ff0 <__aeabi_fmul>
    prefix = 'm';
 800b984:	266d      	movs	r6, #109	; 0x6d
    val *= 1e3;
 800b986:	1c04      	adds	r4, r0, #0
 800b988:	e768      	b.n	800b85c <string_value_with_prefix+0x5c>
  } else if (val < 1e9) {
 800b98a:	491b      	ldr	r1, [pc, #108]	; (800b9f8 <string_value_with_prefix+0x1f8>)
 800b98c:	1c20      	adds	r0, r4, #0
 800b98e:	f7f4 fdf9 	bl	8000584 <__aeabi_fcmplt>
 800b992:	2800      	cmp	r0, #0
 800b994:	d006      	beq.n	800b9a4 <string_value_with_prefix+0x1a4>
    val /= 1e6;
 800b996:	1c20      	adds	r0, r4, #0
 800b998:	4916      	ldr	r1, [pc, #88]	; (800b9f4 <string_value_with_prefix+0x1f4>)
 800b99a:	f7f5 f949 	bl	8000c30 <__aeabi_fdiv>
    prefix = 'M';
 800b99e:	264d      	movs	r6, #77	; 0x4d
    val /= 1e6;
 800b9a0:	1c04      	adds	r4, r0, #0
 800b9a2:	e75b      	b.n	800b85c <string_value_with_prefix+0x5c>
    val /= 1e9;
 800b9a4:	1c20      	adds	r0, r4, #0
 800b9a6:	4914      	ldr	r1, [pc, #80]	; (800b9f8 <string_value_with_prefix+0x1f8>)
 800b9a8:	f7f5 f942 	bl	8000c30 <__aeabi_fdiv>
    prefix = 'G';
 800b9ac:	2647      	movs	r6, #71	; 0x47
    val /= 1e9;
 800b9ae:	1c04      	adds	r4, r0, #0
 800b9b0:	e754      	b.n	800b85c <string_value_with_prefix+0x5c>
 800b9b2:	46c0      	nop			; (mov r8, r8)
 800b9b4:	812dea11 	.word	0x812dea11
 800b9b8:	3d719799 	.word	0x3d719799
 800b9bc:	26340000 	.word	0x26340000
 800b9c0:	430c6bf5 	.word	0x430c6bf5
 800b9c4:	41200000 	.word	0x41200000
 800b9c8:	42c80000 	.word	0x42c80000
 800b9cc:	08014ab4 	.word	0x08014ab4
 800b9d0:	08014aac 	.word	0x08014aac
 800b9d4:	e826d695 	.word	0xe826d695
 800b9d8:	3e112e0b 	.word	0x3e112e0b
 800b9dc:	426d1a94 	.word	0x426d1a94
 800b9e0:	08014aa4 	.word	0x08014aa4
 800b9e4:	a0b5ed8d 	.word	0xa0b5ed8d
 800b9e8:	3eb0c6f7 	.word	0x3eb0c6f7
 800b9ec:	d2f1a9fc 	.word	0xd2f1a9fc
 800b9f0:	3f50624d 	.word	0x3f50624d
 800b9f4:	49742400 	.word	0x49742400
 800b9f8:	4e6e6b28 	.word	0x4e6e6b28
 800b9fc:	447a0000 	.word	0x447a0000

0800ba00 <frequency_string>:
  mark_map(m, n);

}

static void frequency_string(char *buf, size_t len, int32_t freq)
{
 800ba00:	b5f0      	push	{r4, r5, r6, r7, lr}
 800ba02:	0005      	movs	r5, r0
 800ba04:	b083      	sub	sp, #12
 800ba06:	000e      	movs	r6, r1
 800ba08:	1e14      	subs	r4, r2, #0
  if (freq < 0) {
 800ba0a:	da04      	bge.n	800ba16 <frequency_string+0x16>
    freq = -freq;
    *buf++ = '-';
 800ba0c:	232d      	movs	r3, #45	; 0x2d
    freq = -freq;
 800ba0e:	4254      	negs	r4, r2
    *buf++ = '-';
 800ba10:	7003      	strb	r3, [r0, #0]
    len -= 1;
 800ba12:	3e01      	subs	r6, #1
    *buf++ = '-';
 800ba14:	3501      	adds	r5, #1
  }
  if (freq < 1000) {
 800ba16:	4b19      	ldr	r3, [pc, #100]	; (800ba7c <frequency_string+0x7c>)
 800ba18:	429c      	cmp	r4, r3
 800ba1a:	dd28      	ble.n	800ba6e <frequency_string+0x6e>
    chsnprintf(buf, len, "%dHz", (int)freq);
  } else if (freq < 1000000) {
 800ba1c:	21fa      	movs	r1, #250	; 0xfa
 800ba1e:	0020      	movs	r0, r4
 800ba20:	0089      	lsls	r1, r1, #2
 800ba22:	f7f4 fc65 	bl	80002f0 <__divsi3>
 800ba26:	4b16      	ldr	r3, [pc, #88]	; (800ba80 <frequency_string+0x80>)
 800ba28:	0007      	movs	r7, r0
 800ba2a:	429c      	cmp	r4, r3
 800ba2c:	dd12      	ble.n	800ba54 <frequency_string+0x54>
//	   chsnprintf(buf, len, "%d.%03d %03d MHz",
//               (int)(freq / 1000000),
//	             (int)((freq / 1000) % 1000),
//	             (int)(freq % 1000));
	   chsnprintf(buf, len, "%d.%03dMHz",
	             (int)(freq / 1000000),
 800ba2e:	4915      	ldr	r1, [pc, #84]	; (800ba84 <frequency_string+0x84>)
 800ba30:	0020      	movs	r0, r4
 800ba32:	f7f4 fc5d 	bl	80002f0 <__divsi3>
	             (int)((freq / 1000) % 1000));
 800ba36:	21fa      	movs	r1, #250	; 0xfa
	             (int)(freq / 1000000),
 800ba38:	0004      	movs	r4, r0
	             (int)((freq / 1000) % 1000));
 800ba3a:	0089      	lsls	r1, r1, #2
 800ba3c:	0038      	movs	r0, r7
 800ba3e:	f7f4 fd3d 	bl	80004bc <__aeabi_idivmod>
	   chsnprintf(buf, len, "%d.%03dMHz",
 800ba42:	0023      	movs	r3, r4
 800ba44:	9100      	str	r1, [sp, #0]
 800ba46:	4a10      	ldr	r2, [pc, #64]	; (800ba88 <frequency_string+0x88>)
 800ba48:	0031      	movs	r1, r6
 800ba4a:	0028      	movs	r0, r5
 800ba4c:	f7fb fd70 	bl	8007530 <chsnprintf>
  }
}
 800ba50:	b003      	add	sp, #12
 800ba52:	bdf0      	pop	{r4, r5, r6, r7, pc}
             (int)(freq % 1000));
 800ba54:	21fa      	movs	r1, #250	; 0xfa
 800ba56:	0020      	movs	r0, r4
 800ba58:	0089      	lsls	r1, r1, #2
 800ba5a:	f7f4 fd2f 	bl	80004bc <__aeabi_idivmod>
    chsnprintf(buf, len, "%d.%03dkHz",
 800ba5e:	003b      	movs	r3, r7
 800ba60:	9100      	str	r1, [sp, #0]
 800ba62:	4a0a      	ldr	r2, [pc, #40]	; (800ba8c <frequency_string+0x8c>)
 800ba64:	0031      	movs	r1, r6
 800ba66:	0028      	movs	r0, r5
 800ba68:	f7fb fd62 	bl	8007530 <chsnprintf>
 800ba6c:	e7f0      	b.n	800ba50 <frequency_string+0x50>
    chsnprintf(buf, len, "%dHz", (int)freq);
 800ba6e:	0023      	movs	r3, r4
 800ba70:	4a07      	ldr	r2, [pc, #28]	; (800ba90 <frequency_string+0x90>)
 800ba72:	0031      	movs	r1, r6
 800ba74:	0028      	movs	r0, r5
 800ba76:	f7fb fd5b 	bl	8007530 <chsnprintf>
 800ba7a:	e7e9      	b.n	800ba50 <frequency_string+0x50>
 800ba7c:	000003e7 	.word	0x000003e7
 800ba80:	000f423f 	.word	0x000f423f
 800ba84:	000f4240 	.word	0x000f4240
 800ba88:	08014a98 	.word	0x08014a98
 800ba8c:	08014a8c 	.word	0x08014a8c
 800ba90:	08014a84 	.word	0x08014a84
	...

0800baa0 <swr>:
  float x = sqrtf(v[0]*v[0] + v[1]*v[1]);
 800baa0:	6803      	ldr	r3, [r0, #0]
{
 800baa2:	b570      	push	{r4, r5, r6, lr}
  float x = sqrtf(v[0]*v[0] + v[1]*v[1]);
 800baa4:	1c19      	adds	r1, r3, #0
 800baa6:	6844      	ldr	r4, [r0, #4]
 800baa8:	1c18      	adds	r0, r3, #0
 800baaa:	f7f5 faa1 	bl	8000ff0 <__aeabi_fmul>
 800baae:	1c21      	adds	r1, r4, #0
 800bab0:	1c05      	adds	r5, r0, #0
 800bab2:	1c20      	adds	r0, r4, #0
 800bab4:	f7f5 fa9c 	bl	8000ff0 <__aeabi_fmul>
 800bab8:	1c01      	adds	r1, r0, #0
 800baba:	1c28      	adds	r0, r5, #0
 800babc:	f7f4 ff38 	bl	8000930 <__aeabi_fadd>
 800bac0:	f005 fc9e 	bl	8011400 <sqrtf>
  if (x > 1)
 800bac4:	21fe      	movs	r1, #254	; 0xfe
 800bac6:	0589      	lsls	r1, r1, #22
  float x = sqrtf(v[0]*v[0] + v[1]*v[1]);
 800bac8:	1c04      	adds	r4, r0, #0
  if (x > 1)
 800baca:	f7f4 fd6f 	bl	80005ac <__aeabi_fcmpgt>
 800bace:	2800      	cmp	r0, #0
 800bad0:	d10f      	bne.n	800baf2 <swr+0x52>
  return (1 + x)/(1 - x);
 800bad2:	21fe      	movs	r1, #254	; 0xfe
 800bad4:	1c20      	adds	r0, r4, #0
 800bad6:	0589      	lsls	r1, r1, #22
 800bad8:	f7f4 ff2a 	bl	8000930 <__aeabi_fadd>
 800badc:	1c05      	adds	r5, r0, #0
 800bade:	20fe      	movs	r0, #254	; 0xfe
 800bae0:	1c21      	adds	r1, r4, #0
 800bae2:	0580      	lsls	r0, r0, #22
 800bae4:	f7f5 fb9c 	bl	8001220 <__aeabi_fsub>
 800bae8:	1c01      	adds	r1, r0, #0
 800baea:	1c28      	adds	r0, r5, #0
 800baec:	f7f5 f8a0 	bl	8000c30 <__aeabi_fdiv>
}
 800baf0:	bd70      	pop	{r4, r5, r6, pc}
    return INFINITY;
 800baf2:	20ff      	movs	r0, #255	; 0xff
 800baf4:	05c0      	lsls	r0, r0, #23
 800baf6:	e7fb      	b.n	800baf0 <swr+0x50>
	...

0800bb00 <cell_drawline>:
{
 800bb00:	b5f0      	push	{r4, r5, r6, r7, lr}
 800bb02:	4645      	mov	r5, r8
 800bb04:	4657      	mov	r7, sl
 800bb06:	46de      	mov	lr, fp
 800bb08:	464e      	mov	r6, r9
 800bb0a:	b5e0      	push	{r5, r6, r7, lr}
 800bb0c:	b083      	sub	sp, #12
 800bb0e:	4680      	mov	r8, r0
 800bb10:	9c0c      	ldr	r4, [sp, #48]	; 0x30
 800bb12:	0008      	movs	r0, r1
 800bb14:	9f0d      	ldr	r7, [sp, #52]	; 0x34
        code |= LEFT;
 800bb16:	2501      	movs	r5, #1
    if (x < 0) {
 800bb18:	2a00      	cmp	r2, #0
 800bb1a:	db03      	blt.n	800bb24 <cell_drawline+0x24>
    uint8_t code = 0;
 800bb1c:	2500      	movs	r5, #0
    if (x > w) {
 800bb1e:	4590      	cmp	r8, r2
 800bb20:	da00      	bge.n	800bb24 <cell_drawline+0x24>
 800bb22:	e0a9      	b.n	800bc78 <cell_drawline+0x178>
    if (y < 0) {
 800bb24:	2b00      	cmp	r3, #0
 800bb26:	da00      	bge.n	800bb2a <cell_drawline+0x2a>
 800bb28:	e0aa      	b.n	800bc80 <cell_drawline+0x180>
    if (y > h) {
 800bb2a:	4298      	cmp	r0, r3
 800bb2c:	da00      	bge.n	800bb30 <cell_drawline+0x30>
 800bb2e:	e0a0      	b.n	800bc72 <cell_drawline+0x172>
        code |= LEFT;
 800bb30:	2101      	movs	r1, #1
    if (x < 0) {
 800bb32:	2c00      	cmp	r4, #0
 800bb34:	db03      	blt.n	800bb3e <cell_drawline+0x3e>
    uint8_t code = 0;
 800bb36:	2100      	movs	r1, #0
    if (x > w) {
 800bb38:	45a0      	cmp	r8, r4
 800bb3a:	da00      	bge.n	800bb3e <cell_drawline+0x3e>
 800bb3c:	e092      	b.n	800bc64 <cell_drawline+0x164>
    if (y < 0) {
 800bb3e:	2f00      	cmp	r7, #0
 800bb40:	da00      	bge.n	800bb44 <cell_drawline+0x44>
 800bb42:	e093      	b.n	800bc6c <cell_drawline+0x16c>
    if (y > h) {
 800bb44:	42b8      	cmp	r0, r7
 800bb46:	da00      	bge.n	800bb4a <cell_drawline+0x4a>
 800bb48:	e09d      	b.n	800bc86 <cell_drawline+0x186>
    if (outcode0 & outcode1) {
 800bb4a:	420d      	tst	r5, r1
 800bb4c:	d13a      	bne.n	800bbc4 <cell_drawline+0xc4>
    if (x0 > x1) {
 800bb4e:	42a2      	cmp	r2, r4
 800bb50:	dd05      	ble.n	800bb5e <cell_drawline+0x5e>
 800bb52:	0019      	movs	r1, r3
 800bb54:	003b      	movs	r3, r7
 800bb56:	000f      	movs	r7, r1
 800bb58:	0011      	movs	r1, r2
 800bb5a:	0022      	movs	r2, r4
 800bb5c:	000c      	movs	r4, r1
    int sy = dy > 0 ? 1 : -1;
 800bb5e:	2101      	movs	r1, #1
    int dx = x1 - x0;
 800bb60:	1aa6      	subs	r6, r4, r2
    int dy = y1 - y0;
 800bb62:	1afd      	subs	r5, r7, r3
    int sy = dy > 0 ? 1 : -1;
 800bb64:	468c      	mov	ip, r1
 800bb66:	2d00      	cmp	r5, #0
 800bb68:	dc00      	bgt.n	800bb6c <cell_drawline+0x6c>
 800bb6a:	e08f      	b.n	800bc8c <cell_drawline+0x18c>
    if (dx >= dy) {
 800bb6c:	42ae      	cmp	r6, r5
 800bb6e:	db30      	blt.n	800bbd2 <cell_drawline+0xd2>
        e = dy * 2 - dx;
 800bb70:	006d      	lsls	r5, r5, #1
 800bb72:	1ba9      	subs	r1, r5, r6
        while (x0 != x1) {
 800bb74:	4294      	cmp	r4, r2
 800bb76:	d063      	beq.n	800bc40 <cell_drawline+0x140>
                e -= dx * 2;
 800bb78:	0076      	lsls	r6, r6, #1
            if (y0 >= 0 && y0 < h && x0 >= 0 && x0 < w)  spi_buffer[y0*w+x0] |= c;
 800bb7a:	4f47      	ldr	r7, [pc, #284]	; (800bc98 <cell_drawline+0x198>)
 800bb7c:	46b3      	mov	fp, r6
 800bb7e:	4666      	mov	r6, ip
 800bb80:	46b9      	mov	r9, r7
 800bb82:	4684      	mov	ip, r0
 800bb84:	9600      	str	r6, [sp, #0]
 800bb86:	2b00      	cmp	r3, #0
 800bb88:	db0f      	blt.n	800bbaa <cell_drawline+0xaa>
 800bb8a:	459c      	cmp	ip, r3
 800bb8c:	dd0d      	ble.n	800bbaa <cell_drawline+0xaa>
 800bb8e:	2a00      	cmp	r2, #0
 800bb90:	db0b      	blt.n	800bbaa <cell_drawline+0xaa>
 800bb92:	4590      	cmp	r8, r2
 800bb94:	dd09      	ble.n	800bbaa <cell_drawline+0xaa>
 800bb96:	4647      	mov	r7, r8
 800bb98:	435f      	muls	r7, r3
 800bb9a:	18bf      	adds	r7, r7, r2
 800bb9c:	007e      	lsls	r6, r7, #1
 800bb9e:	464f      	mov	r7, r9
 800bba0:	980e      	ldr	r0, [sp, #56]	; 0x38
 800bba2:	5bf7      	ldrh	r7, [r6, r7]
 800bba4:	4307      	orrs	r7, r0
 800bba6:	4648      	mov	r0, r9
 800bba8:	5237      	strh	r7, [r6, r0]
            x0++;
 800bbaa:	3201      	adds	r2, #1
            if (e >= 0) {
 800bbac:	1949      	adds	r1, r1, r5
 800bbae:	d404      	bmi.n	800bbba <cell_drawline+0xba>
                e -= dx * 2;
 800bbb0:	4658      	mov	r0, fp
 800bbb2:	1a09      	subs	r1, r1, r0
                y0 += sy;
 800bbb4:	9800      	ldr	r0, [sp, #0]
 800bbb6:	4682      	mov	sl, r0
 800bbb8:	4453      	add	r3, sl
        while (x0 != x1) {
 800bbba:	4294      	cmp	r4, r2
 800bbbc:	d1e3      	bne.n	800bb86 <cell_drawline+0x86>
 800bbbe:	4660      	mov	r0, ip
        if (y0 >= 0 && y0 < h && x0 >= 0 && x0 < w)  spi_buffer[y0*w+x0] |= c;
 800bbc0:	2b00      	cmp	r3, #0
 800bbc2:	da3f      	bge.n	800bc44 <cell_drawline+0x144>
}
 800bbc4:	b003      	add	sp, #12
 800bbc6:	bc3c      	pop	{r2, r3, r4, r5}
 800bbc8:	4690      	mov	r8, r2
 800bbca:	4699      	mov	r9, r3
 800bbcc:	46a2      	mov	sl, r4
 800bbce:	46ab      	mov	fp, r5
 800bbd0:	bdf0      	pop	{r4, r5, r6, r7, pc}
        e = dx * 2 - dy;
 800bbd2:	0076      	lsls	r6, r6, #1
 800bbd4:	1b74      	subs	r4, r6, r5
        while (y0 != y1) {
 800bbd6:	429f      	cmp	r7, r3
 800bbd8:	d032      	beq.n	800bc40 <cell_drawline+0x140>
                e -= dy * 2;
 800bbda:	0069      	lsls	r1, r5, #1
 800bbdc:	468a      	mov	sl, r1
 800bbde:	4665      	mov	r5, ip
 800bbe0:	4641      	mov	r1, r8
 800bbe2:	4369      	muls	r1, r5
            if (y0 >= 0 && y0 < h && x0 >= 0 && x0 < w)  spi_buffer[y0*w+x0] |= c;
 800bbe4:	4655      	mov	r5, sl
 800bbe6:	4689      	mov	r9, r1
 800bbe8:	4641      	mov	r1, r8
 800bbea:	9601      	str	r6, [sp, #4]
 800bbec:	4666      	mov	r6, ip
 800bbee:	970d      	str	r7, [sp, #52]	; 0x34
 800bbf0:	46ac      	mov	ip, r5
 800bbf2:	464f      	mov	r7, r9
 800bbf4:	4681      	mov	r9, r0
 800bbf6:	4359      	muls	r1, r3
 800bbf8:	9600      	str	r6, [sp, #0]
 800bbfa:	2b00      	cmp	r3, #0
 800bbfc:	db12      	blt.n	800bc24 <cell_drawline+0x124>
 800bbfe:	4599      	cmp	r9, r3
 800bc00:	dd10      	ble.n	800bc24 <cell_drawline+0x124>
 800bc02:	2a00      	cmp	r2, #0
 800bc04:	db0e      	blt.n	800bc24 <cell_drawline+0x124>
 800bc06:	4590      	cmp	r8, r2
 800bc08:	dd0c      	ble.n	800bc24 <cell_drawline+0x124>
 800bc0a:	1888      	adds	r0, r1, r2
 800bc0c:	0040      	lsls	r0, r0, #1
 800bc0e:	4682      	mov	sl, r0
 800bc10:	4655      	mov	r5, sl
 800bc12:	4821      	ldr	r0, [pc, #132]	; (800bc98 <cell_drawline+0x198>)
 800bc14:	5a28      	ldrh	r0, [r5, r0]
 800bc16:	9d0e      	ldr	r5, [sp, #56]	; 0x38
 800bc18:	4328      	orrs	r0, r5
 800bc1a:	4683      	mov	fp, r0
 800bc1c:	4655      	mov	r5, sl
 800bc1e:	465e      	mov	r6, fp
 800bc20:	481d      	ldr	r0, [pc, #116]	; (800bc98 <cell_drawline+0x198>)
 800bc22:	522e      	strh	r6, [r5, r0]
            y0 += sy;
 800bc24:	9800      	ldr	r0, [sp, #0]
 800bc26:	4682      	mov	sl, r0
            if (e >= 0) {
 800bc28:	9801      	ldr	r0, [sp, #4]
            y0 += sy;
 800bc2a:	4453      	add	r3, sl
            if (e >= 0) {
 800bc2c:	1824      	adds	r4, r4, r0
 800bc2e:	d402      	bmi.n	800bc36 <cell_drawline+0x136>
                e -= dy * 2;
 800bc30:	4660      	mov	r0, ip
                x0++;
 800bc32:	3201      	adds	r2, #1
                e -= dy * 2;
 800bc34:	1a24      	subs	r4, r4, r0
        while (y0 != y1) {
 800bc36:	980d      	ldr	r0, [sp, #52]	; 0x34
 800bc38:	19c9      	adds	r1, r1, r7
 800bc3a:	4298      	cmp	r0, r3
 800bc3c:	d1dd      	bne.n	800bbfa <cell_drawline+0xfa>
 800bc3e:	4648      	mov	r0, r9
        if (y0 >= 0 && y0 < h && x0 >= 0 && x0 < w)  spi_buffer[y0*w+x0] |= c;
 800bc40:	2b00      	cmp	r3, #0
 800bc42:	dbbf      	blt.n	800bbc4 <cell_drawline+0xc4>
 800bc44:	4298      	cmp	r0, r3
 800bc46:	ddbd      	ble.n	800bbc4 <cell_drawline+0xc4>
 800bc48:	2a00      	cmp	r2, #0
 800bc4a:	dbbb      	blt.n	800bbc4 <cell_drawline+0xc4>
 800bc4c:	4590      	cmp	r8, r2
 800bc4e:	ddb9      	ble.n	800bbc4 <cell_drawline+0xc4>
 800bc50:	4641      	mov	r1, r8
 800bc52:	434b      	muls	r3, r1
 800bc54:	4910      	ldr	r1, [pc, #64]	; (800bc98 <cell_drawline+0x198>)
 800bc56:	189a      	adds	r2, r3, r2
 800bc58:	0052      	lsls	r2, r2, #1
 800bc5a:	5a53      	ldrh	r3, [r2, r1]
 800bc5c:	980e      	ldr	r0, [sp, #56]	; 0x38
 800bc5e:	4303      	orrs	r3, r0
 800bc60:	5253      	strh	r3, [r2, r1]
 800bc62:	e7af      	b.n	800bbc4 <cell_drawline+0xc4>
        code |= RIGHT;
 800bc64:	3102      	adds	r1, #2
    if (y < 0) {
 800bc66:	2f00      	cmp	r7, #0
 800bc68:	db00      	blt.n	800bc6c <cell_drawline+0x16c>
 800bc6a:	e76b      	b.n	800bb44 <cell_drawline+0x44>
        code |= BOTTOM;
 800bc6c:	2604      	movs	r6, #4
 800bc6e:	4331      	orrs	r1, r6
 800bc70:	e76b      	b.n	800bb4a <cell_drawline+0x4a>
        code |= TOP;
 800bc72:	2108      	movs	r1, #8
 800bc74:	430d      	orrs	r5, r1
 800bc76:	e75b      	b.n	800bb30 <cell_drawline+0x30>
        code |= RIGHT;
 800bc78:	3502      	adds	r5, #2
    if (y < 0) {
 800bc7a:	2b00      	cmp	r3, #0
 800bc7c:	db00      	blt.n	800bc80 <cell_drawline+0x180>
 800bc7e:	e754      	b.n	800bb2a <cell_drawline+0x2a>
        code |= BOTTOM;
 800bc80:	2104      	movs	r1, #4
 800bc82:	430d      	orrs	r5, r1
 800bc84:	e754      	b.n	800bb30 <cell_drawline+0x30>
        code |= TOP;
 800bc86:	2608      	movs	r6, #8
 800bc88:	4331      	orrs	r1, r6
 800bc8a:	e75e      	b.n	800bb4a <cell_drawline+0x4a>
    int sy = dy > 0 ? 1 : -1;
 800bc8c:	3902      	subs	r1, #2
 800bc8e:	1bdd      	subs	r5, r3, r7
 800bc90:	468c      	mov	ip, r1
    if (dx >= dy) {
 800bc92:	42ae      	cmp	r6, r5
 800bc94:	db9d      	blt.n	800bbd2 <cell_drawline+0xd2>
 800bc96:	e76b      	b.n	800bb70 <cell_drawline+0x70>
 800bc98:	200030ac 	.word	0x200030ac
 800bc9c:	00000000 	.word	0x00000000

0800bca0 <cell_drawchar_7x13>:
{
 800bca0:	b5f0      	push	{r4, r5, r6, r7, lr}
 800bca2:	4645      	mov	r5, r8
 800bca4:	4657      	mov	r7, sl
 800bca6:	46de      	mov	lr, fp
 800bca8:	464e      	mov	r6, r9
 800bcaa:	b5e0      	push	{r5, r6, r7, lr}
 800bcac:	b083      	sub	sp, #12
 800bcae:	ac0c      	add	r4, sp, #48	; 0x30
 800bcb0:	cc20      	ldmia	r4!, {r5}
 800bcb2:	4698      	mov	r8, r3
 800bcb4:	8823      	ldrh	r3, [r4, #0]
 800bcb6:	9100      	str	r1, [sp, #0]
 800bcb8:	469a      	mov	sl, r3
  if (y <= -13 || y >= h || x <= -7 || x >= w)
 800bcba:	002b      	movs	r3, r5
 800bcbc:	330c      	adds	r3, #12
 800bcbe:	db44      	blt.n	800bd4a <cell_drawchar_7x13+0xaa>
 800bcc0:	428d      	cmp	r5, r1
 800bcc2:	da42      	bge.n	800bd4a <cell_drawchar_7x13+0xaa>
 800bcc4:	4643      	mov	r3, r8
 800bcc6:	3306      	adds	r3, #6
 800bcc8:	db3f      	blt.n	800bd4a <cell_drawchar_7x13+0xaa>
 800bcca:	4580      	cmp	r8, r0
 800bccc:	da3d      	bge.n	800bd4a <cell_drawchar_7x13+0xaa>
 800bcce:	002e      	movs	r6, r5
 800bcd0:	0043      	lsls	r3, r0, #1
 800bcd2:	435e      	muls	r6, r3
 800bcd4:	9301      	str	r3, [sp, #4]
 800bcd6:	230d      	movs	r3, #13
 800bcd8:	4c1f      	ldr	r4, [pc, #124]	; (800bd58 <cell_drawchar_7x13+0xb8>)
 800bcda:	4699      	mov	r9, r3
 800bcdc:	1936      	adds	r6, r6, r4
    bits = x7x13b_bits[(ch * 13) + c];
 800bcde:	0054      	lsls	r4, r2, #1
 800bce0:	18a4      	adds	r4, r4, r2
 800bce2:	00a4      	lsls	r4, r4, #2
 800bce4:	18a2      	adds	r2, r4, r2
 800bce6:	1b52      	subs	r2, r2, r5
 800bce8:	0052      	lsls	r2, r2, #1
 800bcea:	4694      	mov	ip, r2
 800bcec:	4643      	mov	r3, r8
 800bcee:	4c1b      	ldr	r4, [pc, #108]	; (800bd5c <cell_drawchar_7x13+0xbc>)
 800bcf0:	44a9      	add	r9, r5
 800bcf2:	44a4      	add	ip, r4
 800bcf4:	1ddf      	adds	r7, r3, #7
 800bcf6:	e005      	b.n	800bd04 <cell_drawchar_7x13+0x64>
 800bcf8:	9b01      	ldr	r3, [sp, #4]
 800bcfa:	3501      	adds	r5, #1
 800bcfc:	469b      	mov	fp, r3
 800bcfe:	445e      	add	r6, fp
  for(c = 0; c < 13; c++) {
 800bd00:	454d      	cmp	r5, r9
 800bd02:	d022      	beq.n	800bd4a <cell_drawchar_7x13+0xaa>
    if ((y + c) < 0 || (y + c) >= h)
 800bd04:	2d00      	cmp	r5, #0
 800bd06:	dbf7      	blt.n	800bcf8 <cell_drawchar_7x13+0x58>
 800bd08:	9b00      	ldr	r3, [sp, #0]
 800bd0a:	42ab      	cmp	r3, r5
 800bd0c:	ddf4      	ble.n	800bcf8 <cell_drawchar_7x13+0x58>
    bits = x7x13b_bits[(ch * 13) + c];
 800bd0e:	4663      	mov	r3, ip
 800bd10:	006a      	lsls	r2, r5, #1
 800bd12:	5a9c      	ldrh	r4, [r3, r2]
    if (invert)
 800bd14:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800bd16:	2b00      	cmp	r3, #0
 800bd18:	d001      	beq.n	800bd1e <cell_drawchar_7x13+0x7e>
      bits = ~bits;
 800bd1a:	43e4      	mvns	r4, r4
 800bd1c:	b2a4      	uxth	r4, r4
 800bd1e:	4642      	mov	r2, r8
      if ((x+r) >= 0 && (x+r) < w && (0x8000 & bits)) 
 800bd20:	2a00      	cmp	r2, #0
 800bd22:	db07      	blt.n	800bd34 <cell_drawchar_7x13+0x94>
 800bd24:	4290      	cmp	r0, r2
 800bd26:	dd05      	ble.n	800bd34 <cell_drawchar_7x13+0x94>
 800bd28:	b223      	sxth	r3, r4
 800bd2a:	2b00      	cmp	r3, #0
 800bd2c:	da02      	bge.n	800bd34 <cell_drawchar_7x13+0x94>
        spi_buffer[(y+c)*w + (x+r)] = fg;
 800bd2e:	4651      	mov	r1, sl
 800bd30:	0053      	lsls	r3, r2, #1
 800bd32:	52f1      	strh	r1, [r6, r3]
      bits <<= 1;
 800bd34:	0064      	lsls	r4, r4, #1
 800bd36:	3201      	adds	r2, #1
 800bd38:	b2a4      	uxth	r4, r4
    for (r = 0; r < 7; r++) {
 800bd3a:	4297      	cmp	r7, r2
 800bd3c:	d1f0      	bne.n	800bd20 <cell_drawchar_7x13+0x80>
 800bd3e:	9b01      	ldr	r3, [sp, #4]
 800bd40:	3501      	adds	r5, #1
 800bd42:	469b      	mov	fp, r3
 800bd44:	445e      	add	r6, fp
  for(c = 0; c < 13; c++) {
 800bd46:	454d      	cmp	r5, r9
 800bd48:	d1dc      	bne.n	800bd04 <cell_drawchar_7x13+0x64>
}
 800bd4a:	b003      	add	sp, #12
 800bd4c:	bc3c      	pop	{r2, r3, r4, r5}
 800bd4e:	4690      	mov	r8, r2
 800bd50:	4699      	mov	r9, r3
 800bd52:	46a2      	mov	sl, r4
 800bd54:	46ab      	mov	fp, r5
 800bd56:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800bd58:	200030ac 	.word	0x200030ac
 800bd5c:	08015d48 	.word	0x08015d48

0800bd60 <group_delay.constprop.11>:
static float group_delay(float gamma[POINT_COUNT][2], uint32_t* freq, int count, int index)
 800bd60:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800bd62:	4647      	mov	r7, r8
 800bd64:	46ce      	mov	lr, r9
 800bd66:	0006      	movs	r6, r0
    if (index == count-1) {
 800bd68:	4b2a      	ldr	r3, [pc, #168]	; (800be14 <group_delay.constprop.11+0xb4>)
static float group_delay(float gamma[POINT_COUNT][2], uint32_t* freq, int count, int index)
 800bd6a:	b580      	push	{r7, lr}
 800bd6c:	00d4      	lsls	r4, r2, #3
 800bd6e:	0097      	lsls	r7, r2, #2
    if (index == count-1) {
 800bd70:	3901      	subs	r1, #1
 800bd72:	59d8      	ldr	r0, [r3, r7]
 800bd74:	1935      	adds	r5, r6, r4
 800bd76:	4291      	cmp	r1, r2
 800bd78:	d041      	beq.n	800bdfe <group_delay.constprop.11+0x9e>
        deltaf = freq[index+1] - freq[index];
 800bd7a:	3304      	adds	r3, #4
 800bd7c:	59db      	ldr	r3, [r3, r7]
        w = gamma[index+1];
 800bd7e:	3408      	adds	r4, #8
        deltaf = freq[index+1] - freq[index];
 800bd80:	1a18      	subs	r0, r3, r0
 800bd82:	f7f5 fc7d 	bl	8001680 <__aeabi_ui2f>
        w = gamma[index+1];
 800bd86:	1934      	adds	r4, r6, r4
        deltaf = freq[index+1] - freq[index];
 800bd88:	1c07      	adds	r7, r0, #0
    float r = w[0]*v[1] - w[1]*v[0];
 800bd8a:	686b      	ldr	r3, [r5, #4]
 800bd8c:	6826      	ldr	r6, [r4, #0]
 800bd8e:	682d      	ldr	r5, [r5, #0]
    float i = w[0]*v[0] + w[1]*v[1];
 800bd90:	1c30      	adds	r0, r6, #0
 800bd92:	1c29      	adds	r1, r5, #0
    float r = w[0]*v[1] - w[1]*v[0];
 800bd94:	4698      	mov	r8, r3
    float i = w[0]*v[0] + w[1]*v[1];
 800bd96:	f7f5 f92b 	bl	8000ff0 <__aeabi_fmul>
    float r = w[0]*v[1] - w[1]*v[0];
 800bd9a:	6864      	ldr	r4, [r4, #4]
    float i = w[0]*v[0] + w[1]*v[1];
 800bd9c:	4681      	mov	r9, r0
 800bd9e:	1c21      	adds	r1, r4, #0
 800bda0:	4640      	mov	r0, r8
 800bda2:	f7f5 f925 	bl	8000ff0 <__aeabi_fmul>
 800bda6:	1c01      	adds	r1, r0, #0
 800bda8:	4648      	mov	r0, r9
 800bdaa:	f7f4 fdc1 	bl	8000930 <__aeabi_fadd>
    float r = w[0]*v[1] - w[1]*v[0];
 800bdae:	4641      	mov	r1, r8
    float i = w[0]*v[0] + w[1]*v[1];
 800bdb0:	4681      	mov	r9, r0
    float r = w[0]*v[1] - w[1]*v[0];
 800bdb2:	1c30      	adds	r0, r6, #0
 800bdb4:	f7f5 f91c 	bl	8000ff0 <__aeabi_fmul>
 800bdb8:	1c29      	adds	r1, r5, #0
 800bdba:	1c06      	adds	r6, r0, #0
 800bdbc:	1c20      	adds	r0, r4, #0
 800bdbe:	f7f5 f917 	bl	8000ff0 <__aeabi_fmul>
 800bdc2:	1c01      	adds	r1, r0, #0
 800bdc4:	1c30      	adds	r0, r6, #0
 800bdc6:	f7f5 fa2b 	bl	8001220 <__aeabi_fsub>
    return atan2f(r, i) / (2 * M_PI * deltaf);
 800bdca:	4649      	mov	r1, r9
 800bdcc:	f005 fa90 	bl	80112f0 <atan2f>
 800bdd0:	f7f7 fb06 	bl	80033e0 <__aeabi_f2d>
 800bdd4:	0004      	movs	r4, r0
 800bdd6:	1c38      	adds	r0, r7, #0
 800bdd8:	000d      	movs	r5, r1
 800bdda:	f7f7 fb01 	bl	80033e0 <__aeabi_f2d>
 800bdde:	4a0e      	ldr	r2, [pc, #56]	; (800be18 <group_delay.constprop.11+0xb8>)
 800bde0:	4b0e      	ldr	r3, [pc, #56]	; (800be1c <group_delay.constprop.11+0xbc>)
 800bde2:	f7f6 fc0d 	bl	8002600 <__aeabi_dmul>
 800bde6:	0002      	movs	r2, r0
 800bde8:	000b      	movs	r3, r1
 800bdea:	0020      	movs	r0, r4
 800bdec:	0029      	movs	r1, r5
 800bdee:	f7f5 ffff 	bl	8001df0 <__aeabi_ddiv>
 800bdf2:	f7f7 fb4d 	bl	8003490 <__aeabi_d2f>
}
 800bdf6:	bc0c      	pop	{r2, r3}
 800bdf8:	4690      	mov	r8, r2
 800bdfa:	4699      	mov	r9, r3
 800bdfc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        deltaf = freq[index] - freq[index-1];
 800bdfe:	3b04      	subs	r3, #4
 800be00:	59db      	ldr	r3, [r3, r7]
 800be02:	1ac0      	subs	r0, r0, r3
 800be04:	f7f5 fc3c 	bl	8001680 <__aeabi_ui2f>
        v = gamma[index-1];
 800be08:	0023      	movs	r3, r4
 800be0a:	3b08      	subs	r3, #8
        w = gamma[index];
 800be0c:	002c      	movs	r4, r5
        deltaf = freq[index] - freq[index-1];
 800be0e:	1c07      	adds	r7, r0, #0
        v = gamma[index-1];
 800be10:	18f5      	adds	r5, r6, r3
 800be12:	e7ba      	b.n	800bd8a <group_delay.constprop.11+0x2a>
 800be14:	20000464 	.word	0x20000464
 800be18:	54442d18 	.word	0x54442d18
 800be1c:	401921fb 	.word	0x401921fb

0800be20 <markmap_marker.part.2>:
        uint32_t index = markers[marker].index;
 800be20:	218d      	movs	r1, #141	; 0x8d
 800be22:	0089      	lsls	r1, r1, #2
 800be24:	468c      	mov	ip, r1
static void markmap_marker(int marker)
 800be26:	b5f0      	push	{r4, r5, r6, r7, lr}
 800be28:	4645      	mov	r5, r8
 800be2a:	46de      	mov	lr, fp
 800be2c:	4657      	mov	r7, sl
 800be2e:	464e      	mov	r6, r9
        uint32_t index = markers[marker].index;
 800be30:	4956      	ldr	r1, [pc, #344]	; (800bf8c <markmap_marker.part.2+0x16c>)
 800be32:	4460      	add	r0, ip
 800be34:	468c      	mov	ip, r1
static void markmap_marker(int marker)
 800be36:	b5e0      	push	{r5, r6, r7, lr}
 800be38:	4a55      	ldr	r2, [pc, #340]	; (800bf90 <markmap_marker.part.2+0x170>)
        index = trace_index[t][index];
 800be3a:	4956      	ldr	r1, [pc, #344]	; (800bf94 <markmap_marker.part.2+0x174>)
    markmap[current_mappage][y] |= 1<<x;
 800be3c:	4b56      	ldr	r3, [pc, #344]	; (800bf98 <markmap_marker.part.2+0x178>)
        uint32_t index = markers[marker].index;
 800be3e:	00c0      	lsls	r0, r0, #3
 800be40:	1810      	adds	r0, r2, r0
    markmap[current_mappage][y] |= 1<<x;
 800be42:	881b      	ldrh	r3, [r3, #0]
        uint32_t index = markers[marker].index;
 800be44:	4460      	add	r0, ip
        index = trace_index[t][index];
 800be46:	468c      	mov	ip, r1
    markmap[current_mappage][y] |= 1<<x;
 800be48:	4954      	ldr	r1, [pc, #336]	; (800bf9c <markmap_marker.part.2+0x17c>)
static void markmap_marker(int marker)
 800be4a:	b083      	sub	sp, #12
    markmap[current_mappage][y] |= 1<<x;
 800be4c:	9301      	str	r3, [sp, #4]
 800be4e:	4688      	mov	r8, r1
    for (t = 0; t < TRACE_COUNT; t++) {
 800be50:	2300      	movs	r3, #0
    markmap[current_mappage][y] |= 1<<x;
 800be52:	9000      	str	r0, [sp, #0]
        if (!trace[t].enabled)
 800be54:	7811      	ldrb	r1, [r2, #0]
 800be56:	2900      	cmp	r1, #0
 800be58:	d06f      	beq.n	800bf3a <markmap_marker.part.2+0x11a>
        uint32_t index = markers[marker].index;
 800be5a:	9900      	ldr	r1, [sp, #0]
 800be5c:	2400      	movs	r4, #0
 800be5e:	5f0c      	ldrsh	r4, [r1, r4]
        if (index >= POINT_COUNT)
 800be60:	2c64      	cmp	r4, #100	; 0x64
 800be62:	d86a      	bhi.n	800bf3a <markmap_marker.part.2+0x11a>
        index = trace_index[t][index];
 800be64:	2165      	movs	r1, #101	; 0x65
 800be66:	4359      	muls	r1, r3
 800be68:	1909      	adds	r1, r1, r4
 800be6a:	4664      	mov	r4, ip
 800be6c:	0089      	lsls	r1, r1, #2
 800be6e:	590d      	ldr	r5, [r1, r4]
        int x = CELL_X(index);
 800be70:	24f8      	movs	r4, #248	; 0xf8
 800be72:	271f      	movs	r7, #31
 800be74:	096e      	lsrs	r6, r5, #5
 800be76:	0da9      	lsrs	r1, r5, #22
 800be78:	00a4      	lsls	r4, r4, #2
 800be7a:	403e      	ands	r6, r7
 800be7c:	4021      	ands	r1, r4
 800be7e:	4331      	orrs	r1, r6
        int y = CELL_Y(index);
 800be80:	0c6e      	lsrs	r6, r5, #17
 800be82:	4034      	ands	r4, r6
 800be84:	403d      	ands	r5, r7
 800be86:	432c      	orrs	r4, r5
        int m = x>>5;
 800be88:	114d      	asrs	r5, r1, #5
 800be8a:	46a9      	mov	r9, r5
        int n = y>>5;
 800be8c:	1166      	asrs	r6, r4, #5
  if (y >= 0 && y < 8 && x >= 0 && x < 16)
 800be8e:	4039      	ands	r1, r7
 800be90:	2e07      	cmp	r6, #7
 800be92:	dc28      	bgt.n	800bee6 <markmap_marker.part.2+0xc6>
 800be94:	2d0f      	cmp	r5, #15
 800be96:	dc0f      	bgt.n	800beb8 <markmap_marker.part.2+0x98>
    markmap[current_mappage][y] |= 1<<x;
 800be98:	4648      	mov	r0, r9
 800be9a:	4d40      	ldr	r5, [pc, #256]	; (800bf9c <markmap_marker.part.2+0x17c>)
 800be9c:	3f1e      	subs	r7, #30
 800be9e:	46aa      	mov	sl, r5
 800bea0:	4087      	lsls	r7, r0
 800bea2:	4650      	mov	r0, sl
 800bea4:	46bb      	mov	fp, r7
 800bea6:	9d01      	ldr	r5, [sp, #4]
 800bea8:	00ed      	lsls	r5, r5, #3
 800beaa:	19ad      	adds	r5, r5, r6
 800beac:	006d      	lsls	r5, r5, #1
 800beae:	5a2f      	ldrh	r7, [r5, r0]
 800beb0:	4658      	mov	r0, fp
 800beb2:	4307      	orrs	r7, r0
 800beb4:	4650      	mov	r0, sl
 800beb6:	522f      	strh	r7, [r5, r0]
        if ((x&31) < 6)
 800beb8:	2905      	cmp	r1, #5
 800beba:	dd49      	ble.n	800bf50 <markmap_marker.part.2+0x130>
        if ((x&31) > 32-6)
 800bebc:	291a      	cmp	r1, #26
 800bebe:	dd12      	ble.n	800bee6 <markmap_marker.part.2+0xc6>
            mark_map(m+1, n);
 800bec0:	4648      	mov	r0, r9
 800bec2:	1c47      	adds	r7, r0, #1
  if (y >= 0 && y < 8 && x >= 0 && x < 16)
 800bec4:	2f0f      	cmp	r7, #15
 800bec6:	dc0e      	bgt.n	800bee6 <markmap_marker.part.2+0xc6>
    markmap[current_mappage][y] |= 1<<x;
 800bec8:	4834      	ldr	r0, [pc, #208]	; (800bf9c <markmap_marker.part.2+0x17c>)
 800beca:	4682      	mov	sl, r0
 800becc:	9801      	ldr	r0, [sp, #4]
 800bece:	00c5      	lsls	r5, r0, #3
 800bed0:	2001      	movs	r0, #1
 800bed2:	40b8      	lsls	r0, r7
 800bed4:	4683      	mov	fp, r0
 800bed6:	4650      	mov	r0, sl
 800bed8:	19ad      	adds	r5, r5, r6
 800beda:	006d      	lsls	r5, r5, #1
 800bedc:	5a2f      	ldrh	r7, [r5, r0]
 800bede:	4658      	mov	r0, fp
 800bee0:	4307      	orrs	r7, r0
 800bee2:	4650      	mov	r0, sl
 800bee4:	522f      	strh	r7, [r5, r0]
        if ((y&31) < 12) {
 800bee6:	251f      	movs	r5, #31
 800bee8:	402c      	ands	r4, r5
 800beea:	2c0b      	cmp	r4, #11
 800beec:	dc25      	bgt.n	800bf3a <markmap_marker.part.2+0x11a>
            mark_map(m, n-1);
 800beee:	3e01      	subs	r6, #1
  if (y >= 0 && y < 8 && x >= 0 && x < 16)
 800bef0:	2e07      	cmp	r6, #7
 800bef2:	d822      	bhi.n	800bf3a <markmap_marker.part.2+0x11a>
 800bef4:	4648      	mov	r0, r9
 800bef6:	280f      	cmp	r0, #15
 800bef8:	dc0c      	bgt.n	800bf14 <markmap_marker.part.2+0xf4>
    markmap[current_mappage][y] |= 1<<x;
 800befa:	4828      	ldr	r0, [pc, #160]	; (800bf9c <markmap_marker.part.2+0x17c>)
 800befc:	2701      	movs	r7, #1
 800befe:	4682      	mov	sl, r0
 800bf00:	9801      	ldr	r0, [sp, #4]
 800bf02:	00c4      	lsls	r4, r0, #3
 800bf04:	4648      	mov	r0, r9
 800bf06:	4087      	lsls	r7, r0
 800bf08:	4650      	mov	r0, sl
 800bf0a:	19a4      	adds	r4, r4, r6
 800bf0c:	0064      	lsls	r4, r4, #1
 800bf0e:	5a25      	ldrh	r5, [r4, r0]
 800bf10:	433d      	orrs	r5, r7
 800bf12:	5225      	strh	r5, [r4, r0]
            if ((x&31) < 6)
 800bf14:	2905      	cmp	r1, #5
 800bf16:	dc21      	bgt.n	800bf5c <markmap_marker.part.2+0x13c>
  if (y >= 0 && y < 8 && x >= 0 && x < 16)
 800bf18:	4649      	mov	r1, r9
 800bf1a:	1e4c      	subs	r4, r1, #1
 800bf1c:	d30d      	bcc.n	800bf3a <markmap_marker.part.2+0x11a>
 800bf1e:	2c0f      	cmp	r4, #15
 800bf20:	dc0b      	bgt.n	800bf3a <markmap_marker.part.2+0x11a>
    markmap[current_mappage][y] |= 1<<x;
 800bf22:	9901      	ldr	r1, [sp, #4]
 800bf24:	481d      	ldr	r0, [pc, #116]	; (800bf9c <markmap_marker.part.2+0x17c>)
 800bf26:	00c9      	lsls	r1, r1, #3
 800bf28:	198e      	adds	r6, r1, r6
 800bf2a:	2101      	movs	r1, #1
 800bf2c:	40a1      	lsls	r1, r4
 800bf2e:	000c      	movs	r4, r1
 800bf30:	491a      	ldr	r1, [pc, #104]	; (800bf9c <markmap_marker.part.2+0x17c>)
 800bf32:	0076      	lsls	r6, r6, #1
 800bf34:	5a71      	ldrh	r1, [r6, r1]
 800bf36:	4321      	orrs	r1, r4
 800bf38:	5231      	strh	r1, [r6, r0]
    for (t = 0; t < TRACE_COUNT; t++) {
 800bf3a:	3301      	adds	r3, #1
 800bf3c:	320c      	adds	r2, #12
 800bf3e:	2b04      	cmp	r3, #4
 800bf40:	d188      	bne.n	800be54 <markmap_marker.part.2+0x34>
}
 800bf42:	b003      	add	sp, #12
 800bf44:	bc3c      	pop	{r2, r3, r4, r5}
 800bf46:	4690      	mov	r8, r2
 800bf48:	4699      	mov	r9, r3
 800bf4a:	46a2      	mov	sl, r4
 800bf4c:	46ab      	mov	fp, r5
 800bf4e:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if (y >= 0 && y < 8 && x >= 0 && x < 16)
 800bf50:	4648      	mov	r0, r9
 800bf52:	1e47      	subs	r7, r0, #1
 800bf54:	d3c7      	bcc.n	800bee6 <markmap_marker.part.2+0xc6>
 800bf56:	2f0f      	cmp	r7, #15
 800bf58:	dcc5      	bgt.n	800bee6 <markmap_marker.part.2+0xc6>
 800bf5a:	e7b5      	b.n	800bec8 <markmap_marker.part.2+0xa8>
            if ((x&31) > 32-6)
 800bf5c:	291a      	cmp	r1, #26
 800bf5e:	ddec      	ble.n	800bf3a <markmap_marker.part.2+0x11a>
                mark_map(m+1, n-1);
 800bf60:	464c      	mov	r4, r9
 800bf62:	3401      	adds	r4, #1
  if (y >= 0 && y < 8 && x >= 0 && x < 16)
 800bf64:	2c0f      	cmp	r4, #15
 800bf66:	dce8      	bgt.n	800bf3a <markmap_marker.part.2+0x11a>
    markmap[current_mappage][y] |= 1<<x;
 800bf68:	9901      	ldr	r1, [sp, #4]
 800bf6a:	4640      	mov	r0, r8
 800bf6c:	00c9      	lsls	r1, r1, #3
 800bf6e:	198e      	adds	r6, r1, r6
 800bf70:	2101      	movs	r1, #1
 800bf72:	40a1      	lsls	r1, r4
 800bf74:	000c      	movs	r4, r1
 800bf76:	4641      	mov	r1, r8
 800bf78:	0076      	lsls	r6, r6, #1
 800bf7a:	5a71      	ldrh	r1, [r6, r1]
    for (t = 0; t < TRACE_COUNT; t++) {
 800bf7c:	3301      	adds	r3, #1
    markmap[current_mappage][y] |= 1<<x;
 800bf7e:	4321      	orrs	r1, r4
 800bf80:	5231      	strh	r1, [r6, r0]
 800bf82:	320c      	adds	r2, #12
    for (t = 0; t < TRACE_COUNT; t++) {
 800bf84:	2b04      	cmp	r3, #4
 800bf86:	d000      	beq.n	800bf8a <markmap_marker.part.2+0x16a>
 800bf88:	e764      	b.n	800be54 <markmap_marker.part.2+0x34>
 800bf8a:	e7da      	b.n	800bf42 <markmap_marker.part.2+0x122>
 800bf8c:	ffffee92 	.word	0xffffee92
 800bf90:	200015c4 	.word	0x200015c4
 800bf94:	20002a24 	.word	0x20002a24
 800bf98:	200029fc 	.word	0x200029fc
 800bf9c:	20002a04 	.word	0x20002a04

0800bfa0 <update_grid>:
{
 800bfa0:	b5f0      	push	{r4, r5, r6, r7, lr}
 800bfa2:	46c6      	mov	lr, r8
  if (frequency1 > 0) {
 800bfa4:	4b39      	ldr	r3, [pc, #228]	; (800c08c <update_grid+0xec>)
{
 800bfa6:	b500      	push	{lr}
  if (frequency1 > 0) {
 800bfa8:	689d      	ldr	r5, [r3, #8]
 800bfaa:	685b      	ldr	r3, [r3, #4]
 800bfac:	4698      	mov	r8, r3
 800bfae:	2d00      	cmp	r5, #0
 800bfb0:	dd64      	ble.n	800c07c <update_grid+0xdc>
    fspan = frequency1 - frequency0;
 800bfb2:	1aed      	subs	r5, r5, r3
{
 800bfb4:	4c36      	ldr	r4, [pc, #216]	; (800c090 <update_grid+0xf0>)
    if (fspan / grid >= 4)
 800bfb6:	0028      	movs	r0, r5
    grid = 5 * gdigit;
 800bfb8:	00a6      	lsls	r6, r4, #2
 800bfba:	1936      	adds	r6, r6, r4
    if (fspan / grid >= 4)
 800bfbc:	0031      	movs	r1, r6
{
 800bfbe:	2706      	movs	r7, #6
    if (fspan / grid >= 4)
 800bfc0:	f7f4 f996 	bl	80002f0 <__divsi3>
 800bfc4:	2803      	cmp	r0, #3
 800bfc6:	dc1c      	bgt.n	800c002 <update_grid+0x62>
    grid = 2 * gdigit;
 800bfc8:	0066      	lsls	r6, r4, #1
    if (fspan / grid >= 4)
 800bfca:	0031      	movs	r1, r6
 800bfcc:	0028      	movs	r0, r5
 800bfce:	f7f4 f98f 	bl	80002f0 <__divsi3>
 800bfd2:	2803      	cmp	r0, #3
 800bfd4:	dc15      	bgt.n	800c002 <update_grid+0x62>
    if (fspan / grid >= 4)
 800bfd6:	0021      	movs	r1, r4
 800bfd8:	0028      	movs	r0, r5
 800bfda:	f7f4 f989 	bl	80002f0 <__divsi3>
 800bfde:	2803      	cmp	r0, #3
 800bfe0:	dc10      	bgt.n	800c004 <update_grid+0x64>
    gdigit /= 10;
 800bfe2:	210a      	movs	r1, #10
 800bfe4:	0020      	movs	r0, r4
 800bfe6:	3f01      	subs	r7, #1
 800bfe8:	f7f4 f982 	bl	80002f0 <__divsi3>
  while (gdigit > 100) {
 800bfec:	2f00      	cmp	r7, #0
 800bfee:	d009      	beq.n	800c004 <update_grid+0x64>
    gdigit /= 10;
 800bff0:	0004      	movs	r4, r0
    grid = 5 * gdigit;
 800bff2:	00a6      	lsls	r6, r4, #2
 800bff4:	1936      	adds	r6, r6, r4
    if (fspan / grid >= 4)
 800bff6:	0031      	movs	r1, r6
 800bff8:	0028      	movs	r0, r5
 800bffa:	f7f4 f979 	bl	80002f0 <__divsi3>
 800bffe:	2803      	cmp	r0, #3
 800c000:	dde2      	ble.n	800bfc8 <update_grid+0x28>
    grid = 2 * gdigit;
 800c002:	0034      	movs	r4, r6
  grid_offset = (WIDTH-1) * ((fstart % fgrid) / 100) / (fspan / 100);
 800c004:	4640      	mov	r0, r8
 800c006:	0021      	movs	r1, r4
 800c008:	f7f4 fa58 	bl	80004bc <__aeabi_idivmod>
 800c00c:	0008      	movs	r0, r1
 800c00e:	2164      	movs	r1, #100	; 0x64
 800c010:	f7f4 f96e 	bl	80002f0 <__divsi3>
 800c014:	00c6      	lsls	r6, r0, #3
 800c016:	1836      	adds	r6, r6, r0
 800c018:	0136      	lsls	r6, r6, #4
 800c01a:	1836      	adds	r6, r6, r0
 800c01c:	2164      	movs	r1, #100	; 0x64
 800c01e:	0028      	movs	r0, r5
 800c020:	f7f4 f966 	bl	80002f0 <__divsi3>
 800c024:	0076      	lsls	r6, r6, #1
 800c026:	0001      	movs	r1, r0
 800c028:	0030      	movs	r0, r6
 800c02a:	f7f4 f961 	bl	80002f0 <__divsi3>
 800c02e:	4b19      	ldr	r3, [pc, #100]	; (800c094 <update_grid+0xf4>)
  grid_width = (WIDTH-1) * (fgrid / 100) / (fspan / 1000);
 800c030:	2164      	movs	r1, #100	; 0x64
  grid_offset = (WIDTH-1) * ((fstart % fgrid) / 100) / (fspan / 100);
 800c032:	8018      	strh	r0, [r3, #0]
  grid_width = (WIDTH-1) * (fgrid / 100) / (fspan / 1000);
 800c034:	0020      	movs	r0, r4
 800c036:	f7f4 f95b 	bl	80002f0 <__divsi3>
 800c03a:	21fa      	movs	r1, #250	; 0xfa
 800c03c:	00c4      	lsls	r4, r0, #3
 800c03e:	1824      	adds	r4, r4, r0
 800c040:	0124      	lsls	r4, r4, #4
 800c042:	1824      	adds	r4, r4, r0
 800c044:	0089      	lsls	r1, r1, #2
 800c046:	0028      	movs	r0, r5
 800c048:	f7f4 f952 	bl	80002f0 <__divsi3>
 800c04c:	0064      	lsls	r4, r4, #1
 800c04e:	0001      	movs	r1, r0
 800c050:	0020      	movs	r0, r4
 800c052:	f7f4 f94d 	bl	80002f0 <__divsi3>
 800c056:	4b10      	ldr	r3, [pc, #64]	; (800c098 <update_grid+0xf8>)
  memset(markmap[current_mappage], 0xff, sizeof markmap[current_mappage]);
 800c058:	2210      	movs	r2, #16
  grid_width = (WIDTH-1) * (fgrid / 100) / (fspan / 1000);
 800c05a:	8018      	strh	r0, [r3, #0]
  memset(markmap[current_mappage], 0xff, sizeof markmap[current_mappage]);
 800c05c:	4b0f      	ldr	r3, [pc, #60]	; (800c09c <update_grid+0xfc>)
 800c05e:	4810      	ldr	r0, [pc, #64]	; (800c0a0 <update_grid+0x100>)
 800c060:	881b      	ldrh	r3, [r3, #0]
 800c062:	21ff      	movs	r1, #255	; 0xff
 800c064:	011b      	lsls	r3, r3, #4
 800c066:	18c0      	adds	r0, r0, r3
 800c068:	f007 f842 	bl	80130f0 <memset>
  redraw_request |= REDRAW_FREQUENCY;
 800c06c:	2102      	movs	r1, #2
 800c06e:	4a0d      	ldr	r2, [pc, #52]	; (800c0a4 <update_grid+0x104>)
 800c070:	8813      	ldrh	r3, [r2, #0]
 800c072:	430b      	orrs	r3, r1
 800c074:	8013      	strh	r3, [r2, #0]
}
 800c076:	bc04      	pop	{r2}
 800c078:	4690      	mov	r8, r2
 800c07a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    fstart = frequency0 - fspan/2;
 800c07c:	4642      	mov	r2, r8
    fspan = -frequency1;
 800c07e:	426d      	negs	r5, r5
    fstart = frequency0 - fspan/2;
 800c080:	0feb      	lsrs	r3, r5, #31
 800c082:	195b      	adds	r3, r3, r5
 800c084:	105b      	asrs	r3, r3, #1
 800c086:	1ad3      	subs	r3, r2, r3
 800c088:	4698      	mov	r8, r3
 800c08a:	e793      	b.n	800bfb4 <update_grid+0x14>
 800c08c:	20000454 	.word	0x20000454
 800c090:	05f5e100 	.word	0x05f5e100
 800c094:	200029fe 	.word	0x200029fe
 800c098:	20002a00 	.word	0x20002a00
 800c09c:	200029fc 	.word	0x200029fc
 800c0a0:	20002a04 	.word	0x20002a04
 800c0a4:	20002236 	.word	0x20002236
	...

0800c0b0 <trace_get_info>:
{
 800c0b0:	b5f0      	push	{r4, r5, r6, r7, lr}
 800c0b2:	0004      	movs	r4, r0
 800c0b4:	b083      	sub	sp, #12
 800c0b6:	0016      	movs	r6, r2
 800c0b8:	000d      	movs	r5, r1
  const char *type = get_trace_typename(t);
 800c0ba:	f7fe f9c9 	bl	800a450 <get_trace_typename>
  switch (trace[t].type) {
 800c0be:	0063      	lsls	r3, r4, #1
 800c0c0:	191b      	adds	r3, r3, r4
 800c0c2:	009a      	lsls	r2, r3, #2
 800c0c4:	4b24      	ldr	r3, [pc, #144]	; (800c158 <trace_get_info+0xa8>)
  const char *type = get_trace_typename(t);
 800c0c6:	0007      	movs	r7, r0
  switch (trace[t].type) {
 800c0c8:	189b      	adds	r3, r3, r2
 800c0ca:	4a24      	ldr	r2, [pc, #144]	; (800c15c <trace_get_info+0xac>)
 800c0cc:	4694      	mov	ip, r2
 800c0ce:	4463      	add	r3, ip
 800c0d0:	781b      	ldrb	r3, [r3, #0]
 800c0d2:	2b01      	cmp	r3, #1
 800c0d4:	d013      	beq.n	800c0fe <trace_get_info+0x4e>
 800c0d6:	2b00      	cmp	r3, #0
 800c0d8:	d030      	beq.n	800c13c <trace_get_info+0x8c>
 800c0da:	3b03      	subs	r3, #3
 800c0dc:	2b01      	cmp	r3, #1
 800c0de:	d81b      	bhi.n	800c118 <trace_get_info+0x68>
    chsnprintf(buf, len, "%s %.1fFS", type, get_trace_scale(t));
 800c0e0:	0020      	movs	r0, r4
 800c0e2:	f7fe fa8d 	bl	800a600 <get_trace_scale>
 800c0e6:	f7f7 f97b 	bl	80033e0 <__aeabi_f2d>
 800c0ea:	003b      	movs	r3, r7
 800c0ec:	9000      	str	r0, [sp, #0]
 800c0ee:	9101      	str	r1, [sp, #4]
 800c0f0:	4a1b      	ldr	r2, [pc, #108]	; (800c160 <trace_get_info+0xb0>)
 800c0f2:	0031      	movs	r1, r6
 800c0f4:	0028      	movs	r0, r5
 800c0f6:	f7fb fa1b 	bl	8007530 <chsnprintf>
}
 800c0fa:	b003      	add	sp, #12
 800c0fc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    chsnprintf(buf, len, "%s %d" S_DEGREE "/", type, (int)get_trace_scale(t));
 800c0fe:	0020      	movs	r0, r4
 800c100:	f7fe fa7e 	bl	800a600 <get_trace_scale>
 800c104:	f7f5 fa4c 	bl	80015a0 <__aeabi_f2iz>
 800c108:	003b      	movs	r3, r7
 800c10a:	9000      	str	r0, [sp, #0]
 800c10c:	4a15      	ldr	r2, [pc, #84]	; (800c164 <trace_get_info+0xb4>)
 800c10e:	0031      	movs	r1, r6
 800c110:	0028      	movs	r0, r5
 800c112:	f7fb fa0d 	bl	8007530 <chsnprintf>
    break;
 800c116:	e7f0      	b.n	800c0fa <trace_get_info+0x4a>
    n = chsnprintf(buf, len, "%s ", type);
 800c118:	0003      	movs	r3, r0
 800c11a:	0031      	movs	r1, r6
 800c11c:	4a12      	ldr	r2, [pc, #72]	; (800c168 <trace_get_info+0xb8>)
 800c11e:	0028      	movs	r0, r5
 800c120:	f7fb fa06 	bl	8007530 <chsnprintf>
    string_value_with_prefix(buf+n, len-n, get_trace_scale(t), '/');
 800c124:	182d      	adds	r5, r5, r0
 800c126:	1a36      	subs	r6, r6, r0
 800c128:	0020      	movs	r0, r4
 800c12a:	f7fe fa69 	bl	800a600 <get_trace_scale>
 800c12e:	232f      	movs	r3, #47	; 0x2f
 800c130:	1c02      	adds	r2, r0, #0
 800c132:	0031      	movs	r1, r6
 800c134:	0028      	movs	r0, r5
 800c136:	f7ff fb63 	bl	800b800 <string_value_with_prefix>
}
 800c13a:	e7de      	b.n	800c0fa <trace_get_info+0x4a>
    chsnprintf(buf, len, "%s %ddB/", type, (int)get_trace_scale(t));
 800c13c:	0020      	movs	r0, r4
 800c13e:	f7fe fa5f 	bl	800a600 <get_trace_scale>
 800c142:	f7f5 fa2d 	bl	80015a0 <__aeabi_f2iz>
 800c146:	003b      	movs	r3, r7
 800c148:	9000      	str	r0, [sp, #0]
 800c14a:	4a08      	ldr	r2, [pc, #32]	; (800c16c <trace_get_info+0xbc>)
 800c14c:	0031      	movs	r1, r6
 800c14e:	0028      	movs	r0, r5
 800c150:	f7fb f9ee 	bl	8007530 <chsnprintf>
    break;
 800c154:	e7d1      	b.n	800c0fa <trace_get_info+0x4a>
 800c156:	46c0      	nop			; (mov r8, r8)
 800c158:	20000454 	.word	0x20000454
 800c15c:	00001171 	.word	0x00001171
 800c160:	08014acc 	.word	0x08014acc
 800c164:	08014ac4 	.word	0x08014ac4
 800c168:	08013a14 	.word	0x08013a14
 800c16c:	08014ab8 	.word	0x08014ab8

0800c170 <draw_all_cells>:
{
 800c170:	b5f0      	push	{r4, r5, r6, r7, lr}
 800c172:	46de      	mov	lr, fp
 800c174:	4657      	mov	r7, sl
 800c176:	464e      	mov	r6, r9
 800c178:	4645      	mov	r5, r8
 800c17a:	b5e0      	push	{r5, r6, r7, lr}
  for (m = 0; m < (area_width+CELLWIDTH-1) / CELLWIDTH; m++)
 800c17c:	4bca      	ldr	r3, [pc, #808]	; (800c4a8 <draw_all_cells+0x338>)
{
 800c17e:	b0ad      	sub	sp, #180	; 0xb4
  for (m = 0; m < (area_width+CELLWIDTH-1) / CELLWIDTH; m++)
 800c180:	681a      	ldr	r2, [r3, #0]
{
 800c182:	9024      	str	r0, [sp, #144]	; 0x90
  for (m = 0; m < (area_width+CELLWIDTH-1) / CELLWIDTH; m++)
 800c184:	2a00      	cmp	r2, #0
 800c186:	dc01      	bgt.n	800c18c <draw_all_cells+0x1c>
 800c188:	f000 ff01 	bl	800cf8e <draw_all_cells+0xe1e>
 800c18c:	2397      	movs	r3, #151	; 0x97
 800c18e:	425b      	negs	r3, r3
 800c190:	9311      	str	r3, [sp, #68]	; 0x44
 800c192:	3392      	adds	r3, #146	; 0x92
 800c194:	930c      	str	r3, [sp, #48]	; 0x30
 800c196:	3320      	adds	r3, #32
 800c198:	9317      	str	r3, [sp, #92]	; 0x5c
 800c19a:	49c4      	ldr	r1, [pc, #784]	; (800c4ac <draw_all_cells+0x33c>)
 800c19c:	2300      	movs	r3, #0
 800c19e:	468c      	mov	ip, r1
 800c1a0:	9318      	str	r3, [sp, #96]	; 0x60
 800c1a2:	4bc3      	ldr	r3, [pc, #780]	; (800c4b0 <draw_all_cells+0x340>)
 800c1a4:	4463      	add	r3, ip
 800c1a6:	931b      	str	r3, [sp, #108]	; 0x6c
    for (n = 0; n < (area_height+CELLHEIGHT-1) / CELLHEIGHT; n++) {
 800c1a8:	4bc2      	ldr	r3, [pc, #776]	; (800c4b4 <draw_all_cells+0x344>)
 800c1aa:	681c      	ldr	r4, [r3, #0]
 800c1ac:	2c00      	cmp	r4, #0
 800c1ae:	dc01      	bgt.n	800c1b4 <draw_all_cells+0x44>
 800c1b0:	f000 fed6 	bl	800cf60 <draw_all_cells+0xdf0>
  uint16_t bit = 1<<x;
 800c1b4:	2301      	movs	r3, #1
 800c1b6:	9918      	ldr	r1, [sp, #96]	; 0x60
 800c1b8:	408b      	lsls	r3, r1
 800c1ba:	0149      	lsls	r1, r1, #5
 800c1bc:	468b      	mov	fp, r1
 800c1be:	2108      	movs	r1, #8
 800c1c0:	b298      	uxth	r0, r3
 800c1c2:	9016      	str	r0, [sp, #88]	; 0x58
 800c1c4:	980c      	ldr	r0, [sp, #48]	; 0x30
    markmap[current_mappage][y] |= 1<<x;
 800c1c6:	b21b      	sxth	r3, r3
 800c1c8:	1a09      	subs	r1, r1, r0
 800c1ca:	9121      	str	r1, [sp, #132]	; 0x84
 800c1cc:	2139      	movs	r1, #57	; 0x39
 800c1ce:	1a09      	subs	r1, r1, r0
 800c1d0:	9120      	str	r1, [sp, #128]	; 0x80
 800c1d2:	21c4      	movs	r1, #196	; 0xc4
 800c1d4:	1a09      	subs	r1, r1, r0
 800c1d6:	911f      	str	r1, [sp, #124]	; 0x7c
 800c1d8:	9322      	str	r3, [sp, #136]	; 0x88
 800c1da:	21d2      	movs	r1, #210	; 0xd2
 800c1dc:	4bb6      	ldr	r3, [pc, #728]	; (800c4b8 <draw_all_cells+0x348>)
 800c1de:	1a09      	subs	r1, r1, r0
 800c1e0:	9309      	str	r3, [sp, #36]	; 0x24
    for (n = 0; n < (area_height+CELLHEIGHT-1) / CELLHEIGHT; n++) {
 800c1e2:	2300      	movs	r3, #0
 800c1e4:	911e      	str	r1, [sp, #120]	; 0x78
 800c1e6:	21bd      	movs	r1, #189	; 0xbd
 800c1e8:	9308      	str	r3, [sp, #32]
 800c1ea:	465b      	mov	r3, fp
 800c1ec:	1a09      	subs	r1, r1, r0
 800c1ee:	3012      	adds	r0, #18
 800c1f0:	9123      	str	r1, [sp, #140]	; 0x8c
 800c1f2:	901c      	str	r0, [sp, #112]	; 0x70
 800c1f4:	9306      	str	r3, [sp, #24]
 800c1f6:	e01e      	b.n	800c236 <draw_all_cells+0xc6>
    w = area_width - x0off;
 800c1f8:	990c      	ldr	r1, [sp, #48]	; 0x30
  if (y0 + h > area_height)
 800c1fa:	3320      	adds	r3, #32
    w = area_width - x0off;
 800c1fc:	1a51      	subs	r1, r2, r1
 800c1fe:	468b      	mov	fp, r1
  if (y0 + h > area_height)
 800c200:	42a3      	cmp	r3, r4
 800c202:	dd01      	ble.n	800c208 <draw_all_cells+0x98>
 800c204:	f000 fca1 	bl	800cb4a <draw_all_cells+0x9da>
  if (w <= 0 || h <= 0)
 800c208:	2900      	cmp	r1, #0
 800c20a:	dd01      	ble.n	800c210 <draw_all_cells+0xa0>
 800c20c:	f000 ff05 	bl	800d01a <draw_all_cells+0xeaa>
    for (n = 0; n < (area_height+CELLHEIGHT-1) / CELLHEIGHT; n++) {
 800c210:	4ba8      	ldr	r3, [pc, #672]	; (800c4b4 <draw_all_cells+0x344>)
 800c212:	9d08      	ldr	r5, [sp, #32]
 800c214:	681c      	ldr	r4, [r3, #0]
 800c216:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800c218:	0021      	movs	r1, r4
 800c21a:	3302      	adds	r3, #2
 800c21c:	9309      	str	r3, [sp, #36]	; 0x24
 800c21e:	231f      	movs	r3, #31
 800c220:	311f      	adds	r1, #31
 800c222:	17c8      	asrs	r0, r1, #31
 800c224:	4003      	ands	r3, r0
 800c226:	3501      	adds	r5, #1
 800c228:	185b      	adds	r3, r3, r1
 800c22a:	9508      	str	r5, [sp, #32]
 800c22c:	115b      	asrs	r3, r3, #5
 800c22e:	42ab      	cmp	r3, r5
 800c230:	dc01      	bgt.n	800c236 <draw_all_cells+0xc6>
 800c232:	f000 fe95 	bl	800cf60 <draw_all_cells+0xdf0>
  return (markmap[0][y] & bit) || (markmap[1][y] & bit);
 800c236:	9909      	ldr	r1, [sp, #36]	; 0x24
 800c238:	9816      	ldr	r0, [sp, #88]	; 0x58
 800c23a:	880b      	ldrh	r3, [r1, #0]
 800c23c:	4203      	tst	r3, r0
 800c23e:	d102      	bne.n	800c246 <draw_all_cells+0xd6>
 800c240:	8a0b      	ldrh	r3, [r1, #16]
 800c242:	4203      	tst	r3, r0
 800c244:	d0e4      	beq.n	800c210 <draw_all_cells+0xa0>
  int y0 = n * CELLHEIGHT;
 800c246:	9b08      	ldr	r3, [sp, #32]
  if (x0off + w > area_width)
 800c248:	9917      	ldr	r1, [sp, #92]	; 0x5c
 800c24a:	015b      	lsls	r3, r3, #5
 800c24c:	9304      	str	r3, [sp, #16]
 800c24e:	4291      	cmp	r1, r2
 800c250:	dcd2      	bgt.n	800c1f8 <draw_all_cells+0x88>
  if (y0 + h > area_height)
 800c252:	9b04      	ldr	r3, [sp, #16]
 800c254:	3320      	adds	r3, #32
 800c256:	42a3      	cmp	r3, r4
 800c258:	dd01      	ble.n	800c25e <draw_all_cells+0xee>
 800c25a:	f000 fc6a 	bl	800cb32 <draw_all_cells+0x9c2>
  int w = CELLWIDTH;
 800c25e:	2320      	movs	r3, #32
 800c260:	469b      	mov	fp, r3
  int h = CELLHEIGHT;
 800c262:	469a      	mov	sl, r3
  chMtxLock(&mutex_ili9341); // [protect spi_buffer]
 800c264:	4895      	ldr	r0, [pc, #596]	; (800c4bc <draw_all_cells+0x34c>)
 800c266:	f7f7 ff2b 	bl	80040c0 <chMtxLock>
  for (t = 0; t < TRACE_COUNT; t++) {
 800c26a:	4b95      	ldr	r3, [pc, #596]	; (800c4c0 <draw_all_cells+0x350>)
  uint16_t grid_mode = 0;
 800c26c:	2600      	movs	r6, #0
 800c26e:	0019      	movs	r1, r3
      grid_mode |= GRID_RECTANGULAR;
 800c270:	2001      	movs	r0, #1
      grid_mode |= GRID_POLAR;
 800c272:	2508      	movs	r5, #8
      grid_mode |= GRID_SMITH;
 800c274:	2402      	movs	r4, #2
 800c276:	930f      	str	r3, [sp, #60]	; 0x3c
 800c278:	3130      	adds	r1, #48	; 0x30
    if (!trace[t].enabled)
 800c27a:	781a      	ldrb	r2, [r3, #0]
 800c27c:	2a00      	cmp	r2, #0
 800c27e:	d009      	beq.n	800c294 <draw_all_cells+0x124>
    if (trace[t].type == TRC_SMITH)
 800c280:	785a      	ldrb	r2, [r3, #1]
 800c282:	2a03      	cmp	r2, #3
 800c284:	d101      	bne.n	800c28a <draw_all_cells+0x11a>
 800c286:	f000 fc4e 	bl	800cb26 <draw_all_cells+0x9b6>
    else if (trace[t].type == TRC_POLAR)
 800c28a:	2a04      	cmp	r2, #4
 800c28c:	d101      	bne.n	800c292 <draw_all_cells+0x122>
 800c28e:	f000 fc4d 	bl	800cb2c <draw_all_cells+0x9bc>
      grid_mode |= GRID_RECTANGULAR;
 800c292:	4306      	orrs	r6, r0
 800c294:	330c      	adds	r3, #12
  for (t = 0; t < TRACE_COUNT; t++) {
 800c296:	4299      	cmp	r1, r3
 800c298:	d1ef      	bne.n	800c27a <draw_all_cells+0x10a>
  PULSE;
 800c29a:	2280      	movs	r2, #128	; 0x80
 800c29c:	4b89      	ldr	r3, [pc, #548]	; (800c4c4 <draw_all_cells+0x354>)
 800c29e:	0192      	lsls	r2, r2, #6
 800c2a0:	835a      	strh	r2, [r3, #26]
 800c2a2:	831a      	strh	r2, [r3, #24]
  if (grid_mode & GRID_RECTANGULAR) {
 800c2a4:	07f3      	lsls	r3, r6, #31
 800c2a6:	d401      	bmi.n	800c2ac <draw_all_cells+0x13c>
 800c2a8:	f000 fe7c 	bl	800cfa4 <draw_all_cells+0xe34>
 800c2ac:	4b86      	ldr	r3, [pc, #536]	; (800c4c8 <draw_all_cells+0x358>)
  if ((((x + grid_offset) * 10) % grid_width) < 10)
 800c2ae:	9c0c      	ldr	r4, [sp, #48]	; 0x30
 800c2b0:	9319      	str	r3, [sp, #100]	; 0x64
 800c2b2:	889f      	ldrh	r7, [r3, #4]
 800c2b4:	4b85      	ldr	r3, [pc, #532]	; (800c4cc <draw_all_cells+0x35c>)
 800c2b6:	2200      	movs	r2, #0
 800c2b8:	5e9b      	ldrsh	r3, [r3, r2]
 800c2ba:	9307      	str	r3, [sp, #28]
 800c2bc:	4b84      	ldr	r3, [pc, #528]	; (800c4d0 <draw_all_cells+0x360>)
 800c2be:	931a      	str	r3, [sp, #104]	; 0x68
 800c2c0:	001d      	movs	r5, r3
 800c2c2:	9b06      	ldr	r3, [sp, #24]
 800c2c4:	3b05      	subs	r3, #5
 800c2c6:	930d      	str	r3, [sp, #52]	; 0x34
 800c2c8:	445b      	add	r3, fp
 800c2ca:	4698      	mov	r8, r3
 800c2cc:	4b81      	ldr	r3, [pc, #516]	; (800c4d4 <draw_all_cells+0x364>)
 800c2ce:	2200      	movs	r2, #0
 800c2d0:	5e9b      	ldrsh	r3, [r3, r2]
 800c2d2:	003a      	movs	r2, r7
 800c2d4:	930a      	str	r3, [sp, #40]	; 0x28
 800c2d6:	465b      	mov	r3, fp
 800c2d8:	005b      	lsls	r3, r3, #1
 800c2da:	9305      	str	r3, [sp, #20]
  if (x == 0 || x == WIDTH)
 800c2dc:	2324      	movs	r3, #36	; 0x24
 800c2de:	33ff      	adds	r3, #255	; 0xff
 800c2e0:	4699      	mov	r9, r3
 800c2e2:	4653      	mov	r3, sl
 800c2e4:	4647      	mov	r7, r8
 800c2e6:	46b2      	mov	sl, r6
 800c2e8:	4690      	mov	r8, r2
 800c2ea:	001e      	movs	r6, r3
  if (x < 0)
 800c2ec:	2c00      	cmp	r4, #0
 800c2ee:	da00      	bge.n	800c2f2 <draw_all_cells+0x182>
 800c2f0:	e348      	b.n	800c984 <draw_all_cells+0x814>
  if (x == 0 || x == WIDTH)
 800c2f2:	d100      	bne.n	800c2f6 <draw_all_cells+0x186>
 800c2f4:	e2d0      	b.n	800c898 <draw_all_cells+0x728>
 800c2f6:	454c      	cmp	r4, r9
 800c2f8:	d100      	bne.n	800c2fc <draw_all_cells+0x18c>
 800c2fa:	e2cd      	b.n	800c898 <draw_all_cells+0x728>
  if ((((x + grid_offset) * 10) % grid_width) < 10)
 800c2fc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800c2fe:	9907      	ldr	r1, [sp, #28]
 800c300:	191b      	adds	r3, r3, r4
 800c302:	0098      	lsls	r0, r3, #2
 800c304:	18c0      	adds	r0, r0, r3
 800c306:	0040      	lsls	r0, r0, #1
 800c308:	f7f4 f8d8 	bl	80004bc <__aeabi_idivmod>
 800c30c:	2000      	movs	r0, #0
 800c30e:	2909      	cmp	r1, #9
 800c310:	dc00      	bgt.n	800c314 <draw_all_cells+0x1a4>
 800c312:	e2c1      	b.n	800c898 <draw_all_cells+0x728>
 800c314:	002a      	movs	r2, r5
      for (y = 0; y < h; y++)
 800c316:	2300      	movs	r3, #0
        spi_buffer[y * w + x] = c;
 800c318:	9905      	ldr	r1, [sp, #20]
      for (y = 0; y < h; y++)
 800c31a:	3301      	adds	r3, #1
 800c31c:	468c      	mov	ip, r1
        spi_buffer[y * w + x] = c;
 800c31e:	8010      	strh	r0, [r2, #0]
 800c320:	4462      	add	r2, ip
      for (y = 0; y < h; y++)
 800c322:	42b3      	cmp	r3, r6
 800c324:	d1f8      	bne.n	800c318 <draw_all_cells+0x1a8>
 800c326:	3401      	adds	r4, #1
 800c328:	3502      	adds	r5, #2
    for (x = 0; x < w; x++) {
 800c32a:	42bc      	cmp	r4, r7
 800c32c:	d1de      	bne.n	800c2ec <draw_all_cells+0x17c>
 800c32e:	0033      	movs	r3, r6
 800c330:	9c04      	ldr	r4, [sp, #16]
 800c332:	4656      	mov	r6, sl
 800c334:	469a      	mov	sl, r3
 800c336:	0023      	movs	r3, r4
 800c338:	4453      	add	r3, sl
 800c33a:	4699      	mov	r9, r3
 800c33c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800c33e:	4647      	mov	r7, r8
 800c340:	445b      	add	r3, fp
 800c342:	9307      	str	r3, [sp, #28]
        if (x+x0off >= 0 && x+x0off <= WIDTH)
 800c344:	2324      	movs	r3, #36	; 0x24
 800c346:	33ff      	adds	r3, #255	; 0xff
 800c348:	4698      	mov	r8, r3
 800c34a:	003b      	movs	r3, r7
 800c34c:	464f      	mov	r7, r9
 800c34e:	46b1      	mov	r9, r6
 800c350:	001e      	movs	r6, r3
 800c352:	9d1a      	ldr	r5, [sp, #104]	; 0x68
  if ((y % GRIDY) == 0)
 800c354:	211d      	movs	r1, #29
 800c356:	0020      	movs	r0, r4
 800c358:	f7f4 f8b0 	bl	80004bc <__aeabi_idivmod>
 800c35c:	2900      	cmp	r1, #0
 800c35e:	d100      	bne.n	800c362 <draw_all_cells+0x1f2>
 800c360:	e29c      	b.n	800c89c <draw_all_cells+0x72c>
 800c362:	2000      	movs	r0, #0
    for (x = 0; x < w; x++) {
 800c364:	002a      	movs	r2, r5
 800c366:	9b0c      	ldr	r3, [sp, #48]	; 0x30
        if (x+x0off >= 0 && x+x0off <= WIDTH)
 800c368:	4543      	cmp	r3, r8
 800c36a:	d802      	bhi.n	800c372 <draw_all_cells+0x202>
          spi_buffer[y * w + x] |= c;
 800c36c:	8811      	ldrh	r1, [r2, #0]
 800c36e:	4301      	orrs	r1, r0
 800c370:	8011      	strh	r1, [r2, #0]
      for (x = 0; x < w; x++)
 800c372:	9907      	ldr	r1, [sp, #28]
 800c374:	3301      	adds	r3, #1
 800c376:	3202      	adds	r2, #2
 800c378:	428b      	cmp	r3, r1
 800c37a:	d1f5      	bne.n	800c368 <draw_all_cells+0x1f8>
 800c37c:	9b05      	ldr	r3, [sp, #20]
 800c37e:	3401      	adds	r4, #1
 800c380:	469c      	mov	ip, r3
 800c382:	4465      	add	r5, ip
    for (y = 0; y < h; y++) {
 800c384:	42a7      	cmp	r7, r4
 800c386:	d1e5      	bne.n	800c354 <draw_all_cells+0x1e4>
 800c388:	464e      	mov	r6, r9
  if (grid_mode & (GRID_SMITH|GRID_ADMIT|GRID_POLAR)) {
 800c38a:	230e      	movs	r3, #14
 800c38c:	4233      	tst	r3, r6
 800c38e:	d05a      	beq.n	800c446 <draw_all_cells+0x2d6>
  int c = config.grid_color;
 800c390:	9b19      	ldr	r3, [sp, #100]	; 0x64
 800c392:	9c04      	ldr	r4, [sp, #16]
 800c394:	889b      	ldrh	r3, [r3, #4]
 800c396:	3c74      	subs	r4, #116	; 0x74
 800c398:	469c      	mov	ip, r3
 800c39a:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 800c39c:	4661      	mov	r1, ip
 800c39e:	4698      	mov	r8, r3
 800c3a0:	0023      	movs	r3, r4
 800c3a2:	4453      	add	r3, sl
 800c3a4:	930d      	str	r3, [sp, #52]	; 0x34
 800c3a6:	2302      	movs	r3, #2
 800c3a8:	4033      	ands	r3, r6
 800c3aa:	9307      	str	r3, [sp, #28]
 800c3ac:	9b06      	ldr	r3, [sp, #24]
 800c3ae:	3b97      	subs	r3, #151	; 0x97
 800c3b0:	445b      	add	r3, fp
 800c3b2:	930e      	str	r3, [sp, #56]	; 0x38
        else if (grid_mode & GRID_POLAR)
 800c3b4:	2308      	movs	r3, #8
 800c3b6:	4033      	ands	r3, r6
 800c3b8:	9310      	str	r3, [sp, #64]	; 0x40
 800c3ba:	4653      	mov	r3, sl
 800c3bc:	46da      	mov	sl, fp
 800c3be:	931d      	str	r3, [sp, #116]	; 0x74
  int d = x*x + y*y - r*r;
 800c3c0:	0023      	movs	r3, r4
 800c3c2:	4363      	muls	r3, r4
 800c3c4:	469b      	mov	fp, r3
  if (circle_inout(x, y-58, 58) == 0)
 800c3c6:	0023      	movs	r3, r4
 800c3c8:	3b3a      	subs	r3, #58	; 0x3a
  int d = x*x + y*y - r*r;
 800c3ca:	435b      	muls	r3, r3
 800c3cc:	469c      	mov	ip, r3
  if (circle_inout(x, y-116, 116) == 0)
 800c3ce:	0023      	movs	r3, r4
 800c3d0:	3b74      	subs	r3, #116	; 0x74
  int d = x*x + y*y - r*r;
 800c3d2:	435b      	muls	r3, r3
 800c3d4:	9312      	str	r3, [sp, #72]	; 0x48
  if (circle_inout(x, y+232, 232) == 0)
 800c3d6:	0023      	movs	r3, r4
 800c3d8:	33e8      	adds	r3, #232	; 0xe8
  int d = x*x + y*y - r*r;
 800c3da:	435b      	muls	r3, r3
 800c3dc:	9314      	str	r3, [sp, #80]	; 0x50
  if (circle_inout(x, y-232, 232) == 0)
 800c3de:	0023      	movs	r3, r4
  int d = x*x + y*y - r*r;
 800c3e0:	0025      	movs	r5, r4
  if (circle_inout(x, y+58, 58) == 0)
 800c3e2:	0027      	movs	r7, r4
  int d = x*x + y*y - r*r;
 800c3e4:	4646      	mov	r6, r8
 800c3e6:	4658      	mov	r0, fp
  if (circle_inout(x, y-232, 232) == 0)
 800c3e8:	3be8      	subs	r3, #232	; 0xe8
  int d = x*x + y*y - r*r;
 800c3ea:	435b      	muls	r3, r3
 800c3ec:	3574      	adds	r5, #116	; 0x74
  if (circle_inout(x, y+58, 58) == 0)
 800c3ee:	373a      	adds	r7, #58	; 0x3a
  int d = x*x + y*y - r*r;
 800c3f0:	436d      	muls	r5, r5
 800c3f2:	437f      	muls	r7, r7
 800c3f4:	9315      	str	r3, [sp, #84]	; 0x54
 800c3f6:	9a11      	ldr	r2, [sp, #68]	; 0x44
  if (x == y || x == -y)
 800c3f8:	4263      	negs	r3, r4
 800c3fa:	9313      	str	r3, [sp, #76]	; 0x4c
 800c3fc:	950a      	str	r5, [sp, #40]	; 0x28
        if (grid_mode & GRID_SMITH)
 800c3fe:	9b07      	ldr	r3, [sp, #28]
 800c400:	2b00      	cmp	r3, #0
 800c402:	d100      	bne.n	800c406 <draw_all_cells+0x296>
 800c404:	e198      	b.n	800c738 <draw_all_cells+0x5c8>
  int d = x*x + y*y - r*r;
 800c406:	0013      	movs	r3, r2
 800c408:	4d33      	ldr	r5, [pc, #204]	; (800c4d8 <draw_all_cells+0x368>)
 800c40a:	4353      	muls	r3, r2
 800c40c:	46a9      	mov	r9, r5
 800c40e:	181b      	adds	r3, r3, r0
 800c410:	444b      	add	r3, r9
  if (d <= -r)
 800c412:	001d      	movs	r5, r3
 800c414:	3573      	adds	r5, #115	; 0x73
 800c416:	da00      	bge.n	800c41a <draw_all_cells+0x2aa>
 800c418:	e1cf      	b.n	800c7ba <draw_all_cells+0x64a>
  if (d > r)
 800c41a:	2b74      	cmp	r3, #116	; 0x74
 800c41c:	dd00      	ble.n	800c420 <draw_all_cells+0x2b0>
 800c41e:	e1ca      	b.n	800c7b6 <draw_all_cells+0x646>
  if (x == y || x == -y)
 800c420:	000b      	movs	r3, r1
        spi_buffer[y * w + x] |= c;
 800c422:	8835      	ldrh	r5, [r6, #0]
 800c424:	3201      	adds	r2, #1
 800c426:	432b      	orrs	r3, r5
 800c428:	8033      	strh	r3, [r6, #0]
      for (x = 0; x < w; x++) {
 800c42a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800c42c:	3602      	adds	r6, #2
 800c42e:	4293      	cmp	r3, r2
 800c430:	d1e5      	bne.n	800c3fe <draw_all_cells+0x28e>
 800c432:	9b05      	ldr	r3, [sp, #20]
 800c434:	3401      	adds	r4, #1
 800c436:	469c      	mov	ip, r3
    for (y = 0; y < h; y++) {
 800c438:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800c43a:	44e0      	add	r8, ip
 800c43c:	42a3      	cmp	r3, r4
 800c43e:	d1bf      	bne.n	800c3c0 <draw_all_cells+0x250>
 800c440:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 800c442:	46d3      	mov	fp, sl
 800c444:	469a      	mov	sl, r3
  PULSE;
 800c446:	2280      	movs	r2, #128	; 0x80
 800c448:	4b1e      	ldr	r3, [pc, #120]	; (800c4c4 <draw_all_cells+0x354>)
 800c44a:	0192      	lsls	r2, r2, #6
 800c44c:	835a      	strh	r2, [r3, #26]
 800c44e:	831a      	strh	r2, [r3, #24]
  for (t = 0; t < TRACE_COUNT; t++) {
 800c450:	9b19      	ldr	r3, [sp, #100]	; 0x64
  x &= 0x03e0;
 800c452:	26f8      	movs	r6, #248	; 0xf8
 800c454:	930e      	str	r3, [sp, #56]	; 0x38
  PULSE;
 800c456:	9307      	str	r3, [sp, #28]
 800c458:	4b20      	ldr	r3, [pc, #128]	; (800c4dc <draw_all_cells+0x36c>)
  x &= 0x03e0;
 800c45a:	9f06      	ldr	r7, [sp, #24]
  PULSE;
 800c45c:	4698      	mov	r8, r3
 800c45e:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
  x &= 0x03e0;
 800c460:	00b6      	lsls	r6, r6, #2
  PULSE;
 800c462:	4699      	mov	r9, r3
 800c464:	2300      	movs	r3, #0
 800c466:	930a      	str	r3, [sp, #40]	; 0x28
  x &= 0x03e0;
 800c468:	465b      	mov	r3, fp
 800c46a:	4037      	ands	r7, r6
 800c46c:	9310      	str	r3, [sp, #64]	; 0x40
    if (!trace[t].enabled)
 800c46e:	464b      	mov	r3, r9
 800c470:	781b      	ldrb	r3, [r3, #0]
 800c472:	2b00      	cmp	r3, #0
 800c474:	d055      	beq.n	800c522 <draw_all_cells+0x3b2>
    if (trace[t].type == TRC_SMITH || trace[t].type == TRC_POLAR)
 800c476:	464b      	mov	r3, r9
 800c478:	785b      	ldrb	r3, [r3, #1]
 800c47a:	3b03      	subs	r3, #3
 800c47c:	2b01      	cmp	r3, #1
 800c47e:	d950      	bls.n	800c522 <draw_all_cells+0x3b2>
  int tail = sweep_points;
 800c480:	4b17      	ldr	r3, [pc, #92]	; (800c4e0 <draw_all_cells+0x370>)
 800c482:	220c      	movs	r2, #12
 800c484:	5e9a      	ldrsh	r2, [r3, r2]
  while (head < tail) {
 800c486:	2a00      	cmp	r2, #0
 800c488:	dc01      	bgt.n	800c48e <draw_all_cells+0x31e>
 800c48a:	f000 ff9d 	bl	800d3c8 <draw_all_cells+0x1258>
    if (x == CELL_X0(index[i]))
 800c48e:	4643      	mov	r3, r8
    i = (head + tail) / 2;
 800c490:	1054      	asrs	r4, r2, #1
    if (x == CELL_X0(index[i]))
 800c492:	00a0      	lsls	r0, r4, #2
 800c494:	58c3      	ldr	r3, [r0, r3]
 800c496:	0d9b      	lsrs	r3, r3, #22
 800c498:	4033      	ands	r3, r6
 800c49a:	42bb      	cmp	r3, r7
 800c49c:	d100      	bne.n	800c4a0 <draw_all_cells+0x330>
 800c49e:	e274      	b.n	800c98a <draw_all_cells+0x81a>
  int head = 0;
 800c4a0:	2100      	movs	r1, #0
 800c4a2:	4645      	mov	r5, r8
 800c4a4:	e02f      	b.n	800c506 <draw_all_cells+0x396>
 800c4a6:	46c0      	nop			; (mov r8, r8)
 800c4a8:	2000163c 	.word	0x2000163c
 800c4ac:	000004fa 	.word	0x000004fa
 800c4b0:	08015d48 	.word	0x08015d48
 800c4b4:	20001638 	.word	0x20001638
 800c4b8:	20002a04 	.word	0x20002a04
 800c4bc:	2000220c 	.word	0x2000220c
 800c4c0:	200015c4 	.word	0x200015c4
 800c4c4:	48000800 	.word	0x48000800
 800c4c8:	2000042c 	.word	0x2000042c
 800c4cc:	20002a00 	.word	0x20002a00
 800c4d0:	200030ac 	.word	0x200030ac
 800c4d4:	200029fe 	.word	0x200029fe
 800c4d8:	ffffcb70 	.word	0xffffcb70
 800c4dc:	20002a24 	.word	0x20002a24
 800c4e0:	20000454 	.word	0x20000454
      if (tail == i+1)
 800c4e4:	1c63      	adds	r3, r4, #1
 800c4e6:	4293      	cmp	r3, r2
 800c4e8:	d014      	beq.n	800c514 <draw_all_cells+0x3a4>
 800c4ea:	001a      	movs	r2, r3
  while (head < tail) {
 800c4ec:	428a      	cmp	r2, r1
 800c4ee:	dd11      	ble.n	800c514 <draw_all_cells+0x3a4>
    i = (head + tail) / 2;
 800c4f0:	1853      	adds	r3, r2, r1
 800c4f2:	0fdc      	lsrs	r4, r3, #31
 800c4f4:	18e4      	adds	r4, r4, r3
 800c4f6:	1064      	asrs	r4, r4, #1
    if (x == CELL_X0(index[i]))
 800c4f8:	00a0      	lsls	r0, r4, #2
 800c4fa:	5943      	ldr	r3, [r0, r5]
 800c4fc:	0d9b      	lsrs	r3, r3, #22
 800c4fe:	4033      	ands	r3, r6
 800c500:	429f      	cmp	r7, r3
 800c502:	d100      	bne.n	800c506 <draw_all_cells+0x396>
 800c504:	e240      	b.n	800c988 <draw_all_cells+0x818>
    else if (x < CELL_X0(index[i])) {
 800c506:	429f      	cmp	r7, r3
 800c508:	dbec      	blt.n	800c4e4 <draw_all_cells+0x374>
      if (head == i)
 800c50a:	428c      	cmp	r4, r1
 800c50c:	d002      	beq.n	800c514 <draw_all_cells+0x3a4>
 800c50e:	0021      	movs	r1, r4
  while (head < tail) {
 800c510:	428a      	cmp	r2, r1
 800c512:	dced      	bgt.n	800c4f0 <draw_all_cells+0x380>
  if (x != CELL_X0(index[i]))
 800c514:	5943      	ldr	r3, [r0, r5]
 800c516:	46a8      	mov	r8, r5
 800c518:	0d9b      	lsrs	r3, r3, #22
 800c51a:	4033      	ands	r3, r6
 800c51c:	429f      	cmp	r7, r3
 800c51e:	d100      	bne.n	800c522 <draw_all_cells+0x3b2>
 800c520:	e233      	b.n	800c98a <draw_all_cells+0x81a>
 800c522:	230c      	movs	r3, #12
 800c524:	469c      	mov	ip, r3
 800c526:	3389      	adds	r3, #137	; 0x89
 800c528:	33ff      	adds	r3, #255	; 0xff
 800c52a:	44e1      	add	r9, ip
 800c52c:	469c      	mov	ip, r3
 800c52e:	9b07      	ldr	r3, [sp, #28]
 800c530:	44e0      	add	r8, ip
 800c532:	3302      	adds	r3, #2
 800c534:	9307      	str	r3, [sp, #28]
 800c536:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800c538:	3365      	adds	r3, #101	; 0x65
 800c53a:	001a      	movs	r2, r3
 800c53c:	930a      	str	r3, [sp, #40]	; 0x28
  for (t = 0; t < TRACE_COUNT; t++) {
 800c53e:	4562      	cmp	r2, ip
 800c540:	d195      	bne.n	800c46e <draw_all_cells+0x2fe>
 800c542:	9b10      	ldr	r3, [sp, #64]	; 0x40
 800c544:	9f0f      	ldr	r7, [sp, #60]	; 0x3c
 800c546:	469b      	mov	fp, r3
  for (t = 0; t < TRACE_COUNT; t++) {
 800c548:	2300      	movs	r3, #0
 800c54a:	4698      	mov	r8, r3
 800c54c:	920d      	str	r2, [sp, #52]	; 0x34
    if (!trace[t].enabled)
 800c54e:	783b      	ldrb	r3, [r7, #0]
 800c550:	2b00      	cmp	r3, #0
 800c552:	d004      	beq.n	800c55e <draw_all_cells+0x3ee>
    if (trace[t].type != TRC_SMITH && trace[t].type != TRC_POLAR)
 800c554:	787b      	ldrb	r3, [r7, #1]
 800c556:	3b03      	subs	r3, #3
 800c558:	2b01      	cmp	r3, #1
 800c55a:	d800      	bhi.n	800c55e <draw_all_cells+0x3ee>
 800c55c:	e299      	b.n	800ca92 <draw_all_cells+0x922>
  for (t = 0; t < TRACE_COUNT; t++) {
 800c55e:	2301      	movs	r3, #1
 800c560:	469c      	mov	ip, r3
 800c562:	44e0      	add	r8, ip
 800c564:	4643      	mov	r3, r8
 800c566:	370c      	adds	r7, #12
 800c568:	2b04      	cmp	r3, #4
 800c56a:	d1f0      	bne.n	800c54e <draw_all_cells+0x3de>
  PULSE;
 800c56c:	2280      	movs	r2, #128	; 0x80
 800c56e:	4bcc      	ldr	r3, [pc, #816]	; (800c8a0 <draw_all_cells+0x730>)
 800c570:	0192      	lsls	r2, r2, #6
 800c572:	835a      	strh	r2, [r3, #26]
 800c574:	831a      	strh	r2, [r3, #24]
  for (i = 0; i < MARKER_COUNT; i++) {
 800c576:	2300      	movs	r3, #0
		  if (bits & (0x8000>>(i+2)))
 800c578:	46d9      	mov	r9, fp
 800c57a:	4698      	mov	r8, r3
 800c57c:	4fc9      	ldr	r7, [pc, #804]	; (800c8a4 <draw_all_cells+0x734>)
    if (!markers[i].enabled)
 800c57e:	2300      	movs	r3, #0
 800c580:	56fb      	ldrsb	r3, [r7, r3]
 800c582:	2b00      	cmp	r3, #0
 800c584:	d000      	beq.n	800c588 <draw_all_cells+0x418>
 800c586:	e1b9      	b.n	800c8fc <draw_all_cells+0x78c>
  for (i = 0; i < MARKER_COUNT; i++) {
 800c588:	2301      	movs	r3, #1
 800c58a:	469c      	mov	ip, r3
 800c58c:	44e0      	add	r8, ip
 800c58e:	4643      	mov	r3, r8
 800c590:	3708      	adds	r7, #8
 800c592:	2b04      	cmp	r3, #4
 800c594:	d1f3      	bne.n	800c57e <draw_all_cells+0x40e>
  if (n > 1)
 800c596:	9908      	ldr	r1, [sp, #32]
 800c598:	46cb      	mov	fp, r9
 800c59a:	2901      	cmp	r1, #1
 800c59c:	dd00      	ble.n	800c5a0 <draw_all_cells+0x430>
 800c59e:	e0b5      	b.n	800c70c <draw_all_cells+0x59c>
  if (active_marker < 0)
 800c5a0:	238e      	movs	r3, #142	; 0x8e
 800c5a2:	4ac1      	ldr	r2, [pc, #772]	; (800c8a8 <draw_all_cells+0x738>)
 800c5a4:	015b      	lsls	r3, r3, #5
 800c5a6:	58d3      	ldr	r3, [r2, r3]
 800c5a8:	2b00      	cmp	r3, #0
 800c5aa:	da00      	bge.n	800c5ae <draw_all_cells+0x43e>
 800c5ac:	e0ae      	b.n	800c70c <draw_all_cells+0x59c>
  int idx = markers[active_marker].index;
 800c5ae:	228d      	movs	r2, #141	; 0x8d
 800c5b0:	0092      	lsls	r2, r2, #2
 800c5b2:	4694      	mov	ip, r2
 800c5b4:	4abc      	ldr	r2, [pc, #752]	; (800c8a8 <draw_all_cells+0x738>)
 800c5b6:	4463      	add	r3, ip
 800c5b8:	4694      	mov	ip, r2
 800c5ba:	00db      	lsls	r3, r3, #3
 800c5bc:	4463      	add	r3, ip
 800c5be:	2202      	movs	r2, #2
 800c5c0:	5e9b      	ldrsh	r3, [r3, r2]
    gamma2reactance(buf, len, coeff[i]);
 800c5c2:	00da      	lsls	r2, r3, #3
  int idx = markers[active_marker].index;
 800c5c4:	9313      	str	r3, [sp, #76]	; 0x4c
    gamma2reactance(buf, len, coeff[i]);
 800c5c6:	9214      	str	r2, [sp, #80]	; 0x50
    gamma2imp(buf, len, coeff[i], freq[i]);
 800c5c8:	009a      	lsls	r2, r3, #2
 800c5ca:	4663      	mov	r3, ip
 800c5cc:	3310      	adds	r3, #16
 800c5ce:	18d3      	adds	r3, r2, r3
 800c5d0:	9319      	str	r3, [sp, #100]	; 0x64
 800c5d2:	014b      	lsls	r3, r1, #5
 800c5d4:	425b      	negs	r3, r3
 800c5d6:	9315      	str	r3, [sp, #84]	; 0x54
 800c5d8:	3301      	adds	r3, #1
 800c5da:	9312      	str	r3, [sp, #72]	; 0x48
 800c5dc:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
  int j = 0;
 800c5de:	2200      	movs	r2, #0
 800c5e0:	4699      	mov	r9, r3
 800c5e2:	920d      	str	r2, [sp, #52]	; 0x34
  for (t = 0; t < TRACE_COUNT; t++) {
 800c5e4:	9207      	str	r2, [sp, #28]
    if (!trace[t].enabled)
 800c5e6:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800c5e8:	469c      	mov	ip, r3
 800c5ea:	005c      	lsls	r4, r3, #1
 800c5ec:	4464      	add	r4, ip
 800c5ee:	00a4      	lsls	r4, r4, #2
 800c5f0:	4464      	add	r4, ip
 800c5f2:	9b04      	ldr	r3, [sp, #16]
 800c5f4:	9410      	str	r4, [sp, #64]	; 0x40
 800c5f6:	3401      	adds	r4, #1
 800c5f8:	1ae4      	subs	r4, r4, r3
 800c5fa:	464b      	mov	r3, r9
 800c5fc:	781b      	ldrb	r3, [r3, #0]
 800c5fe:	2b00      	cmp	r3, #0
 800c600:	d000      	beq.n	800c604 <draw_all_cells+0x494>
 800c602:	e2aa      	b.n	800cb5a <draw_all_cells+0x9ea>
 800c604:	220c      	movs	r2, #12
 800c606:	4694      	mov	ip, r2
  for (t = 0; t < TRACE_COUNT; t++) {
 800c608:	9b07      	ldr	r3, [sp, #28]
 800c60a:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 800c60c:	3301      	adds	r3, #1
 800c60e:	3202      	adds	r2, #2
 800c610:	9307      	str	r3, [sp, #28]
 800c612:	44e1      	add	r9, ip
 800c614:	920e      	str	r2, [sp, #56]	; 0x38
 800c616:	2b04      	cmp	r3, #4
 800c618:	d1e5      	bne.n	800c5e6 <draw_all_cells+0x476>
    if (electrical_delay != 0) {
 800c61a:	4ba4      	ldr	r3, [pc, #656]	; (800c8ac <draw_all_cells+0x73c>)
 800c61c:	4aa2      	ldr	r2, [pc, #648]	; (800c8a8 <draw_all_cells+0x738>)
 800c61e:	2100      	movs	r1, #0
 800c620:	58d0      	ldr	r0, [r2, r3]
 800c622:	46a1      	mov	r9, r4
 800c624:	f7f3 ffa8 	bl	8000578 <__aeabi_fcmpeq>
 800c628:	2800      	cmp	r0, #0
 800c62a:	d101      	bne.n	800c630 <draw_all_cells+0x4c0>
 800c62c:	f000 fde6 	bl	800d1fc <draw_all_cells+0x108c>
  chsnprintf(buf, sizeof buf, "%d:", active_marker + 1);
 800c630:	238e      	movs	r3, #142	; 0x8e
 800c632:	4a9d      	ldr	r2, [pc, #628]	; (800c8a8 <draw_all_cells+0x738>)
 800c634:	015b      	lsls	r3, r3, #5
 800c636:	58d3      	ldr	r3, [r2, r3]
 800c638:	2118      	movs	r1, #24
 800c63a:	3301      	adds	r3, #1
 800c63c:	4a9c      	ldr	r2, [pc, #624]	; (800c8b0 <draw_all_cells+0x740>)
 800c63e:	a826      	add	r0, sp, #152	; 0x98
 800c640:	f7fa ff76 	bl	8007530 <chsnprintf>
  while (*str) {
 800c644:	ab22      	add	r3, sp, #136	; 0x88
 800c646:	7c1a      	ldrb	r2, [r3, #16]
 800c648:	9c1f      	ldr	r4, [sp, #124]	; 0x7c
 800c64a:	ad26      	add	r5, sp, #152	; 0x98
 800c64c:	2a00      	cmp	r2, #0
 800c64e:	d011      	beq.n	800c674 <draw_all_cells+0x504>
 800c650:	9b12      	ldr	r3, [sp, #72]	; 0x48
    cell_drawchar_7x13(w, h, *str, x, y, fg, FALSE);
 800c652:	2700      	movs	r7, #0
 800c654:	4698      	mov	r8, r3
 800c656:	4e97      	ldr	r6, [pc, #604]	; (800c8b4 <draw_all_cells+0x744>)
 800c658:	4643      	mov	r3, r8
 800c65a:	9702      	str	r7, [sp, #8]
 800c65c:	9300      	str	r3, [sp, #0]
 800c65e:	9601      	str	r6, [sp, #4]
 800c660:	0023      	movs	r3, r4
 800c662:	4651      	mov	r1, sl
 800c664:	4658      	mov	r0, fp
    str++;
 800c666:	3501      	adds	r5, #1
    cell_drawchar_7x13(w, h, *str, x, y, fg, FALSE);
 800c668:	f7ff fb1a 	bl	800bca0 <cell_drawchar_7x13>
  while (*str) {
 800c66c:	782a      	ldrb	r2, [r5, #0]
    x += 7;
 800c66e:	3407      	adds	r4, #7
  while (*str) {
 800c670:	2a00      	cmp	r2, #0
 800c672:	d1f1      	bne.n	800c658 <draw_all_cells+0x4e8>
  if ((domain_mode & DOMAIN_MODE) == DOMAIN_FREQ) {
 800c674:	4b90      	ldr	r3, [pc, #576]	; (800c8b8 <draw_all_cells+0x748>)
 800c676:	4a8c      	ldr	r2, [pc, #560]	; (800c8a8 <draw_all_cells+0x738>)
 800c678:	5cd3      	ldrb	r3, [r2, r3]
 800c67a:	07db      	lsls	r3, r3, #31
 800c67c:	d501      	bpl.n	800c682 <draw_all_cells+0x512>
 800c67e:	f000 fd46 	bl	800d10e <draw_all_cells+0xf9e>
    frequency_string(buf, sizeof buf, frequencies[idx]);
 800c682:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 800c684:	4a88      	ldr	r2, [pc, #544]	; (800c8a8 <draw_all_cells+0x738>)
 800c686:	3304      	adds	r3, #4
 800c688:	009b      	lsls	r3, r3, #2
 800c68a:	58d2      	ldr	r2, [r2, r3]
 800c68c:	2118      	movs	r1, #24
 800c68e:	a826      	add	r0, sp, #152	; 0x98
 800c690:	f7ff f9b6 	bl	800ba00 <frequency_string>
  while (*str) {
 800c694:	ab22      	add	r3, sp, #136	; 0x88
 800c696:	7c1a      	ldrb	r2, [r3, #16]
 800c698:	9c1e      	ldr	r4, [sp, #120]	; 0x78
 800c69a:	ad26      	add	r5, sp, #152	; 0x98
 800c69c:	2a00      	cmp	r2, #0
 800c69e:	d011      	beq.n	800c6c4 <draw_all_cells+0x554>
 800c6a0:	9b12      	ldr	r3, [sp, #72]	; 0x48
    cell_drawchar_7x13(w, h, *str, x, y, fg, FALSE);
 800c6a2:	2700      	movs	r7, #0
 800c6a4:	4698      	mov	r8, r3
 800c6a6:	4e83      	ldr	r6, [pc, #524]	; (800c8b4 <draw_all_cells+0x744>)
 800c6a8:	4643      	mov	r3, r8
 800c6aa:	9702      	str	r7, [sp, #8]
 800c6ac:	9300      	str	r3, [sp, #0]
 800c6ae:	9601      	str	r6, [sp, #4]
 800c6b0:	0023      	movs	r3, r4
 800c6b2:	4651      	mov	r1, sl
 800c6b4:	4658      	mov	r0, fp
    str++;
 800c6b6:	3501      	adds	r5, #1
    cell_drawchar_7x13(w, h, *str, x, y, fg, FALSE);
 800c6b8:	f7ff faf2 	bl	800bca0 <cell_drawchar_7x13>
  while (*str) {
 800c6bc:	782a      	ldrb	r2, [r5, #0]
    x += 7;
 800c6be:	3407      	adds	r4, #7
  while (*str) {
 800c6c0:	2a00      	cmp	r2, #0
 800c6c2:	d1f1      	bne.n	800c6a8 <draw_all_cells+0x538>
  if (previous_marker >= 0 && active_marker != previous_marker && markers[previous_marker].enabled) {
 800c6c4:	4b7d      	ldr	r3, [pc, #500]	; (800c8bc <draw_all_cells+0x74c>)
 800c6c6:	781b      	ldrb	r3, [r3, #0]
 800c6c8:	b25b      	sxtb	r3, r3
 800c6ca:	2b00      	cmp	r3, #0
 800c6cc:	db0e      	blt.n	800c6ec <draw_all_cells+0x57c>
 800c6ce:	228e      	movs	r2, #142	; 0x8e
 800c6d0:	4975      	ldr	r1, [pc, #468]	; (800c8a8 <draw_all_cells+0x738>)
 800c6d2:	0152      	lsls	r2, r2, #5
 800c6d4:	588a      	ldr	r2, [r1, r2]
 800c6d6:	429a      	cmp	r2, r3
 800c6d8:	d008      	beq.n	800c6ec <draw_all_cells+0x57c>
 800c6da:	228d      	movs	r2, #141	; 0x8d
 800c6dc:	0092      	lsls	r2, r2, #2
 800c6de:	189a      	adds	r2, r3, r2
 800c6e0:	00d2      	lsls	r2, r2, #3
 800c6e2:	5689      	ldrsb	r1, [r1, r2]
 800c6e4:	2900      	cmp	r1, #0
 800c6e6:	d001      	beq.n	800c6ec <draw_all_cells+0x57c>
 800c6e8:	f000 fe0b 	bl	800d302 <draw_all_cells+0x1192>
  if (y >= 0 && y < 8 && x >= 0 && x < 16)
 800c6ec:	9b18      	ldr	r3, [sp, #96]	; 0x60
 800c6ee:	2b0f      	cmp	r3, #15
 800c6f0:	dc0c      	bgt.n	800c70c <draw_all_cells+0x59c>
    markmap[current_mappage][y] |= 1<<x;
 800c6f2:	9a08      	ldr	r2, [sp, #32]
 800c6f4:	4b72      	ldr	r3, [pc, #456]	; (800c8c0 <draw_all_cells+0x750>)
 800c6f6:	4694      	mov	ip, r2
 800c6f8:	881b      	ldrh	r3, [r3, #0]
 800c6fa:	4a72      	ldr	r2, [pc, #456]	; (800c8c4 <draw_all_cells+0x754>)
 800c6fc:	00db      	lsls	r3, r3, #3
 800c6fe:	4463      	add	r3, ip
 800c700:	005b      	lsls	r3, r3, #1
 800c702:	5ad2      	ldrh	r2, [r2, r3]
 800c704:	9922      	ldr	r1, [sp, #136]	; 0x88
 800c706:	430a      	orrs	r2, r1
 800c708:	496e      	ldr	r1, [pc, #440]	; (800c8c4 <draw_all_cells+0x754>)
 800c70a:	52ca      	strh	r2, [r1, r3]
  PULSE;
 800c70c:	2280      	movs	r2, #128	; 0x80
 800c70e:	4b64      	ldr	r3, [pc, #400]	; (800c8a0 <draw_all_cells+0x730>)
 800c710:	0192      	lsls	r2, r2, #6
 800c712:	835a      	strh	r2, [r3, #26]
 800c714:	831a      	strh	r2, [r3, #24]
  if (m == 0)
 800c716:	9b18      	ldr	r3, [sp, #96]	; 0x60
 800c718:	2b00      	cmp	r3, #0
 800c71a:	d101      	bne.n	800c720 <draw_all_cells+0x5b0>
 800c71c:	f000 fc51 	bl	800cfc2 <draw_all_cells+0xe52>
  ili9341_bulk(OFFSETX + x0off, OFFSETY + y0, w, h);
 800c720:	4653      	mov	r3, sl
 800c722:	465a      	mov	r2, fp
 800c724:	9904      	ldr	r1, [sp, #16]
 800c726:	981c      	ldr	r0, [sp, #112]	; 0x70
 800c728:	f003 ffa2 	bl	8010670 <ili9341_bulk>
  chMtxUnlock(&mutex_ili9341); // [/protect spi_buffer]
 800c72c:	4866      	ldr	r0, [pc, #408]	; (800c8c8 <draw_all_cells+0x758>)
 800c72e:	f7f7 fccf 	bl	80040d0 <chMtxUnlock>
 800c732:	4b66      	ldr	r3, [pc, #408]	; (800c8cc <draw_all_cells+0x75c>)
 800c734:	681a      	ldr	r2, [r3, #0]
 800c736:	e56b      	b.n	800c210 <draw_all_cells+0xa0>
        else if (grid_mode & GRID_POLAR)
 800c738:	9d10      	ldr	r5, [sp, #64]	; 0x40
        uint16_t c = 0;
 800c73a:	2300      	movs	r3, #0
        else if (grid_mode & GRID_POLAR)
 800c73c:	2d00      	cmp	r5, #0
 800c73e:	d100      	bne.n	800c742 <draw_all_cells+0x5d2>
 800c740:	e66f      	b.n	800c422 <draw_all_cells+0x2b2>
  int d = x*x + y*y - r*r;
 800c742:	0013      	movs	r3, r2
 800c744:	4353      	muls	r3, r2
 800c746:	4699      	mov	r9, r3
 800c748:	4b61      	ldr	r3, [pc, #388]	; (800c8d0 <draw_all_cells+0x760>)
 800c74a:	4481      	add	r9, r0
 800c74c:	444b      	add	r3, r9
  if (d <= -r)
 800c74e:	001d      	movs	r5, r3
 800c750:	3573      	adds	r5, #115	; 0x73
 800c752:	db00      	blt.n	800c756 <draw_all_cells+0x5e6>
 800c754:	e661      	b.n	800c41a <draw_all_cells+0x2aa>
  if (x == 0 || y == 0)
 800c756:	2a00      	cmp	r2, #0
 800c758:	d100      	bne.n	800c75c <draw_all_cells+0x5ec>
 800c75a:	e661      	b.n	800c420 <draw_all_cells+0x2b0>
 800c75c:	2c00      	cmp	r4, #0
 800c75e:	d100      	bne.n	800c762 <draw_all_cells+0x5f2>
 800c760:	e65e      	b.n	800c420 <draw_all_cells+0x2b0>
  int d = x*x + y*y - r*r;
 800c762:	4b5c      	ldr	r3, [pc, #368]	; (800c8d4 <draw_all_cells+0x764>)
 800c764:	444b      	add	r3, r9
 800c766:	469b      	mov	fp, r3
  if (d <= -r)
 800c768:	3316      	adds	r3, #22
 800c76a:	db24      	blt.n	800c7b6 <draw_all_cells+0x646>
  if (d > r)
 800c76c:	465d      	mov	r5, fp
 800c76e:	000b      	movs	r3, r1
 800c770:	2d17      	cmp	r5, #23
 800c772:	dc00      	bgt.n	800c776 <draw_all_cells+0x606>
 800c774:	e655      	b.n	800c422 <draw_all_cells+0x2b2>
  int d = x*x + y*y - r*r;
 800c776:	4b58      	ldr	r3, [pc, #352]	; (800c8d8 <draw_all_cells+0x768>)
 800c778:	444b      	add	r3, r9
 800c77a:	469b      	mov	fp, r3
  if (d <= -r)
 800c77c:	332d      	adds	r3, #45	; 0x2d
 800c77e:	db1a      	blt.n	800c7b6 <draw_all_cells+0x646>
  if (d > r)
 800c780:	465d      	mov	r5, fp
 800c782:	000b      	movs	r3, r1
 800c784:	2d2e      	cmp	r5, #46	; 0x2e
 800c786:	dc00      	bgt.n	800c78a <draw_all_cells+0x61a>
 800c788:	e64b      	b.n	800c422 <draw_all_cells+0x2b2>
  if (x == y || x == -y)
 800c78a:	42a2      	cmp	r2, r4
 800c78c:	d100      	bne.n	800c790 <draw_all_cells+0x620>
 800c78e:	e647      	b.n	800c420 <draw_all_cells+0x2b0>
 800c790:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 800c792:	429a      	cmp	r2, r3
 800c794:	d100      	bne.n	800c798 <draw_all_cells+0x628>
 800c796:	e643      	b.n	800c420 <draw_all_cells+0x2b0>
  int d = x*x + y*y - r*r;
 800c798:	4b50      	ldr	r3, [pc, #320]	; (800c8dc <draw_all_cells+0x76c>)
 800c79a:	444b      	add	r3, r9
 800c79c:	469b      	mov	fp, r3
  if (d <= -r)
 800c79e:	3344      	adds	r3, #68	; 0x44
 800c7a0:	db09      	blt.n	800c7b6 <draw_all_cells+0x646>
  if (d > r)
 800c7a2:	465d      	mov	r5, fp
 800c7a4:	000b      	movs	r3, r1
 800c7a6:	2d45      	cmp	r5, #69	; 0x45
 800c7a8:	dc00      	bgt.n	800c7ac <draw_all_cells+0x63c>
 800c7aa:	e63a      	b.n	800c422 <draw_all_cells+0x2b2>
 800c7ac:	4b4c      	ldr	r3, [pc, #304]	; (800c8e0 <draw_all_cells+0x770>)
 800c7ae:	444b      	add	r3, r9
 800c7b0:	2bb7      	cmp	r3, #183	; 0xb7
 800c7b2:	d800      	bhi.n	800c7b6 <draw_all_cells+0x646>
 800c7b4:	e634      	b.n	800c420 <draw_all_cells+0x2b0>
 800c7b6:	2300      	movs	r3, #0
 800c7b8:	e633      	b.n	800c422 <draw_all_cells+0x2b2>
  if (y == 0)
 800c7ba:	2c00      	cmp	r4, #0
 800c7bc:	d100      	bne.n	800c7c0 <draw_all_cells+0x650>
 800c7be:	e62f      	b.n	800c420 <draw_all_cells+0x2b0>
  x -= P_RADIUS;
 800c7c0:	0013      	movs	r3, r2
  if (d > r)
 800c7c2:	4d48      	ldr	r5, [pc, #288]	; (800c8e4 <draw_all_cells+0x774>)
 800c7c4:	3b74      	subs	r3, #116	; 0x74
 800c7c6:	46ab      	mov	fp, r5
  int d = x*x + y*y - r*r;
 800c7c8:	435b      	muls	r3, r3
 800c7ca:	4699      	mov	r9, r3
 800c7cc:	19db      	adds	r3, r3, r7
  if (d > r)
 800c7ce:	449b      	add	fp, r3
 800c7d0:	465d      	mov	r5, fp
 800c7d2:	000b      	movs	r3, r1
 800c7d4:	2d73      	cmp	r5, #115	; 0x73
 800c7d6:	d800      	bhi.n	800c7da <draw_all_cells+0x66a>
 800c7d8:	e623      	b.n	800c422 <draw_all_cells+0x2b2>
 800c7da:	4d42      	ldr	r5, [pc, #264]	; (800c8e4 <draw_all_cells+0x774>)
  int d = x*x + y*y - r*r;
 800c7dc:	464b      	mov	r3, r9
  if (d > r)
 800c7de:	46ab      	mov	fp, r5
  int d = x*x + y*y - r*r;
 800c7e0:	4463      	add	r3, ip
  if (d > r)
 800c7e2:	449b      	add	fp, r3
 800c7e4:	465d      	mov	r5, fp
 800c7e6:	000b      	movs	r3, r1
 800c7e8:	2d73      	cmp	r5, #115	; 0x73
 800c7ea:	d800      	bhi.n	800c7ee <draw_all_cells+0x67e>
 800c7ec:	e619      	b.n	800c422 <draw_all_cells+0x2b2>
  d = circle_inout(x+29, y, 29);
 800c7ee:	0013      	movs	r3, r2
  int d = x*x + y*y - r*r;
 800c7f0:	4d3d      	ldr	r5, [pc, #244]	; (800c8e8 <draw_all_cells+0x778>)
 800c7f2:	3b57      	subs	r3, #87	; 0x57
 800c7f4:	46ab      	mov	fp, r5
 800c7f6:	435b      	muls	r3, r3
 800c7f8:	181b      	adds	r3, r3, r0
 800c7fa:	449b      	add	fp, r3
  if (d <= -r)
 800c7fc:	465b      	mov	r3, fp
 800c7fe:	331c      	adds	r3, #28
 800c800:	dbd9      	blt.n	800c7b6 <draw_all_cells+0x646>
  if (d > r)
 800c802:	465d      	mov	r5, fp
 800c804:	000b      	movs	r3, r1
 800c806:	2d1d      	cmp	r5, #29
 800c808:	dc00      	bgt.n	800c80c <draw_all_cells+0x69c>
 800c80a:	e60a      	b.n	800c422 <draw_all_cells+0x2b2>
  int d = x*x + y*y - r*r;
 800c80c:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 800c80e:	464b      	mov	r3, r9
 800c810:	46ab      	mov	fp, r5
  if (d > r)
 800c812:	4d36      	ldr	r5, [pc, #216]	; (800c8ec <draw_all_cells+0x77c>)
  int d = x*x + y*y - r*r;
 800c814:	445b      	add	r3, fp
  if (d > r)
 800c816:	46ab      	mov	fp, r5
 800c818:	449b      	add	fp, r3
 800c81a:	465d      	mov	r5, fp
 800c81c:	000b      	movs	r3, r1
 800c81e:	2de7      	cmp	r5, #231	; 0xe7
 800c820:	d800      	bhi.n	800c824 <draw_all_cells+0x6b4>
 800c822:	e5fe      	b.n	800c422 <draw_all_cells+0x2b2>
 800c824:	4d31      	ldr	r5, [pc, #196]	; (800c8ec <draw_all_cells+0x77c>)
  int d = x*x + y*y - r*r;
 800c826:	9b12      	ldr	r3, [sp, #72]	; 0x48
  if (d > r)
 800c828:	46ab      	mov	fp, r5
  int d = x*x + y*y - r*r;
 800c82a:	444b      	add	r3, r9
  if (d > r)
 800c82c:	449b      	add	fp, r3
 800c82e:	465d      	mov	r5, fp
 800c830:	000b      	movs	r3, r1
 800c832:	2de7      	cmp	r5, #231	; 0xe7
 800c834:	d800      	bhi.n	800c838 <draw_all_cells+0x6c8>
 800c836:	e5f4      	b.n	800c422 <draw_all_cells+0x2b2>
  d = circle_inout(x+58, y, 58);
 800c838:	0013      	movs	r3, r2
  int d = x*x + y*y - r*r;
 800c83a:	4d2d      	ldr	r5, [pc, #180]	; (800c8f0 <draw_all_cells+0x780>)
 800c83c:	3b3a      	subs	r3, #58	; 0x3a
 800c83e:	46ab      	mov	fp, r5
 800c840:	435b      	muls	r3, r3
 800c842:	181b      	adds	r3, r3, r0
 800c844:	449b      	add	fp, r3
  if (d <= -r)
 800c846:	465b      	mov	r3, fp
 800c848:	3339      	adds	r3, #57	; 0x39
 800c84a:	dbb4      	blt.n	800c7b6 <draw_all_cells+0x646>
  if (d > r)
 800c84c:	465d      	mov	r5, fp
 800c84e:	000b      	movs	r3, r1
 800c850:	2d3a      	cmp	r5, #58	; 0x3a
 800c852:	dc00      	bgt.n	800c856 <draw_all_cells+0x6e6>
 800c854:	e5e5      	b.n	800c422 <draw_all_cells+0x2b2>
 800c856:	4d27      	ldr	r5, [pc, #156]	; (800c8f4 <draw_all_cells+0x784>)
  int d = x*x + y*y - r*r;
 800c858:	9b14      	ldr	r3, [sp, #80]	; 0x50
  if (d > r)
 800c85a:	46ab      	mov	fp, r5
 800c85c:	25d0      	movs	r5, #208	; 0xd0
  int d = x*x + y*y - r*r;
 800c85e:	444b      	add	r3, r9
  if (d > r)
 800c860:	449b      	add	fp, r3
 800c862:	35ff      	adds	r5, #255	; 0xff
 800c864:	000b      	movs	r3, r1
 800c866:	45ab      	cmp	fp, r5
 800c868:	d800      	bhi.n	800c86c <draw_all_cells+0x6fc>
 800c86a:	e5da      	b.n	800c422 <draw_all_cells+0x2b2>
  int d = x*x + y*y - r*r;
 800c86c:	9b15      	ldr	r3, [sp, #84]	; 0x54
 800c86e:	469b      	mov	fp, r3
  if (d > r)
 800c870:	4b20      	ldr	r3, [pc, #128]	; (800c8f4 <draw_all_cells+0x784>)
  int d = x*x + y*y - r*r;
 800c872:	44d9      	add	r9, fp
  if (d > r)
 800c874:	469b      	mov	fp, r3
 800c876:	44d9      	add	r9, fp
 800c878:	000b      	movs	r3, r1
 800c87a:	45a9      	cmp	r9, r5
 800c87c:	d800      	bhi.n	800c880 <draw_all_cells+0x710>
 800c87e:	e5d0      	b.n	800c422 <draw_all_cells+0x2b2>
  if (circle_inout(x+87, y, 87) == 0)
 800c880:	0013      	movs	r3, r2
  if (d > r)
 800c882:	4d1d      	ldr	r5, [pc, #116]	; (800c8f8 <draw_all_cells+0x788>)
 800c884:	3b1d      	subs	r3, #29
 800c886:	46a9      	mov	r9, r5
  int d = x*x + y*y - r*r;
 800c888:	435b      	muls	r3, r3
 800c88a:	181b      	adds	r3, r3, r0
  if (d > r)
 800c88c:	444b      	add	r3, r9
 800c88e:	2bad      	cmp	r3, #173	; 0xad
 800c890:	d800      	bhi.n	800c894 <draw_all_cells+0x724>
 800c892:	e5c5      	b.n	800c420 <draw_all_cells+0x2b0>
 800c894:	2300      	movs	r3, #0
 800c896:	e5c4      	b.n	800c422 <draw_all_cells+0x2b2>
  if (x == 0 || x == WIDTH)
 800c898:	4640      	mov	r0, r8
 800c89a:	e53b      	b.n	800c314 <draw_all_cells+0x1a4>
  if ((y % GRIDY) == 0)
 800c89c:	0030      	movs	r0, r6
 800c89e:	e561      	b.n	800c364 <draw_all_cells+0x1f4>
 800c8a0:	48000800 	.word	0x48000800
 800c8a4:	200015f4 	.word	0x200015f4
 800c8a8:	20000454 	.word	0x20000454
 800c8ac:	0000116c 	.word	0x0000116c
 800c8b0:	080149ec 	.word	0x080149ec
 800c8b4:	0000ffff 	.word	0x0000ffff
 800c8b8:	000011c4 	.word	0x000011c4
 800c8bc:	20001650 	.word	0x20001650
 800c8c0:	200029fc 	.word	0x200029fc
 800c8c4:	20002a04 	.word	0x20002a04
 800c8c8:	2000220c 	.word	0x2000220c
 800c8cc:	2000163c 	.word	0x2000163c
 800c8d0:	ffffcb70 	.word	0xffffcb70
 800c8d4:	fffffdef 	.word	0xfffffdef
 800c8d8:	fffff7bc 	.word	0xfffff7bc
 800c8dc:	ffffed67 	.word	0xffffed67
 800c8e0:	ffffdf4b 	.word	0xffffdf4b
 800c8e4:	fffff315 	.word	0xfffff315
 800c8e8:	fffffcb7 	.word	0xfffffcb7
 800c8ec:	ffffcbe3 	.word	0xffffcbe3
 800c8f0:	fffff2dc 	.word	0xfffff2dc
 800c8f4:	ffff2ea7 	.word	0xffff2ea7
 800c8f8:	ffffe2c5 	.word	0xffffe2c5
 800c8fc:	4642      	mov	r2, r8
 800c8fe:	231a      	movs	r3, #26
 800c900:	4353      	muls	r3, r2
 800c902:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
    for (t = 0; t < TRACE_COUNT; t++) {
 800c904:	2600      	movs	r6, #0
 800c906:	4694      	mov	ip, r2
 800c908:	4463      	add	r3, ip
 800c90a:	9313      	str	r3, [sp, #76]	; 0x4c
    if (!markers[i].enabled)
 800c90c:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800c90e:	469c      	mov	ip, r3
      if (x > -6 && x < w+6 && y >= 0 && y < h+12)
 800c910:	464b      	mov	r3, r9
 800c912:	3305      	adds	r3, #5
 800c914:	930d      	str	r3, [sp, #52]	; 0x34
 800c916:	4663      	mov	r3, ip
 800c918:	46c4      	mov	ip, r8
 800c91a:	46c8      	mov	r8, r9
 800c91c:	46d1      	mov	r9, sl
 800c91e:	46ba      	mov	sl, r7
 800c920:	001f      	movs	r7, r3
      if (!trace[t].enabled)
 800c922:	783b      	ldrb	r3, [r7, #0]
 800c924:	2b00      	cmp	r3, #0
 800c926:	d024      	beq.n	800c972 <draw_all_cells+0x802>
      uint32_t index = trace_index[t][markers[i].index];
 800c928:	4653      	mov	r3, sl
 800c92a:	2202      	movs	r2, #2
 800c92c:	5e9a      	ldrsh	r2, [r3, r2]
 800c92e:	2365      	movs	r3, #101	; 0x65
      int x = CELL_X(index) - x0;
 800c930:	24f8      	movs	r4, #248	; 0xf8
 800c932:	201f      	movs	r0, #31
      uint32_t index = trace_index[t][markers[i].index];
 800c934:	4373      	muls	r3, r6
 800c936:	189b      	adds	r3, r3, r2
 800c938:	4ac0      	ldr	r2, [pc, #768]	; (800cc3c <draw_all_cells+0xacc>)
 800c93a:	009b      	lsls	r3, r3, #2
 800c93c:	58d2      	ldr	r2, [r2, r3]
      int x = CELL_X(index) - x0;
 800c93e:	00a4      	lsls	r4, r4, #2
 800c940:	0953      	lsrs	r3, r2, #5
 800c942:	0d91      	lsrs	r1, r2, #22
 800c944:	4021      	ands	r1, r4
 800c946:	4003      	ands	r3, r0
 800c948:	430b      	orrs	r3, r1
 800c94a:	9906      	ldr	r1, [sp, #24]
 800c94c:	1a5b      	subs	r3, r3, r1
      if (x > -6 && x < w+6 && y >= 0 && y < h+12)
 800c94e:	1d59      	adds	r1, r3, #5
 800c950:	db0f      	blt.n	800c972 <draw_all_cells+0x802>
 800c952:	990d      	ldr	r1, [sp, #52]	; 0x34
 800c954:	428b      	cmp	r3, r1
 800c956:	dc0c      	bgt.n	800c972 <draw_all_cells+0x802>
      int y = CELL_Y(index) - y0;
 800c958:	0c51      	lsrs	r1, r2, #17
 800c95a:	4021      	ands	r1, r4
 800c95c:	4002      	ands	r2, r0
 800c95e:	430a      	orrs	r2, r1
 800c960:	9904      	ldr	r1, [sp, #16]
 800c962:	1a51      	subs	r1, r2, r1
 800c964:	910a      	str	r1, [sp, #40]	; 0x28
      if (x > -6 && x < w+6 && y >= 0 && y < h+12)
 800c966:	d404      	bmi.n	800c972 <draw_all_cells+0x802>
 800c968:	464a      	mov	r2, r9
 800c96a:	320b      	adds	r2, #11
 800c96c:	4291      	cmp	r1, r2
 800c96e:	dc00      	bgt.n	800c972 <draw_all_cells+0x802>
 800c970:	e37c      	b.n	800d06c <draw_all_cells+0xefc>
    for (t = 0; t < TRACE_COUNT; t++) {
 800c972:	3601      	adds	r6, #1
 800c974:	370c      	adds	r7, #12
 800c976:	2e04      	cmp	r6, #4
 800c978:	d1d3      	bne.n	800c922 <draw_all_cells+0x7b2>
 800c97a:	4657      	mov	r7, sl
 800c97c:	46ca      	mov	sl, r9
 800c97e:	46c1      	mov	r9, r8
 800c980:	46e0      	mov	r8, ip
 800c982:	e601      	b.n	800c588 <draw_all_cells+0x418>
  if (x < 0)
 800c984:	2000      	movs	r0, #0
 800c986:	e4c5      	b.n	800c314 <draw_all_cells+0x1a4>
 800c988:	46a8      	mov	r8, r5
  while (j > 0 && x == CELL_X0(index[j-1]))
 800c98a:	2c00      	cmp	r4, #0
 800c98c:	dc01      	bgt.n	800c992 <draw_all_cells+0x822>
 800c98e:	f000 fe75 	bl	800d67c <draw_all_cells+0x150c>
 800c992:	4642      	mov	r2, r8
 800c994:	4baa      	ldr	r3, [pc, #680]	; (800cc40 <draw_all_cells+0xad0>)
 800c996:	18e3      	adds	r3, r4, r3
 800c998:	009b      	lsls	r3, r3, #2
 800c99a:	589b      	ldr	r3, [r3, r2]
 800c99c:	0d9b      	lsrs	r3, r3, #22
 800c99e:	4033      	ands	r3, r6
 800c9a0:	429f      	cmp	r7, r3
 800c9a2:	d001      	beq.n	800c9a8 <draw_all_cells+0x838>
 800c9a4:	f000 fd24 	bl	800d3f0 <draw_all_cells+0x1280>
 800c9a8:	4ba6      	ldr	r3, [pc, #664]	; (800cc44 <draw_all_cells+0xad4>)
 800c9aa:	0025      	movs	r5, r4
 800c9ac:	18e2      	adds	r2, r4, r3
 800c9ae:	0092      	lsls	r2, r2, #2
 800c9b0:	4442      	add	r2, r8
 800c9b2:	e005      	b.n	800c9c0 <draw_all_cells+0x850>
 800c9b4:	6813      	ldr	r3, [r2, #0]
 800c9b6:	3a04      	subs	r2, #4
 800c9b8:	0d9b      	lsrs	r3, r3, #22
 800c9ba:	4033      	ands	r3, r6
 800c9bc:	429f      	cmp	r7, r3
 800c9be:	d102      	bne.n	800c9c6 <draw_all_cells+0x856>
    j--;
 800c9c0:	3d01      	subs	r5, #1
  while (j > 0 && x == CELL_X0(index[j-1]))
 800c9c2:	2d00      	cmp	r5, #0
 800c9c4:	d1f6      	bne.n	800c9b4 <draw_all_cells+0x844>
  while (j < 100 && x == CELL_X0(index[j+1]))
 800c9c6:	2c63      	cmp	r4, #99	; 0x63
 800c9c8:	dc18      	bgt.n	800c9fc <draw_all_cells+0x88c>
 800c9ca:	4641      	mov	r1, r8
 800c9cc:	1c62      	adds	r2, r4, #1
 800c9ce:	0093      	lsls	r3, r2, #2
 800c9d0:	585b      	ldr	r3, [r3, r1]
 800c9d2:	0d9b      	lsrs	r3, r3, #22
 800c9d4:	4033      	ands	r3, r6
 800c9d6:	429f      	cmp	r7, r3
 800c9d8:	d001      	beq.n	800c9de <draw_all_cells+0x86e>
 800c9da:	f000 fc8b 	bl	800d2f4 <draw_all_cells+0x1184>
 800c9de:	1ca1      	adds	r1, r4, #2
 800c9e0:	0089      	lsls	r1, r1, #2
 800c9e2:	4441      	add	r1, r8
 800c9e4:	e007      	b.n	800c9f6 <draw_all_cells+0x886>
 800c9e6:	c908      	ldmia	r1!, {r3}
 800c9e8:	3201      	adds	r2, #1
 800c9ea:	0d9b      	lsrs	r3, r3, #22
 800c9ec:	4033      	ands	r3, r6
 800c9ee:	429f      	cmp	r7, r3
 800c9f0:	d001      	beq.n	800c9f6 <draw_all_cells+0x886>
 800c9f2:	f000 fc7f 	bl	800d2f4 <draw_all_cells+0x1184>
    j++;
 800c9f6:	0014      	movs	r4, r2
  while (j < 100 && x == CELL_X0(index[j+1]))
 800c9f8:	2a64      	cmp	r2, #100	; 0x64
 800c9fa:	d1f4      	bne.n	800c9e6 <draw_all_cells+0x876>
      if (i0 > 0)
 800c9fc:	2d00      	cmp	r5, #0
 800c9fe:	dd03      	ble.n	800ca08 <draw_all_cells+0x898>
        i0--;
 800ca00:	3d01      	subs	r5, #1
      for (i = i0; i < i1; i++) {
 800ca02:	42a5      	cmp	r5, r4
 800ca04:	db00      	blt.n	800ca08 <draw_all_cells+0x898>
 800ca06:	e58c      	b.n	800c522 <draw_all_cells+0x3b2>
 800ca08:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800ca0a:	4a8c      	ldr	r2, [pc, #560]	; (800cc3c <draw_all_cells+0xacc>)
 800ca0c:	469c      	mov	ip, r3
 800ca0e:	4465      	add	r5, ip
 800ca10:	4694      	mov	ip, r2
 800ca12:	00ad      	lsls	r5, r5, #2
 800ca14:	4465      	add	r5, ip
 800ca16:	469c      	mov	ip, r3
        int y1 = CELL_Y(trace_index[t][i]);
 800ca18:	4643      	mov	r3, r8
 800ca1a:	4693      	mov	fp, r2
 800ca1c:	9312      	str	r3, [sp, #72]	; 0x48
 800ca1e:	9b06      	ldr	r3, [sp, #24]
 800ca20:	4464      	add	r4, ip
 800ca22:	00a4      	lsls	r4, r4, #2
 800ca24:	4698      	mov	r8, r3
 800ca26:	464b      	mov	r3, r9
 800ca28:	44a3      	add	fp, r4
 800ca2a:	241f      	movs	r4, #31
 800ca2c:	46b9      	mov	r9, r7
 800ca2e:	9f04      	ldr	r7, [sp, #16]
 800ca30:	9313      	str	r3, [sp, #76]	; 0x4c
 800ca32:	0022      	movs	r2, r4
        int x1 = CELL_X(trace_index[t][i]);
 800ca34:	6828      	ldr	r0, [r5, #0]
        int x2 = CELL_X(trace_index[t][i+1]);
 800ca36:	6869      	ldr	r1, [r5, #4]
        int y1 = CELL_Y(trace_index[t][i]);
 800ca38:	0c43      	lsrs	r3, r0, #17
 800ca3a:	4002      	ands	r2, r0
 800ca3c:	4033      	ands	r3, r6
 800ca3e:	4313      	orrs	r3, r2
        cell_drawline(w, h, x1 - x0, y1 - y0, x2 - x0, y2 - y0, c);
 800ca40:	1bdb      	subs	r3, r3, r7
 800ca42:	930d      	str	r3, [sp, #52]	; 0x34
 800ca44:	4643      	mov	r3, r8
        int x1 = CELL_X(trace_index[t][i]);
 800ca46:	0942      	lsrs	r2, r0, #5
 800ca48:	0d80      	lsrs	r0, r0, #22
 800ca4a:	4030      	ands	r0, r6
 800ca4c:	4022      	ands	r2, r4
 800ca4e:	4302      	orrs	r2, r0
        cell_drawline(w, h, x1 - x0, y1 - y0, x2 - x0, y2 - y0, c);
 800ca50:	1ad2      	subs	r2, r2, r3
        int c = config.trace_color[t];
 800ca52:	9b07      	ldr	r3, [sp, #28]
 800ca54:	3504      	adds	r5, #4
 800ca56:	8958      	ldrh	r0, [r3, #10]
        int y2 = CELL_Y(trace_index[t][i+1]);
 800ca58:	0023      	movs	r3, r4
        int c = config.trace_color[t];
 800ca5a:	9002      	str	r0, [sp, #8]
        int y2 = CELL_Y(trace_index[t][i+1]);
 800ca5c:	0c48      	lsrs	r0, r1, #17
 800ca5e:	400b      	ands	r3, r1
 800ca60:	4030      	ands	r0, r6
 800ca62:	4318      	orrs	r0, r3
        cell_drawline(w, h, x1 - x0, y1 - y0, x2 - x0, y2 - y0, c);
 800ca64:	4643      	mov	r3, r8
 800ca66:	1bc0      	subs	r0, r0, r7
 800ca68:	9001      	str	r0, [sp, #4]
        int x2 = CELL_X(trace_index[t][i+1]);
 800ca6a:	0948      	lsrs	r0, r1, #5
 800ca6c:	0d89      	lsrs	r1, r1, #22
 800ca6e:	4020      	ands	r0, r4
 800ca70:	4031      	ands	r1, r6
 800ca72:	4301      	orrs	r1, r0
        cell_drawline(w, h, x1 - x0, y1 - y0, x2 - x0, y2 - y0, c);
 800ca74:	1ac9      	subs	r1, r1, r3
 800ca76:	9100      	str	r1, [sp, #0]
 800ca78:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800ca7a:	4651      	mov	r1, sl
 800ca7c:	9810      	ldr	r0, [sp, #64]	; 0x40
 800ca7e:	f7ff f83f 	bl	800bb00 <cell_drawline>
      for (i = i0; i < i1; i++) {
 800ca82:	45ab      	cmp	fp, r5
 800ca84:	d1d5      	bne.n	800ca32 <draw_all_cells+0x8c2>
 800ca86:	9b12      	ldr	r3, [sp, #72]	; 0x48
 800ca88:	464f      	mov	r7, r9
 800ca8a:	4698      	mov	r8, r3
 800ca8c:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 800ca8e:	4699      	mov	r9, r3
 800ca90:	e547      	b.n	800c522 <draw_all_cells+0x3b2>
    for (i = 1; i < sweep_points; i++) {
 800ca92:	4b6d      	ldr	r3, [pc, #436]	; (800cc48 <draw_all_cells+0xad8>)
 800ca94:	220c      	movs	r2, #12
 800ca96:	5e9b      	ldrsh	r3, [r3, r2]
 800ca98:	2b01      	cmp	r3, #1
 800ca9a:	dc00      	bgt.n	800ca9e <draw_all_cells+0x92e>
 800ca9c:	e55f      	b.n	800c55e <draw_all_cells+0x3ee>
    int c = config.trace_color[t];
 800ca9e:	4643      	mov	r3, r8
 800caa0:	4a6a      	ldr	r2, [pc, #424]	; (800cc4c <draw_all_cells+0xadc>)
 800caa2:	005b      	lsls	r3, r3, #1
 800caa4:	5ad3      	ldrh	r3, [r2, r3]
 800caa6:	9c0d      	ldr	r4, [sp, #52]	; 0x34
 800caa8:	930a      	str	r3, [sp, #40]	; 0x28
 800caaa:	4643      	mov	r3, r8
 800caac:	435c      	muls	r4, r3
 800caae:	4b63      	ldr	r3, [pc, #396]	; (800cc3c <draw_all_cells+0xacc>)
      int y1 = CELL_Y(trace_index[t][i-1]);
 800cab0:	26f8      	movs	r6, #248	; 0xf8
 800cab2:	469c      	mov	ip, r3
    for (i = 1; i < sweep_points; i++) {
 800cab4:	2301      	movs	r3, #1
 800cab6:	4699      	mov	r9, r3
      int y1 = CELL_Y(trace_index[t][i-1]);
 800cab8:	003b      	movs	r3, r7
 800caba:	251f      	movs	r5, #31
 800cabc:	464f      	mov	r7, r9
 800cabe:	4699      	mov	r9, r3
 800cac0:	4464      	add	r4, ip
 800cac2:	00b6      	lsls	r6, r6, #2
 800cac4:	002a      	movs	r2, r5
      int x1 = CELL_X(trace_index[t][i-1]);
 800cac6:	6820      	ldr	r0, [r4, #0]
      int x2 = CELL_X(trace_index[t][i]);
 800cac8:	6861      	ldr	r1, [r4, #4]
      int y1 = CELL_Y(trace_index[t][i-1]);
 800caca:	0c43      	lsrs	r3, r0, #17
 800cacc:	4002      	ands	r2, r0
 800cace:	4033      	ands	r3, r6
 800cad0:	4313      	orrs	r3, r2
      cell_drawline(w, h, x1 - x0, y1 - y0, x2 - x0, y2 - y0, c);
 800cad2:	9a04      	ldr	r2, [sp, #16]
    for (i = 1; i < sweep_points; i++) {
 800cad4:	3701      	adds	r7, #1
      cell_drawline(w, h, x1 - x0, y1 - y0, x2 - x0, y2 - y0, c);
 800cad6:	1a9b      	subs	r3, r3, r2
 800cad8:	9307      	str	r3, [sp, #28]
    int c = config.trace_color[t];
 800cada:	9b0a      	ldr	r3, [sp, #40]	; 0x28
      int x1 = CELL_X(trace_index[t][i-1]);
 800cadc:	0942      	lsrs	r2, r0, #5
    int c = config.trace_color[t];
 800cade:	9302      	str	r3, [sp, #8]
      int y2 = CELL_Y(trace_index[t][i]);
 800cae0:	002b      	movs	r3, r5
      int x1 = CELL_X(trace_index[t][i-1]);
 800cae2:	0d80      	lsrs	r0, r0, #22
 800cae4:	4030      	ands	r0, r6
 800cae6:	402a      	ands	r2, r5
 800cae8:	4302      	orrs	r2, r0
      cell_drawline(w, h, x1 - x0, y1 - y0, x2 - x0, y2 - y0, c);
 800caea:	9806      	ldr	r0, [sp, #24]
      int y2 = CELL_Y(trace_index[t][i]);
 800caec:	400b      	ands	r3, r1
      cell_drawline(w, h, x1 - x0, y1 - y0, x2 - x0, y2 - y0, c);
 800caee:	1a12      	subs	r2, r2, r0
      int y2 = CELL_Y(trace_index[t][i]);
 800caf0:	0c48      	lsrs	r0, r1, #17
 800caf2:	4030      	ands	r0, r6
 800caf4:	4318      	orrs	r0, r3
      cell_drawline(w, h, x1 - x0, y1 - y0, x2 - x0, y2 - y0, c);
 800caf6:	9b04      	ldr	r3, [sp, #16]
 800caf8:	3404      	adds	r4, #4
 800cafa:	1ac0      	subs	r0, r0, r3
 800cafc:	9001      	str	r0, [sp, #4]
      int x2 = CELL_X(trace_index[t][i]);
 800cafe:	0948      	lsrs	r0, r1, #5
 800cb00:	0d89      	lsrs	r1, r1, #22
 800cb02:	4028      	ands	r0, r5
 800cb04:	4031      	ands	r1, r6
 800cb06:	4301      	orrs	r1, r0
      cell_drawline(w, h, x1 - x0, y1 - y0, x2 - x0, y2 - y0, c);
 800cb08:	9806      	ldr	r0, [sp, #24]
 800cb0a:	9b07      	ldr	r3, [sp, #28]
 800cb0c:	1a09      	subs	r1, r1, r0
 800cb0e:	9100      	str	r1, [sp, #0]
 800cb10:	4658      	mov	r0, fp
 800cb12:	4651      	mov	r1, sl
 800cb14:	f7fe fff4 	bl	800bb00 <cell_drawline>
    for (i = 1; i < sweep_points; i++) {
 800cb18:	4b4b      	ldr	r3, [pc, #300]	; (800cc48 <draw_all_cells+0xad8>)
 800cb1a:	220c      	movs	r2, #12
 800cb1c:	5e9b      	ldrsh	r3, [r3, r2]
 800cb1e:	429f      	cmp	r7, r3
 800cb20:	dbd0      	blt.n	800cac4 <draw_all_cells+0x954>
 800cb22:	464f      	mov	r7, r9
 800cb24:	e51b      	b.n	800c55e <draw_all_cells+0x3ee>
      grid_mode |= GRID_SMITH;
 800cb26:	4326      	orrs	r6, r4
 800cb28:	f7ff fbb4 	bl	800c294 <draw_all_cells+0x124>
      grid_mode |= GRID_POLAR;
 800cb2c:	432e      	orrs	r6, r5
 800cb2e:	f7ff fbb1 	bl	800c294 <draw_all_cells+0x124>
    h = area_height - y0;
 800cb32:	9b04      	ldr	r3, [sp, #16]
 800cb34:	1ae3      	subs	r3, r4, r3
 800cb36:	469a      	mov	sl, r3
  int w = CELLWIDTH;
 800cb38:	2320      	movs	r3, #32
 800cb3a:	469b      	mov	fp, r3
  if (w <= 0 || h <= 0)
 800cb3c:	4653      	mov	r3, sl
 800cb3e:	2b00      	cmp	r3, #0
 800cb40:	dc01      	bgt.n	800cb46 <draw_all_cells+0x9d6>
 800cb42:	f7ff fb65 	bl	800c210 <draw_all_cells+0xa0>
 800cb46:	f7ff fb8d 	bl	800c264 <draw_all_cells+0xf4>
 800cb4a:	2900      	cmp	r1, #0
 800cb4c:	dc01      	bgt.n	800cb52 <draw_all_cells+0x9e2>
 800cb4e:	f7ff fb5f 	bl	800c210 <draw_all_cells+0xa0>
    h = area_height - y0;
 800cb52:	9b04      	ldr	r3, [sp, #16]
 800cb54:	1ae3      	subs	r3, r4, r3
 800cb56:	469a      	mov	sl, r3
 800cb58:	e7f0      	b.n	800cb3c <draw_all_cells+0x9cc>
    xpos -= m * CELLWIDTH -CELLOFFSETX;
 800cb5a:	2501      	movs	r5, #1
 800cb5c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    cell_drawstring_invert_7x13(w, h, buf, xpos, ypos, config.trace_color[t], t == uistat.current_trace);
 800cb5e:	2702      	movs	r7, #2
 800cb60:	1aed      	subs	r5, r5, r3
    chsnprintf(buf, sizeof buf, "CH%d", trace[t].channel);
 800cb62:	464b      	mov	r3, r9
 800cb64:	4a3a      	ldr	r2, [pc, #232]	; (800cc50 <draw_all_cells+0xae0>)
 800cb66:	789b      	ldrb	r3, [r3, #2]
 800cb68:	2118      	movs	r1, #24
 800cb6a:	a826      	add	r0, sp, #152	; 0x98
 800cb6c:	f7fa fce0 	bl	8007530 <chsnprintf>
    cell_drawstring_invert_7x13(w, h, buf, xpos, ypos, config.trace_color[t], t == uistat.current_trace);
 800cb70:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  while (*str) {
 800cb72:	ae26      	add	r6, sp, #152	; 0x98
    cell_drawstring_invert_7x13(w, h, buf, xpos, ypos, config.trace_color[t], t == uistat.current_trace);
 800cb74:	895b      	ldrh	r3, [r3, #10]
 800cb76:	4698      	mov	r8, r3
 800cb78:	4b36      	ldr	r3, [pc, #216]	; (800cc54 <draw_all_cells+0xae4>)
 800cb7a:	57df      	ldrsb	r7, [r3, r7]
 800cb7c:	9b07      	ldr	r3, [sp, #28]
 800cb7e:	1aff      	subs	r7, r7, r3
 800cb80:	427b      	negs	r3, r7
 800cb82:	415f      	adcs	r7, r3
  while (*str) {
 800cb84:	ab22      	add	r3, sp, #136	; 0x88
 800cb86:	7c1a      	ldrb	r2, [r3, #16]
 800cb88:	2a00      	cmp	r2, #0
 800cb8a:	d019      	beq.n	800cbc0 <draw_all_cells+0xa50>
 800cb8c:	0021      	movs	r1, r4
 800cb8e:	003b      	movs	r3, r7
 800cb90:	4654      	mov	r4, sl
 800cb92:	465f      	mov	r7, fp
 800cb94:	468a      	mov	sl, r1
 800cb96:	469b      	mov	fp, r3
    cell_drawchar_7x13(w, h, *str, x, y, fg, invert);
 800cb98:	465b      	mov	r3, fp
 800cb9a:	9302      	str	r3, [sp, #8]
 800cb9c:	4643      	mov	r3, r8
 800cb9e:	9301      	str	r3, [sp, #4]
 800cba0:	4653      	mov	r3, sl
 800cba2:	0021      	movs	r1, r4
 800cba4:	9300      	str	r3, [sp, #0]
 800cba6:	0038      	movs	r0, r7
 800cba8:	002b      	movs	r3, r5
    str++;
 800cbaa:	3601      	adds	r6, #1
    cell_drawchar_7x13(w, h, *str, x, y, fg, invert);
 800cbac:	f7ff f878 	bl	800bca0 <cell_drawchar_7x13>
  while (*str) {
 800cbb0:	7832      	ldrb	r2, [r6, #0]
    x += 7;
 800cbb2:	3507      	adds	r5, #7
  while (*str) {
 800cbb4:	2a00      	cmp	r2, #0
 800cbb6:	d1ef      	bne.n	800cb98 <draw_all_cells+0xa28>
 800cbb8:	4653      	mov	r3, sl
 800cbba:	46bb      	mov	fp, r7
 800cbbc:	46a2      	mov	sl, r4
 800cbbe:	001c      	movs	r4, r3
    trace_get_info(t, buf, sizeof buf);
 800cbc0:	2218      	movs	r2, #24
 800cbc2:	a926      	add	r1, sp, #152	; 0x98
 800cbc4:	9807      	ldr	r0, [sp, #28]
 800cbc6:	9f0c      	ldr	r7, [sp, #48]	; 0x30
 800cbc8:	f7ff fa72 	bl	800c0b0 <trace_get_info>
    cell_drawstring_7x13(w, h, buf, xpos, ypos, config.trace_color[t]);
 800cbcc:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800cbce:	261d      	movs	r6, #29
 800cbd0:	895b      	ldrh	r3, [r3, #10]
 800cbd2:	2577      	movs	r5, #119	; 0x77
 800cbd4:	930a      	str	r3, [sp, #40]	; 0x28
  while (*str) {
 800cbd6:	ab22      	add	r3, sp, #136	; 0x88
 800cbd8:	7c1a      	ldrb	r2, [r3, #16]
    cell_drawchar_7x13(w, h, *str, x, y, fg, FALSE);
 800cbda:	2300      	movs	r3, #0
 800cbdc:	1bf6      	subs	r6, r6, r7
static void cell_drawstring_7x13(int w, int h, char *str, int x, int y, uint16_t fg)
 800cbde:	1bed      	subs	r5, r5, r7
    cell_drawchar_7x13(w, h, *str, x, y, fg, FALSE);
 800cbe0:	4698      	mov	r8, r3
  while (*str) {
 800cbe2:	af26      	add	r7, sp, #152	; 0x98
 800cbe4:	2a00      	cmp	r2, #0
 800cbe6:	d100      	bne.n	800cbea <draw_all_cells+0xa7a>
 800cbe8:	e3df      	b.n	800d3aa <draw_all_cells+0x123a>
 800cbea:	0023      	movs	r3, r4
 800cbec:	465c      	mov	r4, fp
 800cbee:	46ab      	mov	fp, r5
 800cbf0:	4655      	mov	r5, sl
 800cbf2:	469a      	mov	sl, r3
    cell_drawchar_7x13(w, h, *str, x, y, fg, FALSE);
 800cbf4:	4643      	mov	r3, r8
 800cbf6:	9302      	str	r3, [sp, #8]
 800cbf8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800cbfa:	0029      	movs	r1, r5
 800cbfc:	9301      	str	r3, [sp, #4]
 800cbfe:	4653      	mov	r3, sl
 800cc00:	0020      	movs	r0, r4
 800cc02:	9300      	str	r3, [sp, #0]
    str++;
 800cc04:	3701      	adds	r7, #1
    cell_drawchar_7x13(w, h, *str, x, y, fg, FALSE);
 800cc06:	0033      	movs	r3, r6
 800cc08:	f7ff f84a 	bl	800bca0 <cell_drawchar_7x13>
  while (*str) {
 800cc0c:	783a      	ldrb	r2, [r7, #0]
    x += 7;
 800cc0e:	3607      	adds	r6, #7
  while (*str) {
 800cc10:	2a00      	cmp	r2, #0
 800cc12:	d1ef      	bne.n	800cbf4 <draw_all_cells+0xa84>
 800cc14:	4653      	mov	r3, sl
 800cc16:	46aa      	mov	sl, r5
 800cc18:	465d      	mov	r5, fp
 800cc1a:	46a3      	mov	fp, r4
 800cc1c:	001c      	movs	r4, r3
        idx, measured[trace[t].channel], frequencies, sweep_points);
 800cc1e:	464b      	mov	r3, r9
 800cc20:	26ca      	movs	r6, #202	; 0xca
 800cc22:	7898      	ldrb	r0, [r3, #2]
 800cc24:	00b6      	lsls	r6, r6, #2
 800cc26:	4346      	muls	r6, r0
  switch (trace[t].type) {
 800cc28:	785b      	ldrb	r3, [r3, #1]
        idx, measured[trace[t].channel], frequencies, sweep_points);
 800cc2a:	480b      	ldr	r0, [pc, #44]	; (800cc58 <draw_all_cells+0xae8>)
 800cc2c:	1836      	adds	r6, r6, r0
  switch (trace[t].type) {
 800cc2e:	2b0a      	cmp	r3, #10
 800cc30:	d847      	bhi.n	800ccc2 <draw_all_cells+0xb52>
 800cc32:	4a0a      	ldr	r2, [pc, #40]	; (800cc5c <draw_all_cells+0xaec>)
 800cc34:	009b      	lsls	r3, r3, #2
 800cc36:	58d3      	ldr	r3, [r2, r3]
 800cc38:	469f      	mov	pc, r3
 800cc3a:	46c0      	nop			; (mov r8, r8)
 800cc3c:	20002a24 	.word	0x20002a24
 800cc40:	3fffffff 	.word	0x3fffffff
 800cc44:	3ffffffe 	.word	0x3ffffffe
 800cc48:	20000454 	.word	0x20000454
 800cc4c:	20000436 	.word	0x20000436
 800cc50:	080149b0 	.word	0x080149b0
 800cc54:	20001654 	.word	0x20001654
 800cc58:	20001bbc 	.word	0x20001bbc
 800cc5c:	0801492c 	.word	0x0801492c
    gamma2resistance(buf, len, coeff[i]);
 800cc60:	9b14      	ldr	r3, [sp, #80]	; 0x50
  float d = z0 / ((1-coeff[0])*(1-coeff[0])+coeff[1]*coeff[1]);
 800cc62:	20fe      	movs	r0, #254	; 0xfe
    gamma2resistance(buf, len, coeff[i]);
 800cc64:	469c      	mov	ip, r3
 800cc66:	4466      	add	r6, ip
  float d = z0 / ((1-coeff[0])*(1-coeff[0])+coeff[1]*coeff[1]);
 800cc68:	6833      	ldr	r3, [r6, #0]
 800cc6a:	0580      	lsls	r0, r0, #22
 800cc6c:	1c19      	adds	r1, r3, #0
 800cc6e:	930a      	str	r3, [sp, #40]	; 0x28
 800cc70:	f7f4 fad6 	bl	8001220 <__aeabi_fsub>
 800cc74:	1c07      	adds	r7, r0, #0
 800cc76:	6870      	ldr	r0, [r6, #4]
 800cc78:	1c01      	adds	r1, r0, #0
 800cc7a:	f7f4 f9b9 	bl	8000ff0 <__aeabi_fmul>
 800cc7e:	4680      	mov	r8, r0
 800cc80:	1c39      	adds	r1, r7, #0
 800cc82:	1c38      	adds	r0, r7, #0
 800cc84:	f7f4 f9b4 	bl	8000ff0 <__aeabi_fmul>
 800cc88:	4641      	mov	r1, r8
 800cc8a:	f7f3 fe51 	bl	8000930 <__aeabi_fadd>
 800cc8e:	1c01      	adds	r1, r0, #0
 800cc90:	48e4      	ldr	r0, [pc, #912]	; (800d024 <draw_all_cells+0xeb4>)
 800cc92:	f7f3 ffcd 	bl	8000c30 <__aeabi_fdiv>
  float zr = ((1+coeff[0])*(1-coeff[0]) - coeff[1]*coeff[1]) * d;
 800cc96:	21fe      	movs	r1, #254	; 0xfe
  float d = z0 / ((1-coeff[0])*(1-coeff[0])+coeff[1]*coeff[1]);
 800cc98:	1c06      	adds	r6, r0, #0
  float zr = ((1+coeff[0])*(1-coeff[0]) - coeff[1]*coeff[1]) * d;
 800cc9a:	0589      	lsls	r1, r1, #22
 800cc9c:	980a      	ldr	r0, [sp, #40]	; 0x28
 800cc9e:	f7f3 fe47 	bl	8000930 <__aeabi_fadd>
 800cca2:	1c39      	adds	r1, r7, #0
 800cca4:	f7f4 f9a4 	bl	8000ff0 <__aeabi_fmul>
 800cca8:	4641      	mov	r1, r8
 800ccaa:	f7f4 fab9 	bl	8001220 <__aeabi_fsub>
 800ccae:	1c01      	adds	r1, r0, #0
 800ccb0:	1c30      	adds	r0, r6, #0
  float zi = 2*coeff[1] * d;
 800ccb2:	f7f4 f99d 	bl	8000ff0 <__aeabi_fmul>
  string_value_with_prefix(buf, len, zi, S_OHM[0]);
 800ccb6:	231e      	movs	r3, #30
  float zi = 2*coeff[1] * d;
 800ccb8:	1c02      	adds	r2, r0, #0
  string_value_with_prefix(buf, len, zi, S_OHM[0]);
 800ccba:	2118      	movs	r1, #24
 800ccbc:	a826      	add	r0, sp, #152	; 0x98
 800ccbe:	f7fe fd9f 	bl	800b800 <string_value_with_prefix>
    cell_drawstring_7x13(w, h, buf, xpos, ypos, config.trace_color[t]);
 800ccc2:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  while (*str) {
 800ccc4:	ae26      	add	r6, sp, #152	; 0x98
    cell_drawstring_7x13(w, h, buf, xpos, ypos, config.trace_color[t]);
 800ccc6:	895b      	ldrh	r3, [r3, #10]
    cell_drawchar_7x13(w, h, *str, x, y, fg, FALSE);
 800ccc8:	2700      	movs	r7, #0
    cell_drawstring_7x13(w, h, buf, xpos, ypos, config.trace_color[t]);
 800ccca:	4698      	mov	r8, r3
  while (*str) {
 800cccc:	ab22      	add	r3, sp, #136	; 0x88
 800ccce:	7c1a      	ldrb	r2, [r3, #16]
 800ccd0:	2a00      	cmp	r2, #0
 800ccd2:	d012      	beq.n	800ccfa <draw_all_cells+0xb8a>
 800ccd4:	0023      	movs	r3, r4
 800ccd6:	465c      	mov	r4, fp
 800ccd8:	469b      	mov	fp, r3
    cell_drawchar_7x13(w, h, *str, x, y, fg, FALSE);
 800ccda:	4643      	mov	r3, r8
 800ccdc:	9301      	str	r3, [sp, #4]
 800ccde:	465b      	mov	r3, fp
 800cce0:	9702      	str	r7, [sp, #8]
 800cce2:	9300      	str	r3, [sp, #0]
 800cce4:	4651      	mov	r1, sl
 800cce6:	002b      	movs	r3, r5
 800cce8:	0020      	movs	r0, r4
    str++;
 800ccea:	3601      	adds	r6, #1
    cell_drawchar_7x13(w, h, *str, x, y, fg, FALSE);
 800ccec:	f7fe ffd8 	bl	800bca0 <cell_drawchar_7x13>
  while (*str) {
 800ccf0:	7832      	ldrb	r2, [r6, #0]
    x += 7;
 800ccf2:	3507      	adds	r5, #7
  while (*str) {
 800ccf4:	2a00      	cmp	r2, #0
 800ccf6:	d1f0      	bne.n	800ccda <draw_all_cells+0xb6a>
 800ccf8:	46a3      	mov	fp, r4
    j++;
 800ccfa:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800ccfc:	9c10      	ldr	r4, [sp, #64]	; 0x40
 800ccfe:	3301      	adds	r3, #1
 800cd00:	930d      	str	r3, [sp, #52]	; 0x34
 800cd02:	9b04      	ldr	r3, [sp, #16]
 800cd04:	340e      	adds	r4, #14
 800cd06:	1ae4      	subs	r4, r4, r3
 800cd08:	e47c      	b.n	800c604 <draw_all_cells+0x494>
    v = logmag(coeff[i]);
 800cd0a:	9b14      	ldr	r3, [sp, #80]	; 0x50
 800cd0c:	469c      	mov	ip, r3
 800cd0e:	4466      	add	r6, ip
  return log10f(v[0]*v[0] + v[1]*v[1]) * 10;
 800cd10:	6830      	ldr	r0, [r6, #0]
 800cd12:	6876      	ldr	r6, [r6, #4]
 800cd14:	1c01      	adds	r1, r0, #0
 800cd16:	f7f4 f96b 	bl	8000ff0 <__aeabi_fmul>
 800cd1a:	1c31      	adds	r1, r6, #0
 800cd1c:	1c07      	adds	r7, r0, #0
 800cd1e:	1c30      	adds	r0, r6, #0
 800cd20:	f7f4 f966 	bl	8000ff0 <__aeabi_fmul>
 800cd24:	1c01      	adds	r1, r0, #0
 800cd26:	1c38      	adds	r0, r7, #0
 800cd28:	f7f3 fe02 	bl	8000930 <__aeabi_fadd>
 800cd2c:	f004 fae8 	bl	8011300 <log10f>
 800cd30:	49bd      	ldr	r1, [pc, #756]	; (800d028 <draw_all_cells+0xeb8>)
 800cd32:	f7f4 f95d 	bl	8000ff0 <__aeabi_fmul>
    if (v == -INFINITY)
 800cd36:	49bd      	ldr	r1, [pc, #756]	; (800d02c <draw_all_cells+0xebc>)
  return log10f(v[0]*v[0] + v[1]*v[1]) * 10;
 800cd38:	1c06      	adds	r6, r0, #0
    if (v == -INFINITY)
 800cd3a:	f7f3 fc1d 	bl	8000578 <__aeabi_fcmpeq>
 800cd3e:	2800      	cmp	r0, #0
 800cd40:	d101      	bne.n	800cd46 <draw_all_cells+0xbd6>
 800cd42:	f000 fc18 	bl	800d576 <draw_all_cells+0x1406>
      chsnprintf(buf, len, "-INF dB");
 800cd46:	4aba      	ldr	r2, [pc, #744]	; (800d030 <draw_all_cells+0xec0>)
 800cd48:	2118      	movs	r1, #24
 800cd4a:	a826      	add	r0, sp, #152	; 0x98
 800cd4c:	f7fa fbf0 	bl	8007530 <chsnprintf>
 800cd50:	e7b7      	b.n	800ccc2 <draw_all_cells+0xb52>
    gamma2reactance(buf, len, coeff[i]);
 800cd52:	9b14      	ldr	r3, [sp, #80]	; 0x50
  float d = z0 / ((1-coeff[0])*(1-coeff[0])+coeff[1]*coeff[1]);
 800cd54:	20fe      	movs	r0, #254	; 0xfe
    gamma2reactance(buf, len, coeff[i]);
 800cd56:	469c      	mov	ip, r3
 800cd58:	4466      	add	r6, ip
  float d = z0 / ((1-coeff[0])*(1-coeff[0])+coeff[1]*coeff[1]);
 800cd5a:	6831      	ldr	r1, [r6, #0]
 800cd5c:	0580      	lsls	r0, r0, #22
 800cd5e:	f7f4 fa5f 	bl	8001220 <__aeabi_fsub>
 800cd62:	1c01      	adds	r1, r0, #0
 800cd64:	f7f4 f944 	bl	8000ff0 <__aeabi_fmul>
 800cd68:	6876      	ldr	r6, [r6, #4]
 800cd6a:	1c07      	adds	r7, r0, #0
 800cd6c:	1c31      	adds	r1, r6, #0
 800cd6e:	1c30      	adds	r0, r6, #0
 800cd70:	f7f4 f93e 	bl	8000ff0 <__aeabi_fmul>
 800cd74:	1c01      	adds	r1, r0, #0
 800cd76:	1c38      	adds	r0, r7, #0
 800cd78:	f7f3 fdda 	bl	8000930 <__aeabi_fadd>
 800cd7c:	1c01      	adds	r1, r0, #0
 800cd7e:	48a9      	ldr	r0, [pc, #676]	; (800d024 <draw_all_cells+0xeb4>)
 800cd80:	f7f3 ff56 	bl	8000c30 <__aeabi_fdiv>
  float zi = 2*coeff[1] * d;
 800cd84:	1c31      	adds	r1, r6, #0
  float d = z0 / ((1-coeff[0])*(1-coeff[0])+coeff[1]*coeff[1]);
 800cd86:	1c07      	adds	r7, r0, #0
  float zi = 2*coeff[1] * d;
 800cd88:	1c30      	adds	r0, r6, #0
 800cd8a:	f7f3 fdd1 	bl	8000930 <__aeabi_fadd>
 800cd8e:	1c01      	adds	r1, r0, #0
 800cd90:	1c38      	adds	r0, r7, #0
 800cd92:	e78e      	b.n	800ccb2 <draw_all_cells+0xb42>
    chsnprintf(buf, len, "%.3fj", coeff[i][1]);
 800cd94:	9b14      	ldr	r3, [sp, #80]	; 0x50
 800cd96:	469c      	mov	ip, r3
 800cd98:	4466      	add	r6, ip
 800cd9a:	6870      	ldr	r0, [r6, #4]
 800cd9c:	f7f6 fb20 	bl	80033e0 <__aeabi_f2d>
 800cda0:	4aa4      	ldr	r2, [pc, #656]	; (800d034 <draw_all_cells+0xec4>)
 800cda2:	9000      	str	r0, [sp, #0]
 800cda4:	9101      	str	r1, [sp, #4]
 800cda6:	2118      	movs	r1, #24
 800cda8:	a826      	add	r0, sp, #152	; 0x98
 800cdaa:	f7fa fbc1 	bl	8007530 <chsnprintf>
    break;
 800cdae:	e788      	b.n	800ccc2 <draw_all_cells+0xb52>
    chsnprintf(buf, len, "%.3f", coeff[i][0]);
 800cdb0:	9b14      	ldr	r3, [sp, #80]	; 0x50
 800cdb2:	58f0      	ldr	r0, [r6, r3]
 800cdb4:	f7f6 fb14 	bl	80033e0 <__aeabi_f2d>
 800cdb8:	4a9f      	ldr	r2, [pc, #636]	; (800d038 <draw_all_cells+0xec8>)
 800cdba:	9000      	str	r0, [sp, #0]
 800cdbc:	9101      	str	r1, [sp, #4]
 800cdbe:	2118      	movs	r1, #24
 800cdc0:	a826      	add	r0, sp, #152	; 0x98
 800cdc2:	f7fa fbb5 	bl	8007530 <chsnprintf>
    break;
 800cdc6:	e77c      	b.n	800ccc2 <draw_all_cells+0xb52>
    v = swr(coeff[i]);
 800cdc8:	9b14      	ldr	r3, [sp, #80]	; 0x50
 800cdca:	18f0      	adds	r0, r6, r3
 800cdcc:	f7fe fe68 	bl	800baa0 <swr>
    chsnprintf(buf, len, "%.2f", v);
 800cdd0:	f7f6 fb06 	bl	80033e0 <__aeabi_f2d>
 800cdd4:	4a99      	ldr	r2, [pc, #612]	; (800d03c <draw_all_cells+0xecc>)
 800cdd6:	9000      	str	r0, [sp, #0]
 800cdd8:	9101      	str	r1, [sp, #4]
 800cdda:	2118      	movs	r1, #24
 800cddc:	a826      	add	r0, sp, #152	; 0x98
 800cdde:	f7fa fba7 	bl	8007530 <chsnprintf>
    break;
 800cde2:	e76e      	b.n	800ccc2 <draw_all_cells+0xb52>
    v = linear(coeff[i]);
 800cde4:	9b14      	ldr	r3, [sp, #80]	; 0x50
 800cde6:	469c      	mov	ip, r3
 800cde8:	4466      	add	r6, ip
  return  sqrtf(v[0]*v[0] + v[1]*v[1]);
 800cdea:	6830      	ldr	r0, [r6, #0]
 800cdec:	6876      	ldr	r6, [r6, #4]
 800cdee:	1c01      	adds	r1, r0, #0
 800cdf0:	f7f4 f8fe 	bl	8000ff0 <__aeabi_fmul>
 800cdf4:	1c31      	adds	r1, r6, #0
 800cdf6:	1c07      	adds	r7, r0, #0
 800cdf8:	1c30      	adds	r0, r6, #0
 800cdfa:	f7f4 f8f9 	bl	8000ff0 <__aeabi_fmul>
 800cdfe:	1c01      	adds	r1, r0, #0
 800ce00:	1c38      	adds	r0, r7, #0
 800ce02:	f7f3 fd95 	bl	8000930 <__aeabi_fadd>
 800ce06:	f004 fafb 	bl	8011400 <sqrtf>
    chsnprintf(buf, len, "%.3f", v);
 800ce0a:	e7d3      	b.n	800cdb4 <draw_all_cells+0xc44>
    chsnprintf(buf, len, "%.3f %.3fj", coeff[i][0], coeff[i][1]);
 800ce0c:	9b14      	ldr	r3, [sp, #80]	; 0x50
 800ce0e:	469c      	mov	ip, r3
 800ce10:	4466      	add	r6, ip
 800ce12:	6870      	ldr	r0, [r6, #4]
 800ce14:	f7f6 fae4 	bl	80033e0 <__aeabi_f2d>
 800ce18:	9002      	str	r0, [sp, #8]
 800ce1a:	9103      	str	r1, [sp, #12]
 800ce1c:	6830      	ldr	r0, [r6, #0]
 800ce1e:	f7f6 fadf 	bl	80033e0 <__aeabi_f2d>
 800ce22:	4a87      	ldr	r2, [pc, #540]	; (800d040 <draw_all_cells+0xed0>)
 800ce24:	9000      	str	r0, [sp, #0]
 800ce26:	9101      	str	r1, [sp, #4]
 800ce28:	2118      	movs	r1, #24
 800ce2a:	a826      	add	r0, sp, #152	; 0x98
 800ce2c:	f7fa fb80 	bl	8007530 <chsnprintf>
    break;
 800ce30:	e747      	b.n	800ccc2 <draw_all_cells+0xb52>
    gamma2imp(buf, len, coeff[i], freq[i]);
 800ce32:	9b14      	ldr	r3, [sp, #80]	; 0x50
  float d = z0 / ((1-coeff[0])*(1-coeff[0])+coeff[1]*coeff[1]);
 800ce34:	20fe      	movs	r0, #254	; 0xfe
    gamma2imp(buf, len, coeff[i], freq[i]);
 800ce36:	469c      	mov	ip, r3
 800ce38:	9b19      	ldr	r3, [sp, #100]	; 0x64
 800ce3a:	4466      	add	r6, ip
  float d = z0 / ((1-coeff[0])*(1-coeff[0])+coeff[1]*coeff[1]);
 800ce3c:	6832      	ldr	r2, [r6, #0]
    gamma2imp(buf, len, coeff[i], freq[i]);
 800ce3e:	681b      	ldr	r3, [r3, #0]
  float d = z0 / ((1-coeff[0])*(1-coeff[0])+coeff[1]*coeff[1]);
 800ce40:	1c11      	adds	r1, r2, #0
 800ce42:	0580      	lsls	r0, r0, #22
    gamma2imp(buf, len, coeff[i], freq[i]);
 800ce44:	930a      	str	r3, [sp, #40]	; 0x28
  float d = z0 / ((1-coeff[0])*(1-coeff[0])+coeff[1]*coeff[1]);
 800ce46:	921d      	str	r2, [sp, #116]	; 0x74
 800ce48:	f7f4 f9ea 	bl	8001220 <__aeabi_fsub>
 800ce4c:	6876      	ldr	r6, [r6, #4]
 800ce4e:	4680      	mov	r8, r0
 800ce50:	1c31      	adds	r1, r6, #0
 800ce52:	1c30      	adds	r0, r6, #0
 800ce54:	f7f4 f8cc 	bl	8000ff0 <__aeabi_fmul>
 800ce58:	4641      	mov	r1, r8
 800ce5a:	1c07      	adds	r7, r0, #0
 800ce5c:	4640      	mov	r0, r8
 800ce5e:	f7f4 f8c7 	bl	8000ff0 <__aeabi_fmul>
 800ce62:	1c39      	adds	r1, r7, #0
 800ce64:	9725      	str	r7, [sp, #148]	; 0x94
 800ce66:	f7f3 fd63 	bl	8000930 <__aeabi_fadd>
 800ce6a:	1c01      	adds	r1, r0, #0
 800ce6c:	486d      	ldr	r0, [pc, #436]	; (800d024 <draw_all_cells+0xeb4>)
 800ce6e:	f7f3 fedf 	bl	8000c30 <__aeabi_fdiv>
  float zi = 2*coeff[1] * d;
 800ce72:	1c31      	adds	r1, r6, #0
  float d = z0 / ((1-coeff[0])*(1-coeff[0])+coeff[1]*coeff[1]);
 800ce74:	1c07      	adds	r7, r0, #0
  float zi = 2*coeff[1] * d;
 800ce76:	1c30      	adds	r0, r6, #0
 800ce78:	f7f3 fd5a 	bl	8000930 <__aeabi_fadd>
 800ce7c:	1c39      	adds	r1, r7, #0
 800ce7e:	f7f4 f8b7 	bl	8000ff0 <__aeabi_fmul>
  float zr = ((1+coeff[0])*(1-coeff[0]) - coeff[1]*coeff[1]) * d;
 800ce82:	21fe      	movs	r1, #254	; 0xfe
  float zi = 2*coeff[1] * d;
 800ce84:	1c06      	adds	r6, r0, #0
  float zr = ((1+coeff[0])*(1-coeff[0]) - coeff[1]*coeff[1]) * d;
 800ce86:	0589      	lsls	r1, r1, #22
 800ce88:	981d      	ldr	r0, [sp, #116]	; 0x74
 800ce8a:	f7f3 fd51 	bl	8000930 <__aeabi_fadd>
 800ce8e:	4641      	mov	r1, r8
 800ce90:	f7f4 f8ae 	bl	8000ff0 <__aeabi_fmul>
 800ce94:	9925      	ldr	r1, [sp, #148]	; 0x94
 800ce96:	f7f4 f9c3 	bl	8001220 <__aeabi_fsub>
 800ce9a:	1c39      	adds	r1, r7, #0
 800ce9c:	f7f4 f8a8 	bl	8000ff0 <__aeabi_fmul>
  n = string_value_with_prefix(buf, len, zr, S_OHM[0]);
 800cea0:	231e      	movs	r3, #30
  float zr = ((1+coeff[0])*(1-coeff[0]) - coeff[1]*coeff[1]) * d;
 800cea2:	1c02      	adds	r2, r0, #0
  n = string_value_with_prefix(buf, len, zr, S_OHM[0]);
 800cea4:	2118      	movs	r1, #24
 800cea6:	a826      	add	r0, sp, #152	; 0x98
 800cea8:	f7fe fcaa 	bl	800b800 <string_value_with_prefix>
  buf[n++] = ' ';
 800ceac:	2110      	movs	r1, #16
 800ceae:	2320      	movs	r3, #32
 800ceb0:	1c42      	adds	r2, r0, #1
 800ceb2:	4690      	mov	r8, r2
 800ceb4:	aa22      	add	r2, sp, #136	; 0x88
 800ceb6:	1852      	adds	r2, r2, r1
 800ceb8:	5413      	strb	r3, [r2, r0]
  if (zi < 0) {
 800ceba:	2100      	movs	r1, #0
 800cebc:	1c30      	adds	r0, r6, #0
 800cebe:	f7f3 fb61 	bl	8000584 <__aeabi_fcmplt>
 800cec2:	2800      	cmp	r0, #0
 800cec4:	d000      	beq.n	800cec8 <draw_all_cells+0xd58>
 800cec6:	e362      	b.n	800d58e <draw_all_cells+0x141e>
    float l = zi / (PI2 * frequency);
 800cec8:	1c30      	adds	r0, r6, #0
 800ceca:	f7f6 fa89 	bl	80033e0 <__aeabi_f2d>
 800cece:	0006      	movs	r6, r0
 800ced0:	980a      	ldr	r0, [sp, #40]	; 0x28
 800ced2:	000f      	movs	r7, r1
 800ced4:	f7f6 fa4c 	bl	8003370 <__aeabi_ui2d>
 800ced8:	4a5a      	ldr	r2, [pc, #360]	; (800d044 <draw_all_cells+0xed4>)
 800ceda:	4b5b      	ldr	r3, [pc, #364]	; (800d048 <draw_all_cells+0xed8>)
 800cedc:	f7f5 fb90 	bl	8002600 <__aeabi_dmul>
 800cee0:	0002      	movs	r2, r0
 800cee2:	000b      	movs	r3, r1
 800cee4:	0030      	movs	r0, r6
 800cee6:	0039      	movs	r1, r7
 800cee8:	f7f4 ff82 	bl	8001df0 <__aeabi_ddiv>
 800ceec:	f7f6 fad0 	bl	8003490 <__aeabi_d2f>
    string_value_with_prefix(buf+n, len-n, l, 'H');
 800cef0:	4643      	mov	r3, r8
 800cef2:	2118      	movs	r1, #24
    float l = zi / (PI2 * frequency);
 800cef4:	1c02      	adds	r2, r0, #0
    string_value_with_prefix(buf+n, len-n, l, 'H');
 800cef6:	a826      	add	r0, sp, #152	; 0x98
 800cef8:	1ac9      	subs	r1, r1, r3
 800cefa:	4440      	add	r0, r8
 800cefc:	2348      	movs	r3, #72	; 0x48
 800cefe:	f7fe fc7f 	bl	800b800 <string_value_with_prefix>
 800cf02:	e6de      	b.n	800ccc2 <draw_all_cells+0xb52>
    trace_get_value_string(
 800cf04:	4b51      	ldr	r3, [pc, #324]	; (800d04c <draw_all_cells+0xedc>)
    v = group_delay(coeff, freq, point_count, i);
 800cf06:	9a13      	ldr	r2, [sp, #76]	; 0x4c
    trace_get_value_string(
 800cf08:	210c      	movs	r1, #12
 800cf0a:	5e59      	ldrsh	r1, [r3, r1]
    v = group_delay(coeff, freq, point_count, i);
 800cf0c:	0030      	movs	r0, r6
 800cf0e:	f7fe ff27 	bl	800bd60 <group_delay.constprop.11>
    string_value_with_prefix(buf, len, v, 's');
 800cf12:	2373      	movs	r3, #115	; 0x73
    v = group_delay(coeff, freq, point_count, i);
 800cf14:	1c02      	adds	r2, r0, #0
    string_value_with_prefix(buf, len, v, 's');
 800cf16:	2118      	movs	r1, #24
 800cf18:	a826      	add	r0, sp, #152	; 0x98
 800cf1a:	f7fe fc71 	bl	800b800 <string_value_with_prefix>
    break;
 800cf1e:	e6d0      	b.n	800ccc2 <draw_all_cells+0xb52>
    v = phase(coeff[i]);
 800cf20:	9b14      	ldr	r3, [sp, #80]	; 0x50
 800cf22:	469c      	mov	ip, r3
 800cf24:	4466      	add	r6, ip
  return 2 * atan2f(v[1], v[0]) / M_PI * 90;
 800cf26:	6831      	ldr	r1, [r6, #0]
 800cf28:	6870      	ldr	r0, [r6, #4]
 800cf2a:	f004 f9e1 	bl	80112f0 <atan2f>
 800cf2e:	1c01      	adds	r1, r0, #0
 800cf30:	f7f3 fcfe 	bl	8000930 <__aeabi_fadd>
 800cf34:	f7f6 fa54 	bl	80033e0 <__aeabi_f2d>
 800cf38:	4a45      	ldr	r2, [pc, #276]	; (800d050 <draw_all_cells+0xee0>)
 800cf3a:	4b46      	ldr	r3, [pc, #280]	; (800d054 <draw_all_cells+0xee4>)
 800cf3c:	f7f4 ff58 	bl	8001df0 <__aeabi_ddiv>
 800cf40:	2200      	movs	r2, #0
 800cf42:	4b45      	ldr	r3, [pc, #276]	; (800d058 <draw_all_cells+0xee8>)
 800cf44:	f7f5 fb5c 	bl	8002600 <__aeabi_dmul>
 800cf48:	f7f6 faa2 	bl	8003490 <__aeabi_d2f>
    chsnprintf(buf, len, "%.3f" S_DEGREE, v);
 800cf4c:	f7f6 fa48 	bl	80033e0 <__aeabi_f2d>
 800cf50:	4a42      	ldr	r2, [pc, #264]	; (800d05c <draw_all_cells+0xeec>)
 800cf52:	9000      	str	r0, [sp, #0]
 800cf54:	9101      	str	r1, [sp, #4]
 800cf56:	2118      	movs	r1, #24
 800cf58:	a826      	add	r0, sp, #152	; 0x98
 800cf5a:	f7fa fae9 	bl	8007530 <chsnprintf>
    break;
 800cf5e:	e6b0      	b.n	800ccc2 <draw_all_cells+0xb52>
 800cf60:	9b17      	ldr	r3, [sp, #92]	; 0x5c
  for (m = 0; m < (area_width+CELLWIDTH-1) / CELLWIDTH; m++)
 800cf62:	0011      	movs	r1, r2
 800cf64:	3320      	adds	r3, #32
 800cf66:	9317      	str	r3, [sp, #92]	; 0x5c
 800cf68:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800cf6a:	311f      	adds	r1, #31
 800cf6c:	3320      	adds	r3, #32
 800cf6e:	930c      	str	r3, [sp, #48]	; 0x30
 800cf70:	9b11      	ldr	r3, [sp, #68]	; 0x44
 800cf72:	9c18      	ldr	r4, [sp, #96]	; 0x60
 800cf74:	3320      	adds	r3, #32
 800cf76:	9311      	str	r3, [sp, #68]	; 0x44
 800cf78:	231f      	movs	r3, #31
 800cf7a:	17c8      	asrs	r0, r1, #31
 800cf7c:	4003      	ands	r3, r0
 800cf7e:	3401      	adds	r4, #1
 800cf80:	185b      	adds	r3, r3, r1
 800cf82:	9418      	str	r4, [sp, #96]	; 0x60
 800cf84:	115b      	asrs	r3, r3, #5
 800cf86:	42a3      	cmp	r3, r4
 800cf88:	dd01      	ble.n	800cf8e <draw_all_cells+0xe1e>
 800cf8a:	f7ff f90d 	bl	800c1a8 <draw_all_cells+0x38>
  if (flush_markmap) {
 800cf8e:	9b24      	ldr	r3, [sp, #144]	; 0x90
 800cf90:	2b00      	cmp	r3, #0
 800cf92:	d000      	beq.n	800cf96 <draw_all_cells+0xe26>
 800cf94:	e375      	b.n	800d682 <draw_all_cells+0x1512>
}
 800cf96:	b02d      	add	sp, #180	; 0xb4
 800cf98:	bc3c      	pop	{r2, r3, r4, r5}
 800cf9a:	4690      	mov	r8, r2
 800cf9c:	4699      	mov	r9, r3
 800cf9e:	46a2      	mov	sl, r4
 800cfa0:	46ab      	mov	fp, r5
 800cfa2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    memset(spi_buffer, 0, sizeof spi_buffer);
 800cfa4:	2280      	movs	r2, #128	; 0x80
 800cfa6:	4b2e      	ldr	r3, [pc, #184]	; (800d060 <draw_all_cells+0xef0>)
 800cfa8:	0112      	lsls	r2, r2, #4
 800cfaa:	0018      	movs	r0, r3
 800cfac:	2100      	movs	r1, #0
 800cfae:	931a      	str	r3, [sp, #104]	; 0x68
 800cfb0:	f006 f89e 	bl	80130f0 <memset>
 800cfb4:	4b2b      	ldr	r3, [pc, #172]	; (800d064 <draw_all_cells+0xef4>)
 800cfb6:	9319      	str	r3, [sp, #100]	; 0x64
 800cfb8:	465b      	mov	r3, fp
 800cfba:	005b      	lsls	r3, r3, #1
 800cfbc:	9305      	str	r3, [sp, #20]
 800cfbe:	f7ff f9e4 	bl	800c38a <draw_all_cells+0x21a>
 800cfc2:	9b05      	ldr	r3, [sp, #20]
  for (t = 0; t < TRACE_COUNT; t++) {
 800cfc4:	2400      	movs	r4, #0
 800cfc6:	3b04      	subs	r3, #4
 800cfc8:	4698      	mov	r8, r3
 800cfca:	465b      	mov	r3, fp
 800cfcc:	005b      	lsls	r3, r3, #1
 800cfce:	425b      	negs	r3, r3
 800cfd0:	4699      	mov	r9, r3
      draw_refpos(w, h, x, y, config.trace_color[t]);
 800cfd2:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
    if (!trace[t].enabled)
 800cfd4:	782b      	ldrb	r3, [r5, #0]
 800cfd6:	2b00      	cmp	r3, #0
 800cfd8:	d019      	beq.n	800d00e <draw_all_cells+0xe9e>
    if (trace[t].type == TRC_SMITH || trace[t].type == TRC_POLAR)
 800cfda:	786b      	ldrb	r3, [r5, #1]
 800cfdc:	3b03      	subs	r3, #3
 800cfde:	2b01      	cmp	r3, #1
 800cfe0:	d915      	bls.n	800d00e <draw_all_cells+0xe9e>
    int y = 8*GRIDY - (int)(get_trace_refpos(t) * GRIDY) - y0;
 800cfe2:	0020      	movs	r0, r4
 800cfe4:	f7fd fb44 	bl	800a670 <get_trace_refpos>
    if (x > -5 && x < w && y >= -3 && y < h+3)
 800cfe8:	465b      	mov	r3, fp
 800cfea:	2b05      	cmp	r3, #5
 800cfec:	dd0f      	ble.n	800d00e <draw_all_cells+0xe9e>
    int y = 8*GRIDY - (int)(get_trace_refpos(t) * GRIDY) - y0;
 800cfee:	491e      	ldr	r1, [pc, #120]	; (800d068 <draw_all_cells+0xef8>)
 800cff0:	f7f3 fffe 	bl	8000ff0 <__aeabi_fmul>
 800cff4:	f7f4 fad4 	bl	80015a0 <__aeabi_f2iz>
 800cff8:	23e8      	movs	r3, #232	; 0xe8
 800cffa:	1a18      	subs	r0, r3, r0
 800cffc:	9b04      	ldr	r3, [sp, #16]
 800cffe:	1ac0      	subs	r0, r0, r3
    if (x > -5 && x < w && y >= -3 && y < h+3)
 800d000:	1cc3      	adds	r3, r0, #3
 800d002:	db04      	blt.n	800d00e <draw_all_cells+0xe9e>
 800d004:	4653      	mov	r3, sl
 800d006:	3302      	adds	r3, #2
 800d008:	4298      	cmp	r0, r3
 800d00a:	dc00      	bgt.n	800d00e <draw_all_cells+0xe9e>
 800d00c:	e2e4      	b.n	800d5d8 <draw_all_cells+0x1468>
  for (t = 0; t < TRACE_COUNT; t++) {
 800d00e:	3401      	adds	r4, #1
 800d010:	350c      	adds	r5, #12
 800d012:	2c04      	cmp	r4, #4
 800d014:	d1de      	bne.n	800cfd4 <draw_all_cells+0xe64>
 800d016:	f7ff fb83 	bl	800c720 <draw_all_cells+0x5b0>
  int h = CELLHEIGHT;
 800d01a:	2320      	movs	r3, #32
 800d01c:	469a      	mov	sl, r3
 800d01e:	f7ff f921 	bl	800c264 <draw_all_cells+0xf4>
 800d022:	46c0      	nop			; (mov r8, r8)
 800d024:	42480000 	.word	0x42480000
 800d028:	41200000 	.word	0x41200000
 800d02c:	ff800000 	.word	0xff800000
 800d030:	080149b8 	.word	0x080149b8
 800d034:	080149d8 	.word	0x080149d8
 800d038:	080149d0 	.word	0x080149d0
 800d03c:	08014aa4 	.word	0x08014aa4
 800d040:	080149e0 	.word	0x080149e0
 800d044:	fc8b007a 	.word	0xfc8b007a
 800d048:	401921fa 	.word	0x401921fa
 800d04c:	20000454 	.word	0x20000454
 800d050:	54442d18 	.word	0x54442d18
 800d054:	400921fb 	.word	0x400921fb
 800d058:	40568000 	.word	0x40568000
 800d05c:	080149c8 	.word	0x080149c8
 800d060:	200030ac 	.word	0x200030ac
 800d064:	2000042c 	.word	0x2000042c
 800d068:	41e80000 	.word	0x41e80000
        draw_marker(w, h, x, y, config.trace_color[t], '1' + i);
 800d06c:	49e2      	ldr	r1, [pc, #904]	; (800d3f8 <draw_all_cells+0x1288>)
 800d06e:	0072      	lsls	r2, r6, #1
 800d070:	5a89      	ldrh	r1, [r1, r2]
for (j = 17; j >= 0; j--) {
 800d072:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 800d074:	9805      	ldr	r0, [sp, #20]
 800d076:	3a11      	subs	r2, #17
 800d078:	4342      	muls	r2, r0
 800d07a:	981a      	ldr	r0, [sp, #104]	; 0x68
 800d07c:	1c5c      	adds	r4, r3, #1
 800d07e:	4683      	mov	fp, r0
 800d080:	9312      	str	r3, [sp, #72]	; 0x48
 800d082:	4663      	mov	r3, ip
 800d084:	445a      	add	r2, fp
 800d086:	9315      	str	r3, [sp, #84]	; 0x54
 800d088:	4653      	mov	r3, sl
 800d08a:	9614      	str	r6, [sp, #80]	; 0x50
 800d08c:	971d      	str	r7, [sp, #116]	; 0x74
 800d08e:	2011      	movs	r0, #17
 800d090:	000f      	movs	r7, r1
 800d092:	0016      	movs	r6, r2
        draw_marker(w, h, x, y, config.trace_color[t], '1' + i);
 800d094:	9d13      	ldr	r5, [sp, #76]	; 0x4c
 800d096:	9410      	str	r4, [sp, #64]	; 0x40
 800d098:	9319      	str	r3, [sp, #100]	; 0x64
    int j0 = j / 2;
 800d09a:	9b12      	ldr	r3, [sp, #72]	; 0x48
 800d09c:	1041      	asrs	r1, r0, #1
    for (i = -j0; i <= j0; i++) {
 800d09e:	1a5a      	subs	r2, r3, r1
 800d0a0:	2302      	movs	r3, #2
 800d0a2:	1a5c      	subs	r4, r3, r1
 800d0a4:	9b10      	ldr	r3, [sp, #64]	; 0x40
 800d0a6:	469c      	mov	ip, r3
 800d0a8:	1f03      	subs	r3, r0, #4
 800d0aa:	469a      	mov	sl, r3
 800d0ac:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800d0ae:	4461      	add	r1, ip
 800d0b0:	1a1b      	subs	r3, r3, r0
 800d0b2:	469c      	mov	ip, r3
 800d0b4:	9107      	str	r1, [sp, #28]
 if (j <= 17 && j > 3 && i >= -2 && i <= 4) {
 800d0b6:	4653      	mov	r3, sl
 800d0b8:	2b0d      	cmp	r3, #13
 800d0ba:	d900      	bls.n	800d0be <draw_all_cells+0xf4e>
 800d0bc:	e2ef      	b.n	800d69e <draw_all_cells+0x152e>
      int cc = c;
 800d0be:	003b      	movs	r3, r7
 if (j <= 17 && j > 3 && i >= -2 && i <= 4) {
 800d0c0:	2c06      	cmp	r4, #6
 800d0c2:	d80a      	bhi.n	800d0da <draw_all_cells+0xf6a>
		  if (bits & (0x8000>>(i+2)))
 800d0c4:	882b      	ldrh	r3, [r5, #0]
 800d0c6:	469b      	mov	fp, r3
 800d0c8:	2380      	movs	r3, #128	; 0x80
 800d0ca:	021b      	lsls	r3, r3, #8
 800d0cc:	4659      	mov	r1, fp
 800d0ce:	4123      	asrs	r3, r4
 800d0d0:	400b      	ands	r3, r1
		     cc = 0;
 800d0d2:	4259      	negs	r1, r3
 800d0d4:	4159      	adcs	r1, r3
 800d0d6:	424b      	negs	r3, r1
 800d0d8:	403b      	ands	r3, r7
      if (y0 >= 0 && y0 < h && x0 >= 0 && x0 < w)
 800d0da:	45cc      	cmp	ip, r9
 800d0dc:	d205      	bcs.n	800d0ea <draw_all_cells+0xf7a>
 800d0de:	2a00      	cmp	r2, #0
 800d0e0:	db03      	blt.n	800d0ea <draw_all_cells+0xf7a>
 800d0e2:	4590      	cmp	r8, r2
 800d0e4:	dd01      	ble.n	800d0ea <draw_all_cells+0xf7a>
        spi_buffer[y0*w+x0] = cc;
 800d0e6:	0051      	lsls	r1, r2, #1
 800d0e8:	5273      	strh	r3, [r6, r1]
    for (i = -j0; i <= j0; i++) {
 800d0ea:	9b07      	ldr	r3, [sp, #28]
 800d0ec:	3201      	adds	r2, #1
 800d0ee:	3401      	adds	r4, #1
 800d0f0:	4293      	cmp	r3, r2
 800d0f2:	d1e0      	bne.n	800d0b6 <draw_all_cells+0xf46>
 800d0f4:	9b05      	ldr	r3, [sp, #20]
 800d0f6:	3502      	adds	r5, #2
 800d0f8:	469c      	mov	ip, r3
 800d0fa:	4466      	add	r6, ip
for (j = 17; j >= 0; j--) {
 800d0fc:	3801      	subs	r0, #1
 800d0fe:	d2cc      	bcs.n	800d09a <draw_all_cells+0xf2a>
 800d100:	9b15      	ldr	r3, [sp, #84]	; 0x54
 800d102:	9e14      	ldr	r6, [sp, #80]	; 0x50
 800d104:	469c      	mov	ip, r3
 800d106:	9b19      	ldr	r3, [sp, #100]	; 0x64
 800d108:	9f1d      	ldr	r7, [sp, #116]	; 0x74
 800d10a:	469a      	mov	sl, r3
 800d10c:	e431      	b.n	800c972 <draw_all_cells+0x802>
   return 1.0 / (float)(frequencies[1] - frequencies[0]) / (float)FFT_SIZE * idx;
 800d10e:	4bbb      	ldr	r3, [pc, #748]	; (800d3fc <draw_all_cells+0x128c>)
 800d110:	695b      	ldr	r3, [r3, #20]
 800d112:	9307      	str	r3, [sp, #28]
 800d114:	4bb9      	ldr	r3, [pc, #740]	; (800d3fc <draw_all_cells+0x128c>)
 800d116:	691b      	ldr	r3, [r3, #16]
 800d118:	930a      	str	r3, [sp, #40]	; 0x28
 800d11a:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 800d11c:	9b07      	ldr	r3, [sp, #28]
 800d11e:	1a98      	subs	r0, r3, r2
 800d120:	f7f4 faae 	bl	8001680 <__aeabi_ui2f>
 800d124:	f7f6 f95c 	bl	80033e0 <__aeabi_f2d>
 800d128:	0002      	movs	r2, r0
 800d12a:	000b      	movs	r3, r1
 800d12c:	2000      	movs	r0, #0
 800d12e:	49b4      	ldr	r1, [pc, #720]	; (800d400 <draw_all_cells+0x1290>)
 800d130:	f7f4 fe5e 	bl	8001df0 <__aeabi_ddiv>
 800d134:	2200      	movs	r2, #0
 800d136:	4bb3      	ldr	r3, [pc, #716]	; (800d404 <draw_all_cells+0x1294>)
 800d138:	f7f5 fa62 	bl	8002600 <__aeabi_dmul>
 800d13c:	9f13      	ldr	r7, [sp, #76]	; 0x4c
 800d13e:	0004      	movs	r4, r0
 800d140:	0038      	movs	r0, r7
 800d142:	000d      	movs	r5, r1
 800d144:	f7f6 f8d4 	bl	80032f0 <__aeabi_i2d>
 800d148:	0002      	movs	r2, r0
 800d14a:	000b      	movs	r3, r1
 800d14c:	0020      	movs	r0, r4
 800d14e:	0029      	movs	r1, r5
 800d150:	f7f5 fa56 	bl	8002600 <__aeabi_dmul>
 800d154:	f7f6 f99c 	bl	8003490 <__aeabi_d2f>
    int n = string_value_with_prefix(buf, sizeof buf, time_of_index(idx), 's');  
 800d158:	2373      	movs	r3, #115	; 0x73
   return 1.0 / (float)(frequencies[1] - frequencies[0]) / (float)FFT_SIZE * idx;
 800d15a:	1c02      	adds	r2, r0, #0
    int n = string_value_with_prefix(buf, sizeof buf, time_of_index(idx), 's');  
 800d15c:	2118      	movs	r1, #24
 800d15e:	a826      	add	r0, sp, #152	; 0x98
 800d160:	f7fe fb4e 	bl	800b800 <string_value_with_prefix>
    buf[n++] = ' ';
 800d164:	2110      	movs	r1, #16
 800d166:	2320      	movs	r3, #32
 800d168:	aa22      	add	r2, sp, #136	; 0x88
 800d16a:	1852      	adds	r2, r2, r1
 800d16c:	5413      	strb	r3, [r2, r0]
 800d16e:	1c46      	adds	r6, r0, #1
   float distance = ((float)idx * (float)SPEED_OF_LIGHT) / ( (float)(frequencies[1] - frequencies[0]) * (float)FFT_SIZE * 2.0);
 800d170:	0038      	movs	r0, r7
 800d172:	f7f4 fa35 	bl	80015e0 <__aeabi_i2f>
 800d176:	49a4      	ldr	r1, [pc, #656]	; (800d408 <draw_all_cells+0x1298>)
 800d178:	f7f3 ff3a 	bl	8000ff0 <__aeabi_fmul>
 800d17c:	f7f6 f930 	bl	80033e0 <__aeabi_f2d>
 800d180:	4b9e      	ldr	r3, [pc, #632]	; (800d3fc <draw_all_cells+0x128c>)
 800d182:	0004      	movs	r4, r0
 800d184:	695b      	ldr	r3, [r3, #20]
 800d186:	000d      	movs	r5, r1
 800d188:	9307      	str	r3, [sp, #28]
 800d18a:	4b9c      	ldr	r3, [pc, #624]	; (800d3fc <draw_all_cells+0x128c>)
 800d18c:	691b      	ldr	r3, [r3, #16]
 800d18e:	930a      	str	r3, [sp, #40]	; 0x28
 800d190:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 800d192:	9b07      	ldr	r3, [sp, #28]
 800d194:	1a98      	subs	r0, r3, r2
 800d196:	f7f4 fa73 	bl	8001680 <__aeabi_ui2f>
 800d19a:	2187      	movs	r1, #135	; 0x87
 800d19c:	05c9      	lsls	r1, r1, #23
 800d19e:	f7f3 ff27 	bl	8000ff0 <__aeabi_fmul>
 800d1a2:	f7f6 f91d 	bl	80033e0 <__aeabi_f2d>
 800d1a6:	0002      	movs	r2, r0
 800d1a8:	000b      	movs	r3, r1
 800d1aa:	f7f4 faa9 	bl	8001700 <__aeabi_dadd>
 800d1ae:	0002      	movs	r2, r0
 800d1b0:	000b      	movs	r3, r1
 800d1b2:	0020      	movs	r0, r4
 800d1b4:	0029      	movs	r1, r5
 800d1b6:	f7f4 fe1b 	bl	8001df0 <__aeabi_ddiv>
 800d1ba:	f7f6 f969 	bl	8003490 <__aeabi_d2f>
   return distance * (velocity_factor / 100.0);
 800d1be:	f7f6 f90f 	bl	80033e0 <__aeabi_f2d>
 800d1c2:	4b92      	ldr	r3, [pc, #584]	; (800d40c <draw_all_cells+0x129c>)
 800d1c4:	4a8d      	ldr	r2, [pc, #564]	; (800d3fc <draw_all_cells+0x128c>)
 800d1c6:	0004      	movs	r4, r0
 800d1c8:	5cd0      	ldrb	r0, [r2, r3]
 800d1ca:	000d      	movs	r5, r1
 800d1cc:	f7f6 f890 	bl	80032f0 <__aeabi_i2d>
 800d1d0:	2200      	movs	r2, #0
 800d1d2:	4b8f      	ldr	r3, [pc, #572]	; (800d410 <draw_all_cells+0x12a0>)
 800d1d4:	f7f4 fe0c 	bl	8001df0 <__aeabi_ddiv>
 800d1d8:	0002      	movs	r2, r0
 800d1da:	000b      	movs	r3, r1
 800d1dc:	0020      	movs	r0, r4
 800d1de:	0029      	movs	r1, r5
 800d1e0:	f7f5 fa0e 	bl	8002600 <__aeabi_dmul>
 800d1e4:	f7f6 f954 	bl	8003490 <__aeabi_d2f>
    string_value_with_prefix(&buf[n], sizeof buf-n, distance_of_index(idx), 'm');
 800d1e8:	2118      	movs	r1, #24
 800d1ea:	ab26      	add	r3, sp, #152	; 0x98
   return distance * (velocity_factor / 100.0);
 800d1ec:	1c02      	adds	r2, r0, #0
    string_value_with_prefix(&buf[n], sizeof buf-n, distance_of_index(idx), 'm');
 800d1ee:	1b89      	subs	r1, r1, r6
 800d1f0:	1998      	adds	r0, r3, r6
 800d1f2:	236d      	movs	r3, #109	; 0x6d
 800d1f4:	f7fe fb04 	bl	800b800 <string_value_with_prefix>
 800d1f8:	f7ff fa4c 	bl	800c694 <draw_all_cells+0x524>
     chsnprintf(buf, sizeof buf, "Edelay");
 800d1fc:	4a85      	ldr	r2, [pc, #532]	; (800d414 <draw_all_cells+0x12a4>)
 800d1fe:	2118      	movs	r1, #24
 800d200:	a826      	add	r0, sp, #152	; 0x98
 800d202:	f7fa f995 	bl	8007530 <chsnprintf>
  while (*str) {
 800d206:	ab22      	add	r3, sp, #136	; 0x88
 800d208:	7c1a      	ldrb	r2, [r3, #16]
 800d20a:	9c21      	ldr	r4, [sp, #132]	; 0x84
 800d20c:	ad26      	add	r5, sp, #152	; 0x98
 800d20e:	2a00      	cmp	r2, #0
 800d210:	d00f      	beq.n	800d232 <draw_all_cells+0x10c2>
    cell_drawchar_7x13(w, h, *str, x, y, fg, FALSE);
 800d212:	2700      	movs	r7, #0
 800d214:	4e80      	ldr	r6, [pc, #512]	; (800d418 <draw_all_cells+0x12a8>)
 800d216:	464b      	mov	r3, r9
 800d218:	9702      	str	r7, [sp, #8]
 800d21a:	9300      	str	r3, [sp, #0]
 800d21c:	9601      	str	r6, [sp, #4]
 800d21e:	0023      	movs	r3, r4
 800d220:	4651      	mov	r1, sl
 800d222:	4658      	mov	r0, fp
    str++;
 800d224:	3501      	adds	r5, #1
    cell_drawchar_7x13(w, h, *str, x, y, fg, FALSE);
 800d226:	f7fe fd3b 	bl	800bca0 <cell_drawchar_7x13>
  while (*str) {
 800d22a:	782a      	ldrb	r2, [r5, #0]
    x += 7;
 800d22c:	3407      	adds	r4, #7
  while (*str) {
 800d22e:	2a00      	cmp	r2, #0
 800d230:	d1f1      	bne.n	800d216 <draw_all_cells+0x10a6>
     int n = string_value_with_prefix(buf, sizeof buf, electrical_delay * 1e-12, 's');
 800d232:	4a72      	ldr	r2, [pc, #456]	; (800d3fc <draw_all_cells+0x128c>)
 800d234:	4b79      	ldr	r3, [pc, #484]	; (800d41c <draw_all_cells+0x12ac>)
  while (*str) {
 800d236:	ad26      	add	r5, sp, #152	; 0x98
     int n = string_value_with_prefix(buf, sizeof buf, electrical_delay * 1e-12, 's');
 800d238:	58d0      	ldr	r0, [r2, r3]
 800d23a:	f7f6 f8d1 	bl	80033e0 <__aeabi_f2d>
 800d23e:	4a78      	ldr	r2, [pc, #480]	; (800d420 <draw_all_cells+0x12b0>)
 800d240:	4b78      	ldr	r3, [pc, #480]	; (800d424 <draw_all_cells+0x12b4>)
 800d242:	f7f5 f9dd 	bl	8002600 <__aeabi_dmul>
 800d246:	f7f6 f923 	bl	8003490 <__aeabi_d2f>
 800d24a:	2373      	movs	r3, #115	; 0x73
 800d24c:	1c02      	adds	r2, r0, #0
 800d24e:	2118      	movs	r1, #24
 800d250:	a826      	add	r0, sp, #152	; 0x98
 800d252:	f7fe fad5 	bl	800b800 <string_value_with_prefix>
  while (*str) {
 800d256:	ab22      	add	r3, sp, #136	; 0x88
 800d258:	7c1a      	ldrb	r2, [r3, #16]
     int n = string_value_with_prefix(buf, sizeof buf, electrical_delay * 1e-12, 's');
 800d25a:	4680      	mov	r8, r0
  while (*str) {
 800d25c:	9c20      	ldr	r4, [sp, #128]	; 0x80
 800d25e:	2a00      	cmp	r2, #0
 800d260:	d00f      	beq.n	800d282 <draw_all_cells+0x1112>
    cell_drawchar_7x13(w, h, *str, x, y, fg, FALSE);
 800d262:	2700      	movs	r7, #0
 800d264:	4e6c      	ldr	r6, [pc, #432]	; (800d418 <draw_all_cells+0x12a8>)
 800d266:	464b      	mov	r3, r9
 800d268:	9702      	str	r7, [sp, #8]
 800d26a:	9300      	str	r3, [sp, #0]
 800d26c:	9601      	str	r6, [sp, #4]
 800d26e:	0023      	movs	r3, r4
 800d270:	4651      	mov	r1, sl
 800d272:	4658      	mov	r0, fp
    str++;
 800d274:	3501      	adds	r5, #1
    cell_drawchar_7x13(w, h, *str, x, y, fg, FALSE);
 800d276:	f7fe fd13 	bl	800bca0 <cell_drawchar_7x13>
  while (*str) {
 800d27a:	782a      	ldrb	r2, [r5, #0]
    x += 7;
 800d27c:	3407      	adds	r4, #7
  while (*str) {
 800d27e:	2a00      	cmp	r2, #0
 800d280:	d1f1      	bne.n	800d266 <draw_all_cells+0x10f6>
     xpos += n * 7 + 5;
 800d282:	4643      	mov	r3, r8
 800d284:	00dc      	lsls	r4, r3, #3
 800d286:	1ae4      	subs	r4, r4, r3
 800d288:	9b20      	ldr	r3, [sp, #128]	; 0x80
     string_value_with_prefix(buf, sizeof buf, electrical_delay * light_speed_ps * velocity_factor / 100.0, 'm');
 800d28a:	4a5c      	ldr	r2, [pc, #368]	; (800d3fc <draw_all_cells+0x128c>)
     xpos += n * 7 + 5;
 800d28c:	469c      	mov	ip, r3
     string_value_with_prefix(buf, sizeof buf, electrical_delay * light_speed_ps * velocity_factor / 100.0, 'm');
 800d28e:	4b63      	ldr	r3, [pc, #396]	; (800d41c <draw_all_cells+0x12ac>)
 800d290:	4965      	ldr	r1, [pc, #404]	; (800d428 <draw_all_cells+0x12b8>)
 800d292:	58d0      	ldr	r0, [r2, r3]
     xpos += n * 7 + 5;
 800d294:	3405      	adds	r4, #5
 800d296:	4464      	add	r4, ip
     string_value_with_prefix(buf, sizeof buf, electrical_delay * light_speed_ps * velocity_factor / 100.0, 'm');
 800d298:	f7f3 feaa 	bl	8000ff0 <__aeabi_fmul>
 800d29c:	4a57      	ldr	r2, [pc, #348]	; (800d3fc <draw_all_cells+0x128c>)
 800d29e:	4b5b      	ldr	r3, [pc, #364]	; (800d40c <draw_all_cells+0x129c>)
 800d2a0:	1c05      	adds	r5, r0, #0
 800d2a2:	5cd0      	ldrb	r0, [r2, r3]
 800d2a4:	f7f4 f99c 	bl	80015e0 <__aeabi_i2f>
 800d2a8:	1c01      	adds	r1, r0, #0
 800d2aa:	1c28      	adds	r0, r5, #0
 800d2ac:	f7f3 fea0 	bl	8000ff0 <__aeabi_fmul>
 800d2b0:	495e      	ldr	r1, [pc, #376]	; (800d42c <draw_all_cells+0x12bc>)
 800d2b2:	f7f3 fcbd 	bl	8000c30 <__aeabi_fdiv>
 800d2b6:	236d      	movs	r3, #109	; 0x6d
 800d2b8:	1c02      	adds	r2, r0, #0
 800d2ba:	2118      	movs	r1, #24
 800d2bc:	a826      	add	r0, sp, #152	; 0x98
 800d2be:	f7fe fa9f 	bl	800b800 <string_value_with_prefix>
  while (*str) {
 800d2c2:	ab22      	add	r3, sp, #136	; 0x88
 800d2c4:	7c1a      	ldrb	r2, [r3, #16]
 800d2c6:	ad26      	add	r5, sp, #152	; 0x98
 800d2c8:	2a00      	cmp	r2, #0
 800d2ca:	d101      	bne.n	800d2d0 <draw_all_cells+0x1160>
 800d2cc:	f7ff f9b0 	bl	800c630 <draw_all_cells+0x4c0>
    cell_drawchar_7x13(w, h, *str, x, y, fg, FALSE);
 800d2d0:	2700      	movs	r7, #0
 800d2d2:	4e51      	ldr	r6, [pc, #324]	; (800d418 <draw_all_cells+0x12a8>)
 800d2d4:	464b      	mov	r3, r9
 800d2d6:	9702      	str	r7, [sp, #8]
 800d2d8:	9300      	str	r3, [sp, #0]
 800d2da:	9601      	str	r6, [sp, #4]
 800d2dc:	0023      	movs	r3, r4
 800d2de:	4651      	mov	r1, sl
 800d2e0:	4658      	mov	r0, fp
    str++;
 800d2e2:	3501      	adds	r5, #1
    cell_drawchar_7x13(w, h, *str, x, y, fg, FALSE);
 800d2e4:	f7fe fcdc 	bl	800bca0 <cell_drawchar_7x13>
  while (*str) {
 800d2e8:	782a      	ldrb	r2, [r5, #0]
    x += 7;
 800d2ea:	3407      	adds	r4, #7
  while (*str) {
 800d2ec:	2a00      	cmp	r2, #0
 800d2ee:	d1f1      	bne.n	800d2d4 <draw_all_cells+0x1164>
 800d2f0:	f7ff f99e 	bl	800c630 <draw_all_cells+0x4c0>
        i0--;
 800d2f4:	17eb      	asrs	r3, r5, #31
 800d2f6:	1b5b      	subs	r3, r3, r5
 800d2f8:	0fdb      	lsrs	r3, r3, #31
 800d2fa:	1aed      	subs	r5, r5, r3
        i1++;
 800d2fc:	0014      	movs	r4, r2
 800d2fe:	f7ff fb80 	bl	800ca02 <draw_all_cells+0x892>
    int idx0 = markers[previous_marker].index;
 800d302:	493e      	ldr	r1, [pc, #248]	; (800d3fc <draw_all_cells+0x128c>)
    chsnprintf(buf, sizeof buf, "D%d:", previous_marker+1);
 800d304:	3301      	adds	r3, #1
    int idx0 = markers[previous_marker].index;
 800d306:	468c      	mov	ip, r1
 800d308:	4462      	add	r2, ip
 800d30a:	2102      	movs	r1, #2
 800d30c:	5e52      	ldrsh	r2, [r2, r1]
 800d30e:	210e      	movs	r1, #14
 800d310:	468c      	mov	ip, r1
 800d312:	9207      	str	r2, [sp, #28]
    ypos += 13;
 800d314:	9a15      	ldr	r2, [sp, #84]	; 0x54
    chsnprintf(buf, sizeof buf, "D%d:", previous_marker+1);
 800d316:	310a      	adds	r1, #10
 800d318:	4462      	add	r2, ip
 800d31a:	4690      	mov	r8, r2
 800d31c:	a826      	add	r0, sp, #152	; 0x98
 800d31e:	4a44      	ldr	r2, [pc, #272]	; (800d430 <draw_all_cells+0x12c0>)
 800d320:	f7fa f906 	bl	8007530 <chsnprintf>
  while (*str) {
 800d324:	ab22      	add	r3, sp, #136	; 0x88
 800d326:	7c1a      	ldrb	r2, [r3, #16]
 800d328:	9c23      	ldr	r4, [sp, #140]	; 0x8c
 800d32a:	ad26      	add	r5, sp, #152	; 0x98
 800d32c:	2a00      	cmp	r2, #0
 800d32e:	d00f      	beq.n	800d350 <draw_all_cells+0x11e0>
    cell_drawchar_7x13(w, h, *str, x, y, fg, FALSE);
 800d330:	2700      	movs	r7, #0
 800d332:	4e39      	ldr	r6, [pc, #228]	; (800d418 <draw_all_cells+0x12a8>)
 800d334:	4643      	mov	r3, r8
 800d336:	9702      	str	r7, [sp, #8]
 800d338:	9300      	str	r3, [sp, #0]
 800d33a:	9601      	str	r6, [sp, #4]
 800d33c:	0023      	movs	r3, r4
 800d33e:	4651      	mov	r1, sl
 800d340:	4658      	mov	r0, fp
    str++;
 800d342:	3501      	adds	r5, #1
    cell_drawchar_7x13(w, h, *str, x, y, fg, FALSE);
 800d344:	f7fe fcac 	bl	800bca0 <cell_drawchar_7x13>
  while (*str) {
 800d348:	782a      	ldrb	r2, [r5, #0]
    x += 7;
 800d34a:	3407      	adds	r4, #7
  while (*str) {
 800d34c:	2a00      	cmp	r2, #0
 800d34e:	d1f1      	bne.n	800d334 <draw_all_cells+0x11c4>
	    if ((domain_mode & DOMAIN_MODE) == DOMAIN_FREQ) {
 800d350:	4b38      	ldr	r3, [pc, #224]	; (800d434 <draw_all_cells+0x12c4>)
 800d352:	4a2a      	ldr	r2, [pc, #168]	; (800d3fc <draw_all_cells+0x128c>)
 800d354:	5cd3      	ldrb	r3, [r2, r3]
 800d356:	07db      	lsls	r3, r3, #31
 800d358:	d472      	bmi.n	800d440 <draw_all_cells+0x12d0>
      frequency_string(buf, sizeof buf, frequencies[idx] - frequencies[idx0]);
 800d35a:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 800d35c:	9b07      	ldr	r3, [sp, #28]
 800d35e:	4927      	ldr	r1, [pc, #156]	; (800d3fc <draw_all_cells+0x128c>)
 800d360:	3204      	adds	r2, #4
 800d362:	3304      	adds	r3, #4
 800d364:	0092      	lsls	r2, r2, #2
 800d366:	009b      	lsls	r3, r3, #2
 800d368:	588a      	ldr	r2, [r1, r2]
 800d36a:	58cb      	ldr	r3, [r1, r3]
 800d36c:	a826      	add	r0, sp, #152	; 0x98
 800d36e:	1ad2      	subs	r2, r2, r3
 800d370:	2118      	movs	r1, #24
 800d372:	f7fe fb45 	bl	800ba00 <frequency_string>
  while (*str) {
 800d376:	ab22      	add	r3, sp, #136	; 0x88
 800d378:	7c1a      	ldrb	r2, [r3, #16]
 800d37a:	2a00      	cmp	r2, #0
 800d37c:	d101      	bne.n	800d382 <draw_all_cells+0x1212>
 800d37e:	f7ff f9b5 	bl	800c6ec <draw_all_cells+0x57c>
    cell_drawchar_7x13(w, h, *str, x, y, fg, FALSE);
 800d382:	2700      	movs	r7, #0
  while (*str) {
 800d384:	9d1e      	ldr	r5, [sp, #120]	; 0x78
    cell_drawchar_7x13(w, h, *str, x, y, fg, FALSE);
 800d386:	4e24      	ldr	r6, [pc, #144]	; (800d418 <draw_all_cells+0x12a8>)
  while (*str) {
 800d388:	ac26      	add	r4, sp, #152	; 0x98
    cell_drawchar_7x13(w, h, *str, x, y, fg, FALSE);
 800d38a:	4643      	mov	r3, r8
 800d38c:	9702      	str	r7, [sp, #8]
 800d38e:	9300      	str	r3, [sp, #0]
 800d390:	9601      	str	r6, [sp, #4]
 800d392:	002b      	movs	r3, r5
 800d394:	4651      	mov	r1, sl
 800d396:	4658      	mov	r0, fp
    str++;
 800d398:	3401      	adds	r4, #1
    cell_drawchar_7x13(w, h, *str, x, y, fg, FALSE);
 800d39a:	f7fe fc81 	bl	800bca0 <cell_drawchar_7x13>
  while (*str) {
 800d39e:	7822      	ldrb	r2, [r4, #0]
    x += 7;
 800d3a0:	3507      	adds	r5, #7
  while (*str) {
 800d3a2:	2a00      	cmp	r2, #0
 800d3a4:	d1f1      	bne.n	800d38a <draw_all_cells+0x121a>
 800d3a6:	f7ff f9a1 	bl	800c6ec <draw_all_cells+0x57c>
        idx, measured[trace[t].channel], frequencies, sweep_points);
 800d3aa:	464b      	mov	r3, r9
 800d3ac:	26ca      	movs	r6, #202	; 0xca
 800d3ae:	7898      	ldrb	r0, [r3, #2]
 800d3b0:	00b6      	lsls	r6, r6, #2
 800d3b2:	4346      	muls	r6, r0
  switch (trace[t].type) {
 800d3b4:	785b      	ldrb	r3, [r3, #1]
        idx, measured[trace[t].channel], frequencies, sweep_points);
 800d3b6:	4820      	ldr	r0, [pc, #128]	; (800d438 <draw_all_cells+0x12c8>)
 800d3b8:	1836      	adds	r6, r6, r0
  switch (trace[t].type) {
 800d3ba:	2b0a      	cmp	r3, #10
 800d3bc:	d900      	bls.n	800d3c0 <draw_all_cells+0x1250>
 800d3be:	e49c      	b.n	800ccfa <draw_all_cells+0xb8a>
 800d3c0:	4a1e      	ldr	r2, [pc, #120]	; (800d43c <draw_all_cells+0x12cc>)
 800d3c2:	009b      	lsls	r3, r3, #2
 800d3c4:	58d3      	ldr	r3, [r2, r3]
 800d3c6:	469f      	mov	pc, r3
  if (x != CELL_X0(index[i]))
 800d3c8:	4643      	mov	r3, r8
 800d3ca:	681b      	ldr	r3, [r3, #0]
 800d3cc:	0d9b      	lsrs	r3, r3, #22
 800d3ce:	4033      	ands	r3, r6
 800d3d0:	429f      	cmp	r7, r3
 800d3d2:	d001      	beq.n	800d3d8 <draw_all_cells+0x1268>
 800d3d4:	f7ff f8a5 	bl	800c522 <draw_all_cells+0x3b2>
  while (j < 100 && x == CELL_X0(index[j+1]))
 800d3d8:	4643      	mov	r3, r8
 800d3da:	685b      	ldr	r3, [r3, #4]
  i = 0;
 800d3dc:	2500      	movs	r5, #0
  while (j < 100 && x == CELL_X0(index[j+1]))
 800d3de:	0d9b      	lsrs	r3, r3, #22
 800d3e0:	4033      	ands	r3, r6
 800d3e2:	2201      	movs	r2, #1
 800d3e4:	429f      	cmp	r7, r3
 800d3e6:	d189      	bne.n	800d2fc <draw_all_cells+0x118c>
  i = 0;
 800d3e8:	2400      	movs	r4, #0
 800d3ea:	2201      	movs	r2, #1
 800d3ec:	f7ff faf7 	bl	800c9de <draw_all_cells+0x86e>
  while (j > 0 && x == CELL_X0(index[j-1]))
 800d3f0:	0025      	movs	r5, r4
 800d3f2:	f7ff fae8 	bl	800c9c6 <draw_all_cells+0x856>
 800d3f6:	46c0      	nop			; (mov r8, r8)
 800d3f8:	20000436 	.word	0x20000436
 800d3fc:	20000454 	.word	0x20000454
 800d400:	3ff00000 	.word	0x3ff00000
 800d404:	3f700000 	.word	0x3f700000
 800d408:	4d8ef3c2 	.word	0x4d8ef3c2
 800d40c:	000011c5 	.word	0x000011c5
 800d410:	40590000 	.word	0x40590000
 800d414:	080149f0 	.word	0x080149f0
 800d418:	0000ffff 	.word	0x0000ffff
 800d41c:	0000116c 	.word	0x0000116c
 800d420:	812dea11 	.word	0x812dea11
 800d424:	3d719799 	.word	0x3d719799
 800d428:	399d2d76 	.word	0x399d2d76
 800d42c:	42c80000 	.word	0x42c80000
 800d430:	080149f8 	.word	0x080149f8
 800d434:	000011c4 	.word	0x000011c4
 800d438:	20001bbc 	.word	0x20001bbc
 800d43c:	08014958 	.word	0x08014958
   return 1.0 / (float)(frequencies[1] - frequencies[0]) / (float)FFT_SIZE * idx;
 800d440:	4b98      	ldr	r3, [pc, #608]	; (800d6a4 <draw_all_cells+0x1534>)
 800d442:	695b      	ldr	r3, [r3, #20]
 800d444:	930a      	str	r3, [sp, #40]	; 0x28
 800d446:	4b97      	ldr	r3, [pc, #604]	; (800d6a4 <draw_all_cells+0x1534>)
 800d448:	691b      	ldr	r3, [r3, #16]
 800d44a:	930d      	str	r3, [sp, #52]	; 0x34
 800d44c:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 800d44e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800d450:	1a98      	subs	r0, r3, r2
 800d452:	f7f4 f915 	bl	8001680 <__aeabi_ui2f>
 800d456:	f7f5 ffc3 	bl	80033e0 <__aeabi_f2d>
 800d45a:	0002      	movs	r2, r0
 800d45c:	000b      	movs	r3, r1
 800d45e:	2000      	movs	r0, #0
 800d460:	4991      	ldr	r1, [pc, #580]	; (800d6a8 <draw_all_cells+0x1538>)
 800d462:	f7f4 fcc5 	bl	8001df0 <__aeabi_ddiv>
 800d466:	2200      	movs	r2, #0
 800d468:	4b90      	ldr	r3, [pc, #576]	; (800d6ac <draw_all_cells+0x153c>)
 800d46a:	f7f5 f8c9 	bl	8002600 <__aeabi_dmul>
 800d46e:	0006      	movs	r6, r0
 800d470:	000f      	movs	r7, r1
 800d472:	9813      	ldr	r0, [sp, #76]	; 0x4c
 800d474:	f7f5 ff3c 	bl	80032f0 <__aeabi_i2d>
 800d478:	0032      	movs	r2, r6
 800d47a:	003b      	movs	r3, r7
 800d47c:	f7f5 f8c0 	bl	8002600 <__aeabi_dmul>
 800d480:	f7f6 f806 	bl	8003490 <__aeabi_d2f>
 800d484:	1c04      	adds	r4, r0, #0
 800d486:	9807      	ldr	r0, [sp, #28]
 800d488:	f7f5 ff32 	bl	80032f0 <__aeabi_i2d>
 800d48c:	0032      	movs	r2, r6
 800d48e:	003b      	movs	r3, r7
 800d490:	f7f5 f8b6 	bl	8002600 <__aeabi_dmul>
 800d494:	f7f5 fffc 	bl	8003490 <__aeabi_d2f>
 800d498:	1c01      	adds	r1, r0, #0
      int n = string_value_with_prefix(buf, sizeof buf, time_of_index(idx) - time_of_index(idx0), 's');
 800d49a:	1c20      	adds	r0, r4, #0
 800d49c:	f7f3 fec0 	bl	8001220 <__aeabi_fsub>
 800d4a0:	ac26      	add	r4, sp, #152	; 0x98
 800d4a2:	1c02      	adds	r2, r0, #0
 800d4a4:	2373      	movs	r3, #115	; 0x73
 800d4a6:	2118      	movs	r1, #24
 800d4a8:	0020      	movs	r0, r4
 800d4aa:	f7fe f9a9 	bl	800b800 <string_value_with_prefix>
      buf[n++] = ' ';
 800d4ae:	2110      	movs	r1, #16
 800d4b0:	2320      	movs	r3, #32
 800d4b2:	aa22      	add	r2, sp, #136	; 0x88
 800d4b4:	1852      	adds	r2, r2, r1
 800d4b6:	5413      	strb	r3, [r2, r0]
 800d4b8:	1c43      	adds	r3, r0, #1
 800d4ba:	4699      	mov	r9, r3
   float distance = ((float)idx * (float)SPEED_OF_LIGHT) / ( (float)(frequencies[1] - frequencies[0]) * (float)FFT_SIZE * 2.0);
 800d4bc:	4b79      	ldr	r3, [pc, #484]	; (800d6a4 <draw_all_cells+0x1534>)
 800d4be:	695b      	ldr	r3, [r3, #20]
 800d4c0:	930a      	str	r3, [sp, #40]	; 0x28
 800d4c2:	4b78      	ldr	r3, [pc, #480]	; (800d6a4 <draw_all_cells+0x1534>)
 800d4c4:	691b      	ldr	r3, [r3, #16]
 800d4c6:	930d      	str	r3, [sp, #52]	; 0x34
 800d4c8:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 800d4ca:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800d4cc:	1a98      	subs	r0, r3, r2
 800d4ce:	f7f4 f8d7 	bl	8001680 <__aeabi_ui2f>
 800d4d2:	2187      	movs	r1, #135	; 0x87
 800d4d4:	05c9      	lsls	r1, r1, #23
 800d4d6:	f7f3 fd8b 	bl	8000ff0 <__aeabi_fmul>
 800d4da:	f7f5 ff81 	bl	80033e0 <__aeabi_f2d>
 800d4de:	0002      	movs	r2, r0
 800d4e0:	000b      	movs	r3, r1
 800d4e2:	f7f4 f90d 	bl	8001700 <__aeabi_dadd>
   return distance * (velocity_factor / 100.0);
 800d4e6:	4a6f      	ldr	r2, [pc, #444]	; (800d6a4 <draw_all_cells+0x1534>)
 800d4e8:	4b71      	ldr	r3, [pc, #452]	; (800d6b0 <draw_all_cells+0x1540>)
   float distance = ((float)idx * (float)SPEED_OF_LIGHT) / ( (float)(frequencies[1] - frequencies[0]) * (float)FFT_SIZE * 2.0);
 800d4ea:	0006      	movs	r6, r0
   return distance * (velocity_factor / 100.0);
 800d4ec:	5cd0      	ldrb	r0, [r2, r3]
   float distance = ((float)idx * (float)SPEED_OF_LIGHT) / ( (float)(frequencies[1] - frequencies[0]) * (float)FFT_SIZE * 2.0);
 800d4ee:	000f      	movs	r7, r1
   return distance * (velocity_factor / 100.0);
 800d4f0:	f7f5 fefe 	bl	80032f0 <__aeabi_i2d>
 800d4f4:	2200      	movs	r2, #0
 800d4f6:	4b6f      	ldr	r3, [pc, #444]	; (800d6b4 <draw_all_cells+0x1544>)
 800d4f8:	f7f4 fc7a 	bl	8001df0 <__aeabi_ddiv>
 800d4fc:	000d      	movs	r5, r1
 800d4fe:	0004      	movs	r4, r0
   float distance = ((float)idx * (float)SPEED_OF_LIGHT) / ( (float)(frequencies[1] - frequencies[0]) * (float)FFT_SIZE * 2.0);
 800d500:	9813      	ldr	r0, [sp, #76]	; 0x4c
 800d502:	f7f4 f86d 	bl	80015e0 <__aeabi_i2f>
 800d506:	496c      	ldr	r1, [pc, #432]	; (800d6b8 <draw_all_cells+0x1548>)
 800d508:	f7f3 fd72 	bl	8000ff0 <__aeabi_fmul>
 800d50c:	f7f5 ff68 	bl	80033e0 <__aeabi_f2d>
 800d510:	0032      	movs	r2, r6
 800d512:	003b      	movs	r3, r7
 800d514:	f7f4 fc6c 	bl	8001df0 <__aeabi_ddiv>
 800d518:	f7f5 ffba 	bl	8003490 <__aeabi_d2f>
   return distance * (velocity_factor / 100.0);
 800d51c:	f7f5 ff60 	bl	80033e0 <__aeabi_f2d>
 800d520:	0022      	movs	r2, r4
 800d522:	002b      	movs	r3, r5
 800d524:	f7f5 f86c 	bl	8002600 <__aeabi_dmul>
 800d528:	f7f5 ffb2 	bl	8003490 <__aeabi_d2f>
 800d52c:	900a      	str	r0, [sp, #40]	; 0x28
   float distance = ((float)idx * (float)SPEED_OF_LIGHT) / ( (float)(frequencies[1] - frequencies[0]) * (float)FFT_SIZE * 2.0);
 800d52e:	9807      	ldr	r0, [sp, #28]
 800d530:	f7f4 f856 	bl	80015e0 <__aeabi_i2f>
 800d534:	4960      	ldr	r1, [pc, #384]	; (800d6b8 <draw_all_cells+0x1548>)
 800d536:	f7f3 fd5b 	bl	8000ff0 <__aeabi_fmul>
 800d53a:	f7f5 ff51 	bl	80033e0 <__aeabi_f2d>
 800d53e:	0032      	movs	r2, r6
 800d540:	003b      	movs	r3, r7
 800d542:	f7f4 fc55 	bl	8001df0 <__aeabi_ddiv>
 800d546:	f7f5 ffa3 	bl	8003490 <__aeabi_d2f>
   return distance * (velocity_factor / 100.0);
 800d54a:	f7f5 ff49 	bl	80033e0 <__aeabi_f2d>
 800d54e:	0022      	movs	r2, r4
 800d550:	002b      	movs	r3, r5
 800d552:	f7f5 f855 	bl	8002600 <__aeabi_dmul>
 800d556:	f7f5 ff9b 	bl	8003490 <__aeabi_d2f>
 800d55a:	1c01      	adds	r1, r0, #0
      string_value_with_prefix(&buf[n], sizeof buf - n, distance_of_index(idx) - distance_of_index(idx0), 'm');
 800d55c:	980a      	ldr	r0, [sp, #40]	; 0x28
 800d55e:	f7f3 fe5f 	bl	8001220 <__aeabi_fsub>
 800d562:	464b      	mov	r3, r9
 800d564:	2118      	movs	r1, #24
 800d566:	1c02      	adds	r2, r0, #0
 800d568:	a826      	add	r0, sp, #152	; 0x98
 800d56a:	1ac9      	subs	r1, r1, r3
 800d56c:	4448      	add	r0, r9
 800d56e:	236d      	movs	r3, #109	; 0x6d
 800d570:	f7fe f946 	bl	800b800 <string_value_with_prefix>
 800d574:	e6ff      	b.n	800d376 <draw_all_cells+0x1206>
      chsnprintf(buf, len, "%.2fdB", v);
 800d576:	1c30      	adds	r0, r6, #0
 800d578:	f7f5 ff32 	bl	80033e0 <__aeabi_f2d>
 800d57c:	4a4f      	ldr	r2, [pc, #316]	; (800d6bc <draw_all_cells+0x154c>)
 800d57e:	9000      	str	r0, [sp, #0]
 800d580:	9101      	str	r1, [sp, #4]
 800d582:	2118      	movs	r1, #24
 800d584:	a826      	add	r0, sp, #152	; 0x98
 800d586:	f7f9 ffd3 	bl	8007530 <chsnprintf>
 800d58a:	f7ff fb9a 	bl	800ccc2 <draw_all_cells+0xb52>
    float c = -1 / (PI2 * frequency * zi);
 800d58e:	980a      	ldr	r0, [sp, #40]	; 0x28
 800d590:	f7f5 feee 	bl	8003370 <__aeabi_ui2d>
 800d594:	4a4a      	ldr	r2, [pc, #296]	; (800d6c0 <draw_all_cells+0x1550>)
 800d596:	4b4b      	ldr	r3, [pc, #300]	; (800d6c4 <draw_all_cells+0x1554>)
 800d598:	f7f5 f832 	bl	8002600 <__aeabi_dmul>
 800d59c:	900a      	str	r0, [sp, #40]	; 0x28
 800d59e:	910b      	str	r1, [sp, #44]	; 0x2c
 800d5a0:	1c30      	adds	r0, r6, #0
 800d5a2:	f7f5 ff1d 	bl	80033e0 <__aeabi_f2d>
 800d5a6:	0002      	movs	r2, r0
 800d5a8:	000b      	movs	r3, r1
 800d5aa:	980a      	ldr	r0, [sp, #40]	; 0x28
 800d5ac:	990b      	ldr	r1, [sp, #44]	; 0x2c
 800d5ae:	f7f5 f827 	bl	8002600 <__aeabi_dmul>
 800d5b2:	0002      	movs	r2, r0
 800d5b4:	000b      	movs	r3, r1
 800d5b6:	2000      	movs	r0, #0
 800d5b8:	4943      	ldr	r1, [pc, #268]	; (800d6c8 <draw_all_cells+0x1558>)
 800d5ba:	f7f4 fc19 	bl	8001df0 <__aeabi_ddiv>
 800d5be:	f7f5 ff67 	bl	8003490 <__aeabi_d2f>
    string_value_with_prefix(buf+n, len-n, c, 'F');
 800d5c2:	4643      	mov	r3, r8
 800d5c4:	2118      	movs	r1, #24
    float c = -1 / (PI2 * frequency * zi);
 800d5c6:	1c02      	adds	r2, r0, #0
    string_value_with_prefix(buf+n, len-n, c, 'F');
 800d5c8:	a826      	add	r0, sp, #152	; 0x98
 800d5ca:	1ac9      	subs	r1, r1, r3
 800d5cc:	4440      	add	r0, r8
 800d5ce:	2346      	movs	r3, #70	; 0x46
 800d5d0:	f7fe f916 	bl	800b800 <string_value_with_prefix>
 800d5d4:	f7ff fb75 	bl	800ccc2 <draw_all_cells+0xb52>
  if (y < -3 || y > 32 + 3)
 800d5d8:	1cc3      	adds	r3, r0, #3
 800d5da:	2b26      	cmp	r3, #38	; 0x26
 800d5dc:	d900      	bls.n	800d5e0 <draw_all_cells+0x1470>
 800d5de:	e516      	b.n	800d00e <draw_all_cells+0xe9e>
      draw_refpos(w, h, x, y, config.trace_color[t]);
 800d5e0:	4a3a      	ldr	r2, [pc, #232]	; (800d6cc <draw_all_cells+0x155c>)
 800d5e2:	0063      	lsls	r3, r4, #1
 800d5e4:	5ad3      	ldrh	r3, [r2, r3]
 800d5e6:	991a      	ldr	r1, [sp, #104]	; 0x68
 800d5e8:	9310      	str	r3, [sp, #64]	; 0x40
 800d5ea:	465b      	mov	r3, fp
 800d5ec:	468c      	mov	ip, r1
 800d5ee:	4343      	muls	r3, r0
 800d5f0:	1d9a      	adds	r2, r3, #6
 800d5f2:	0052      	lsls	r2, r2, #1
 800d5f4:	4494      	add	ip, r2
 800d5f6:	464a      	mov	r2, r9
 800d5f8:	4667      	mov	r7, ip
 800d5fa:	009b      	lsls	r3, r3, #2
 800d5fc:	468c      	mov	ip, r1
  for (j = 0; j < 3; j++) {
 800d5fe:	0026      	movs	r6, r4
 800d600:	930f      	str	r3, [sp, #60]	; 0x3c
 800d602:	002b      	movs	r3, r5
 800d604:	4342      	muls	r2, r0
 800d606:	920a      	str	r2, [sp, #40]	; 0x28
 800d608:	9a05      	ldr	r2, [sp, #20]
 800d60a:	4654      	mov	r4, sl
 800d60c:	4342      	muls	r2, r0
 800d60e:	4462      	add	r2, ip
 800d610:	920d      	str	r2, [sp, #52]	; 0x34
 800d612:	003d      	movs	r5, r7
      draw_refpos(w, h, x, y, config.trace_color[t]);
 800d614:	0001      	movs	r1, r0
  for (j = 0; j < 3; j++) {
 800d616:	2200      	movs	r2, #0
 800d618:	001f      	movs	r7, r3
 800d61a:	46b2      	mov	sl, r6
    for (i = 0; i < j0; i++) {
 800d61c:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
  for (j = 0; j < 3; j++) {
 800d61e:	970e      	str	r7, [sp, #56]	; 0x38
 800d620:	001e      	movs	r6, r3
 800d622:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800d624:	9007      	str	r0, [sp, #28]
 800d626:	469c      	mov	ip, r3
 800d628:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800d62a:	4466      	add	r6, ip
      if (y0 >= 0 && y0 < h && x0 >= 0 && x0 < w)
 800d62c:	42a1      	cmp	r1, r4
 800d62e:	d205      	bcs.n	800d63c <draw_all_cells+0x14cc>
        spi_buffer[y0*w+x0] = c;
 800d630:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 800d632:	9810      	ldr	r0, [sp, #64]	; 0x40
 800d634:	46bc      	mov	ip, r7
 800d636:	449c      	add	ip, r3
 800d638:	4667      	mov	r7, ip
 800d63a:	53b8      	strh	r0, [r7, r6]
      if (j != 0 && y1 >= 0 && y1 < h && x0 >= 0 && x0 < w)
 800d63c:	2a00      	cmp	r2, #0
 800d63e:	d004      	beq.n	800d64a <draw_all_cells+0x14da>
 800d640:	9807      	ldr	r0, [sp, #28]
 800d642:	42a0      	cmp	r0, r4
 800d644:	d201      	bcs.n	800d64a <draw_all_cells+0x14da>
        spi_buffer[y1*w+x0] = c;
 800d646:	9810      	ldr	r0, [sp, #64]	; 0x40
 800d648:	8018      	strh	r0, [r3, #0]
 800d64a:	3302      	adds	r3, #2
    for (i = 0; i < j0; i++) {
 800d64c:	429d      	cmp	r5, r3
 800d64e:	d1ed      	bne.n	800d62c <draw_all_cells+0x14bc>
 800d650:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800d652:	9807      	ldr	r0, [sp, #28]
 800d654:	444b      	add	r3, r9
 800d656:	930a      	str	r3, [sp, #40]	; 0x28
 800d658:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  for (j = 0; j < 3; j++) {
 800d65a:	3201      	adds	r2, #1
 800d65c:	001e      	movs	r6, r3
 800d65e:	9b05      	ldr	r3, [sp, #20]
 800d660:	9f0e      	ldr	r7, [sp, #56]	; 0x38
 800d662:	469c      	mov	ip, r3
 800d664:	4466      	add	r6, ip
 800d666:	4445      	add	r5, r8
 800d668:	3001      	adds	r0, #1
 800d66a:	960d      	str	r6, [sp, #52]	; 0x34
 800d66c:	3901      	subs	r1, #1
 800d66e:	2a03      	cmp	r2, #3
 800d670:	d1d4      	bne.n	800d61c <draw_all_cells+0x14ac>
 800d672:	4653      	mov	r3, sl
 800d674:	003d      	movs	r5, r7
 800d676:	46a2      	mov	sl, r4
 800d678:	001c      	movs	r4, r3
 800d67a:	e4c8      	b.n	800d00e <draw_all_cells+0xe9e>
  while (j > 0 && x == CELL_X0(index[j-1]))
 800d67c:	0025      	movs	r5, r4
 800d67e:	f7ff f9a4 	bl	800c9ca <draw_all_cells+0x85a>
  current_mappage = 1 - current_mappage;
 800d682:	2001      	movs	r0, #1
 800d684:	4b12      	ldr	r3, [pc, #72]	; (800d6d0 <draw_all_cells+0x1560>)
  memset(markmap[current_mappage], 0, sizeof markmap[current_mappage]);
 800d686:	2100      	movs	r1, #0
  current_mappage = 1 - current_mappage;
 800d688:	881a      	ldrh	r2, [r3, #0]
 800d68a:	1a80      	subs	r0, r0, r2
 800d68c:	b280      	uxth	r0, r0
 800d68e:	8018      	strh	r0, [r3, #0]
  memset(markmap[current_mappage], 0, sizeof markmap[current_mappage]);
 800d690:	4b10      	ldr	r3, [pc, #64]	; (800d6d4 <draw_all_cells+0x1564>)
 800d692:	0100      	lsls	r0, r0, #4
 800d694:	1818      	adds	r0, r3, r0
 800d696:	2210      	movs	r2, #16
 800d698:	f005 fd2a 	bl	80130f0 <memset>
}
 800d69c:	e47b      	b.n	800cf96 <draw_all_cells+0xe26>
      int cc = c;
 800d69e:	003b      	movs	r3, r7
 800d6a0:	e51b      	b.n	800d0da <draw_all_cells+0xf6a>
 800d6a2:	46c0      	nop			; (mov r8, r8)
 800d6a4:	20000454 	.word	0x20000454
 800d6a8:	3ff00000 	.word	0x3ff00000
 800d6ac:	3f700000 	.word	0x3f700000
 800d6b0:	000011c5 	.word	0x000011c5
 800d6b4:	40590000 	.word	0x40590000
 800d6b8:	4d8ef3c2 	.word	0x4d8ef3c2
 800d6bc:	080149c0 	.word	0x080149c0
 800d6c0:	fc8b007a 	.word	0xfc8b007a
 800d6c4:	401921fa 	.word	0x401921fa
 800d6c8:	bff00000 	.word	0xbff00000
 800d6cc:	20000436 	.word	0x20000436
 800d6d0:	200029fc 	.word	0x200029fc
 800d6d4:	20002a04 	.word	0x20002a04
	...

0800d6e0 <force_set_markmap>:
  memset(markmap[current_mappage], 0xff, sizeof markmap[current_mappage]);
 800d6e0:	4b05      	ldr	r3, [pc, #20]	; (800d6f8 <force_set_markmap+0x18>)
{
 800d6e2:	b510      	push	{r4, lr}
  memset(markmap[current_mappage], 0xff, sizeof markmap[current_mappage]);
 800d6e4:	881b      	ldrh	r3, [r3, #0]
 800d6e6:	4805      	ldr	r0, [pc, #20]	; (800d6fc <force_set_markmap+0x1c>)
 800d6e8:	011b      	lsls	r3, r3, #4
 800d6ea:	18c0      	adds	r0, r0, r3
 800d6ec:	2210      	movs	r2, #16
 800d6ee:	21ff      	movs	r1, #255	; 0xff
 800d6f0:	f005 fcfe 	bl	80130f0 <memset>
}
 800d6f4:	bd10      	pop	{r4, pc}
 800d6f6:	46c0      	nop			; (mov r8, r8)
 800d6f8:	200029fc 	.word	0x200029fc
 800d6fc:	20002a04 	.word	0x20002a04

0800d700 <plot_into_index>:
{
 800d700:	b5f0      	push	{r4, r5, r6, r7, lr}
 800d702:	46de      	mov	lr, fp
 800d704:	4657      	mov	r7, sl
 800d706:	464e      	mov	r6, r9
 800d708:	4645      	mov	r5, r8
 800d70a:	b5e0      	push	{r5, r6, r7, lr}
  for (i = 0; i < sweep_points; i++) {
 800d70c:	4bdd      	ldr	r3, [pc, #884]	; (800da84 <plot_into_index+0x384>)
{
 800d70e:	b08b      	sub	sp, #44	; 0x2c
 800d710:	9004      	str	r0, [sp, #16]
  for (i = 0; i < sweep_points; i++) {
 800d712:	220c      	movs	r2, #12
 800d714:	5e9b      	ldrsh	r3, [r3, r2]
 800d716:	9306      	str	r3, [sp, #24]
 800d718:	2b00      	cmp	r3, #0
 800d71a:	dc00      	bgt.n	800d71e <plot_into_index+0x1e>
 800d71c:	e27a      	b.n	800dc14 <plot_into_index+0x514>
 800d71e:	4bda      	ldr	r3, [pc, #872]	; (800da88 <plot_into_index+0x388>)
 800d720:	4ada      	ldr	r2, [pc, #872]	; (800da8c <plot_into_index+0x38c>)
 800d722:	9309      	str	r3, [sp, #36]	; 0x24
 800d724:	9302      	str	r3, [sp, #8]
 800d726:	2300      	movs	r3, #0
 800d728:	4694      	mov	ip, r2
 800d72a:	469b      	mov	fp, r3
 800d72c:	9301      	str	r3, [sp, #4]
 800d72e:	4bd5      	ldr	r3, [pc, #852]	; (800da84 <plot_into_index+0x384>)
 800d730:	46da      	mov	sl, fp
 800d732:	4463      	add	r3, ip
 800d734:	9305      	str	r3, [sp, #20]
 800d736:	9b06      	ldr	r3, [sp, #24]
 800d738:	4698      	mov	r8, r3
    for (t = 0; t < TRACE_COUNT; t++) {
 800d73a:	4653      	mov	r3, sl
 800d73c:	00db      	lsls	r3, r3, #3
 800d73e:	9303      	str	r3, [sp, #12]
    return INDEX(x +CELLOFFSETX, y, i);
 800d740:	4653      	mov	r3, sl
 800d742:	029a      	lsls	r2, r3, #10
 800d744:	4bd2      	ldr	r3, [pc, #840]	; (800da90 <plot_into_index+0x390>)
    int x = i * (WIDTH-1) / (sweep_points-1);
 800d746:	9801      	ldr	r0, [sp, #4]
    return INDEX(x +CELLOFFSETX, y, i);
 800d748:	401a      	ands	r2, r3
    int x = i * (WIDTH-1) / (sweep_points-1);
 800d74a:	4643      	mov	r3, r8
 800d74c:	1e59      	subs	r1, r3, #1
    return INDEX(x +CELLOFFSETX, y, i);
 800d74e:	0014      	movs	r4, r2
 800d750:	9206      	str	r2, [sp, #24]
    int x = i * (WIDTH-1) / (sweep_points-1);
 800d752:	f7f2 fdcd 	bl	80002f0 <__divsi3>
  return INDEX(x +CELLOFFSETX, y, i);
 800d756:	22f8      	movs	r2, #248	; 0xf8
 800d758:	3005      	adds	r0, #5
 800d75a:	0583      	lsls	r3, r0, #22
 800d75c:	0edb      	lsrs	r3, r3, #27
 800d75e:	0140      	lsls	r0, r0, #5
 800d760:	0092      	lsls	r2, r2, #2
 800d762:	06db      	lsls	r3, r3, #27
 800d764:	4010      	ands	r0, r2
 800d766:	4318      	orrs	r0, r3
 800d768:	4304      	orrs	r4, r0
 800d76a:	46a3      	mov	fp, r4
    for (t = 0; t < TRACE_COUNT; t++) {
 800d76c:	2400      	movs	r4, #0
 800d76e:	46d9      	mov	r9, fp
 800d770:	46d3      	mov	fp, sl
 800d772:	9d05      	ldr	r5, [sp, #20]
  return INDEX(x +CELLOFFSETX, y, i);
 800d774:	9f02      	ldr	r7, [sp, #8]
      if (!trace[t].enabled)
 800d776:	782b      	ldrb	r3, [r5, #0]
 800d778:	2b00      	cmp	r3, #0
 800d77a:	d06c      	beq.n	800d856 <plot_into_index+0x156>
        measured[n], frequencies, sweep_points);
 800d77c:	23ca      	movs	r3, #202	; 0xca
 800d77e:	78a8      	ldrb	r0, [r5, #2]
 800d780:	009b      	lsls	r3, r3, #2
 800d782:	4358      	muls	r0, r3
 800d784:	9b04      	ldr	r3, [sp, #16]
 800d786:	469a      	mov	sl, r3
 800d788:	4482      	add	sl, r0
  float refpos = 8 - get_trace_refpos(t);
 800d78a:	0020      	movs	r0, r4
 800d78c:	f7fc ff70 	bl	800a670 <get_trace_refpos>
 800d790:	1c01      	adds	r1, r0, #0
 800d792:	2082      	movs	r0, #130	; 0x82
 800d794:	05c0      	lsls	r0, r0, #23
 800d796:	f7f3 fd43 	bl	8001220 <__aeabi_fsub>
 800d79a:	9000      	str	r0, [sp, #0]
  float scale = 1 / get_trace_scale(t);
 800d79c:	0020      	movs	r0, r4
 800d79e:	f7fc ff2f 	bl	800a600 <get_trace_scale>
 800d7a2:	1c01      	adds	r1, r0, #0
 800d7a4:	20fe      	movs	r0, #254	; 0xfe
 800d7a6:	0580      	lsls	r0, r0, #22
 800d7a8:	f7f3 fa42 	bl	8000c30 <__aeabi_fdiv>
  switch (trace[t].type) {
 800d7ac:	786b      	ldrb	r3, [r5, #1]
  float scale = 1 / get_trace_scale(t);
 800d7ae:	1c06      	adds	r6, r0, #0
  switch (trace[t].type) {
 800d7b0:	2b0a      	cmp	r3, #10
 800d7b2:	d900      	bls.n	800d7b6 <plot_into_index+0xb6>
 800d7b4:	e236      	b.n	800dc24 <plot_into_index+0x524>
 800d7b6:	4ab7      	ldr	r2, [pc, #732]	; (800da94 <plot_into_index+0x394>)
 800d7b8:	009b      	lsls	r3, r3, #2
 800d7ba:	58d3      	ldr	r3, [r2, r3]
 800d7bc:	469f      	mov	pc, r3
    v = refpos - resitance(coeff[i]) * scale;
 800d7be:	9b03      	ldr	r3, [sp, #12]
  float d = z0 / ((1-v[0])*(1-v[0])+v[1]*v[1]);
 800d7c0:	20fe      	movs	r0, #254	; 0xfe
    v = refpos - resitance(coeff[i]) * scale;
 800d7c2:	469c      	mov	ip, r3
 800d7c4:	44e2      	add	sl, ip
  float d = z0 / ((1-v[0])*(1-v[0])+v[1]*v[1]);
 800d7c6:	4653      	mov	r3, sl
 800d7c8:	681b      	ldr	r3, [r3, #0]
 800d7ca:	0580      	lsls	r0, r0, #22
 800d7cc:	1c19      	adds	r1, r3, #0
 800d7ce:	9307      	str	r3, [sp, #28]
 800d7d0:	f7f3 fd26 	bl	8001220 <__aeabi_fsub>
 800d7d4:	4652      	mov	r2, sl
 800d7d6:	4680      	mov	r8, r0
 800d7d8:	6850      	ldr	r0, [r2, #4]
 800d7da:	1c01      	adds	r1, r0, #0
 800d7dc:	f7f3 fc08 	bl	8000ff0 <__aeabi_fmul>
 800d7e0:	4682      	mov	sl, r0
 800d7e2:	4641      	mov	r1, r8
 800d7e4:	4640      	mov	r0, r8
 800d7e6:	f7f3 fc03 	bl	8000ff0 <__aeabi_fmul>
 800d7ea:	4651      	mov	r1, sl
 800d7ec:	f7f3 f8a0 	bl	8000930 <__aeabi_fadd>
 800d7f0:	1c01      	adds	r1, r0, #0
 800d7f2:	48a9      	ldr	r0, [pc, #676]	; (800da98 <plot_into_index+0x398>)
 800d7f4:	f7f3 fa1c 	bl	8000c30 <__aeabi_fdiv>
  float zr = ((1+v[0])*(1-v[0]) - v[1]*v[1]) * d;
 800d7f8:	21fe      	movs	r1, #254	; 0xfe
  float d = z0 / ((1-v[0])*(1-v[0])+v[1]*v[1]);
 800d7fa:	9008      	str	r0, [sp, #32]
  float zr = ((1+v[0])*(1-v[0]) - v[1]*v[1]) * d;
 800d7fc:	0589      	lsls	r1, r1, #22
 800d7fe:	9807      	ldr	r0, [sp, #28]
 800d800:	f7f3 f896 	bl	8000930 <__aeabi_fadd>
 800d804:	4641      	mov	r1, r8
 800d806:	f7f3 fbf3 	bl	8000ff0 <__aeabi_fmul>
 800d80a:	4651      	mov	r1, sl
 800d80c:	f7f3 fd08 	bl	8001220 <__aeabi_fsub>
 800d810:	1c01      	adds	r1, r0, #0
 800d812:	9808      	ldr	r0, [sp, #32]
  float zi = 2*v[1] * d;
 800d814:	f7f3 fbec 	bl	8000ff0 <__aeabi_fmul>
    v = refpos - reactance(coeff[i]) * scale;
 800d818:	1c31      	adds	r1, r6, #0
 800d81a:	f7f3 fbe9 	bl	8000ff0 <__aeabi_fmul>
 800d81e:	1c01      	adds	r1, r0, #0
 800d820:	9800      	ldr	r0, [sp, #0]
 800d822:	f7f3 fcfd 	bl	8001220 <__aeabi_fsub>
 800d826:	1c06      	adds	r6, r0, #0
  if (v < 0) v = 0;
 800d828:	2100      	movs	r1, #0
 800d82a:	1c30      	adds	r0, r6, #0
 800d82c:	f7f2 feaa 	bl	8000584 <__aeabi_fcmplt>
 800d830:	464b      	mov	r3, r9
 800d832:	2800      	cmp	r0, #0
 800d834:	d10a      	bne.n	800d84c <plot_into_index+0x14c>
  if (v > 8) v = 8;
 800d836:	2182      	movs	r1, #130	; 0x82
 800d838:	1c30      	adds	r0, r6, #0
 800d83a:	05c9      	lsls	r1, r1, #23
 800d83c:	f7f2 feb6 	bl	80005ac <__aeabi_fcmpgt>
 800d840:	2800      	cmp	r0, #0
 800d842:	d100      	bne.n	800d846 <plot_into_index+0x146>
 800d844:	e1cb      	b.n	800dbde <plot_into_index+0x4de>
 800d846:	464a      	mov	r2, r9
 800d848:	4b94      	ldr	r3, [pc, #592]	; (800da9c <plot_into_index+0x39c>)
 800d84a:	4313      	orrs	r3, r2
      trace_index[t][i] = trace_into_index(
 800d84c:	603b      	str	r3, [r7, #0]
 800d84e:	4b8d      	ldr	r3, [pc, #564]	; (800da84 <plot_into_index+0x384>)
 800d850:	220c      	movs	r2, #12
 800d852:	5e9b      	ldrsh	r3, [r3, r2]
 800d854:	4698      	mov	r8, r3
 800d856:	3795      	adds	r7, #149	; 0x95
    for (t = 0; t < TRACE_COUNT; t++) {
 800d858:	3401      	adds	r4, #1
 800d85a:	350c      	adds	r5, #12
 800d85c:	37ff      	adds	r7, #255	; 0xff
 800d85e:	2c04      	cmp	r4, #4
 800d860:	d189      	bne.n	800d776 <plot_into_index+0x76>
  for (i = 0; i < sweep_points; i++) {
 800d862:	2301      	movs	r3, #1
 800d864:	46da      	mov	sl, fp
 800d866:	469c      	mov	ip, r3
 800d868:	9b01      	ldr	r3, [sp, #4]
 800d86a:	44e2      	add	sl, ip
 800d86c:	3323      	adds	r3, #35	; 0x23
 800d86e:	33ff      	adds	r3, #255	; 0xff
 800d870:	9301      	str	r3, [sp, #4]
 800d872:	9b02      	ldr	r3, [sp, #8]
 800d874:	3304      	adds	r3, #4
 800d876:	9302      	str	r3, [sp, #8]
 800d878:	45c2      	cmp	sl, r8
 800d87a:	da00      	bge.n	800d87e <plot_into_index+0x17e>
 800d87c:	e75d      	b.n	800d73a <plot_into_index+0x3a>
 800d87e:	4643      	mov	r3, r8
 800d880:	9306      	str	r3, [sp, #24]
 800d882:	9809      	ldr	r0, [sp, #36]	; 0x24
    markmap[current_mappage][y] |= 1<<x;
 800d884:	4b86      	ldr	r3, [pc, #536]	; (800daa0 <plot_into_index+0x3a0>)
 800d886:	4684      	mov	ip, r0
 800d888:	881a      	ldrh	r2, [r3, #0]
 800d88a:	9906      	ldr	r1, [sp, #24]
 800d88c:	9b05      	ldr	r3, [sp, #20]
 800d88e:	9207      	str	r2, [sp, #28]
 800d890:	9304      	str	r3, [sp, #16]
 800d892:	008b      	lsls	r3, r1, #2
 800d894:	449c      	add	ip, r3
 800d896:	4663      	mov	r3, ip
 800d898:	9303      	str	r3, [sp, #12]
 800d89a:	008b      	lsls	r3, r1, #2
 800d89c:	425b      	negs	r3, r3
 800d89e:	9305      	str	r3, [sp, #20]
 800d8a0:	00d3      	lsls	r3, r2, #3
 800d8a2:	9300      	str	r3, [sp, #0]
    if (!trace[t].enabled)
 800d8a4:	9b04      	ldr	r3, [sp, #16]
 800d8a6:	781b      	ldrb	r3, [r3, #0]
 800d8a8:	2b00      	cmp	r3, #0
 800d8aa:	d000      	beq.n	800d8ae <plot_into_index+0x1ae>
 800d8ac:	e108      	b.n	800dac0 <plot_into_index+0x3c0>
 800d8ae:	9a03      	ldr	r2, [sp, #12]
 800d8b0:	9b04      	ldr	r3, [sp, #16]
 800d8b2:	3295      	adds	r2, #149	; 0x95
 800d8b4:	32ff      	adds	r2, #255	; 0xff
 800d8b6:	9203      	str	r2, [sp, #12]
  for (t = 0; t < TRACE_COUNT; t++) {
 800d8b8:	4a7a      	ldr	r2, [pc, #488]	; (800daa4 <plot_into_index+0x3a4>)
 800d8ba:	330c      	adds	r3, #12
 800d8bc:	9304      	str	r3, [sp, #16]
 800d8be:	429a      	cmp	r2, r3
 800d8c0:	d1f0      	bne.n	800d8a4 <plot_into_index+0x1a4>
  for (i = 0; i < MARKER_COUNT; i++) {
 800d8c2:	2400      	movs	r4, #0
 800d8c4:	4d77      	ldr	r5, [pc, #476]	; (800daa4 <plot_into_index+0x3a4>)
    if (!markers[i].enabled)
 800d8c6:	2300      	movs	r3, #0
 800d8c8:	56eb      	ldrsb	r3, [r5, r3]
 800d8ca:	2b00      	cmp	r3, #0
 800d8cc:	d002      	beq.n	800d8d4 <plot_into_index+0x1d4>
    if (!markers[marker].enabled)
 800d8ce:	0020      	movs	r0, r4
 800d8d0:	f7fe faa6 	bl	800be20 <markmap_marker.part.2>
  for (i = 0; i < MARKER_COUNT; i++) {
 800d8d4:	3401      	adds	r4, #1
 800d8d6:	3508      	adds	r5, #8
 800d8d8:	2c04      	cmp	r4, #4
 800d8da:	d1f4      	bne.n	800d8c6 <plot_into_index+0x1c6>
  markmap[current_mappage][0] |= 0xffff;
 800d8dc:	2201      	movs	r2, #1
 800d8de:	9b07      	ldr	r3, [sp, #28]
 800d8e0:	4971      	ldr	r1, [pc, #452]	; (800daa8 <plot_into_index+0x3a8>)
 800d8e2:	011b      	lsls	r3, r3, #4
 800d8e4:	4252      	negs	r2, r2
 800d8e6:	52ca      	strh	r2, [r1, r3]
}
 800d8e8:	b00b      	add	sp, #44	; 0x2c
 800d8ea:	bc3c      	pop	{r2, r3, r4, r5}
 800d8ec:	4690      	mov	r8, r2
 800d8ee:	4699      	mov	r9, r3
 800d8f0:	46a2      	mov	sl, r4
 800d8f2:	46ab      	mov	fp, r5
 800d8f4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    v = refpos - coeff[i][1] * scale;
 800d8f6:	9b03      	ldr	r3, [sp, #12]
 800d8f8:	1c30      	adds	r0, r6, #0
 800d8fa:	4453      	add	r3, sl
 800d8fc:	6859      	ldr	r1, [r3, #4]
 800d8fe:	e78c      	b.n	800d81a <plot_into_index+0x11a>
    v = refpos - coeff[i][0] * scale;
 800d900:	4653      	mov	r3, sl
 800d902:	9a03      	ldr	r2, [sp, #12]
 800d904:	5899      	ldr	r1, [r3, r2]
 800d906:	e788      	b.n	800d81a <plot_into_index+0x11a>
    v = refpos+ (1 - swr(coeff[i])) * scale;
 800d908:	9b03      	ldr	r3, [sp, #12]
 800d90a:	4453      	add	r3, sl
 800d90c:	0018      	movs	r0, r3
 800d90e:	f7fe f8c7 	bl	800baa0 <swr>
 800d912:	1c01      	adds	r1, r0, #0
 800d914:	20fe      	movs	r0, #254	; 0xfe
 800d916:	0580      	lsls	r0, r0, #22
 800d918:	f7f3 fc82 	bl	8001220 <__aeabi_fsub>
 800d91c:	1c31      	adds	r1, r6, #0
 800d91e:	f7f3 fb67 	bl	8000ff0 <__aeabi_fmul>
 800d922:	9900      	ldr	r1, [sp, #0]
 800d924:	f7f3 f804 	bl	8000930 <__aeabi_fadd>
 800d928:	1c06      	adds	r6, r0, #0
    break;
 800d92a:	e77d      	b.n	800d828 <plot_into_index+0x128>
    v = refpos - linear(coeff[i]) * scale;
 800d92c:	9b03      	ldr	r3, [sp, #12]
 800d92e:	4453      	add	r3, sl
  return  sqrtf(v[0]*v[0] + v[1]*v[1]);
 800d930:	6818      	ldr	r0, [r3, #0]
 800d932:	685b      	ldr	r3, [r3, #4]
 800d934:	1c01      	adds	r1, r0, #0
 800d936:	4698      	mov	r8, r3
 800d938:	f7f3 fb5a 	bl	8000ff0 <__aeabi_fmul>
 800d93c:	4641      	mov	r1, r8
 800d93e:	4682      	mov	sl, r0
 800d940:	4640      	mov	r0, r8
 800d942:	f7f3 fb55 	bl	8000ff0 <__aeabi_fmul>
 800d946:	1c01      	adds	r1, r0, #0
 800d948:	4650      	mov	r0, sl
 800d94a:	f7f2 fff1 	bl	8000930 <__aeabi_fadd>
 800d94e:	f003 fd57 	bl	8011400 <sqrtf>
 800d952:	1c01      	adds	r1, r0, #0
    v = refpos - linear(coeff[i]) * scale;
 800d954:	1c30      	adds	r0, r6, #0
 800d956:	e760      	b.n	800d81a <plot_into_index+0x11a>
    cartesian_scale(coeff[i][0], coeff[i][1], &x, &y, scale);
 800d958:	9b03      	ldr	r3, [sp, #12]
  int x = (int)(re * RADIUS * scale);
 800d95a:	4954      	ldr	r1, [pc, #336]	; (800daac <plot_into_index+0x3ac>)
    cartesian_scale(coeff[i][0], coeff[i][1], &x, &y, scale);
 800d95c:	469c      	mov	ip, r3
 800d95e:	44e2      	add	sl, ip
  int x = (int)(re * RADIUS * scale);
 800d960:	4653      	mov	r3, sl
 800d962:	6818      	ldr	r0, [r3, #0]
 800d964:	f7f3 fb44 	bl	8000ff0 <__aeabi_fmul>
 800d968:	1c31      	adds	r1, r6, #0
 800d96a:	f7f3 fb41 	bl	8000ff0 <__aeabi_fmul>
 800d96e:	f7f3 fe17 	bl	80015a0 <__aeabi_f2iz>
  int y = (int)(im * RADIUS * scale);
 800d972:	4653      	mov	r3, sl
  int x = (int)(re * RADIUS * scale);
 800d974:	4680      	mov	r8, r0
  int y = (int)(im * RADIUS * scale);
 800d976:	494d      	ldr	r1, [pc, #308]	; (800daac <plot_into_index+0x3ac>)
 800d978:	6858      	ldr	r0, [r3, #4]
 800d97a:	f7f3 fb39 	bl	8000ff0 <__aeabi_fmul>
 800d97e:	1c31      	adds	r1, r6, #0
 800d980:	f7f3 fb36 	bl	8000ff0 <__aeabi_fmul>
 800d984:	f7f3 fe0c 	bl	80015a0 <__aeabi_f2iz>
  if (x < -RADIUS) x = -RADIUS;
 800d988:	4643      	mov	r3, r8
 800d98a:	4642      	mov	r2, r8
 800d98c:	3373      	adds	r3, #115	; 0x73
 800d98e:	da01      	bge.n	800d994 <plot_into_index+0x294>
 800d990:	2273      	movs	r2, #115	; 0x73
 800d992:	4252      	negs	r2, r2
  if (y < -RADIUS) y = -RADIUS;
 800d994:	0003      	movs	r3, r0
 800d996:	3373      	adds	r3, #115	; 0x73
 800d998:	da01      	bge.n	800d99e <plot_into_index+0x29e>
 800d99a:	2073      	movs	r0, #115	; 0x73
 800d99c:	4240      	negs	r0, r0
    return INDEX(x +CELLOFFSETX, y, i);
 800d99e:	2a73      	cmp	r2, #115	; 0x73
 800d9a0:	dd00      	ble.n	800d9a4 <plot_into_index+0x2a4>
 800d9a2:	2273      	movs	r2, #115	; 0x73
 800d9a4:	3296      	adds	r2, #150	; 0x96
  *yp = HEIGHT/2 - y;
 800d9a6:	2873      	cmp	r0, #115	; 0x73
 800d9a8:	dd00      	ble.n	800d9ac <plot_into_index+0x2ac>
 800d9aa:	2073      	movs	r0, #115	; 0x73
 800d9ac:	2173      	movs	r1, #115	; 0x73
 800d9ae:	1a09      	subs	r1, r1, r0
    return INDEX(x +CELLOFFSETX, y, i);
 800d9b0:	201f      	movs	r0, #31
 800d9b2:	0593      	lsls	r3, r2, #22
 800d9b4:	9e06      	ldr	r6, [sp, #24]
 800d9b6:	4008      	ands	r0, r1
 800d9b8:	0edb      	lsrs	r3, r3, #27
 800d9ba:	4330      	orrs	r0, r6
 800d9bc:	06db      	lsls	r3, r3, #27
 800d9be:	4303      	orrs	r3, r0
 800d9c0:	20f8      	movs	r0, #248	; 0xf8
 800d9c2:	0449      	lsls	r1, r1, #17
 800d9c4:	04c0      	lsls	r0, r0, #19
 800d9c6:	4001      	ands	r1, r0
 800d9c8:	430b      	orrs	r3, r1
 800d9ca:	21f8      	movs	r1, #248	; 0xf8
 800d9cc:	0152      	lsls	r2, r2, #5
 800d9ce:	0089      	lsls	r1, r1, #2
 800d9d0:	400a      	ands	r2, r1
 800d9d2:	4313      	orrs	r3, r2
 800d9d4:	e73a      	b.n	800d84c <plot_into_index+0x14c>
    v = refpos - group_delay(coeff, freq, point_count, i) * scale;
 800d9d6:	4641      	mov	r1, r8
 800d9d8:	465a      	mov	r2, fp
 800d9da:	4650      	mov	r0, sl
 800d9dc:	f7fe f9c0 	bl	800bd60 <group_delay.constprop.11>
 800d9e0:	1c01      	adds	r1, r0, #0
 800d9e2:	1c30      	adds	r0, r6, #0
 800d9e4:	e719      	b.n	800d81a <plot_into_index+0x11a>
    v = refpos - phase(coeff[i]) * scale;
 800d9e6:	9b03      	ldr	r3, [sp, #12]
 800d9e8:	4453      	add	r3, sl
  return 2 * atan2f(v[1], v[0]) / M_PI * 90;
 800d9ea:	6819      	ldr	r1, [r3, #0]
 800d9ec:	6858      	ldr	r0, [r3, #4]
 800d9ee:	f003 fc7f 	bl	80112f0 <atan2f>
 800d9f2:	1c01      	adds	r1, r0, #0
 800d9f4:	f7f2 ff9c 	bl	8000930 <__aeabi_fadd>
 800d9f8:	f7f5 fcf2 	bl	80033e0 <__aeabi_f2d>
 800d9fc:	4a2c      	ldr	r2, [pc, #176]	; (800dab0 <plot_into_index+0x3b0>)
 800d9fe:	4b2d      	ldr	r3, [pc, #180]	; (800dab4 <plot_into_index+0x3b4>)
 800da00:	f7f4 f9f6 	bl	8001df0 <__aeabi_ddiv>
 800da04:	2200      	movs	r2, #0
 800da06:	4b2c      	ldr	r3, [pc, #176]	; (800dab8 <plot_into_index+0x3b8>)
 800da08:	f7f4 fdfa 	bl	8002600 <__aeabi_dmul>
 800da0c:	f7f5 fd40 	bl	8003490 <__aeabi_d2f>
 800da10:	e702      	b.n	800d818 <plot_into_index+0x118>
    v = refpos - reactance(coeff[i]) * scale;
 800da12:	9b03      	ldr	r3, [sp, #12]
  float d = z0 / ((1-v[0])*(1-v[0])+v[1]*v[1]);
 800da14:	20fe      	movs	r0, #254	; 0xfe
    v = refpos - reactance(coeff[i]) * scale;
 800da16:	469c      	mov	ip, r3
 800da18:	44e2      	add	sl, ip
  float d = z0 / ((1-v[0])*(1-v[0])+v[1]*v[1]);
 800da1a:	4653      	mov	r3, sl
 800da1c:	0580      	lsls	r0, r0, #22
 800da1e:	6819      	ldr	r1, [r3, #0]
 800da20:	f7f3 fbfe 	bl	8001220 <__aeabi_fsub>
 800da24:	4653      	mov	r3, sl
 800da26:	685b      	ldr	r3, [r3, #4]
 800da28:	1c01      	adds	r1, r0, #0
 800da2a:	4698      	mov	r8, r3
 800da2c:	f7f3 fae0 	bl	8000ff0 <__aeabi_fmul>
 800da30:	4641      	mov	r1, r8
 800da32:	4682      	mov	sl, r0
 800da34:	4640      	mov	r0, r8
 800da36:	f7f3 fadb 	bl	8000ff0 <__aeabi_fmul>
 800da3a:	1c01      	adds	r1, r0, #0
 800da3c:	4650      	mov	r0, sl
 800da3e:	f7f2 ff77 	bl	8000930 <__aeabi_fadd>
 800da42:	1c01      	adds	r1, r0, #0
 800da44:	4814      	ldr	r0, [pc, #80]	; (800da98 <plot_into_index+0x398>)
 800da46:	f7f3 f8f3 	bl	8000c30 <__aeabi_fdiv>
  float zi = 2*v[1] * d;
 800da4a:	4641      	mov	r1, r8
  float d = z0 / ((1-v[0])*(1-v[0])+v[1]*v[1]);
 800da4c:	4682      	mov	sl, r0
  float zi = 2*v[1] * d;
 800da4e:	4640      	mov	r0, r8
 800da50:	f7f2 ff6e 	bl	8000930 <__aeabi_fadd>
 800da54:	1c01      	adds	r1, r0, #0
 800da56:	4650      	mov	r0, sl
 800da58:	e6dc      	b.n	800d814 <plot_into_index+0x114>
    v = refpos - logmag(coeff[i]) * scale;
 800da5a:	9b03      	ldr	r3, [sp, #12]
 800da5c:	4453      	add	r3, sl
  return log10f(v[0]*v[0] + v[1]*v[1]) * 10;
 800da5e:	6818      	ldr	r0, [r3, #0]
 800da60:	685b      	ldr	r3, [r3, #4]
 800da62:	1c01      	adds	r1, r0, #0
 800da64:	4698      	mov	r8, r3
 800da66:	f7f3 fac3 	bl	8000ff0 <__aeabi_fmul>
 800da6a:	4641      	mov	r1, r8
 800da6c:	4682      	mov	sl, r0
 800da6e:	4640      	mov	r0, r8
 800da70:	f7f3 fabe 	bl	8000ff0 <__aeabi_fmul>
 800da74:	1c01      	adds	r1, r0, #0
 800da76:	4650      	mov	r0, sl
 800da78:	f7f2 ff5a 	bl	8000930 <__aeabi_fadd>
 800da7c:	f003 fc40 	bl	8011300 <log10f>
 800da80:	490e      	ldr	r1, [pc, #56]	; (800dabc <plot_into_index+0x3bc>)
 800da82:	e6c7      	b.n	800d814 <plot_into_index+0x114>
 800da84:	20000454 	.word	0x20000454
 800da88:	20002a24 	.word	0x20002a24
 800da8c:	00001170 	.word	0x00001170
 800da90:	003ffc00 	.word	0x003ffc00
 800da94:	08014984 	.word	0x08014984
 800da98:	42480000 	.word	0x42480000
 800da9c:	01c00008 	.word	0x01c00008
 800daa0:	200029fc 	.word	0x200029fc
 800daa4:	200015f4 	.word	0x200015f4
 800daa8:	20002a04 	.word	0x20002a04
 800daac:	42e60000 	.word	0x42e60000
 800dab0:	54442d18 	.word	0x54442d18
 800dab4:	400921fb 	.word	0x400921fb
 800dab8:	40568000 	.word	0x40568000
 800dabc:	41200000 	.word	0x41200000
    int x0 = CELL_X(trace_index[t][0]);
 800dac0:	20f8      	movs	r0, #248	; 0xf8
 800dac2:	211f      	movs	r1, #31
 800dac4:	9a03      	ldr	r2, [sp, #12]
 800dac6:	9b05      	ldr	r3, [sp, #20]
 800dac8:	0080      	lsls	r0, r0, #2
 800daca:	589b      	ldr	r3, [r3, r2]
 800dacc:	095f      	lsrs	r7, r3, #5
 800dace:	0d9a      	lsrs	r2, r3, #22
    int y0 = CELL_Y(trace_index[t][0]);
 800dad0:	0c5e      	lsrs	r6, r3, #17
    int x0 = CELL_X(trace_index[t][0]);
 800dad2:	4002      	ands	r2, r0
    int y0 = CELL_Y(trace_index[t][0]);
 800dad4:	400b      	ands	r3, r1
    int x0 = CELL_X(trace_index[t][0]);
 800dad6:	400f      	ands	r7, r1
    int y0 = CELL_Y(trace_index[t][0]);
 800dad8:	4006      	ands	r6, r0
    int x0 = CELL_X(trace_index[t][0]);
 800dada:	4317      	orrs	r7, r2
    int y0 = CELL_Y(trace_index[t][0]);
 800dadc:	431e      	orrs	r6, r3
    int n0 = y0 >> 5;
 800dade:	1172      	asrs	r2, r6, #5
    int m0 = x0 >> 5;
 800dae0:	117b      	asrs	r3, r7, #5
  if (y >= 0 && y < 8 && x >= 0 && x < 16)
 800dae2:	2a07      	cmp	r2, #7
 800dae4:	dc02      	bgt.n	800daec <plot_into_index+0x3ec>
 800dae6:	2b0f      	cmp	r3, #15
 800dae8:	dc00      	bgt.n	800daec <plot_into_index+0x3ec>
 800daea:	e088      	b.n	800dbfe <plot_into_index+0x4fe>
 800daec:	9803      	ldr	r0, [sp, #12]
 800daee:	9905      	ldr	r1, [sp, #20]
 800daf0:	4684      	mov	ip, r0
 800daf2:	3104      	adds	r1, #4
 800daf4:	448c      	add	ip, r1
    for (i = 1; i < sweep_points; i++) {
 800daf6:	9906      	ldr	r1, [sp, #24]
 800daf8:	46b8      	mov	r8, r7
 800dafa:	0037      	movs	r7, r6
 800dafc:	2901      	cmp	r1, #1
 800dafe:	dc00      	bgt.n	800db02 <plot_into_index+0x402>
 800db00:	e6d5      	b.n	800d8ae <plot_into_index+0x1ae>
      int x1 = CELL_X(trace_index[t][i]);
 800db02:	4661      	mov	r1, ip
 800db04:	26f8      	movs	r6, #248	; 0xf8
 800db06:	251f      	movs	r5, #31
 800db08:	6809      	ldr	r1, [r1, #0]
 800db0a:	00b6      	lsls	r6, r6, #2
 800db0c:	094c      	lsrs	r4, r1, #5
 800db0e:	0d88      	lsrs	r0, r1, #22
 800db10:	4030      	ands	r0, r6
 800db12:	402c      	ands	r4, r5
 800db14:	4304      	orrs	r4, r0
 800db16:	0020      	movs	r0, r4
 800db18:	9401      	str	r4, [sp, #4]
      int y1 = CELL_Y(trace_index[t][i]);
 800db1a:	24f8      	movs	r4, #248	; 0xf8
 800db1c:	0c4e      	lsrs	r6, r1, #17
 800db1e:	00a4      	lsls	r4, r4, #2
 800db20:	4026      	ands	r6, r4
 800db22:	0034      	movs	r4, r6
 800db24:	4029      	ands	r1, r5
 800db26:	430c      	orrs	r4, r1
      int m1 = x1 >> 5;
 800db28:	1145      	asrs	r5, r0, #5
 800db2a:	0001      	movs	r1, r0
      int n1 = y1 >> 5;
 800db2c:	0020      	movs	r0, r4
 800db2e:	1bc0      	subs	r0, r0, r7
 800db30:	4682      	mov	sl, r0
 800db32:	4640      	mov	r0, r8
 800db34:	1a09      	subs	r1, r1, r0
 800db36:	4689      	mov	r9, r1
 800db38:	46bb      	mov	fp, r7
      int y1 = CELL_Y(trace_index[t][i]);
 800db3a:	9402      	str	r4, [sp, #8]
      int n1 = y1 >> 5;
 800db3c:	1164      	asrs	r4, r4, #5
      while (m0 != m1 || n0 != n1) {
 800db3e:	429d      	cmp	r5, r3
 800db40:	d027      	beq.n	800db92 <plot_into_index+0x492>
        } else if (n0 == n1) {
 800db42:	4294      	cmp	r4, r2
 800db44:	d039      	beq.n	800dbba <plot_into_index+0x4ba>
          int x = (m0 < m1) ? (m0 + 1)<<5 : m0<<5;
 800db46:	0159      	lsls	r1, r3, #5
 800db48:	429d      	cmp	r5, r3
 800db4a:	dd01      	ble.n	800db50 <plot_into_index+0x450>
 800db4c:	1c59      	adds	r1, r3, #1
 800db4e:	0149      	lsls	r1, r1, #5
          int y = (n0 < n1) ? (n0 + 1)<<5 : n0<<5;
 800db50:	4294      	cmp	r4, r2
 800db52:	dd25      	ble.n	800dba0 <plot_into_index+0x4a0>
          if (sgn*(y-y0)*(x1-x0) < sgn*(x-x0)*(y1-y0)) {
 800db54:	465f      	mov	r7, fp
          int y = (n0 < n1) ? (n0 + 1)<<5 : n0<<5;
 800db56:	1c56      	adds	r6, r2, #1
 800db58:	0170      	lsls	r0, r6, #5
          if (sgn*(y-y0)*(x1-x0) < sgn*(x-x0)*(y1-y0)) {
 800db5a:	1bc0      	subs	r0, r0, r7
 800db5c:	464f      	mov	r7, r9
 800db5e:	4378      	muls	r0, r7
 800db60:	4647      	mov	r7, r8
 800db62:	1bc9      	subs	r1, r1, r7
 800db64:	4657      	mov	r7, sl
 800db66:	4379      	muls	r1, r7
 800db68:	4288      	cmp	r0, r1
 800db6a:	db26      	blt.n	800dbba <plot_into_index+0x4ba>
            if (n0 < n1) n0++;
 800db6c:	0032      	movs	r2, r6
  if (y >= 0 && y < 8 && x >= 0 && x < 16)
 800db6e:	2a07      	cmp	r2, #7
 800db70:	d8e5      	bhi.n	800db3e <plot_into_index+0x43e>
 800db72:	2b00      	cmp	r3, #0
 800db74:	dbe3      	blt.n	800db3e <plot_into_index+0x43e>
 800db76:	2b0f      	cmp	r3, #15
 800db78:	dce1      	bgt.n	800db3e <plot_into_index+0x43e>
    markmap[current_mappage][y] |= 1<<x;
 800db7a:	2601      	movs	r6, #1
 800db7c:	409e      	lsls	r6, r3
 800db7e:	9900      	ldr	r1, [sp, #0]
 800db80:	4829      	ldr	r0, [pc, #164]	; (800dc28 <plot_into_index+0x528>)
 800db82:	1889      	adds	r1, r1, r2
 800db84:	0049      	lsls	r1, r1, #1
 800db86:	5a40      	ldrh	r0, [r0, r1]
 800db88:	4330      	orrs	r0, r6
 800db8a:	4e27      	ldr	r6, [pc, #156]	; (800dc28 <plot_into_index+0x528>)
 800db8c:	5270      	strh	r0, [r6, r1]
      while (m0 != m1 || n0 != n1) {
 800db8e:	429d      	cmp	r5, r3
 800db90:	d1d7      	bne.n	800db42 <plot_into_index+0x442>
 800db92:	4294      	cmp	r4, r2
 800db94:	d019      	beq.n	800dbca <plot_into_index+0x4ca>
          if (n0 < n1) n0++; else n0--;
 800db96:	dd16      	ble.n	800dbc6 <plot_into_index+0x4c6>
 800db98:	3201      	adds	r2, #1
  if (y >= 0 && y < 8 && x >= 0 && x < 16)
 800db9a:	2a07      	cmp	r2, #7
 800db9c:	d9eb      	bls.n	800db76 <plot_into_index+0x476>
 800db9e:	e7ce      	b.n	800db3e <plot_into_index+0x43e>
          if (sgn*(y-y0)*(x1-x0) < sgn*(x-x0)*(y1-y0)) {
 800dba0:	4640      	mov	r0, r8
 800dba2:	1a41      	subs	r1, r0, r1
 800dba4:	4650      	mov	r0, sl
 800dba6:	465e      	mov	r6, fp
 800dba8:	4341      	muls	r1, r0
          int y = (n0 < n1) ? (n0 + 1)<<5 : n0<<5;
 800dbaa:	0150      	lsls	r0, r2, #5
          if (sgn*(y-y0)*(x1-x0) < sgn*(x-x0)*(y1-y0)) {
 800dbac:	1a30      	subs	r0, r6, r0
 800dbae:	464e      	mov	r6, r9
 800dbb0:	4370      	muls	r0, r6
 800dbb2:	4281      	cmp	r1, r0
 800dbb4:	dc01      	bgt.n	800dbba <plot_into_index+0x4ba>
            else n0--;
 800dbb6:	3a01      	subs	r2, #1
 800dbb8:	e7d9      	b.n	800db6e <plot_into_index+0x46e>
            if (m0 < m1) m0++;
 800dbba:	429d      	cmp	r5, r3
 800dbbc:	dd01      	ble.n	800dbc2 <plot_into_index+0x4c2>
 800dbbe:	3301      	adds	r3, #1
 800dbc0:	e7d5      	b.n	800db6e <plot_into_index+0x46e>
            else m0--;
 800dbc2:	3b01      	subs	r3, #1
 800dbc4:	e7d3      	b.n	800db6e <plot_into_index+0x46e>
          if (n0 < n1) n0++; else n0--;
 800dbc6:	3a01      	subs	r2, #1
 800dbc8:	e7e7      	b.n	800db9a <plot_into_index+0x49a>
      n0 = n1;
 800dbca:	2104      	movs	r1, #4
 800dbcc:	4688      	mov	r8, r1
      x0 = x1;
 800dbce:	9901      	ldr	r1, [sp, #4]
 800dbd0:	44c4      	add	ip, r8
 800dbd2:	4688      	mov	r8, r1
    for (i = 1; i < sweep_points; i++) {
 800dbd4:	9903      	ldr	r1, [sp, #12]
      y0 = y1;
 800dbd6:	9f02      	ldr	r7, [sp, #8]
    for (i = 1; i < sweep_points; i++) {
 800dbd8:	4561      	cmp	r1, ip
 800dbda:	d192      	bne.n	800db02 <plot_into_index+0x402>
 800dbdc:	e667      	b.n	800d8ae <plot_into_index+0x1ae>
 800dbde:	4913      	ldr	r1, [pc, #76]	; (800dc2c <plot_into_index+0x52c>)
 800dbe0:	1c30      	adds	r0, r6, #0
 800dbe2:	f7f3 fa05 	bl	8000ff0 <__aeabi_fmul>
 800dbe6:	f7f3 fcdb 	bl	80015a0 <__aeabi_f2iz>
 800dbea:	22f8      	movs	r2, #248	; 0xf8
 800dbec:	0443      	lsls	r3, r0, #17
 800dbee:	04d2      	lsls	r2, r2, #19
 800dbf0:	4013      	ands	r3, r2
 800dbf2:	221f      	movs	r2, #31
 800dbf4:	4649      	mov	r1, r9
 800dbf6:	4002      	ands	r2, r0
 800dbf8:	430a      	orrs	r2, r1
 800dbfa:	4313      	orrs	r3, r2
 800dbfc:	e626      	b.n	800d84c <plot_into_index+0x14c>
    markmap[current_mappage][y] |= 1<<x;
 800dbfe:	2401      	movs	r4, #1
 800dc00:	409c      	lsls	r4, r3
 800dc02:	9900      	ldr	r1, [sp, #0]
 800dc04:	4808      	ldr	r0, [pc, #32]	; (800dc28 <plot_into_index+0x528>)
 800dc06:	1889      	adds	r1, r1, r2
 800dc08:	0049      	lsls	r1, r1, #1
 800dc0a:	5a40      	ldrh	r0, [r0, r1]
 800dc0c:	4320      	orrs	r0, r4
 800dc0e:	4c06      	ldr	r4, [pc, #24]	; (800dc28 <plot_into_index+0x528>)
 800dc10:	5260      	strh	r0, [r4, r1]
 800dc12:	e76b      	b.n	800daec <plot_into_index+0x3ec>
 800dc14:	4a06      	ldr	r2, [pc, #24]	; (800dc30 <plot_into_index+0x530>)
 800dc16:	4b07      	ldr	r3, [pc, #28]	; (800dc34 <plot_into_index+0x534>)
 800dc18:	4694      	mov	ip, r2
 800dc1a:	9309      	str	r3, [sp, #36]	; 0x24
 800dc1c:	4b06      	ldr	r3, [pc, #24]	; (800dc38 <plot_into_index+0x538>)
 800dc1e:	4463      	add	r3, ip
 800dc20:	9305      	str	r3, [sp, #20]
 800dc22:	e62e      	b.n	800d882 <plot_into_index+0x182>
  float v = 0;
 800dc24:	2600      	movs	r6, #0
 800dc26:	e5ff      	b.n	800d828 <plot_into_index+0x128>
 800dc28:	20002a04 	.word	0x20002a04
 800dc2c:	41e80000 	.word	0x41e80000
 800dc30:	00001170 	.word	0x00001170
 800dc34:	20002a24 	.word	0x20002a24
 800dc38:	20000454 	.word	0x20000454
 800dc3c:	00000000 	.word	0x00000000

0800dc40 <marker_position>:
{
 800dc40:	b570      	push	{r4, r5, r6, lr}
    uint32_t index = trace_index[t][markers[m].index];
 800dc42:	248d      	movs	r4, #141	; 0x8d
 800dc44:	00a4      	lsls	r4, r4, #2
 800dc46:	1904      	adds	r4, r0, r4
 800dc48:	4d0c      	ldr	r5, [pc, #48]	; (800dc7c <marker_position+0x3c>)
 800dc4a:	00e4      	lsls	r4, r4, #3
 800dc4c:	192c      	adds	r4, r5, r4
 800dc4e:	2002      	movs	r0, #2
 800dc50:	5e24      	ldrsh	r4, [r4, r0]
 800dc52:	2065      	movs	r0, #101	; 0x65
 800dc54:	4348      	muls	r0, r1
 800dc56:	490a      	ldr	r1, [pc, #40]	; (800dc80 <marker_position+0x40>)
 800dc58:	1900      	adds	r0, r0, r4
 800dc5a:	0080      	lsls	r0, r0, #2
    *x = CELL_X(index);
 800dc5c:	26f8      	movs	r6, #248	; 0xf8
    uint32_t index = trace_index[t][markers[m].index];
 800dc5e:	5844      	ldr	r4, [r0, r1]
    *x = CELL_X(index);
 800dc60:	201f      	movs	r0, #31
 800dc62:	00b6      	lsls	r6, r6, #2
 800dc64:	0961      	lsrs	r1, r4, #5
 800dc66:	0da5      	lsrs	r5, r4, #22
 800dc68:	4035      	ands	r5, r6
 800dc6a:	4001      	ands	r1, r0
 800dc6c:	4329      	orrs	r1, r5
 800dc6e:	6011      	str	r1, [r2, #0]
    *y = CELL_Y(index);
 800dc70:	0c62      	lsrs	r2, r4, #17
 800dc72:	4032      	ands	r2, r6
 800dc74:	4020      	ands	r0, r4
 800dc76:	4302      	orrs	r2, r0
 800dc78:	601a      	str	r2, [r3, #0]
}
 800dc7a:	bd70      	pop	{r4, r5, r6, pc}
 800dc7c:	20000454 	.word	0x20000454
 800dc80:	20002a24 	.word	0x20002a24
	...

0800dc90 <search_nearest_index>:
{
 800dc90:	b5f0      	push	{r4, r5, r6, r7, lr}
 800dc92:	0003      	movs	r3, r0
 800dc94:	4645      	mov	r5, r8
 800dc96:	46de      	mov	lr, fp
 800dc98:	4657      	mov	r7, sl
 800dc9a:	464e      	mov	r6, r9
  uint32_t *index = trace_index[t];
 800dc9c:	20ca      	movs	r0, #202	; 0xca
{
 800dc9e:	b5e0      	push	{r5, r6, r7, lr}
  uint32_t *index = trace_index[t];
 800dca0:	0040      	lsls	r0, r0, #1
 800dca2:	4350      	muls	r0, r2
 800dca4:	4a27      	ldr	r2, [pc, #156]	; (800dd44 <search_nearest_index+0xb4>)
{
 800dca6:	b083      	sub	sp, #12
  uint32_t *index = trace_index[t];
 800dca8:	1882      	adds	r2, r0, r2
 800dcaa:	9201      	str	r2, [sp, #4]
  for (i = 0; i < sweep_points; i++) {
 800dcac:	4a26      	ldr	r2, [pc, #152]	; (800dd48 <search_nearest_index+0xb8>)
 800dcae:	200c      	movs	r0, #12
 800dcb0:	5e12      	ldrsh	r2, [r2, r0]
 800dcb2:	4690      	mov	r8, r2
 800dcb4:	2a00      	cmp	r2, #0
 800dcb6:	dd40      	ble.n	800dd3a <search_nearest_index+0xaa>
 800dcb8:	b29b      	uxth	r3, r3
 800dcba:	b28a      	uxth	r2, r1
 800dcbc:	0019      	movs	r1, r3
    if (dx < 0) dx = -dx;
 800dcbe:	2412      	movs	r4, #18
 800dcc0:	3912      	subs	r1, #18
 800dcc2:	b289      	uxth	r1, r1
 800dcc4:	1ae3      	subs	r3, r4, r3
 800dcc6:	468c      	mov	ip, r1
 800dcc8:	469a      	mov	sl, r3
  int min_i = -1;
 800dcca:	2101      	movs	r1, #1
    if (d < min_d) {
 800dccc:	4b1f      	ldr	r3, [pc, #124]	; (800dd4c <search_nearest_index+0xbc>)
    int16_t dx = x - CELL_X(index[i]) - OFFSETX;
 800dcce:	27f8      	movs	r7, #248	; 0xf8
  for (i = 0; i < sweep_points; i++) {
 800dcd0:	2600      	movs	r6, #0
    if (d < min_d) {
 800dcd2:	4699      	mov	r9, r3
  int min_i = -1;
 800dcd4:	4249      	negs	r1, r1
 800dcd6:	468b      	mov	fp, r1
    int16_t dx = x - CELL_X(index[i]) - OFFSETX;
 800dcd8:	00bf      	lsls	r7, r7, #2
 800dcda:	3120      	adds	r1, #32
 800dcdc:	9801      	ldr	r0, [sp, #4]
 800dcde:	00b3      	lsls	r3, r6, #2
 800dce0:	58c3      	ldr	r3, [r0, r3]
 800dce2:	095c      	lsrs	r4, r3, #5
 800dce4:	0d98      	lsrs	r0, r3, #22
 800dce6:	4038      	ands	r0, r7
 800dce8:	400c      	ands	r4, r1
 800dcea:	4304      	orrs	r4, r0
 800dcec:	4660      	mov	r0, ip
    int16_t dy = y - CELL_Y(index[i]) - OFFSETY;
 800dcee:	0c5d      	lsrs	r5, r3, #17
 800dcf0:	403d      	ands	r5, r7
 800dcf2:	400b      	ands	r3, r1
    int16_t dx = x - CELL_X(index[i]) - OFFSETX;
 800dcf4:	1b00      	subs	r0, r0, r4
    int16_t dy = y - CELL_Y(index[i]) - OFFSETY;
 800dcf6:	432b      	orrs	r3, r5
 800dcf8:	1ad5      	subs	r5, r2, r3
    int16_t dx = x - CELL_X(index[i]) - OFFSETX;
 800dcfa:	b200      	sxth	r0, r0
    int16_t dy = y - CELL_Y(index[i]) - OFFSETY;
 800dcfc:	b22d      	sxth	r5, r5
    if (dx < 0) dx = -dx;
 800dcfe:	2800      	cmp	r0, #0
 800dd00:	da01      	bge.n	800dd06 <search_nearest_index+0x76>
 800dd02:	4454      	add	r4, sl
 800dd04:	b220      	sxth	r0, r4
    if (dy < 0) dy = -dy;
 800dd06:	2d00      	cmp	r5, #0
 800dd08:	da01      	bge.n	800dd0e <search_nearest_index+0x7e>
 800dd0a:	1a9b      	subs	r3, r3, r2
 800dd0c:	b21d      	sxth	r5, r3
    if (dx > 20 || dy > 20)
 800dd0e:	2814      	cmp	r0, #20
 800dd10:	dc08      	bgt.n	800dd24 <search_nearest_index+0x94>
 800dd12:	2d14      	cmp	r5, #20
 800dd14:	dc06      	bgt.n	800dd24 <search_nearest_index+0x94>
    int d = dx*dx + dy*dy;
 800dd16:	002b      	movs	r3, r5
 800dd18:	4340      	muls	r0, r0
 800dd1a:	436b      	muls	r3, r5
 800dd1c:	18c0      	adds	r0, r0, r3
    if (d < min_d) {
 800dd1e:	4548      	cmp	r0, r9
 800dd20:	dc00      	bgt.n	800dd24 <search_nearest_index+0x94>
 800dd22:	46b3      	mov	fp, r6
  for (i = 0; i < sweep_points; i++) {
 800dd24:	3601      	adds	r6, #1
 800dd26:	4546      	cmp	r6, r8
 800dd28:	dbd8      	blt.n	800dcdc <search_nearest_index+0x4c>
}
 800dd2a:	4658      	mov	r0, fp
 800dd2c:	b003      	add	sp, #12
 800dd2e:	bc3c      	pop	{r2, r3, r4, r5}
 800dd30:	4690      	mov	r8, r2
 800dd32:	4699      	mov	r9, r3
 800dd34:	46a2      	mov	sl, r4
 800dd36:	46ab      	mov	fp, r5
 800dd38:	bdf0      	pop	{r4, r5, r6, r7, pc}
  int min_i = -1;
 800dd3a:	2301      	movs	r3, #1
 800dd3c:	425b      	negs	r3, r3
 800dd3e:	469b      	mov	fp, r3
  return min_i;
 800dd40:	e7f3      	b.n	800dd2a <search_nearest_index+0x9a>
 800dd42:	46c0      	nop			; (mov r8, r8)
 800dd44:	20002a24 	.word	0x20002a24
 800dd48:	20000454 	.word	0x20000454
 800dd4c:	000003e7 	.word	0x000003e7

0800dd50 <redraw_marker>:
    if (!markers[marker].enabled)
 800dd50:	238d      	movs	r3, #141	; 0x8d
 800dd52:	009b      	lsls	r3, r3, #2
 800dd54:	18c3      	adds	r3, r0, r3
 800dd56:	4a0b      	ldr	r2, [pc, #44]	; (800dd84 <redraw_marker+0x34>)
 800dd58:	00db      	lsls	r3, r3, #3
 800dd5a:	569b      	ldrsb	r3, [r3, r2]
{
 800dd5c:	b510      	push	{r4, lr}
 800dd5e:	000c      	movs	r4, r1
    if (!markers[marker].enabled)
 800dd60:	2b00      	cmp	r3, #0
 800dd62:	d001      	beq.n	800dd68 <redraw_marker+0x18>
 800dd64:	f7fe f85c 	bl	800be20 <markmap_marker.part.2>
  if (update_info)
 800dd68:	2c00      	cmp	r4, #0
 800dd6a:	d006      	beq.n	800dd7a <redraw_marker+0x2a>
    markmap[current_mappage][0] = 0xffff;
 800dd6c:	2101      	movs	r1, #1
 800dd6e:	4b06      	ldr	r3, [pc, #24]	; (800dd88 <redraw_marker+0x38>)
 800dd70:	4a06      	ldr	r2, [pc, #24]	; (800dd8c <redraw_marker+0x3c>)
 800dd72:	881b      	ldrh	r3, [r3, #0]
 800dd74:	4249      	negs	r1, r1
 800dd76:	011b      	lsls	r3, r3, #4
 800dd78:	5299      	strh	r1, [r3, r2]
  draw_all_cells(TRUE);
 800dd7a:	2001      	movs	r0, #1
 800dd7c:	f7fe f9f8 	bl	800c170 <draw_all_cells>
}
 800dd80:	bd10      	pop	{r4, pc}
 800dd82:	46c0      	nop			; (mov r8, r8)
 800dd84:	20000454 	.word	0x20000454
 800dd88:	200029fc 	.word	0x200029fc
 800dd8c:	20002a04 	.word	0x20002a04

0800dd90 <request_to_draw_cells_behind_menu>:
{
 800dd90:	b570      	push	{r4, r5, r6, lr}
  for (m = 7; m <= 9; m++)
 800dd92:	2407      	movs	r4, #7
    markmap[current_mappage][y] |= 1<<x;
 800dd94:	2501      	movs	r5, #1
 800dd96:	4b0d      	ldr	r3, [pc, #52]	; (800ddcc <request_to_draw_cells_behind_menu+0x3c>)
 800dd98:	480d      	ldr	r0, [pc, #52]	; (800ddd0 <request_to_draw_cells_behind_menu+0x40>)
 800dd9a:	881a      	ldrh	r2, [r3, #0]
 800dd9c:	0112      	lsls	r2, r2, #4
 800dd9e:	1886      	adds	r6, r0, r2
 800dda0:	3010      	adds	r0, #16
 800dda2:	1880      	adds	r0, r0, r2
 800dda4:	0029      	movs	r1, r5
 800dda6:	40a1      	lsls	r1, r4
 800dda8:	0033      	movs	r3, r6
 800ddaa:	b209      	sxth	r1, r1
 800ddac:	881a      	ldrh	r2, [r3, #0]
 800ddae:	430a      	orrs	r2, r1
 800ddb0:	801a      	strh	r2, [r3, #0]
 800ddb2:	3302      	adds	r3, #2
    for (n = 0; n < 8; n++)
 800ddb4:	4283      	cmp	r3, r0
 800ddb6:	d1f9      	bne.n	800ddac <request_to_draw_cells_behind_menu+0x1c>
  for (m = 7; m <= 9; m++)
 800ddb8:	3401      	adds	r4, #1
 800ddba:	2c0a      	cmp	r4, #10
 800ddbc:	d1f2      	bne.n	800dda4 <request_to_draw_cells_behind_menu+0x14>
  redraw_request |= REDRAW_CELLS;
 800ddbe:	2101      	movs	r1, #1
 800ddc0:	4a04      	ldr	r2, [pc, #16]	; (800ddd4 <request_to_draw_cells_behind_menu+0x44>)
 800ddc2:	8813      	ldrh	r3, [r2, #0]
 800ddc4:	430b      	orrs	r3, r1
 800ddc6:	8013      	strh	r3, [r2, #0]
}
 800ddc8:	bd70      	pop	{r4, r5, r6, pc}
 800ddca:	46c0      	nop			; (mov r8, r8)
 800ddcc:	200029fc 	.word	0x200029fc
 800ddd0:	20002a04 	.word	0x20002a04
 800ddd4:	20002236 	.word	0x20002236
	...

0800dde0 <request_to_draw_cells_behind_numeric_input>:
{
 800dde0:	b5f0      	push	{r4, r5, r6, r7, lr}
  for (m = 0; m <= 9; m++)
 800dde2:	2400      	movs	r4, #0
    markmap[current_mappage][y] |= 1<<x;
 800dde4:	2501      	movs	r5, #1
 800dde6:	4b0d      	ldr	r3, [pc, #52]	; (800de1c <request_to_draw_cells_behind_numeric_input+0x3c>)
 800dde8:	4e0d      	ldr	r6, [pc, #52]	; (800de20 <request_to_draw_cells_behind_numeric_input+0x40>)
 800ddea:	881f      	ldrh	r7, [r3, #0]
 800ddec:	013f      	lsls	r7, r7, #4
 800ddee:	19f3      	adds	r3, r6, r7
 800ddf0:	8998      	ldrh	r0, [r3, #12]
 800ddf2:	89d9      	ldrh	r1, [r3, #14]
 800ddf4:	002a      	movs	r2, r5
 800ddf6:	40a2      	lsls	r2, r4
 800ddf8:	b212      	sxth	r2, r2
 800ddfa:	4310      	orrs	r0, r2
 800ddfc:	4311      	orrs	r1, r2
  for (m = 0; m <= 9; m++)
 800ddfe:	3401      	adds	r4, #1
    markmap[current_mappage][y] |= 1<<x;
 800de00:	b280      	uxth	r0, r0
 800de02:	b289      	uxth	r1, r1
  for (m = 0; m <= 9; m++)
 800de04:	2c0a      	cmp	r4, #10
 800de06:	d1f5      	bne.n	800ddf4 <request_to_draw_cells_behind_numeric_input+0x14>
 800de08:	19f6      	adds	r6, r6, r7
 800de0a:	81f1      	strh	r1, [r6, #14]
  redraw_request |= REDRAW_CELLS;
 800de0c:	2101      	movs	r1, #1
 800de0e:	4a05      	ldr	r2, [pc, #20]	; (800de24 <request_to_draw_cells_behind_numeric_input+0x44>)
 800de10:	81b0      	strh	r0, [r6, #12]
 800de12:	8813      	ldrh	r3, [r2, #0]
 800de14:	430b      	orrs	r3, r1
 800de16:	8013      	strh	r3, [r2, #0]
}
 800de18:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800de1a:	46c0      	nop			; (mov r8, r8)
 800de1c:	200029fc 	.word	0x200029fc
 800de20:	20002a04 	.word	0x20002a04
 800de24:	20002236 	.word	0x20002236
	...

0800de30 <draw_frequencies>:

void draw_frequencies(void)
{
 800de30:	b5f0      	push	{r4, r5, r6, r7, lr}
  char buf[24];
  if ((domain_mode & DOMAIN_MODE) == DOMAIN_FREQ) {
 800de32:	2401      	movs	r4, #1
 800de34:	4e71      	ldr	r6, [pc, #452]	; (800dffc <draw_frequencies+0x1cc>)
 800de36:	4b72      	ldr	r3, [pc, #456]	; (800e000 <draw_frequencies+0x1d0>)
{
 800de38:	b089      	sub	sp, #36	; 0x24
  if ((domain_mode & DOMAIN_MODE) == DOMAIN_FREQ) {
 800de3a:	5cf3      	ldrb	r3, [r6, r3]
 800de3c:	401c      	ands	r4, r3
 800de3e:	d000      	beq.n	800de42 <draw_frequencies+0x12>
 800de40:	e06e      	b.n	800df20 <draw_frequencies+0xf0>
      if (frequency1 > 0) {
 800de42:	68b5      	ldr	r5, [r6, #8]
 800de44:	6877      	ldr	r7, [r6, #4]
 800de46:	2d00      	cmp	r5, #0
 800de48:	dc31      	bgt.n	800deae <draw_frequencies+0x7e>
        ili9341_drawstring_7x13(buf, OFFSETX, 229, 0xffff, 0x0000);
        strcpy(buf, "STOP ");
        frequency_string(buf+5, 24-5, stop);
        strcat(buf, "    ");
         ili9341_drawstring_7x13(buf, 208, 229, 0xffff, 0x0000);
      } else if (frequency1 < 0) {
 800de4a:	d000      	beq.n	800de4e <draw_frequencies+0x1e>
 800de4c:	e0b4      	b.n	800dfb8 <draw_frequencies+0x188>
        frequency_string(buf+5, 24-5, fspan);
        strcat(buf, "    ");
        ili9341_drawstring_7x13(buf, 208, 229, 0xffff, 0x0000);
      } else {
        int fcenter = frequency0;
        chsnprintf(buf, 24, "CW %d.%03d %03d MHz    ",
 800de4e:	496d      	ldr	r1, [pc, #436]	; (800e004 <draw_frequencies+0x1d4>)
 800de50:	0038      	movs	r0, r7
 800de52:	f7f2 fa4d 	bl	80002f0 <__divsi3>
 800de56:	21fa      	movs	r1, #250	; 0xfa
 800de58:	0004      	movs	r4, r0
 800de5a:	0089      	lsls	r1, r1, #2
 800de5c:	0038      	movs	r0, r7
 800de5e:	f7f2 fb2d 	bl	80004bc <__aeabi_idivmod>
 800de62:	9101      	str	r1, [sp, #4]
                   (int)(fcenter / 1000000),
                   (int)((fcenter / 1000) % 1000),
 800de64:	21fa      	movs	r1, #250	; 0xfa
 800de66:	0038      	movs	r0, r7
 800de68:	0089      	lsls	r1, r1, #2
 800de6a:	f7f2 fa41 	bl	80002f0 <__divsi3>
        chsnprintf(buf, 24, "CW %d.%03d %03d MHz    ",
 800de6e:	21fa      	movs	r1, #250	; 0xfa
 800de70:	0089      	lsls	r1, r1, #2
 800de72:	f7f2 fb23 	bl	80004bc <__aeabi_idivmod>
 800de76:	0023      	movs	r3, r4
 800de78:	9100      	str	r1, [sp, #0]
 800de7a:	4a63      	ldr	r2, [pc, #396]	; (800e008 <draw_frequencies+0x1d8>)
 800de7c:	2118      	movs	r1, #24
 800de7e:	a802      	add	r0, sp, #8
 800de80:	f7f9 fb56 	bl	8007530 <chsnprintf>
                   (int)(fcenter % 1000));
        ili9341_drawstring_7x13(buf, OFFSETX, 229, 0xffff, 0x0000);
 800de84:	4b61      	ldr	r3, [pc, #388]	; (800e00c <draw_frequencies+0x1dc>)
 800de86:	22e5      	movs	r2, #229	; 0xe5
 800de88:	2112      	movs	r1, #18
 800de8a:	a802      	add	r0, sp, #8
 800de8c:	9500      	str	r5, [sp, #0]
 800de8e:	f002 fcdf 	bl	8010850 <ili9341_drawstring_7x13>
        chsnprintf(buf, 24, "                             ");
 800de92:	4a5f      	ldr	r2, [pc, #380]	; (800e010 <draw_frequencies+0x1e0>)
 800de94:	2118      	movs	r1, #24
 800de96:	a802      	add	r0, sp, #8
 800de98:	f7f9 fb4a 	bl	8007530 <chsnprintf>
        ili9341_drawstring_7x13(buf, 208, 229, 0xffff, 0x0000);
 800de9c:	9500      	str	r5, [sp, #0]
 800de9e:	4b5b      	ldr	r3, [pc, #364]	; (800e00c <draw_frequencies+0x1dc>)
 800dea0:	22e5      	movs	r2, #229	; 0xe5
 800dea2:	21d0      	movs	r1, #208	; 0xd0
 800dea4:	a802      	add	r0, sp, #8
 800dea6:	f002 fcd3 	bl	8010850 <ili9341_drawstring_7x13>
      strcpy(buf, "STOP ");
      chsnprintf(buf+5, 24-5, "%d ns", (uint16_t)(time_of_index(POINT_COUNT-1) * 1e9));
      strcat(buf, "          ");
      ili9341_drawstring_7x13(buf, 208, 229, 0xffff, 0x0000);
  }
}
 800deaa:	b009      	add	sp, #36	; 0x24
 800deac:	bdf0      	pop	{r4, r5, r6, r7, pc}
        frequency_string(buf+6, 24-6, start);
 800deae:	200e      	movs	r0, #14
        strcpy(buf, "START ");
 800deb0:	4b58      	ldr	r3, [pc, #352]	; (800e014 <draw_frequencies+0x1e4>)
 800deb2:	ae02      	add	r6, sp, #8
 800deb4:	681a      	ldr	r2, [r3, #0]
        frequency_string(buf+6, 24-6, start);
 800deb6:	2112      	movs	r1, #18
        strcpy(buf, "START ");
 800deb8:	9202      	str	r2, [sp, #8]
 800deba:	889a      	ldrh	r2, [r3, #4]
        frequency_string(buf+6, 24-6, start);
 800debc:	4468      	add	r0, sp
        strcpy(buf, "START ");
 800debe:	80b2      	strh	r2, [r6, #4]
 800dec0:	799b      	ldrb	r3, [r3, #6]
        frequency_string(buf+6, 24-6, start);
 800dec2:	003a      	movs	r2, r7
        strcpy(buf, "START ");
 800dec4:	71b3      	strb	r3, [r6, #6]
        frequency_string(buf+6, 24-6, start);
 800dec6:	f7fd fd9b 	bl	800ba00 <frequency_string>
        strcat(buf, "    ");
 800deca:	0030      	movs	r0, r6
 800decc:	f7f5 fc90 	bl	80037f0 <strlen>
 800ded0:	4f51      	ldr	r7, [pc, #324]	; (800e018 <draw_frequencies+0x1e8>)
 800ded2:	2205      	movs	r2, #5
 800ded4:	0039      	movs	r1, r7
 800ded6:	1830      	adds	r0, r6, r0
 800ded8:	f005 f8fa 	bl	80130d0 <memcpy>
        ili9341_drawstring_7x13(buf, OFFSETX, 229, 0xffff, 0x0000);
 800dedc:	4b4b      	ldr	r3, [pc, #300]	; (800e00c <draw_frequencies+0x1dc>)
 800dede:	22e5      	movs	r2, #229	; 0xe5
 800dee0:	9400      	str	r4, [sp, #0]
 800dee2:	2112      	movs	r1, #18
 800dee4:	0030      	movs	r0, r6
 800dee6:	f002 fcb3 	bl	8010850 <ili9341_drawstring_7x13>
        strcpy(buf, "STOP ");
 800deea:	4b4c      	ldr	r3, [pc, #304]	; (800e01c <draw_frequencies+0x1ec>)
 800deec:	681a      	ldr	r2, [r3, #0]
 800deee:	9202      	str	r2, [sp, #8]
        frequency_string(buf+5, 24-5, stop);
 800def0:	002a      	movs	r2, r5
        strcpy(buf, "STOP ");
 800def2:	889b      	ldrh	r3, [r3, #4]
 800def4:	80b3      	strh	r3, [r6, #4]
        frequency_string(buf+5, 24-5, fspan);
 800def6:	200d      	movs	r0, #13
 800def8:	2113      	movs	r1, #19
 800defa:	4468      	add	r0, sp
 800defc:	f7fd fd80 	bl	800ba00 <frequency_string>
        strcat(buf, "    ");
 800df00:	0030      	movs	r0, r6
 800df02:	f7f5 fc75 	bl	80037f0 <strlen>
 800df06:	0039      	movs	r1, r7
 800df08:	1830      	adds	r0, r6, r0
 800df0a:	2205      	movs	r2, #5
 800df0c:	f005 f8e0 	bl	80130d0 <memcpy>
        ili9341_drawstring_7x13(buf, 208, 229, 0xffff, 0x0000);
 800df10:	9400      	str	r4, [sp, #0]
 800df12:	4b3e      	ldr	r3, [pc, #248]	; (800e00c <draw_frequencies+0x1dc>)
 800df14:	22e5      	movs	r2, #229	; 0xe5
 800df16:	21d0      	movs	r1, #208	; 0xd0
 800df18:	0030      	movs	r0, r6
 800df1a:	f002 fc99 	bl	8010850 <ili9341_drawstring_7x13>
 800df1e:	e7c4      	b.n	800deaa <draw_frequencies+0x7a>
      strcpy(buf, "START 0s        ");
 800df20:	ac02      	add	r4, sp, #8
 800df22:	0022      	movs	r2, r4
 800df24:	4b3e      	ldr	r3, [pc, #248]	; (800e020 <draw_frequencies+0x1f0>)
 800df26:	cb23      	ldmia	r3!, {r0, r1, r5}
 800df28:	c223      	stmia	r2!, {r0, r1, r5}
      ili9341_drawstring_7x13(buf, OFFSETX, 229, 0xffff, 0x0000);
 800df2a:	2500      	movs	r5, #0
      strcpy(buf, "START 0s        ");
 800df2c:	6819      	ldr	r1, [r3, #0]
      ili9341_drawstring_7x13(buf, OFFSETX, 229, 0xffff, 0x0000);
 800df2e:	0020      	movs	r0, r4
      strcpy(buf, "START 0s        ");
 800df30:	6011      	str	r1, [r2, #0]
 800df32:	791b      	ldrb	r3, [r3, #4]
      ili9341_drawstring_7x13(buf, OFFSETX, 229, 0xffff, 0x0000);
 800df34:	2112      	movs	r1, #18
      strcpy(buf, "START 0s        ");
 800df36:	7113      	strb	r3, [r2, #4]
      ili9341_drawstring_7x13(buf, OFFSETX, 229, 0xffff, 0x0000);
 800df38:	9500      	str	r5, [sp, #0]
 800df3a:	4b34      	ldr	r3, [pc, #208]	; (800e00c <draw_frequencies+0x1dc>)
 800df3c:	22e5      	movs	r2, #229	; 0xe5
 800df3e:	f002 fc87 	bl	8010850 <ili9341_drawstring_7x13>
      strcpy(buf, "STOP ");
 800df42:	4b36      	ldr	r3, [pc, #216]	; (800e01c <draw_frequencies+0x1ec>)
 800df44:	681a      	ldr	r2, [r3, #0]
 800df46:	9202      	str	r2, [sp, #8]
 800df48:	889b      	ldrh	r3, [r3, #4]
 800df4a:	80a3      	strh	r3, [r4, #4]
   return 1.0 / (float)(frequencies[1] - frequencies[0]) / (float)FFT_SIZE * idx;
 800df4c:	6933      	ldr	r3, [r6, #16]
 800df4e:	6970      	ldr	r0, [r6, #20]
 800df50:	1ac0      	subs	r0, r0, r3
 800df52:	f7f3 fb95 	bl	8001680 <__aeabi_ui2f>
 800df56:	f7f5 fa43 	bl	80033e0 <__aeabi_f2d>
 800df5a:	0002      	movs	r2, r0
 800df5c:	000b      	movs	r3, r1
 800df5e:	2000      	movs	r0, #0
 800df60:	4930      	ldr	r1, [pc, #192]	; (800e024 <draw_frequencies+0x1f4>)
 800df62:	f7f3 ff45 	bl	8001df0 <__aeabi_ddiv>
 800df66:	2200      	movs	r2, #0
 800df68:	4b2f      	ldr	r3, [pc, #188]	; (800e028 <draw_frequencies+0x1f8>)
 800df6a:	f7f4 fb49 	bl	8002600 <__aeabi_dmul>
 800df6e:	2200      	movs	r2, #0
 800df70:	4b2e      	ldr	r3, [pc, #184]	; (800e02c <draw_frequencies+0x1fc>)
 800df72:	f7f4 fb45 	bl	8002600 <__aeabi_dmul>
 800df76:	f7f5 fa8b 	bl	8003490 <__aeabi_d2f>
      chsnprintf(buf+5, 24-5, "%d ns", (uint16_t)(time_of_index(POINT_COUNT-1) * 1e9));
 800df7a:	f7f5 fa31 	bl	80033e0 <__aeabi_f2d>
 800df7e:	2200      	movs	r2, #0
 800df80:	4b2b      	ldr	r3, [pc, #172]	; (800e030 <draw_frequencies+0x200>)
 800df82:	f7f4 fb3d 	bl	8002600 <__aeabi_dmul>
 800df86:	f7f2 fbbb 	bl	8000700 <__aeabi_d2uiz>
 800df8a:	b283      	uxth	r3, r0
 800df8c:	200d      	movs	r0, #13
 800df8e:	4a29      	ldr	r2, [pc, #164]	; (800e034 <draw_frequencies+0x204>)
 800df90:	2113      	movs	r1, #19
 800df92:	4468      	add	r0, sp
 800df94:	f7f9 facc 	bl	8007530 <chsnprintf>
      strcat(buf, "          ");
 800df98:	0020      	movs	r0, r4
 800df9a:	f7f5 fc29 	bl	80037f0 <strlen>
 800df9e:	220b      	movs	r2, #11
 800dfa0:	1820      	adds	r0, r4, r0
 800dfa2:	4925      	ldr	r1, [pc, #148]	; (800e038 <draw_frequencies+0x208>)
 800dfa4:	f005 f894 	bl	80130d0 <memcpy>
      ili9341_drawstring_7x13(buf, 208, 229, 0xffff, 0x0000);
 800dfa8:	9500      	str	r5, [sp, #0]
 800dfaa:	4b18      	ldr	r3, [pc, #96]	; (800e00c <draw_frequencies+0x1dc>)
 800dfac:	22e5      	movs	r2, #229	; 0xe5
 800dfae:	21d0      	movs	r1, #208	; 0xd0
 800dfb0:	0020      	movs	r0, r4
 800dfb2:	f002 fc4d 	bl	8010850 <ili9341_drawstring_7x13>
}
 800dfb6:	e778      	b.n	800deaa <draw_frequencies+0x7a>
        strcpy(buf, "CENTER ");
 800dfb8:	ae02      	add	r6, sp, #8
 800dfba:	0032      	movs	r2, r6
 800dfbc:	4b1f      	ldr	r3, [pc, #124]	; (800e03c <draw_frequencies+0x20c>)
 800dfbe:	cb03      	ldmia	r3!, {r0, r1}
 800dfc0:	c203      	stmia	r2!, {r0, r1}
        frequency_string(buf+7, 24-7, fcenter);
 800dfc2:	200f      	movs	r0, #15
 800dfc4:	003a      	movs	r2, r7
 800dfc6:	2111      	movs	r1, #17
 800dfc8:	4468      	add	r0, sp
 800dfca:	f7fd fd19 	bl	800ba00 <frequency_string>
        strcat(buf, "    ");
 800dfce:	0030      	movs	r0, r6
 800dfd0:	f7f5 fc0e 	bl	80037f0 <strlen>
 800dfd4:	4f10      	ldr	r7, [pc, #64]	; (800e018 <draw_frequencies+0x1e8>)
 800dfd6:	2205      	movs	r2, #5
 800dfd8:	0039      	movs	r1, r7
 800dfda:	1830      	adds	r0, r6, r0
 800dfdc:	f005 f878 	bl	80130d0 <memcpy>
         ili9341_drawstring_7x13(buf, OFFSETX, 229, 0xffff, 0x0000);
 800dfe0:	4b0a      	ldr	r3, [pc, #40]	; (800e00c <draw_frequencies+0x1dc>)
 800dfe2:	22e5      	movs	r2, #229	; 0xe5
 800dfe4:	9400      	str	r4, [sp, #0]
 800dfe6:	2112      	movs	r1, #18
 800dfe8:	0030      	movs	r0, r6
 800dfea:	f002 fc31 	bl	8010850 <ili9341_drawstring_7x13>
        strcpy(buf, "SPAN ");
 800dfee:	4b14      	ldr	r3, [pc, #80]	; (800e040 <draw_frequencies+0x210>)
 800dff0:	681a      	ldr	r2, [r3, #0]
 800dff2:	9202      	str	r2, [sp, #8]
 800dff4:	889b      	ldrh	r3, [r3, #4]
        int fspan = -frequency1;
 800dff6:	426a      	negs	r2, r5
        strcpy(buf, "SPAN ");
 800dff8:	80b3      	strh	r3, [r6, #4]
        frequency_string(buf+5, 24-5, fspan);
 800dffa:	e77c      	b.n	800def6 <draw_frequencies+0xc6>
 800dffc:	20000454 	.word	0x20000454
 800e000:	000011c4 	.word	0x000011c4
 800e004:	000f4240 	.word	0x000f4240
 800e008:	08014a24 	.word	0x08014a24
 800e00c:	0000ffff 	.word	0x0000ffff
 800e010:	08014a3c 	.word	0x08014a3c
 800e014:	08014a04 	.word	0x08014a04
 800e018:	08014a68 	.word	0x08014a68
 800e01c:	08014a0c 	.word	0x08014a0c
 800e020:	08014a5c 	.word	0x08014a5c
 800e024:	3ff00000 	.word	0x3ff00000
 800e028:	3f700000 	.word	0x3f700000
 800e02c:	40590000 	.word	0x40590000
 800e030:	41cdcd65 	.word	0x41cdcd65
 800e034:	08014a70 	.word	0x08014a70
 800e038:	08014a78 	.word	0x08014a78
 800e03c:	08014a14 	.word	0x08014a14
 800e040:	08014a1c 	.word	0x08014a1c
	...

0800e050 <draw_cal_status>:
draw_cal_status(void)
{
  int x = 0;
  int y = 100;
#define YSTEP 13
  ili9341_fill(0, y, 14, 6*YSTEP, 0x0000);
 800e050:	2300      	movs	r3, #0
{
 800e052:	b530      	push	{r4, r5, lr}
 800e054:	b085      	sub	sp, #20
  ili9341_fill(0, y, 14, 6*YSTEP, 0x0000);
 800e056:	9300      	str	r3, [sp, #0]
 800e058:	220e      	movs	r2, #14
 800e05a:	334e      	adds	r3, #78	; 0x4e
 800e05c:	2164      	movs	r1, #100	; 0x64
 800e05e:	2000      	movs	r0, #0
 800e060:	f002 fab6 	bl	80105d0 <ili9341_fill>
  if (cal_status & CALSTAT_APPLY) {
 800e064:	4d31      	ldr	r5, [pc, #196]	; (800e12c <draw_cal_status+0xdc>)
  int y = 100;
 800e066:	2464      	movs	r4, #100	; 0x64
  if (cal_status & CALSTAT_APPLY) {
 800e068:	89eb      	ldrh	r3, [r5, #14]
 800e06a:	05da      	lsls	r2, r3, #23
 800e06c:	d516      	bpl.n	800e09c <draw_cal_status+0x4c>
    char c[3] = "C0";
 800e06e:	4a30      	ldr	r2, [pc, #192]	; (800e130 <draw_cal_status+0xe0>)
 800e070:	a803      	add	r0, sp, #12
 800e072:	8811      	ldrh	r1, [r2, #0]
 800e074:	8001      	strh	r1, [r0, #0]
 800e076:	7892      	ldrb	r2, [r2, #2]
 800e078:	7082      	strb	r2, [r0, #2]
    c[1] += lastsaveid;
 800e07a:	4a2e      	ldr	r2, [pc, #184]	; (800e134 <draw_cal_status+0xe4>)
 800e07c:	8812      	ldrh	r2, [r2, #0]
 800e07e:	3230      	adds	r2, #48	; 0x30
 800e080:	7042      	strb	r2, [r0, #1]
    if (cal_status & CALSTAT_INTERPOLATED)
 800e082:	059b      	lsls	r3, r3, #22
 800e084:	d516      	bpl.n	800e0b4 <draw_cal_status+0x64>
      c[0] = 'c';
 800e086:	2363      	movs	r3, #99	; 0x63
 800e088:	7003      	strb	r3, [r0, #0]
    else if (active_props == &current_props)
      c[1] = '*';
    ili9341_drawstring_7x13(c, x, y, 0xffff, 0x0000);
 800e08a:	2300      	movs	r3, #0
    y += YSTEP;
 800e08c:	2471      	movs	r4, #113	; 0x71
    ili9341_drawstring_7x13(c, x, y, 0xffff, 0x0000);
 800e08e:	9300      	str	r3, [sp, #0]
 800e090:	2264      	movs	r2, #100	; 0x64
 800e092:	4b29      	ldr	r3, [pc, #164]	; (800e138 <draw_cal_status+0xe8>)
 800e094:	2100      	movs	r1, #0
 800e096:	f002 fbdb 	bl	8010850 <ili9341_drawstring_7x13>
    y += YSTEP;
 800e09a:	89eb      	ldrh	r3, [r5, #14]
  }

  if (cal_status & CALSTAT_ED) {
 800e09c:	07da      	lsls	r2, r3, #31
 800e09e:	d43a      	bmi.n	800e116 <draw_cal_status+0xc6>
    ili9341_drawstring_7x13("D", x, y, 0xffff, 0x0000);
    y += YSTEP;
  }
  if (cal_status & CALSTAT_ER) {
 800e0a0:	065a      	lsls	r2, r3, #25
 800e0a2:	d42d      	bmi.n	800e100 <draw_cal_status+0xb0>
    ili9341_drawstring_7x13("R", x, y, 0xffff, 0x0000);
    y += YSTEP;
  }
  if (cal_status & CALSTAT_ES) {
 800e0a4:	069a      	lsls	r2, r3, #26
 800e0a6:	d420      	bmi.n	800e0ea <draw_cal_status+0x9a>
    ili9341_drawstring_7x13("S", x, y, 0xffff, 0x0000);
    y += YSTEP;
  }
  if (cal_status & CALSTAT_ET) {
 800e0a8:	061a      	lsls	r2, r3, #24
 800e0aa:	d413      	bmi.n	800e0d4 <draw_cal_status+0x84>
    ili9341_drawstring_7x13("T", x, y, 0xffff, 0x0000);
    y += YSTEP;
  }
  if (cal_status & CALSTAT_EX) {
 800e0ac:	06db      	lsls	r3, r3, #27
 800e0ae:	d408      	bmi.n	800e0c2 <draw_cal_status+0x72>
    ili9341_drawstring_7x13("X", x, y, 0xffff, 0x0000);
    y += YSTEP;
  }
}
 800e0b0:	b005      	add	sp, #20
 800e0b2:	bd30      	pop	{r4, r5, pc}
    else if (active_props == &current_props)
 800e0b4:	4b21      	ldr	r3, [pc, #132]	; (800e13c <draw_cal_status+0xec>)
 800e0b6:	681b      	ldr	r3, [r3, #0]
 800e0b8:	42ab      	cmp	r3, r5
 800e0ba:	d1e6      	bne.n	800e08a <draw_cal_status+0x3a>
      c[1] = '*';
 800e0bc:	232a      	movs	r3, #42	; 0x2a
 800e0be:	7043      	strb	r3, [r0, #1]
 800e0c0:	e7e3      	b.n	800e08a <draw_cal_status+0x3a>
    ili9341_drawstring_7x13("X", x, y, 0xffff, 0x0000);
 800e0c2:	2300      	movs	r3, #0
 800e0c4:	0022      	movs	r2, r4
 800e0c6:	9300      	str	r3, [sp, #0]
 800e0c8:	2100      	movs	r1, #0
 800e0ca:	4b1b      	ldr	r3, [pc, #108]	; (800e138 <draw_cal_status+0xe8>)
 800e0cc:	481c      	ldr	r0, [pc, #112]	; (800e140 <draw_cal_status+0xf0>)
 800e0ce:	f002 fbbf 	bl	8010850 <ili9341_drawstring_7x13>
}
 800e0d2:	e7ed      	b.n	800e0b0 <draw_cal_status+0x60>
    ili9341_drawstring_7x13("T", x, y, 0xffff, 0x0000);
 800e0d4:	2300      	movs	r3, #0
 800e0d6:	0022      	movs	r2, r4
 800e0d8:	9300      	str	r3, [sp, #0]
 800e0da:	2100      	movs	r1, #0
 800e0dc:	4b16      	ldr	r3, [pc, #88]	; (800e138 <draw_cal_status+0xe8>)
 800e0de:	4819      	ldr	r0, [pc, #100]	; (800e144 <draw_cal_status+0xf4>)
 800e0e0:	f002 fbb6 	bl	8010850 <ili9341_drawstring_7x13>
    y += YSTEP;
 800e0e4:	340d      	adds	r4, #13
 800e0e6:	89eb      	ldrh	r3, [r5, #14]
 800e0e8:	e7e0      	b.n	800e0ac <draw_cal_status+0x5c>
    ili9341_drawstring_7x13("S", x, y, 0xffff, 0x0000);
 800e0ea:	2300      	movs	r3, #0
 800e0ec:	0022      	movs	r2, r4
 800e0ee:	9300      	str	r3, [sp, #0]
 800e0f0:	2100      	movs	r1, #0
 800e0f2:	4b11      	ldr	r3, [pc, #68]	; (800e138 <draw_cal_status+0xe8>)
 800e0f4:	4814      	ldr	r0, [pc, #80]	; (800e148 <draw_cal_status+0xf8>)
 800e0f6:	f002 fbab 	bl	8010850 <ili9341_drawstring_7x13>
    y += YSTEP;
 800e0fa:	340d      	adds	r4, #13
 800e0fc:	89eb      	ldrh	r3, [r5, #14]
 800e0fe:	e7d3      	b.n	800e0a8 <draw_cal_status+0x58>
    ili9341_drawstring_7x13("R", x, y, 0xffff, 0x0000);
 800e100:	2300      	movs	r3, #0
 800e102:	0022      	movs	r2, r4
 800e104:	9300      	str	r3, [sp, #0]
 800e106:	2100      	movs	r1, #0
 800e108:	4b0b      	ldr	r3, [pc, #44]	; (800e138 <draw_cal_status+0xe8>)
 800e10a:	4810      	ldr	r0, [pc, #64]	; (800e14c <draw_cal_status+0xfc>)
 800e10c:	f002 fba0 	bl	8010850 <ili9341_drawstring_7x13>
    y += YSTEP;
 800e110:	340d      	adds	r4, #13
 800e112:	89eb      	ldrh	r3, [r5, #14]
 800e114:	e7c6      	b.n	800e0a4 <draw_cal_status+0x54>
    ili9341_drawstring_7x13("D", x, y, 0xffff, 0x0000);
 800e116:	2300      	movs	r3, #0
 800e118:	0022      	movs	r2, r4
 800e11a:	9300      	str	r3, [sp, #0]
 800e11c:	2100      	movs	r1, #0
 800e11e:	4b06      	ldr	r3, [pc, #24]	; (800e138 <draw_cal_status+0xe8>)
 800e120:	480b      	ldr	r0, [pc, #44]	; (800e150 <draw_cal_status+0x100>)
 800e122:	f002 fb95 	bl	8010850 <ili9341_drawstring_7x13>
    y += YSTEP;
 800e126:	340d      	adds	r4, #13
 800e128:	89eb      	ldrh	r3, [r5, #14]
 800e12a:	e7b9      	b.n	800e0a0 <draw_cal_status+0x50>
 800e12c:	20000454 	.word	0x20000454
 800e130:	08014a00 	.word	0x08014a00
 800e134:	200038b0 	.word	0x200038b0
 800e138:	0000ffff 	.word	0x0000ffff
 800e13c:	20000428 	.word	0x20000428
 800e140:	08013c88 	.word	0x08013c88
 800e144:	08015634 	.word	0x08015634
 800e148:	08014ad4 	.word	0x08014ad4
 800e14c:	08014718 	.word	0x08014718
 800e150:	08013c70 	.word	0x08013c70
	...

0800e160 <draw_all>:
{
 800e160:	b510      	push	{r4, lr}
    if (redraw_request & REDRAW_CELLS)
 800e162:	4c0c      	ldr	r4, [pc, #48]	; (800e194 <draw_all+0x34>)
 800e164:	8823      	ldrh	r3, [r4, #0]
 800e166:	07da      	lsls	r2, r3, #31
 800e168:	d406      	bmi.n	800e178 <draw_all+0x18>
    if (redraw_request & REDRAW_FREQUENCY)
 800e16a:	079a      	lsls	r2, r3, #30
 800e16c:	d409      	bmi.n	800e182 <draw_all+0x22>
    if (redraw_request & REDRAW_CAL_STATUS)
 800e16e:	075b      	lsls	r3, r3, #29
 800e170:	d40c      	bmi.n	800e18c <draw_all+0x2c>
    redraw_request = 0;
 800e172:	2300      	movs	r3, #0
 800e174:	8023      	strh	r3, [r4, #0]
}
 800e176:	bd10      	pop	{r4, pc}
        draw_all_cells(flush);
 800e178:	f7fd fffa 	bl	800c170 <draw_all_cells>
 800e17c:	8823      	ldrh	r3, [r4, #0]
    if (redraw_request & REDRAW_FREQUENCY)
 800e17e:	079a      	lsls	r2, r3, #30
 800e180:	d5f5      	bpl.n	800e16e <draw_all+0xe>
        draw_frequencies();
 800e182:	f7ff fe55 	bl	800de30 <draw_frequencies>
 800e186:	8823      	ldrh	r3, [r4, #0]
    if (redraw_request & REDRAW_CAL_STATUS)
 800e188:	075b      	lsls	r3, r3, #29
 800e18a:	d5f2      	bpl.n	800e172 <draw_all+0x12>
        draw_cal_status();
 800e18c:	f7ff ff60 	bl	800e050 <draw_cal_status>
 800e190:	e7ef      	b.n	800e172 <draw_all+0x12>
 800e192:	46c0      	nop			; (mov r8, r8)
 800e194:	20002236 	.word	0x20002236
	...

0800e1a0 <draw_battery_status>:

#endif


void draw_battery_status(void)
{
 800e1a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    chMtxLock(&mutex_ili9341); // [protect spi_buffer]
 800e1a2:	4e5c      	ldr	r6, [pc, #368]	; (800e314 <draw_battery_status+0x174>)
 800e1a4:	0030      	movs	r0, r6
 800e1a6:	f7f5 ff8b 	bl	80040c0 <chMtxLock>
    int w = 10, h = 14;
    int x = 0, y = 0;
    int i, c;
    uint16_t *buf = spi_buffer;
    uint8_t vbati = vbat2bati(vbat);
 800e1aa:	4b5b      	ldr	r3, [pc, #364]	; (800e318 <draw_battery_status+0x178>)
 800e1ac:	2200      	movs	r2, #0
 800e1ae:	5e9b      	ldrsh	r3, [r3, r2]
#define PULSE { palClearPad(GPIOC, GPIOC_LED); palSetPad(GPIOC, GPIOC_LED);}

    // convert vbat [mV] to battery indicator
    static inline uint8_t vbat2bati(int16_t vbat)
    {
    	if (vbat < 3200) return 0;
 800e1b0:	4a5a      	ldr	r2, [pc, #360]	; (800e31c <draw_battery_status+0x17c>)
 800e1b2:	4293      	cmp	r3, r2
 800e1b4:	dc00      	bgt.n	800e1b8 <draw_battery_status+0x18>
 800e1b6:	e0a1      	b.n	800e2fc <draw_battery_status+0x15c>
    	if (vbat < 3450) return 25;
 800e1b8:	4a59      	ldr	r2, [pc, #356]	; (800e320 <draw_battery_status+0x180>)
 800e1ba:	4293      	cmp	r3, r2
 800e1bc:	dc00      	bgt.n	800e1c0 <draw_battery_status+0x20>
 800e1be:	e0a3      	b.n	800e308 <draw_battery_status+0x168>
    	if (vbat < 3700) return 50;
 800e1c0:	4a58      	ldr	r2, [pc, #352]	; (800e324 <draw_battery_status+0x184>)
 800e1c2:	4293      	cmp	r3, r2
 800e1c4:	dc00      	bgt.n	800e1c8 <draw_battery_status+0x28>
 800e1c6:	e09c      	b.n	800e302 <draw_battery_status+0x162>
    	if (vbat < 4100) return 75;
 800e1c8:	4a57      	ldr	r2, [pc, #348]	; (800e328 <draw_battery_status+0x188>)
 800e1ca:	4293      	cmp	r3, r2
 800e1cc:	dc00      	bgt.n	800e1d0 <draw_battery_status+0x30>
 800e1ce:	e09e      	b.n	800e30e <draw_battery_status+0x16e>
 800e1d0:	2700      	movs	r7, #0
    uint16_t col = vbati == 0 ? RGBHEX(0xff0000)  : RGBHEX(0x1fe300);
 800e1d2:	251f      	movs	r5, #31
    memset(spi_buffer, 0, w * h * 2);
 800e1d4:	228c      	movs	r2, #140	; 0x8c
 800e1d6:	4c55      	ldr	r4, [pc, #340]	; (800e32c <draw_battery_status+0x18c>)
 800e1d8:	0052      	lsls	r2, r2, #1
 800e1da:	2100      	movs	r1, #0
 800e1dc:	0020      	movs	r0, r4
 800e1de:	f004 ff87 	bl	80130f0 <memset>
    for (c = 0; c < 3; c++) {
        y++;
        x = 1;
        buf[y * w + x++] = col;
        x++; x++; x++; x++; x++; x++;
        buf[y * w + x++] = col;
 800e1e2:	234c      	movs	r3, #76	; 0x4c
 800e1e4:	52e5      	strh	r5, [r4, r3]

        y++;
        x = 1;
        buf[y * w + x++] = col;
 800e1e6:	3306      	adds	r3, #6
    buf[y * w + x++] = col;
 800e1e8:	80e5      	strh	r5, [r4, #6]
    buf[y * w + x++] = col;
 800e1ea:	8125      	strh	r5, [r4, #8]
    buf[y * w + x++] = col;
 800e1ec:	8165      	strh	r5, [r4, #10]
    buf[y * w + x++] = col;
 800e1ee:	81a5      	strh	r5, [r4, #12]
    buf[y * w + x++] = col;
 800e1f0:	8365      	strh	r5, [r4, #26]
    buf[y * w + x++] = col;
 800e1f2:	8425      	strh	r5, [r4, #32]
        buf[y * w + x++] = col;
 800e1f4:	8565      	strh	r5, [r4, #42]	; 0x2a
 800e1f6:	85a5      	strh	r5, [r4, #44]	; 0x2c
 800e1f8:	85e5      	strh	r5, [r4, #46]	; 0x2e
 800e1fa:	8625      	strh	r5, [r4, #48]	; 0x30
 800e1fc:	8665      	strh	r5, [r4, #50]	; 0x32
 800e1fe:	86a5      	strh	r5, [r4, #52]	; 0x34
 800e200:	86e5      	strh	r5, [r4, #54]	; 0x36
 800e202:	8725      	strh	r5, [r4, #56]	; 0x38
        buf[y * w + x++] = col;
 800e204:	87e5      	strh	r5, [r4, #62]	; 0x3e
        buf[y * w + x++] = col;
 800e206:	52e5      	strh	r5, [r4, r3]
        x++;
        for (i = 0; i < 4; i++)
 800e208:	2200      	movs	r2, #0
 800e20a:	2f19      	cmp	r7, #25
 800e20c:	dc00      	bgt.n	800e210 <draw_battery_status+0x70>
 800e20e:	1c2a      	adds	r2, r5, #0
 800e210:	4b47      	ldr	r3, [pc, #284]	; (800e330 <draw_battery_status+0x190>)
 800e212:	b292      	uxth	r2, r2
 800e214:	0019      	movs	r1, r3
 800e216:	0018      	movs	r0, r3
 800e218:	3950      	subs	r1, #80	; 0x50
 800e21a:	3008      	adds	r0, #8
            buf[y * w + x++] = ( ((c+1) * 25) >= (100 - vbati)) ? col : 0;
 800e21c:	80da      	strh	r2, [r3, #6]
 800e21e:	3302      	adds	r3, #2
        for (i = 0; i < 4; i++)
 800e220:	4283      	cmp	r3, r0
 800e222:	d1fb      	bne.n	800e21c <draw_battery_status+0x7c>
        x++;
        buf[y * w + x++] = col;
 800e224:	2360      	movs	r3, #96	; 0x60
 800e226:	52e5      	strh	r5, [r4, r3]

        y++;
        x = 1;
        buf[y * w + x++] = col;
 800e228:	3306      	adds	r3, #6
 800e22a:	52e5      	strh	r5, [r4, r3]
        x++;
        for (i = 0; i < 4; i++)
 800e22c:	0008      	movs	r0, r1
 800e22e:	0023      	movs	r3, r4
 800e230:	306c      	adds	r0, #108	; 0x6c
 800e232:	3364      	adds	r3, #100	; 0x64
            buf[y * w + x++] = ( ((c+1) * 25) >= (100 - vbati)) ? col : 0;
 800e234:	80da      	strh	r2, [r3, #6]
 800e236:	3302      	adds	r3, #2
        for (i = 0; i < 4; i++)
 800e238:	4283      	cmp	r3, r0
 800e23a:	d1fb      	bne.n	800e234 <draw_battery_status+0x94>
        x++;
        buf[y * w + x++] = col;
 800e23c:	2374      	movs	r3, #116	; 0x74
 800e23e:	52e5      	strh	r5, [r4, r3]
        buf[y * w + x++] = col;
 800e240:	3306      	adds	r3, #6
 800e242:	52e5      	strh	r5, [r4, r3]
        buf[y * w + x++] = col;
 800e244:	330e      	adds	r3, #14
 800e246:	52e5      	strh	r5, [r4, r3]
        buf[y * w + x++] = col;
 800e248:	3306      	adds	r3, #6
 800e24a:	52e5      	strh	r5, [r4, r3]
        for (i = 0; i < 4; i++)
 800e24c:	2200      	movs	r2, #0
 800e24e:	2f32      	cmp	r7, #50	; 0x32
 800e250:	dc00      	bgt.n	800e254 <draw_battery_status+0xb4>
 800e252:	1c2a      	adds	r2, r5, #0
 800e254:	0008      	movs	r0, r1
 800e256:	4b37      	ldr	r3, [pc, #220]	; (800e334 <draw_battery_status+0x194>)
 800e258:	b292      	uxth	r2, r2
 800e25a:	3094      	adds	r0, #148	; 0x94
            buf[y * w + x++] = ( ((c+1) * 25) >= (100 - vbati)) ? col : 0;
 800e25c:	80da      	strh	r2, [r3, #6]
 800e25e:	3302      	adds	r3, #2
        for (i = 0; i < 4; i++)
 800e260:	4283      	cmp	r3, r0
 800e262:	d1fb      	bne.n	800e25c <draw_battery_status+0xbc>
        buf[y * w + x++] = col;
 800e264:	239c      	movs	r3, #156	; 0x9c
 800e266:	52e5      	strh	r5, [r4, r3]
        buf[y * w + x++] = col;
 800e268:	3306      	adds	r3, #6
 800e26a:	52e5      	strh	r5, [r4, r3]
        for (i = 0; i < 4; i++)
 800e26c:	0008      	movs	r0, r1
 800e26e:	0023      	movs	r3, r4
 800e270:	30a8      	adds	r0, #168	; 0xa8
 800e272:	33a0      	adds	r3, #160	; 0xa0
            buf[y * w + x++] = ( ((c+1) * 25) >= (100 - vbati)) ? col : 0;
 800e274:	80da      	strh	r2, [r3, #6]
 800e276:	3302      	adds	r3, #2
        for (i = 0; i < 4; i++)
 800e278:	4283      	cmp	r3, r0
 800e27a:	d1fb      	bne.n	800e274 <draw_battery_status+0xd4>
        buf[y * w + x++] = col;
 800e27c:	23b0      	movs	r3, #176	; 0xb0
 800e27e:	52e5      	strh	r5, [r4, r3]
        buf[y * w + x++] = col;
 800e280:	3306      	adds	r3, #6
 800e282:	52e5      	strh	r5, [r4, r3]
        buf[y * w + x++] = col;
 800e284:	330e      	adds	r3, #14
 800e286:	52e5      	strh	r5, [r4, r3]
        buf[y * w + x++] = col;
 800e288:	3306      	adds	r3, #6
 800e28a:	52e5      	strh	r5, [r4, r3]
        for (i = 0; i < 4; i++)
 800e28c:	2200      	movs	r2, #0
 800e28e:	2f4b      	cmp	r7, #75	; 0x4b
 800e290:	dc00      	bgt.n	800e294 <draw_battery_status+0xf4>
 800e292:	1c2a      	adds	r2, r5, #0
 800e294:	0008      	movs	r0, r1
 800e296:	4b28      	ldr	r3, [pc, #160]	; (800e338 <draw_battery_status+0x198>)
 800e298:	b292      	uxth	r2, r2
 800e29a:	30d0      	adds	r0, #208	; 0xd0
            buf[y * w + x++] = ( ((c+1) * 25) >= (100 - vbati)) ? col : 0;
 800e29c:	80da      	strh	r2, [r3, #6]
 800e29e:	3302      	adds	r3, #2
        for (i = 0; i < 4; i++)
 800e2a0:	4298      	cmp	r0, r3
 800e2a2:	d1fb      	bne.n	800e29c <draw_battery_status+0xfc>
        buf[y * w + x++] = col;
 800e2a4:	23d8      	movs	r3, #216	; 0xd8
 800e2a6:	52e5      	strh	r5, [r4, r3]
        buf[y * w + x++] = col;
 800e2a8:	3306      	adds	r3, #6
 800e2aa:	52e5      	strh	r5, [r4, r3]
        for (i = 0; i < 4; i++)
 800e2ac:	0023      	movs	r3, r4
 800e2ae:	31e4      	adds	r1, #228	; 0xe4
 800e2b0:	33dc      	adds	r3, #220	; 0xdc
            buf[y * w + x++] = ( ((c+1) * 25) >= (100 - vbati)) ? col : 0;
 800e2b2:	80da      	strh	r2, [r3, #6]
 800e2b4:	3302      	adds	r3, #2
        for (i = 0; i < 4; i++)
 800e2b6:	4299      	cmp	r1, r3
 800e2b8:	d1fb      	bne.n	800e2b2 <draw_battery_status+0x112>
        buf[y * w + x++] = col;
 800e2ba:	23ec      	movs	r3, #236	; 0xec
 800e2bc:	52e5      	strh	r5, [r4, r3]
    }

    // battery foot
    y++;
    x = 1;
    buf[y * w + x++] = col;
 800e2be:	3306      	adds	r3, #6
 800e2c0:	52e5      	strh	r5, [r4, r3]
    x++; x++; x++; x++; x++; x++;
    buf[y * w + x++] = col;
 800e2c2:	330e      	adds	r3, #14
 800e2c4:	52e5      	strh	r5, [r4, r3]

    y++;
    x = 1;
    for (i = 0; i < 8; i++)
        buf[y * w + x++] = col;
 800e2c6:	3306      	adds	r3, #6
 800e2c8:	52e5      	strh	r5, [r4, r3]
 800e2ca:	3302      	adds	r3, #2
 800e2cc:	52e5      	strh	r5, [r4, r3]
 800e2ce:	3302      	adds	r3, #2
 800e2d0:	52e5      	strh	r5, [r4, r3]
 800e2d2:	3302      	adds	r3, #2
 800e2d4:	52e5      	strh	r5, [r4, r3]
 800e2d6:	3302      	adds	r3, #2
 800e2d8:	52e5      	strh	r5, [r4, r3]
 800e2da:	3302      	adds	r3, #2
 800e2dc:	52e5      	strh	r5, [r4, r3]
 800e2de:	3302      	adds	r3, #2
 800e2e0:	52e5      	strh	r5, [r4, r3]
 800e2e2:	3302      	adds	r3, #2
 800e2e4:	52e5      	strh	r5, [r4, r3]

    ili9341_bulk(0, 1, w, h);
 800e2e6:	3b07      	subs	r3, #7
 800e2e8:	3bff      	subs	r3, #255	; 0xff
 800e2ea:	220a      	movs	r2, #10
 800e2ec:	2101      	movs	r1, #1
 800e2ee:	2000      	movs	r0, #0
 800e2f0:	f002 f9be 	bl	8010670 <ili9341_bulk>
chMtxUnlock(&mutex_ili9341); // [/protect spi_buffer]
 800e2f4:	0030      	movs	r0, r6
 800e2f6:	f7f5 feeb 	bl	80040d0 <chMtxUnlock>
}
 800e2fa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    	if (vbat < 3200) return 0;
 800e2fc:	2764      	movs	r7, #100	; 0x64
    uint16_t col = vbati == 0 ? RGBHEX(0xff0000)  : RGBHEX(0x1fe300);
 800e2fe:	25f8      	movs	r5, #248	; 0xf8
 800e300:	e768      	b.n	800e1d4 <draw_battery_status+0x34>
    	if (vbat < 3700) return 50;
 800e302:	2732      	movs	r7, #50	; 0x32
 800e304:	251f      	movs	r5, #31
 800e306:	e765      	b.n	800e1d4 <draw_battery_status+0x34>
    	if (vbat < 3450) return 25;
 800e308:	274b      	movs	r7, #75	; 0x4b
 800e30a:	251f      	movs	r5, #31
 800e30c:	e762      	b.n	800e1d4 <draw_battery_status+0x34>
    	if (vbat < 4100) return 75;
 800e30e:	2719      	movs	r7, #25
 800e310:	251f      	movs	r5, #31
 800e312:	e75f      	b.n	800e1d4 <draw_battery_status+0x34>
 800e314:	2000220c 	.word	0x2000220c
 800e318:	200023c6 	.word	0x200023c6
 800e31c:	00000c7f 	.word	0x00000c7f
 800e320:	00000d79 	.word	0x00000d79
 800e324:	00000e73 	.word	0x00000e73
 800e328:	00001003 	.word	0x00001003
 800e32c:	200030ac 	.word	0x200030ac
 800e330:	200030fc 	.word	0x200030fc
 800e334:	20003138 	.word	0x20003138
 800e338:	20003174 	.word	0x20003174
 800e33c:	00000000 	.word	0x00000000

0800e340 <request_to_redraw_grid>:
  memset(markmap[current_mappage], 0xff, sizeof markmap[current_mappage]);
 800e340:	4b07      	ldr	r3, [pc, #28]	; (800e360 <request_to_redraw_grid+0x20>)
 800e342:	4808      	ldr	r0, [pc, #32]	; (800e364 <request_to_redraw_grid+0x24>)
 800e344:	881b      	ldrh	r3, [r3, #0]

void
request_to_redraw_grid(void)
{
 800e346:	b510      	push	{r4, lr}
  memset(markmap[current_mappage], 0xff, sizeof markmap[current_mappage]);
 800e348:	011b      	lsls	r3, r3, #4
 800e34a:	18c0      	adds	r0, r0, r3
 800e34c:	2210      	movs	r2, #16
 800e34e:	21ff      	movs	r1, #255	; 0xff
 800e350:	f004 fece 	bl	80130f0 <memset>
  force_set_markmap();
  redraw_request |= REDRAW_CELLS;
 800e354:	2101      	movs	r1, #1
 800e356:	4a04      	ldr	r2, [pc, #16]	; (800e368 <request_to_redraw_grid+0x28>)
 800e358:	8813      	ldrh	r3, [r2, #0]
 800e35a:	430b      	orrs	r3, r1
 800e35c:	8013      	strh	r3, [r2, #0]
}
 800e35e:	bd10      	pop	{r4, pc}
 800e360:	200029fc 	.word	0x200029fc
 800e364:	20002a04 	.word	0x20002a04
 800e368:	20002236 	.word	0x20002236
 800e36c:	00000000 	.word	0x00000000

0800e370 <redraw_frame>:

void
redraw_frame(void)
{
  ili9341_fill(0, 0, 320, 240, 0);
 800e370:	2300      	movs	r3, #0
 800e372:	22a0      	movs	r2, #160	; 0xa0
{
 800e374:	b500      	push	{lr}
 800e376:	b083      	sub	sp, #12
  ili9341_fill(0, 0, 320, 240, 0);
 800e378:	0052      	lsls	r2, r2, #1
 800e37a:	2100      	movs	r1, #0
 800e37c:	2000      	movs	r0, #0
 800e37e:	9300      	str	r3, [sp, #0]
 800e380:	33f0      	adds	r3, #240	; 0xf0
 800e382:	f002 f925 	bl	80105d0 <ili9341_fill>
  draw_frequencies();
 800e386:	f7ff fd53 	bl	800de30 <draw_frequencies>
  draw_cal_status();
 800e38a:	f7ff fe61 	bl	800e050 <draw_cal_status>
}
 800e38e:	b003      	add	sp, #12
 800e390:	bd00      	pop	{pc}
 800e392:	46c0      	nop			; (mov r8, r8)
	...

0800e3a0 <plot_init>:
  memset(markmap[current_mappage], 0xff, sizeof markmap[current_mappage]);
 800e3a0:	4b05      	ldr	r3, [pc, #20]	; (800e3b8 <plot_init+0x18>)

void
plot_init(void)
{
 800e3a2:	b510      	push	{r4, lr}
  memset(markmap[current_mappage], 0xff, sizeof markmap[current_mappage]);
 800e3a4:	881b      	ldrh	r3, [r3, #0]
 800e3a6:	4805      	ldr	r0, [pc, #20]	; (800e3bc <plot_init+0x1c>)
 800e3a8:	011b      	lsls	r3, r3, #4
 800e3aa:	18c0      	adds	r0, r0, r3
 800e3ac:	2210      	movs	r2, #16
 800e3ae:	21ff      	movs	r1, #255	; 0xff
 800e3b0:	f004 fe9e 	bl	80130f0 <memset>
  force_set_markmap();
}
 800e3b4:	bd10      	pop	{r4, pc}
 800e3b6:	46c0      	nop			; (mov r8, r8)
 800e3b8:	200029fc 	.word	0x200029fc
 800e3bc:	20002a04 	.word	0x20002a04

0800e3c0 <btn_check>:



static int btn_check(void)
{
    int cur_button = READ_PORT() & BUTTON_MASK;
 800e3c0:	2390      	movs	r3, #144	; 0x90
{
 800e3c2:	b5f0      	push	{r4, r5, r6, r7, lr}
    int cur_button = READ_PORT() & BUTTON_MASK;
 800e3c4:	260f      	movs	r6, #15
{
 800e3c6:	46c6      	mov	lr, r8
    int cur_button = READ_PORT() & BUTTON_MASK;
 800e3c8:	05db      	lsls	r3, r3, #23
	int changed = last_button ^ cur_button;
 800e3ca:	4d26      	ldr	r5, [pc, #152]	; (800e464 <btn_check+0xa4>)
    int cur_button = READ_PORT() & BUTTON_MASK;
 800e3cc:	691f      	ldr	r7, [r3, #16]
	int changed = last_button ^ cur_button;
 800e3ce:	882b      	ldrh	r3, [r5, #0]
    int cur_button = READ_PORT() & BUTTON_MASK;
 800e3d0:	403e      	ands	r6, r7
{
 800e3d2:	b500      	push	{lr}
	int changed = last_button ^ cur_button;
 800e3d4:	4073      	eors	r3, r6
  __ASM volatile ("cpsid i" : : : "memory");
 800e3d6:	b672      	cpsid	i
 800e3d8:	2280      	movs	r2, #128	; 0x80
 800e3da:	05d2      	lsls	r2, r2, #23
 800e3dc:	6a51      	ldr	r1, [r2, #36]	; 0x24
  __ASM volatile ("cpsie i" : : : "memory");
 800e3de:	b662      	cpsie	i
	int status = 0;
    uint32_t ticks = chVTGetSystemTime();
	if (changed & (1<<BIT_PUSH)) {
 800e3e0:	2204      	movs	r2, #4
 800e3e2:	0010      	movs	r0, r2
 800e3e4:	4690      	mov	r8, r2
 800e3e6:	4018      	ands	r0, r3
 800e3e8:	d007      	beq.n	800e3fa <btn_check+0x3a>
      if (ticks - last_button_down_ticks >= BUTTON_DEBOUNCE_TICKS) {
 800e3ea:	4a1f      	ldr	r2, [pc, #124]	; (800e468 <btn_check+0xa8>)
 800e3ec:	6810      	ldr	r0, [r2, #0]
 800e3ee:	1a08      	subs	r0, r1, r0
 800e3f0:	4684      	mov	ip, r0
 800e3f2:	4664      	mov	r4, ip
	int status = 0;
 800e3f4:	2000      	movs	r0, #0
      if (ticks - last_button_down_ticks >= BUTTON_DEBOUNCE_TICKS) {
 800e3f6:	2cc7      	cmp	r4, #199	; 0xc7
 800e3f8:	d823      	bhi.n	800e442 <btn_check+0x82>
        }
        last_button_down_ticks = ticks;
      }
	}

    if (changed & (1<<BIT_UP1)) {
 800e3fa:	2208      	movs	r2, #8
 800e3fc:	421a      	tst	r2, r3
 800e3fe:	d009      	beq.n	800e414 <btn_check+0x54>
      if ((cur_button & (1<<BIT_UP1))
 800e400:	423a      	tst	r2, r7
 800e402:	d01b      	beq.n	800e43c <btn_check+0x7c>
          && (ticks >= last_button_down_ticks + BUTTON_DEBOUNCE_TICKS)) {
 800e404:	4a18      	ldr	r2, [pc, #96]	; (800e468 <btn_check+0xa8>)
 800e406:	6814      	ldr	r4, [r2, #0]
 800e408:	34c8      	adds	r4, #200	; 0xc8
 800e40a:	428c      	cmp	r4, r1
 800e40c:	d801      	bhi.n	800e412 <btn_check+0x52>
        status |= EVT_UP;
 800e40e:	2410      	movs	r4, #16
 800e410:	4320      	orrs	r0, r4
      }
      last_button_down_ticks = ticks;
 800e412:	6011      	str	r1, [r2, #0]
    }
    if (changed & (1<<BIT_DOWN1)) {
 800e414:	2202      	movs	r2, #2
 800e416:	421a      	tst	r2, r3
 800e418:	d009      	beq.n	800e42e <btn_check+0x6e>
      if ((cur_button & (1<<BIT_DOWN1))
 800e41a:	423a      	tst	r2, r7
 800e41c:	d00b      	beq.n	800e436 <btn_check+0x76>
          && (ticks >= last_button_down_ticks + BUTTON_DEBOUNCE_TICKS)) {
 800e41e:	4a12      	ldr	r2, [pc, #72]	; (800e468 <btn_check+0xa8>)
 800e420:	6813      	ldr	r3, [r2, #0]
 800e422:	33c8      	adds	r3, #200	; 0xc8
 800e424:	428b      	cmp	r3, r1
 800e426:	d801      	bhi.n	800e42c <btn_check+0x6c>
        status |= EVT_DOWN;
 800e428:	2320      	movs	r3, #32
 800e42a:	4318      	orrs	r0, r3
      }
      last_button_down_ticks = ticks;
 800e42c:	6011      	str	r1, [r2, #0]
    }
    last_button = cur_button;
 800e42e:	802e      	strh	r6, [r5, #0]

	return status;
}
 800e430:	bc04      	pop	{r2}
 800e432:	4690      	mov	r8, r2
 800e434:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800e436:	4a0c      	ldr	r2, [pc, #48]	; (800e468 <btn_check+0xa8>)
      last_button_down_ticks = ticks;
 800e438:	6011      	str	r1, [r2, #0]
 800e43a:	e7f8      	b.n	800e42e <btn_check+0x6e>
 800e43c:	4a0a      	ldr	r2, [pc, #40]	; (800e468 <btn_check+0xa8>)
      last_button_down_ticks = ticks;
 800e43e:	6011      	str	r1, [r2, #0]
 800e440:	e7e8      	b.n	800e414 <btn_check+0x54>
        if (cur_button & (1<<BIT_PUSH)) {
 800e442:	4640      	mov	r0, r8
 800e444:	4038      	ands	r0, r7
 800e446:	d00b      	beq.n	800e460 <btn_check+0xa0>
          if (inhibit_until_release) {
 800e448:	4808      	ldr	r0, [pc, #32]	; (800e46c <btn_check+0xac>)
 800e44a:	4680      	mov	r8, r0
 800e44c:	7800      	ldrb	r0, [r0, #0]
 800e44e:	b240      	sxtb	r0, r0
 800e450:	4684      	mov	ip, r0
 800e452:	4664      	mov	r4, ip
          status |= EVT_BUTTON_SINGLE_CLICK;
 800e454:	2001      	movs	r0, #1
          if (inhibit_until_release) {
 800e456:	2c00      	cmp	r4, #0
 800e458:	d002      	beq.n	800e460 <btn_check+0xa0>
            inhibit_until_release = FALSE;
 800e45a:	2000      	movs	r0, #0
 800e45c:	4644      	mov	r4, r8
 800e45e:	7020      	strb	r0, [r4, #0]
        last_button_down_ticks = ticks;
 800e460:	6011      	str	r1, [r2, #0]
 800e462:	e7ca      	b.n	800e3fa <btn_check+0x3a>
 800e464:	20003090 	.word	0x20003090
 800e468:	20003094 	.word	0x20003094
 800e46c:	20003078 	.word	0x20003078

0800e470 <btn_wait_release>:

static int btn_wait_release(void)
{
  while (TRUE) {
    int cur_button = READ_PORT() & BUTTON_MASK;
 800e470:	2390      	movs	r3, #144	; 0x90
 800e472:	05db      	lsls	r3, r3, #23
{
 800e474:	b5f0      	push	{r4, r5, r6, r7, lr}
 800e476:	464e      	mov	r6, r9
    int cur_button = READ_PORT() & BUTTON_MASK;
 800e478:	4699      	mov	r9, r3
 800e47a:	230f      	movs	r3, #15
{
 800e47c:	4645      	mov	r5, r8
    int cur_button = READ_PORT() & BUTTON_MASK;
 800e47e:	4698      	mov	r8, r3
 800e480:	2380      	movs	r3, #128	; 0x80
 800e482:	05db      	lsls	r3, r3, #23
 800e484:	469c      	mov	ip, r3
    int changed = last_button ^ cur_button;
    uint32_t ticks = chVTGetSystemTime();
    int status = 0;

    if (!inhibit_until_release) {
      if ((cur_button & (1<<BIT_PUSH))
 800e486:	2304      	movs	r3, #4
{
 800e488:	46de      	mov	lr, fp
 800e48a:	4657      	mov	r7, sl
      if ((cur_button & (1<<BIT_PUSH))
 800e48c:	469a      	mov	sl, r3
      inhibit_until_release = FALSE;
      return 0;
    }

    if (ticks - last_button_down_ticks >= BUTTON_DOWN_LONG_TICKS
        && ticks - last_button_repeat_ticks >= BUTTON_REPEAT_TICKS) {
 800e48e:	4b2c      	ldr	r3, [pc, #176]	; (800e540 <btn_wait_release+0xd0>)
{
 800e490:	b5e0      	push	{r5, r6, r7, lr}
        && ticks - last_button_repeat_ticks >= BUTTON_REPEAT_TICKS) {
 800e492:	469b      	mov	fp, r3
 800e494:	4e2b      	ldr	r6, [pc, #172]	; (800e544 <btn_wait_release+0xd4>)
 800e496:	4d2c      	ldr	r5, [pc, #176]	; (800e548 <btn_wait_release+0xd8>)
    int cur_button = READ_PORT() & BUTTON_MASK;
 800e498:	464b      	mov	r3, r9
 800e49a:	4642      	mov	r2, r8
 800e49c:	691b      	ldr	r3, [r3, #16]
    int changed = last_button ^ cur_button;
 800e49e:	8830      	ldrh	r0, [r6, #0]
    int cur_button = READ_PORT() & BUTTON_MASK;
 800e4a0:	401a      	ands	r2, r3
  __ASM volatile ("cpsid i" : : : "memory");
 800e4a2:	b672      	cpsid	i
 800e4a4:	4661      	mov	r1, ip
 800e4a6:	6a49      	ldr	r1, [r1, #36]	; 0x24
  __ASM volatile ("cpsie i" : : : "memory");
 800e4a8:	b662      	cpsie	i
    if (!inhibit_until_release) {
 800e4aa:	2400      	movs	r4, #0
 800e4ac:	572c      	ldrsb	r4, [r5, r4]
 800e4ae:	2c00      	cmp	r4, #0
 800e4b0:	d11b      	bne.n	800e4ea <btn_wait_release+0x7a>
    int changed = last_button ^ cur_button;
 800e4b2:	0004      	movs	r4, r0
      if ((cur_button & (1<<BIT_PUSH))
 800e4b4:	4657      	mov	r7, sl
    int changed = last_button ^ cur_button;
 800e4b6:	4054      	eors	r4, r2
      if ((cur_button & (1<<BIT_PUSH))
 800e4b8:	421f      	tst	r7, r3
 800e4ba:	d02f      	beq.n	800e51c <btn_wait_release+0xac>
          && ticks - last_button_down_ticks >= BUTTON_DOWN_LONG_TICKS) {
 800e4bc:	4b23      	ldr	r3, [pc, #140]	; (800e54c <btn_wait_release+0xdc>)
 800e4be:	4f24      	ldr	r7, [pc, #144]	; (800e550 <btn_wait_release+0xe0>)
 800e4c0:	681b      	ldr	r3, [r3, #0]
 800e4c2:	1acb      	subs	r3, r1, r3
 800e4c4:	42bb      	cmp	r3, r7
 800e4c6:	d834      	bhi.n	800e532 <btn_wait_release+0xc2>
      if ((changed & (1<<BIT_PUSH))
 800e4c8:	4653      	mov	r3, sl
 800e4ca:	4223      	tst	r3, r4
 800e4cc:	d135      	bne.n	800e53a <btn_wait_release+0xca>
    if (changed) {
 800e4ce:	4290      	cmp	r0, r2
 800e4d0:	d0e2      	beq.n	800e498 <btn_wait_release+0x28>
      last_button_down_ticks = ticks;
 800e4d2:	4b1e      	ldr	r3, [pc, #120]	; (800e54c <btn_wait_release+0xdc>)
      return 0;
 800e4d4:	2000      	movs	r0, #0
      last_button_down_ticks = ticks;
 800e4d6:	6019      	str	r1, [r3, #0]
      inhibit_until_release = FALSE;
 800e4d8:	2300      	movs	r3, #0
      last_button = cur_button;
 800e4da:	8032      	strh	r2, [r6, #0]
      inhibit_until_release = FALSE;
 800e4dc:	702b      	strb	r3, [r5, #0]
      }
      last_button_repeat_ticks = ticks;
      return status;
    }
  }
}
 800e4de:	bc3c      	pop	{r2, r3, r4, r5}
 800e4e0:	4690      	mov	r8, r2
 800e4e2:	4699      	mov	r9, r3
 800e4e4:	46a2      	mov	sl, r4
 800e4e6:	46ab      	mov	fp, r5
 800e4e8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (changed) {
 800e4ea:	4290      	cmp	r0, r2
 800e4ec:	d1f1      	bne.n	800e4d2 <btn_wait_release+0x62>
    if (ticks - last_button_down_ticks >= BUTTON_DOWN_LONG_TICKS
 800e4ee:	4a17      	ldr	r2, [pc, #92]	; (800e54c <btn_wait_release+0xdc>)
 800e4f0:	4817      	ldr	r0, [pc, #92]	; (800e550 <btn_wait_release+0xe0>)
 800e4f2:	6812      	ldr	r2, [r2, #0]
 800e4f4:	1a8a      	subs	r2, r1, r2
 800e4f6:	4282      	cmp	r2, r0
 800e4f8:	d9ce      	bls.n	800e498 <btn_wait_release+0x28>
        && ticks - last_button_repeat_ticks >= BUTTON_REPEAT_TICKS) {
 800e4fa:	465a      	mov	r2, fp
 800e4fc:	4815      	ldr	r0, [pc, #84]	; (800e554 <btn_wait_release+0xe4>)
 800e4fe:	6812      	ldr	r2, [r2, #0]
 800e500:	1a8a      	subs	r2, r1, r2
 800e502:	4282      	cmp	r2, r0
 800e504:	d9c8      	bls.n	800e498 <btn_wait_release+0x28>
      if (cur_button & (1<<BIT_DOWN1)) {
 800e506:	2002      	movs	r0, #2
 800e508:	4018      	ands	r0, r3
 800e50a:	d000      	beq.n	800e50e <btn_wait_release+0x9e>
        status |= EVT_DOWN | EVT_REPEAT;
 800e50c:	2060      	movs	r0, #96	; 0x60
      if (cur_button & (1<<BIT_UP1)) {
 800e50e:	071b      	lsls	r3, r3, #28
 800e510:	d501      	bpl.n	800e516 <btn_wait_release+0xa6>
        status |= EVT_UP | EVT_REPEAT;
 800e512:	2350      	movs	r3, #80	; 0x50
 800e514:	4318      	orrs	r0, r3
      last_button_repeat_ticks = ticks;
 800e516:	465b      	mov	r3, fp
 800e518:	6019      	str	r1, [r3, #0]
      return status;
 800e51a:	e7e0      	b.n	800e4de <btn_wait_release+0x6e>
      if ((changed & (1<<BIT_PUSH))
 800e51c:	4227      	tst	r7, r4
 800e51e:	d0e4      	beq.n	800e4ea <btn_wait_release+0x7a>
          && ticks - last_button_down_ticks < BUTTON_DOWN_LONG_TICKS) {
 800e520:	4c0a      	ldr	r4, [pc, #40]	; (800e54c <btn_wait_release+0xdc>)
 800e522:	4f0b      	ldr	r7, [pc, #44]	; (800e550 <btn_wait_release+0xe0>)
 800e524:	6824      	ldr	r4, [r4, #0]
 800e526:	1b0c      	subs	r4, r1, r4
 800e528:	42bc      	cmp	r4, r7
 800e52a:	d906      	bls.n	800e53a <btn_wait_release+0xca>
    if (changed) {
 800e52c:	4290      	cmp	r0, r2
 800e52e:	d0e4      	beq.n	800e4fa <btn_wait_release+0x8a>
 800e530:	e7cf      	b.n	800e4d2 <btn_wait_release+0x62>
        inhibit_until_release = TRUE;
 800e532:	2301      	movs	r3, #1
        return EVT_BUTTON_DOWN_LONG;
 800e534:	2004      	movs	r0, #4
        inhibit_until_release = TRUE;
 800e536:	702b      	strb	r3, [r5, #0]
        return EVT_BUTTON_DOWN_LONG;
 800e538:	e7d1      	b.n	800e4de <btn_wait_release+0x6e>
        return EVT_BUTTON_SINGLE_CLICK;
 800e53a:	2001      	movs	r0, #1
 800e53c:	e7cf      	b.n	800e4de <btn_wait_release+0x6e>
 800e53e:	46c0      	nop			; (mov r8, r8)
 800e540:	20003098 	.word	0x20003098
 800e544:	20003090 	.word	0x20003090
 800e548:	20003078 	.word	0x20003078
 800e54c:	20003094 	.word	0x20003094
 800e550:	00001387 	.word	0x00001387
 800e554:	000003e7 	.word	0x000003e7
	...

0800e560 <extcb1>:

/* Triggered when the button is pressed or released. The LED4 is set to ON.*/
static void extcb1(EXTDriver *extp, expchannel_t channel) {
  (void)extp;
  (void)channel;
  operation_requested = OP_LEVER;
 800e560:	2201      	movs	r2, #1
 800e562:	4b01      	ldr	r3, [pc, #4]	; (800e568 <extcb1+0x8>)
 800e564:	701a      	strb	r2, [r3, #0]
  //cur_button = READ_PORT() & BUTTON_MASK;
}
 800e566:	4770      	bx	lr
 800e568:	200030a3 	.word	0x200030a3
 800e56c:	00000000 	.word	0x00000000

0800e570 <touch_prepare_sense>:
{
 800e570:	b570      	push	{r4, r5, r6, lr}
  palSetPadMode(GPIOA, 7, PAL_MODE_INPUT_PULLDOWN );
 800e572:	2490      	movs	r4, #144	; 0x90
  palSetPadMode(GPIOB, 1, PAL_MODE_INPUT_PULLDOWN );
 800e574:	4d0d      	ldr	r5, [pc, #52]	; (800e5ac <touch_prepare_sense+0x3c>)
  palSetPadMode(GPIOA, 7, PAL_MODE_INPUT_PULLDOWN );
 800e576:	05e4      	lsls	r4, r4, #23
  palSetPadMode(GPIOB, 1, PAL_MODE_INPUT_PULLDOWN );
 800e578:	0028      	movs	r0, r5
 800e57a:	2240      	movs	r2, #64	; 0x40
 800e57c:	2102      	movs	r1, #2
 800e57e:	f7f7 fd3f 	bl	8006000 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOA, 7, PAL_MODE_INPUT_PULLDOWN );
 800e582:	0020      	movs	r0, r4
 800e584:	2240      	movs	r2, #64	; 0x40
 800e586:	2180      	movs	r1, #128	; 0x80
 800e588:	f7f7 fd3a 	bl	8006000 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOB, 0, PAL_MODE_OUTPUT_PUSHPULL );
 800e58c:	0028      	movs	r0, r5
 800e58e:	2201      	movs	r2, #1
 800e590:	2101      	movs	r1, #1
 800e592:	f7f7 fd35 	bl	8006000 <_pal_lld_setgroupmode>
  palSetPad(GPIOB, 0);
 800e596:	2301      	movs	r3, #1
  palSetPadMode(GPIOA, 6, PAL_MODE_OUTPUT_PUSHPULL );
 800e598:	2201      	movs	r2, #1
  palSetPad(GPIOB, 0);
 800e59a:	832b      	strh	r3, [r5, #24]
  palSetPadMode(GPIOA, 6, PAL_MODE_OUTPUT_PUSHPULL );
 800e59c:	2140      	movs	r1, #64	; 0x40
 800e59e:	0020      	movs	r0, r4
 800e5a0:	f7f7 fd2e 	bl	8006000 <_pal_lld_setgroupmode>
  palSetPad(GPIOA, 6);
 800e5a4:	2340      	movs	r3, #64	; 0x40
 800e5a6:	8323      	strh	r3, [r4, #24]
}
 800e5a8:	bd70      	pop	{r4, r5, r6, pc}
 800e5aa:	46c0      	nop			; (mov r8, r8)
 800e5ac:	48000400 	.word	0x48000400

0800e5b0 <draw_numeric_area_frame>:
  ili9341_fill(0, 208, 320, 32, 0xffff);
 800e5b0:	22a0      	movs	r2, #160	; 0xa0
{
 800e5b2:	b510      	push	{r4, lr}
  ili9341_fill(0, 208, 320, 32, 0xffff);
 800e5b4:	4c0a      	ldr	r4, [pc, #40]	; (800e5e0 <draw_numeric_area_frame+0x30>)
{
 800e5b6:	b082      	sub	sp, #8
  ili9341_fill(0, 208, 320, 32, 0xffff);
 800e5b8:	9400      	str	r4, [sp, #0]
 800e5ba:	2320      	movs	r3, #32
 800e5bc:	0052      	lsls	r2, r2, #1
 800e5be:	21d0      	movs	r1, #208	; 0xd0
 800e5c0:	2000      	movs	r0, #0
 800e5c2:	f002 f805 	bl	80105d0 <ili9341_fill>
  ili9341_drawstring_7x13(keypad_mode_label[keypad_mode], 10, 220, 0x0000, 0xffff);
 800e5c6:	4b07      	ldr	r3, [pc, #28]	; (800e5e4 <draw_numeric_area_frame+0x34>)
 800e5c8:	4a07      	ldr	r2, [pc, #28]	; (800e5e8 <draw_numeric_area_frame+0x38>)
 800e5ca:	781b      	ldrb	r3, [r3, #0]
 800e5cc:	210a      	movs	r1, #10
 800e5ce:	009b      	lsls	r3, r3, #2
 800e5d0:	5898      	ldr	r0, [r3, r2]
 800e5d2:	9400      	str	r4, [sp, #0]
 800e5d4:	2300      	movs	r3, #0
 800e5d6:	22dc      	movs	r2, #220	; 0xdc
 800e5d8:	f002 f93a 	bl	8010850 <ili9341_drawstring_7x13>
}
 800e5dc:	b002      	add	sp, #8
 800e5de:	bd10      	pop	{r4, pc}
 800e5e0:	0000ffff 	.word	0x0000ffff
 800e5e4:	20003079 	.word	0x20003079
 800e5e8:	08014cfc 	.word	0x08014cfc
 800e5ec:	00000000 	.word	0x00000000

0800e5f0 <touch_measure_x>:
{
 800e5f0:	b570      	push	{r4, r5, r6, lr}
  palSetPadMode(GPIOA, 6, PAL_MODE_INPUT_PULLDOWN );
 800e5f2:	2490      	movs	r4, #144	; 0x90
  palSetPadMode(GPIOB, 0, PAL_MODE_INPUT_PULLDOWN );
 800e5f4:	4d10      	ldr	r5, [pc, #64]	; (800e638 <touch_measure_x+0x48>)
  palSetPadMode(GPIOA, 6, PAL_MODE_INPUT_PULLDOWN );
 800e5f6:	05e4      	lsls	r4, r4, #23
  palSetPadMode(GPIOB, 0, PAL_MODE_INPUT_PULLDOWN );
 800e5f8:	0028      	movs	r0, r5
 800e5fa:	2240      	movs	r2, #64	; 0x40
 800e5fc:	2101      	movs	r1, #1
 800e5fe:	f7f7 fcff 	bl	8006000 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOA, 6, PAL_MODE_INPUT_PULLDOWN );
 800e602:	0020      	movs	r0, r4
 800e604:	2240      	movs	r2, #64	; 0x40
 800e606:	2140      	movs	r1, #64	; 0x40
 800e608:	f7f7 fcfa 	bl	8006000 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOB, 1, PAL_MODE_OUTPUT_PUSHPULL );
 800e60c:	0028      	movs	r0, r5
 800e60e:	2201      	movs	r2, #1
 800e610:	2102      	movs	r1, #2
 800e612:	f7f7 fcf5 	bl	8006000 <_pal_lld_setgroupmode>
  palSetPad(GPIOB, 1);
 800e616:	2302      	movs	r3, #2
  palSetPadMode(GPIOA, 7, PAL_MODE_OUTPUT_PUSHPULL );
 800e618:	2201      	movs	r2, #1
  palSetPad(GPIOB, 1);
 800e61a:	832b      	strh	r3, [r5, #24]
  palSetPadMode(GPIOA, 7, PAL_MODE_OUTPUT_PUSHPULL );
 800e61c:	2180      	movs	r1, #128	; 0x80
 800e61e:	0020      	movs	r0, r4
 800e620:	f7f7 fcee 	bl	8006000 <_pal_lld_setgroupmode>
  palClearPad(GPIOA, 7);
 800e624:	2380      	movs	r3, #128	; 0x80
  chThdSleepMilliseconds(2);
 800e626:	2014      	movs	r0, #20
  palClearPad(GPIOA, 7);
 800e628:	8363      	strh	r3, [r4, #26]
  chThdSleepMilliseconds(2);
 800e62a:	f7f5 fc71 	bl	8003f10 <chThdSleep>
  v = adc_single_read(ADC1, ADC_CHSELR_CHSEL6);
 800e62e:	2140      	movs	r1, #64	; 0x40
 800e630:	4802      	ldr	r0, [pc, #8]	; (800e63c <touch_measure_x+0x4c>)
 800e632:	f002 fca5 	bl	8010f80 <adc_single_read>
}
 800e636:	bd70      	pop	{r4, r5, r6, pc}
 800e638:	48000400 	.word	0x48000400
 800e63c:	40012400 	.word	0x40012400

0800e640 <touch_measure_y>:
{
 800e640:	b570      	push	{r4, r5, r6, lr}
  palSetPadMode(GPIOA, 7, PAL_MODE_INPUT_PULLDOWN );
 800e642:	2490      	movs	r4, #144	; 0x90
  palSetPadMode(GPIOB, 1, PAL_MODE_INPUT_PULLDOWN );
 800e644:	4d10      	ldr	r5, [pc, #64]	; (800e688 <touch_measure_y+0x48>)
  palSetPadMode(GPIOA, 7, PAL_MODE_INPUT_PULLDOWN );
 800e646:	05e4      	lsls	r4, r4, #23
  palSetPadMode(GPIOB, 1, PAL_MODE_INPUT_PULLDOWN );
 800e648:	0028      	movs	r0, r5
 800e64a:	2240      	movs	r2, #64	; 0x40
 800e64c:	2102      	movs	r1, #2
 800e64e:	f7f7 fcd7 	bl	8006000 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOA, 7, PAL_MODE_INPUT_PULLDOWN );
 800e652:	0020      	movs	r0, r4
 800e654:	2240      	movs	r2, #64	; 0x40
 800e656:	2180      	movs	r1, #128	; 0x80
 800e658:	f7f7 fcd2 	bl	8006000 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOB, 0, PAL_MODE_OUTPUT_PUSHPULL );
 800e65c:	0028      	movs	r0, r5
 800e65e:	2201      	movs	r2, #1
 800e660:	2101      	movs	r1, #1
 800e662:	f7f7 fccd 	bl	8006000 <_pal_lld_setgroupmode>
  palClearPad(GPIOB, 0);
 800e666:	2301      	movs	r3, #1
  palSetPadMode(GPIOA, 6, PAL_MODE_OUTPUT_PUSHPULL );
 800e668:	2201      	movs	r2, #1
  palClearPad(GPIOB, 0);
 800e66a:	836b      	strh	r3, [r5, #26]
  palSetPadMode(GPIOA, 6, PAL_MODE_OUTPUT_PUSHPULL );
 800e66c:	2140      	movs	r1, #64	; 0x40
 800e66e:	0020      	movs	r0, r4
 800e670:	f7f7 fcc6 	bl	8006000 <_pal_lld_setgroupmode>
  palSetPad(GPIOA, 6);
 800e674:	2340      	movs	r3, #64	; 0x40
  chThdSleepMilliseconds(2);
 800e676:	2014      	movs	r0, #20
  palSetPad(GPIOA, 6);
 800e678:	8323      	strh	r3, [r4, #24]
  chThdSleepMilliseconds(2);
 800e67a:	f7f5 fc49 	bl	8003f10 <chThdSleep>
  v = adc_single_read(ADC1, ADC_CHSELR_CHSEL7);
 800e67e:	2180      	movs	r1, #128	; 0x80
 800e680:	4802      	ldr	r0, [pc, #8]	; (800e68c <touch_measure_y+0x4c>)
 800e682:	f002 fc7d 	bl	8010f80 <adc_single_read>
}
 800e686:	bd70      	pop	{r4, r5, r6, pc}
 800e688:	48000400 	.word	0x48000400
 800e68c:	40012400 	.word	0x40012400

0800e690 <touch_check>:
{
 800e690:	b570      	push	{r4, r5, r6, lr}
  touch_prepare_sense();
 800e692:	f7ff ff6d 	bl	800e570 <touch_prepare_sense>
  return adc_single_read(ADC1, ADC_CHSELR_CHSEL7) > TOUCH_THRESHOLD;
 800e696:	2180      	movs	r1, #128	; 0x80
 800e698:	481a      	ldr	r0, [pc, #104]	; (800e704 <touch_check+0x74>)
  if (stat) {
 800e69a:	24fa      	movs	r4, #250	; 0xfa
  return adc_single_read(ADC1, ADC_CHSELR_CHSEL7) > TOUCH_THRESHOLD;
 800e69c:	f002 fc70 	bl	8010f80 <adc_single_read>
  if (stat) {
 800e6a0:	00e4      	lsls	r4, r4, #3
 800e6a2:	42a0      	cmp	r0, r4
 800e6a4:	d80a      	bhi.n	800e6bc <touch_check+0x2c>
  if (stat != last_touch_status) {
 800e6a6:	2200      	movs	r2, #0
 800e6a8:	4b17      	ldr	r3, [pc, #92]	; (800e708 <touch_check+0x78>)
 800e6aa:	569a      	ldrsb	r2, [r3, r2]
 800e6ac:	2a00      	cmp	r2, #0
 800e6ae:	d101      	bne.n	800e6b4 <touch_check+0x24>
      return EVT_TOUCH_DOWN;
 800e6b0:	2000      	movs	r0, #0
}
 800e6b2:	bd70      	pop	{r4, r5, r6, pc}
    last_touch_status = stat;
 800e6b4:	2200      	movs	r2, #0
      return EVT_TOUCH_RELEASED;
 800e6b6:	2003      	movs	r0, #3
    last_touch_status = stat;
 800e6b8:	701a      	strb	r2, [r3, #0]
    if (stat) {
 800e6ba:	e7fa      	b.n	800e6b2 <touch_check+0x22>
    chThdSleepMilliseconds(10);
 800e6bc:	2064      	movs	r0, #100	; 0x64
 800e6be:	f7f5 fc27 	bl	8003f10 <chThdSleep>
    int x = touch_measure_x();
 800e6c2:	f7ff ff95 	bl	800e5f0 <touch_measure_x>
 800e6c6:	0006      	movs	r6, r0
    int y = touch_measure_y();
 800e6c8:	f7ff ffba 	bl	800e640 <touch_measure_y>
 800e6cc:	0005      	movs	r5, r0
  touch_prepare_sense();
 800e6ce:	f7ff ff4f 	bl	800e570 <touch_prepare_sense>
  return adc_single_read(ADC1, ADC_CHSELR_CHSEL7) > TOUCH_THRESHOLD;
 800e6d2:	2180      	movs	r1, #128	; 0x80
 800e6d4:	480b      	ldr	r0, [pc, #44]	; (800e704 <touch_check+0x74>)
 800e6d6:	f002 fc53 	bl	8010f80 <adc_single_read>
    if (touch_status()) {
 800e6da:	42a0      	cmp	r0, r4
 800e6dc:	d80a      	bhi.n	800e6f4 <touch_check+0x64>
    touch_prepare_sense();
 800e6de:	f7ff ff47 	bl	800e570 <touch_prepare_sense>
  if (stat != last_touch_status) {
 800e6e2:	2200      	movs	r2, #0
 800e6e4:	4b08      	ldr	r3, [pc, #32]	; (800e708 <touch_check+0x78>)
 800e6e6:	569a      	ldrsb	r2, [r3, r2]
 800e6e8:	2a01      	cmp	r2, #1
 800e6ea:	d008      	beq.n	800e6fe <touch_check+0x6e>
    last_touch_status = stat;
 800e6ec:	2201      	movs	r2, #1
      return EVT_TOUCH_PRESSED;
 800e6ee:	2002      	movs	r0, #2
    last_touch_status = stat;
 800e6f0:	701a      	strb	r2, [r3, #0]
    if (stat) {
 800e6f2:	e7de      	b.n	800e6b2 <touch_check+0x22>
      last_touch_x = x;
 800e6f4:	4b05      	ldr	r3, [pc, #20]	; (800e70c <touch_check+0x7c>)
 800e6f6:	801e      	strh	r6, [r3, #0]
      last_touch_y = y;
 800e6f8:	4b05      	ldr	r3, [pc, #20]	; (800e710 <touch_check+0x80>)
 800e6fa:	801d      	strh	r5, [r3, #0]
 800e6fc:	e7ef      	b.n	800e6de <touch_check+0x4e>
      return EVT_TOUCH_DOWN;
 800e6fe:	2001      	movs	r0, #1
 800e700:	e7d7      	b.n	800e6b2 <touch_check+0x22>
 800e702:	46c0      	nop			; (mov r8, r8)
 800e704:	40012400 	.word	0x40012400
 800e708:	2000309c 	.word	0x2000309c
 800e70c:	2000309e 	.word	0x2000309e
 800e710:	200030a0 	.word	0x200030a0
	...

0800e720 <draw_numeric_input>:
{
 800e720:	b5f0      	push	{r4, r5, r6, r7, lr}
 800e722:	4657      	mov	r7, sl
 800e724:	464e      	mov	r6, r9
 800e726:	4645      	mov	r5, r8
 800e728:	46de      	mov	lr, fp
 800e72a:	b5e0      	push	{r5, r6, r7, lr}
 800e72c:	b089      	sub	sp, #36	; 0x24
  const uint16_t xsim[] = { 0, 0, 8, 0, 0, 8, 0, 0, 0, 0 };
 800e72e:	ae03      	add	r6, sp, #12
 800e730:	0032      	movs	r2, r6
 800e732:	4b59      	ldr	r3, [pc, #356]	; (800e898 <draw_numeric_input+0x178>)
{
 800e734:	4680      	mov	r8, r0
  const uint16_t xsim[] = { 0, 0, 8, 0, 0, 8, 0, 0, 0, 0 };
 800e736:	cb13      	ldmia	r3!, {r0, r1, r4}
 800e738:	c213      	stmia	r2!, {r0, r1, r4}
 800e73a:	cb03      	ldmia	r3!, {r0, r1}
 800e73c:	c203      	stmia	r2!, {r0, r1}
  int focused = FALSE;
 800e73e:	2300      	movs	r3, #0
 800e740:	4699      	mov	r9, r3
      ili9341_drawfont(c, &NF20x22, x, 208+4, fg, bg);
 800e742:	4b56      	ldr	r3, [pc, #344]	; (800e89c <draw_numeric_input+0x17c>)
  int x = 64;
 800e744:	2540      	movs	r5, #64	; 0x40
  for (i = 0; i < 10 && buf[i]; i++) {
 800e746:	2400      	movs	r4, #0
 800e748:	4f55      	ldr	r7, [pc, #340]	; (800e8a0 <draw_numeric_input+0x180>)
      ili9341_drawfont(c, &NF20x22, x, 208+4, fg, bg);
 800e74a:	469a      	mov	sl, r3
      ili9341_drawfont(0, &NF20x22, x, 208+4, fg, bg);
 800e74c:	469b      	mov	fp, r3
 800e74e:	e01e      	b.n	800e78e <draw_numeric_input+0x6e>
    else if (c == '-')
 800e750:	282d      	cmp	r0, #45	; 0x2d
 800e752:	d047      	beq.n	800e7e4 <draw_numeric_input+0xc4>
    if (uistat.digit == 8-i) {
 800e754:	2208      	movs	r2, #8
    else if (c >= '0' && c <= '9')
 800e756:	3830      	subs	r0, #48	; 0x30
    if (uistat.digit == 8-i) {
 800e758:	1b12      	subs	r2, r2, r4
    else if (c >= '0' && c <= '9')
 800e75a:	2809      	cmp	r0, #9
 800e75c:	d851      	bhi.n	800e802 <draw_numeric_input+0xe2>
    if (uistat.digit == 8-i) {
 800e75e:	4293      	cmp	r3, r2
 800e760:	d100      	bne.n	800e764 <draw_numeric_input+0x44>
 800e762:	e07e      	b.n	800e862 <draw_numeric_input+0x142>
    if (c >= 0)
 800e764:	2800      	cmp	r0, #0
 800e766:	db00      	blt.n	800e76a <draw_numeric_input+0x4a>
 800e768:	e077      	b.n	800e85a <draw_numeric_input+0x13a>
    else if (focused)
 800e76a:	464b      	mov	r3, r9
 800e76c:	2b00      	cmp	r3, #0
 800e76e:	d164      	bne.n	800e83a <draw_numeric_input+0x11a>
      ili9341_fill(x, 208+4, 20, 24, bg);
 800e770:	4b4c      	ldr	r3, [pc, #304]	; (800e8a4 <draw_numeric_input+0x184>)
 800e772:	2214      	movs	r2, #20
 800e774:	9300      	str	r3, [sp, #0]
 800e776:	21d4      	movs	r1, #212	; 0xd4
 800e778:	2318      	movs	r3, #24
 800e77a:	0028      	movs	r0, r5
 800e77c:	f001 ff28 	bl	80105d0 <ili9341_fill>
    if (xsim[i] > 0) {
 800e780:	0063      	lsls	r3, r4, #1
      x += xsim[i];
 800e782:	5af3      	ldrh	r3, [r6, r3]
    x += 20;
 800e784:	3514      	adds	r5, #20
  for (i = 0; i < 10 && buf[i]; i++) {
 800e786:	3401      	adds	r4, #1
      x += xsim[i];
 800e788:	195d      	adds	r5, r3, r5
  for (i = 0; i < 10 && buf[i]; i++) {
 800e78a:	2c0a      	cmp	r4, #10
 800e78c:	d023      	beq.n	800e7d6 <draw_numeric_input+0xb6>
 800e78e:	4643      	mov	r3, r8
 800e790:	5d18      	ldrb	r0, [r3, r4]
 800e792:	2800      	cmp	r0, #0
 800e794:	d054      	beq.n	800e840 <draw_numeric_input+0x120>
    if (c == '.')
 800e796:	2300      	movs	r3, #0
 800e798:	56fb      	ldrsb	r3, [r7, r3]
 800e79a:	282e      	cmp	r0, #46	; 0x2e
 800e79c:	d1d8      	bne.n	800e750 <draw_numeric_input+0x30>
    if (uistat.digit == 8-i) {
 800e79e:	2208      	movs	r2, #8
 800e7a0:	1b12      	subs	r2, r2, r4
 800e7a2:	4293      	cmp	r3, r2
 800e7a4:	d141      	bne.n	800e82a <draw_numeric_input+0x10a>
      if (uistat.digit_mode)
 800e7a6:	2301      	movs	r3, #1
      focused = TRUE;
 800e7a8:	2101      	movs	r1, #1
      if (uistat.digit_mode)
 800e7aa:	56fb      	ldrsb	r3, [r7, r3]
 800e7ac:	200a      	movs	r0, #10
 800e7ae:	425a      	negs	r2, r3
 800e7b0:	4153      	adcs	r3, r2
      focused = TRUE;
 800e7b2:	4689      	mov	r9, r1
      if (uistat.digit_mode)
 800e7b4:	425b      	negs	r3, r3
      fg = RGBHEX(0xf7131f);
 800e7b6:	4a3c      	ldr	r2, [pc, #240]	; (800e8a8 <draw_numeric_input+0x188>)
      if (uistat.digit_mode)
 800e7b8:	b29b      	uxth	r3, r3
      ili9341_drawfont(c, &NF20x22, x, 208+4, fg, bg);
 800e7ba:	9301      	str	r3, [sp, #4]
 800e7bc:	9200      	str	r2, [sp, #0]
 800e7be:	23d4      	movs	r3, #212	; 0xd4
 800e7c0:	002a      	movs	r2, r5
 800e7c2:	4651      	mov	r1, sl
 800e7c4:	f002 f984 	bl	8010ad0 <ili9341_drawfont>
    if (xsim[i] > 0) {
 800e7c8:	0063      	lsls	r3, r4, #1
      x += xsim[i];
 800e7ca:	5af3      	ldrh	r3, [r6, r3]
    x += 20;
 800e7cc:	3514      	adds	r5, #20
  for (i = 0; i < 10 && buf[i]; i++) {
 800e7ce:	3401      	adds	r4, #1
      x += xsim[i];
 800e7d0:	195d      	adds	r5, r3, r5
  for (i = 0; i < 10 && buf[i]; i++) {
 800e7d2:	2c0a      	cmp	r4, #10
 800e7d4:	d1db      	bne.n	800e78e <draw_numeric_input+0x6e>
}
 800e7d6:	b009      	add	sp, #36	; 0x24
 800e7d8:	bc3c      	pop	{r2, r3, r4, r5}
 800e7da:	4690      	mov	r8, r2
 800e7dc:	4699      	mov	r9, r3
 800e7de:	46a2      	mov	sl, r4
 800e7e0:	46ab      	mov	fp, r5
 800e7e2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (uistat.digit == 8-i) {
 800e7e4:	2208      	movs	r2, #8
 800e7e6:	1b12      	subs	r2, r2, r4
 800e7e8:	429a      	cmp	r2, r3
 800e7ea:	d122      	bne.n	800e832 <draw_numeric_input+0x112>
      if (uistat.digit_mode)
 800e7ec:	2301      	movs	r3, #1
 800e7ee:	56fb      	ldrsb	r3, [r7, r3]
      focused = TRUE;
 800e7f0:	2101      	movs	r1, #1
      if (uistat.digit_mode)
 800e7f2:	425a      	negs	r2, r3
 800e7f4:	4153      	adcs	r3, r2
 800e7f6:	425b      	negs	r3, r3
 800e7f8:	b29b      	uxth	r3, r3
 800e7fa:	200b      	movs	r0, #11
      fg = RGBHEX(0xf7131f);
 800e7fc:	4a2a      	ldr	r2, [pc, #168]	; (800e8a8 <draw_numeric_input+0x188>)
      focused = TRUE;
 800e7fe:	4689      	mov	r9, r1
 800e800:	e7db      	b.n	800e7ba <draw_numeric_input+0x9a>
    if (uistat.digit == 8-i) {
 800e802:	4293      	cmp	r3, r2
 800e804:	d1b1      	bne.n	800e76a <draw_numeric_input+0x4a>
      if (uistat.digit_mode)
 800e806:	2301      	movs	r3, #1
 800e808:	56fb      	ldrsb	r3, [r7, r3]
 800e80a:	425a      	negs	r2, r3
 800e80c:	4153      	adcs	r3, r2
      fg = RGBHEX(0xf7131f);
 800e80e:	4a26      	ldr	r2, [pc, #152]	; (800e8a8 <draw_numeric_input+0x188>)
      if (uistat.digit_mode)
 800e810:	425b      	negs	r3, r3
 800e812:	b29b      	uxth	r3, r3
      ili9341_drawfont(0, &NF20x22, x, 208+4, fg, bg);
 800e814:	9301      	str	r3, [sp, #4]
 800e816:	9200      	str	r2, [sp, #0]
 800e818:	23d4      	movs	r3, #212	; 0xd4
 800e81a:	002a      	movs	r2, r5
 800e81c:	4659      	mov	r1, fp
 800e81e:	2000      	movs	r0, #0
 800e820:	f002 f956 	bl	8010ad0 <ili9341_drawfont>
 800e824:	2301      	movs	r3, #1
 800e826:	4699      	mov	r9, r3
 800e828:	e7aa      	b.n	800e780 <draw_numeric_input+0x60>
    if (uistat.digit == 8-i) {
 800e82a:	200a      	movs	r0, #10
    uint16_t bg = 0xffff;
 800e82c:	4b1d      	ldr	r3, [pc, #116]	; (800e8a4 <draw_numeric_input+0x184>)
    uint16_t fg = 0x0000;
 800e82e:	2200      	movs	r2, #0
 800e830:	e7c3      	b.n	800e7ba <draw_numeric_input+0x9a>
    if (uistat.digit == 8-i) {
 800e832:	200b      	movs	r0, #11
    uint16_t bg = 0xffff;
 800e834:	4b1b      	ldr	r3, [pc, #108]	; (800e8a4 <draw_numeric_input+0x184>)
    uint16_t fg = 0x0000;
 800e836:	2200      	movs	r2, #0
 800e838:	e7bf      	b.n	800e7ba <draw_numeric_input+0x9a>
    uint16_t bg = 0xffff;
 800e83a:	4b1a      	ldr	r3, [pc, #104]	; (800e8a4 <draw_numeric_input+0x184>)
    uint16_t fg = 0x0000;
 800e83c:	2200      	movs	r2, #0
 800e83e:	e7e9      	b.n	800e814 <draw_numeric_input+0xf4>
      ili9341_fill(x, 208+4, 20*(10-i), 24, 0xffff);
 800e840:	220a      	movs	r2, #10
 800e842:	1b14      	subs	r4, r2, r4
 800e844:	00a2      	lsls	r2, r4, #2
 800e846:	4b17      	ldr	r3, [pc, #92]	; (800e8a4 <draw_numeric_input+0x184>)
 800e848:	1912      	adds	r2, r2, r4
 800e84a:	9300      	str	r3, [sp, #0]
 800e84c:	0092      	lsls	r2, r2, #2
 800e84e:	2318      	movs	r3, #24
 800e850:	21d4      	movs	r1, #212	; 0xd4
 800e852:	0028      	movs	r0, r5
 800e854:	f001 febc 	bl	80105d0 <ili9341_fill>
 800e858:	e7bd      	b.n	800e7d6 <draw_numeric_input+0xb6>
 800e85a:	b2c0      	uxtb	r0, r0
    uint16_t bg = 0xffff;
 800e85c:	4b11      	ldr	r3, [pc, #68]	; (800e8a4 <draw_numeric_input+0x184>)
    uint16_t fg = 0x0000;
 800e85e:	2200      	movs	r2, #0
 800e860:	e7ab      	b.n	800e7ba <draw_numeric_input+0x9a>
      if (uistat.digit_mode)
 800e862:	2301      	movs	r3, #1
 800e864:	56fb      	ldrsb	r3, [r7, r3]
 800e866:	2b00      	cmp	r3, #0
 800e868:	d004      	beq.n	800e874 <draw_numeric_input+0x154>
    if (c >= 0)
 800e86a:	2800      	cmp	r0, #0
 800e86c:	da07      	bge.n	800e87e <draw_numeric_input+0x15e>
        bg = 0x0000;
 800e86e:	2300      	movs	r3, #0
      fg = RGBHEX(0xf7131f);
 800e870:	4a0d      	ldr	r2, [pc, #52]	; (800e8a8 <draw_numeric_input+0x188>)
 800e872:	e7cf      	b.n	800e814 <draw_numeric_input+0xf4>
    if (c >= 0)
 800e874:	2800      	cmp	r0, #0
 800e876:	da08      	bge.n	800e88a <draw_numeric_input+0x16a>
    uint16_t bg = 0xffff;
 800e878:	4b0a      	ldr	r3, [pc, #40]	; (800e8a4 <draw_numeric_input+0x184>)
      fg = RGBHEX(0xf7131f);
 800e87a:	4a0b      	ldr	r2, [pc, #44]	; (800e8a8 <draw_numeric_input+0x188>)
 800e87c:	e7ca      	b.n	800e814 <draw_numeric_input+0xf4>
      focused = TRUE;
 800e87e:	2101      	movs	r1, #1
 800e880:	b2c0      	uxtb	r0, r0
        bg = 0x0000;
 800e882:	2300      	movs	r3, #0
      fg = RGBHEX(0xf7131f);
 800e884:	4a08      	ldr	r2, [pc, #32]	; (800e8a8 <draw_numeric_input+0x188>)
      focused = TRUE;
 800e886:	4689      	mov	r9, r1
 800e888:	e797      	b.n	800e7ba <draw_numeric_input+0x9a>
 800e88a:	2101      	movs	r1, #1
 800e88c:	b2c0      	uxtb	r0, r0
    uint16_t bg = 0xffff;
 800e88e:	4b05      	ldr	r3, [pc, #20]	; (800e8a4 <draw_numeric_input+0x184>)
      fg = RGBHEX(0xf7131f);
 800e890:	4a05      	ldr	r2, [pc, #20]	; (800e8a8 <draw_numeric_input+0x188>)
      focused = TRUE;
 800e892:	4689      	mov	r9, r1
 800e894:	e791      	b.n	800e7ba <draw_numeric_input+0x9a>
 800e896:	46c0      	nop			; (mov r8, r8)
 800e898:	080132e4 	.word	0x080132e4
 800e89c:	080156d4 	.word	0x080156d4
 800e8a0:	20001654 	.word	0x20001654
 800e8a4:	0000ffff 	.word	0x0000ffff
 800e8a8:	000083f0 	.word	0x000083f0
 800e8ac:	00000000 	.word	0x00000000

0800e8b0 <draw_numeric_area>:
{
 800e8b0:	b500      	push	{lr}
  chsnprintf(buf, sizeof buf, "%9d", uistat.value);
 800e8b2:	4b06      	ldr	r3, [pc, #24]	; (800e8cc <draw_numeric_area+0x1c>)
{
 800e8b4:	b085      	sub	sp, #20
  chsnprintf(buf, sizeof buf, "%9d", uistat.value);
 800e8b6:	685b      	ldr	r3, [r3, #4]
 800e8b8:	4a05      	ldr	r2, [pc, #20]	; (800e8d0 <draw_numeric_area+0x20>)
 800e8ba:	210a      	movs	r1, #10
 800e8bc:	a801      	add	r0, sp, #4
 800e8be:	f7f8 fe37 	bl	8007530 <chsnprintf>
  draw_numeric_input(buf);
 800e8c2:	a801      	add	r0, sp, #4
 800e8c4:	f7ff ff2c 	bl	800e720 <draw_numeric_input>
}
 800e8c8:	b005      	add	sp, #20
 800e8ca:	bd00      	pop	{pc}
 800e8cc:	20001654 	.word	0x20001654
 800e8d0:	08014b94 	.word	0x08014b94
	...

0800e8e0 <draw_keypad>:
{
 800e8e0:	b5f0      	push	{r4, r5, r6, r7, lr}
 800e8e2:	4657      	mov	r7, sl
 800e8e4:	46de      	mov	lr, fp
 800e8e6:	464e      	mov	r6, r9
 800e8e8:	4645      	mov	r5, r8
 800e8ea:	b5e0      	push	{r5, r6, r7, lr}
  while (keypads[i].x) {
 800e8ec:	4f1c      	ldr	r7, [pc, #112]	; (800e960 <draw_keypad+0x80>)
{
 800e8ee:	b083      	sub	sp, #12
  while (keypads[i].x) {
 800e8f0:	683b      	ldr	r3, [r7, #0]
 800e8f2:	8818      	ldrh	r0, [r3, #0]
 800e8f4:	2800      	cmp	r0, #0
 800e8f6:	d02c      	beq.n	800e952 <draw_keypad+0x72>
 800e8f8:	4a1a      	ldr	r2, [pc, #104]	; (800e964 <draw_keypad+0x84>)
  int i = 0;
 800e8fa:	2600      	movs	r6, #0
 800e8fc:	4690      	mov	r8, r2
 800e8fe:	4a1a      	ldr	r2, [pc, #104]	; (800e968 <draw_keypad+0x88>)
  while (keypads[i].x) {
 800e900:	2400      	movs	r4, #0
 800e902:	4693      	mov	fp, r2
 800e904:	4a19      	ldr	r2, [pc, #100]	; (800e96c <draw_keypad+0x8c>)
 800e906:	4692      	mov	sl, r2
    ili9341_drawfont(keypads[i].c, &NF20x22, keypads[i].x+12, keypads[i].y+10, 0x0000, bg);
 800e908:	2200      	movs	r2, #0
 800e90a:	4691      	mov	r9, r2
    uint16_t bg = config.menu_normal_color;
 800e90c:	4642      	mov	r2, r8
 800e90e:	88d5      	ldrh	r5, [r2, #6]
    if (i == selection)
 800e910:	465a      	mov	r2, fp
 800e912:	7812      	ldrb	r2, [r2, #0]
 800e914:	b252      	sxtb	r2, r2
 800e916:	42b2      	cmp	r2, r6
 800e918:	d101      	bne.n	800e91e <draw_keypad+0x3e>
      bg = config.menu_active_color;
 800e91a:	4642      	mov	r2, r8
 800e91c:	8915      	ldrh	r5, [r2, #8]
    ili9341_fill(keypads[i].x, keypads[i].y, 44, 44, bg);
 800e91e:	8859      	ldrh	r1, [r3, #2]
 800e920:	222c      	movs	r2, #44	; 0x2c
 800e922:	232c      	movs	r3, #44	; 0x2c
 800e924:	9500      	str	r5, [sp, #0]
 800e926:	f001 fe53 	bl	80105d0 <ili9341_fill>
    ili9341_drawfont(keypads[i].c, &NF20x22, keypads[i].x+12, keypads[i].y+10, 0x0000, bg);
 800e92a:	683b      	ldr	r3, [r7, #0]
    i++;
 800e92c:	3601      	adds	r6, #1
    ili9341_drawfont(keypads[i].c, &NF20x22, keypads[i].x+12, keypads[i].y+10, 0x0000, bg);
 800e92e:	1919      	adds	r1, r3, r4
 800e930:	884b      	ldrh	r3, [r1, #2]
 800e932:	880a      	ldrh	r2, [r1, #0]
 800e934:	7908      	ldrb	r0, [r1, #4]
 800e936:	4649      	mov	r1, r9
 800e938:	330a      	adds	r3, #10
 800e93a:	9100      	str	r1, [sp, #0]
 800e93c:	320c      	adds	r2, #12
 800e93e:	9501      	str	r5, [sp, #4]
 800e940:	4651      	mov	r1, sl
 800e942:	f002 f8c5 	bl	8010ad0 <ili9341_drawfont>
  while (keypads[i].x) {
 800e946:	683b      	ldr	r3, [r7, #0]
 800e948:	3406      	adds	r4, #6
 800e94a:	191b      	adds	r3, r3, r4
 800e94c:	8818      	ldrh	r0, [r3, #0]
 800e94e:	2800      	cmp	r0, #0
 800e950:	d1dc      	bne.n	800e90c <draw_keypad+0x2c>
}
 800e952:	b003      	add	sp, #12
 800e954:	bc3c      	pop	{r2, r3, r4, r5}
 800e956:	4690      	mov	r8, r2
 800e958:	4699      	mov	r9, r3
 800e95a:	46a2      	mov	sl, r4
 800e95c:	46ab      	mov	fp, r5
 800e95e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800e960:	2000307c 	.word	0x2000307c
 800e964:	2000042c 	.word	0x2000042c
 800e968:	200030a4 	.word	0x200030a4
 800e96c:	080156d4 	.word	0x080156d4

0800e970 <draw_menu_buttons>:
{
 800e970:	b5f0      	push	{r4, r5, r6, r7, lr}
 800e972:	464e      	mov	r6, r9
 800e974:	4645      	mov	r5, r8
 800e976:	46de      	mov	lr, fp
 800e978:	4657      	mov	r7, sl
 800e97a:	4680      	mov	r8, r0
 800e97c:	b5e0      	push	{r5, r6, r7, lr}
  for (i = 0; i < 7; i++) {
 800e97e:	2400      	movs	r4, #0
 800e980:	0006      	movs	r6, r0
{
 800e982:	b083      	sub	sp, #12
    if (menu[i].type == MT_NONE)
 800e984:	7833      	ldrb	r3, [r6, #0]
 800e986:	2b00      	cmp	r3, #0
 800e988:	d04a      	beq.n	800ea20 <draw_menu_buttons+0xb0>
    if (menu[i].type == MT_BLANK) 
 800e98a:	2b01      	cmp	r3, #1
 800e98c:	d044      	beq.n	800ea18 <draw_menu_buttons+0xa8>
    uint16_t bg = config.menu_normal_color;
 800e98e:	4b88      	ldr	r3, [pc, #544]	; (800ebb0 <draw_menu_buttons+0x240>)
 800e990:	0165      	lsls	r5, r4, #5
 800e992:	88db      	ldrh	r3, [r3, #6]
 800e994:	4699      	mov	r9, r3
    if (ui_mode == UI_MENU && i == selection)
 800e996:	4b87      	ldr	r3, [pc, #540]	; (800ebb4 <draw_menu_buttons+0x244>)
 800e998:	781b      	ldrb	r3, [r3, #0]
 800e99a:	2b01      	cmp	r3, #1
 800e99c:	d047      	beq.n	800ea2e <draw_menu_buttons+0xbe>
    ili9341_fill(320-72, y, 72, 30, bg);
 800e99e:	464b      	mov	r3, r9
 800e9a0:	2248      	movs	r2, #72	; 0x48
 800e9a2:	9300      	str	r3, [sp, #0]
 800e9a4:	0029      	movs	r1, r5
 800e9a6:	231e      	movs	r3, #30
 800e9a8:	20f8      	movs	r0, #248	; 0xf8
 800e9aa:	f001 fe11 	bl	80105d0 <ili9341_fill>
  if (menu == menu_trace && item < TRACE_COUNT  && item < MARKER_COUNT) {
 800e9ae:	4b82      	ldr	r3, [pc, #520]	; (800ebb8 <draw_menu_buttons+0x248>)
 800e9b0:	4598      	cmp	r8, r3
 800e9b2:	d045      	beq.n	800ea40 <draw_menu_buttons+0xd0>
  } else if (menu == menu_marker_sel && item < 4&& item < MARKER_COUNT) {
 800e9b4:	4b81      	ldr	r3, [pc, #516]	; (800ebbc <draw_menu_buttons+0x24c>)
 800e9b6:	4598      	cmp	r8, r3
 800e9b8:	d066      	beq.n	800ea88 <draw_menu_buttons+0x118>
  } else if (menu == menu_calop) {
 800e9ba:	4b81      	ldr	r3, [pc, #516]	; (800ebc0 <draw_menu_buttons+0x250>)
 800e9bc:	4598      	cmp	r8, r3
 800e9be:	d100      	bne.n	800e9c2 <draw_menu_buttons+0x52>
 800e9c0:	e070      	b.n	800eaa4 <draw_menu_buttons+0x134>
  } else if (menu == menu_stimulus) {
 800e9c2:	4b80      	ldr	r3, [pc, #512]	; (800ebc4 <draw_menu_buttons+0x254>)
 800e9c4:	4598      	cmp	r8, r3
 800e9c6:	d100      	bne.n	800e9ca <draw_menu_buttons+0x5a>
 800e9c8:	e087      	b.n	800eada <draw_menu_buttons+0x16a>
  } else if (menu == menu_cal) {
 800e9ca:	4b7f      	ldr	r3, [pc, #508]	; (800ebc8 <draw_menu_buttons+0x258>)
 800e9cc:	4598      	cmp	r8, r3
 800e9ce:	d100      	bne.n	800e9d2 <draw_menu_buttons+0x62>
 800e9d0:	e08e      	b.n	800eaf0 <draw_menu_buttons+0x180>
  } else if (menu == menu_transform) {
 800e9d2:	4b7e      	ldr	r3, [pc, #504]	; (800ebcc <draw_menu_buttons+0x25c>)
 800e9d4:	4598      	cmp	r8, r3
 800e9d6:	d000      	beq.n	800e9da <draw_menu_buttons+0x6a>
 800e9d8:	e0ac      	b.n	800eb34 <draw_menu_buttons+0x1c4>
      if ((item == 0 && (domain_mode & DOMAIN_MODE) == DOMAIN_TIME)
 800e9da:	2c00      	cmp	r4, #0
 800e9dc:	d100      	bne.n	800e9e0 <draw_menu_buttons+0x70>
 800e9de:	e098      	b.n	800eb12 <draw_menu_buttons+0x1a2>
       || (item == 1 && (domain_mode & TD_FUNC) == TD_FUNC_LOWPASS_IMPULSE)
 800e9e0:	2c01      	cmp	r4, #1
 800e9e2:	d100      	bne.n	800e9e6 <draw_menu_buttons+0x76>
 800e9e4:	e0c3      	b.n	800eb6e <draw_menu_buttons+0x1fe>
       || (item == 2 && (domain_mode & TD_FUNC) == TD_FUNC_LOWPASS_STEP)
 800e9e6:	2c02      	cmp	r4, #2
 800e9e8:	d000      	beq.n	800e9ec <draw_menu_buttons+0x7c>
 800e9ea:	e0c9      	b.n	800eb80 <draw_menu_buttons+0x210>
 800e9ec:	4b78      	ldr	r3, [pc, #480]	; (800ebd0 <draw_menu_buttons+0x260>)
 800e9ee:	4a79      	ldr	r2, [pc, #484]	; (800ebd4 <draw_menu_buttons+0x264>)
 800e9f0:	5cd2      	ldrb	r2, [r2, r3]
 800e9f2:	2306      	movs	r3, #6
 800e9f4:	4013      	ands	r3, r2
 800e9f6:	2b04      	cmp	r3, #4
 800e9f8:	d04f      	beq.n	800ea9a <draw_menu_buttons+0x12a>
    uint16_t fg = 0x0000;
 800e9fa:	2300      	movs	r3, #0
 800e9fc:	469a      	mov	sl, r3
        if (menu_is_multiline(menu[i].label, &l1, &l2)) {
 800e9fe:	6877      	ldr	r7, [r6, #4]
  if (label[0] != '\2')
 800ea00:	783b      	ldrb	r3, [r7, #0]
 800ea02:	2b02      	cmp	r3, #2
 800ea04:	d02e      	beq.n	800ea64 <draw_menu_buttons+0xf4>
          ili9341_drawstring_7x13(menu[i].label, 320-70, y+9, fg, bg);
 800ea06:	002a      	movs	r2, r5
 800ea08:	3209      	adds	r2, #9
          ili9341_drawstring_7x13(l2, 320-70, y+16, fg, bg);
 800ea0a:	464b      	mov	r3, r9
 800ea0c:	21fa      	movs	r1, #250	; 0xfa
 800ea0e:	9300      	str	r3, [sp, #0]
 800ea10:	0038      	movs	r0, r7
 800ea12:	4653      	mov	r3, sl
 800ea14:	f001 ff1c 	bl	8010850 <ili9341_drawstring_7x13>
  for (i = 0; i < 7; i++) {
 800ea18:	3401      	adds	r4, #1
 800ea1a:	360c      	adds	r6, #12
 800ea1c:	2c07      	cmp	r4, #7
 800ea1e:	d1b1      	bne.n	800e984 <draw_menu_buttons+0x14>
}
 800ea20:	b003      	add	sp, #12
 800ea22:	bc3c      	pop	{r2, r3, r4, r5}
 800ea24:	4690      	mov	r8, r2
 800ea26:	4699      	mov	r9, r3
 800ea28:	46a2      	mov	sl, r4
 800ea2a:	46ab      	mov	fp, r5
 800ea2c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (ui_mode == UI_MENU && i == selection)
 800ea2e:	4b6a      	ldr	r3, [pc, #424]	; (800ebd8 <draw_menu_buttons+0x268>)
 800ea30:	781b      	ldrb	r3, [r3, #0]
 800ea32:	b25b      	sxtb	r3, r3
 800ea34:	42a3      	cmp	r3, r4
 800ea36:	d1b2      	bne.n	800e99e <draw_menu_buttons+0x2e>
      bg = config.menu_active_color;
 800ea38:	4b5d      	ldr	r3, [pc, #372]	; (800ebb0 <draw_menu_buttons+0x240>)
 800ea3a:	891b      	ldrh	r3, [r3, #8]
 800ea3c:	4699      	mov	r9, r3
 800ea3e:	e7ae      	b.n	800e99e <draw_menu_buttons+0x2e>
    uint16_t fg = 0x0000;
 800ea40:	2300      	movs	r3, #0
 800ea42:	469a      	mov	sl, r3
  if (menu == menu_trace && item < TRACE_COUNT  && item < MARKER_COUNT) {
 800ea44:	2c03      	cmp	r4, #3
 800ea46:	dcda      	bgt.n	800e9fe <draw_menu_buttons+0x8e>
    if (trace[item].enabled)
 800ea48:	0062      	lsls	r2, r4, #1
 800ea4a:	1913      	adds	r3, r2, r4
 800ea4c:	4963      	ldr	r1, [pc, #396]	; (800ebdc <draw_menu_buttons+0x26c>)
 800ea4e:	009b      	lsls	r3, r3, #2
 800ea50:	5ccb      	ldrb	r3, [r1, r3]
 800ea52:	2b00      	cmp	r3, #0
 800ea54:	d0d3      	beq.n	800e9fe <draw_menu_buttons+0x8e>
      *bg = config.trace_color[item];
 800ea56:	4b62      	ldr	r3, [pc, #392]	; (800ebe0 <draw_menu_buttons+0x270>)
        if (menu_is_multiline(menu[i].label, &l1, &l2)) {
 800ea58:	6877      	ldr	r7, [r6, #4]
      *bg = config.trace_color[item];
 800ea5a:	5a9b      	ldrh	r3, [r3, r2]
 800ea5c:	4699      	mov	r9, r3
  if (label[0] != '\2')
 800ea5e:	783b      	ldrb	r3, [r7, #0]
 800ea60:	2b02      	cmp	r3, #2
 800ea62:	d1d0      	bne.n	800ea06 <draw_menu_buttons+0x96>
  *l1 = &label[1];
 800ea64:	1c7b      	adds	r3, r7, #1
  *l2 = &label[1] + strlen(&label[1]) + 1;
 800ea66:	0018      	movs	r0, r3
  *l1 = &label[1];
 800ea68:	469b      	mov	fp, r3
  *l2 = &label[1] + strlen(&label[1]) + 1;
 800ea6a:	f7f4 fec1 	bl	80037f0 <strlen>
          ili9341_drawstring_7x13(l1, 320-70, y+3, fg, bg);
 800ea6e:	464b      	mov	r3, r9
  *l2 = &label[1] + strlen(&label[1]) + 1;
 800ea70:	3002      	adds	r0, #2
          ili9341_drawstring_7x13(l1, 320-70, y+3, fg, bg);
 800ea72:	1cea      	adds	r2, r5, #3
 800ea74:	9300      	str	r3, [sp, #0]
  *l2 = &label[1] + strlen(&label[1]) + 1;
 800ea76:	183f      	adds	r7, r7, r0
          ili9341_drawstring_7x13(l1, 320-70, y+3, fg, bg);
 800ea78:	4653      	mov	r3, sl
 800ea7a:	21fa      	movs	r1, #250	; 0xfa
 800ea7c:	4658      	mov	r0, fp
 800ea7e:	f001 fee7 	bl	8010850 <ili9341_drawstring_7x13>
          ili9341_drawstring_7x13(l2, 320-70, y+16, fg, bg);
 800ea82:	002a      	movs	r2, r5
 800ea84:	3210      	adds	r2, #16
 800ea86:	e7c0      	b.n	800ea0a <draw_menu_buttons+0x9a>
    uint16_t fg = 0x0000;
 800ea88:	2300      	movs	r3, #0
 800ea8a:	469a      	mov	sl, r3
  } else if (menu == menu_marker_sel && item < 4&& item < MARKER_COUNT) {
 800ea8c:	2c03      	cmp	r4, #3
 800ea8e:	dcb6      	bgt.n	800e9fe <draw_menu_buttons+0x8e>
    if (markers[item].enabled) {
 800ea90:	4a54      	ldr	r2, [pc, #336]	; (800ebe4 <draw_menu_buttons+0x274>)
 800ea92:	00e3      	lsls	r3, r4, #3
 800ea94:	56d3      	ldrsb	r3, [r2, r3]
 800ea96:	2b00      	cmp	r3, #0
 800ea98:	d0b1      	beq.n	800e9fe <draw_menu_buttons+0x8e>
      *fg = 0xffff;
 800ea9a:	4b53      	ldr	r3, [pc, #332]	; (800ebe8 <draw_menu_buttons+0x278>)
 800ea9c:	469a      	mov	sl, r3
      *bg = 0x0000;
 800ea9e:	2300      	movs	r3, #0
 800eaa0:	4699      	mov	r9, r3
 800eaa2:	e7ac      	b.n	800e9fe <draw_menu_buttons+0x8e>
    if ((item == 0 && (cal_status & CALSTAT_OPEN))
 800eaa4:	2c00      	cmp	r4, #0
 800eaa6:	d10d      	bne.n	800eac4 <draw_menu_buttons+0x154>
 800eaa8:	4b4a      	ldr	r3, [pc, #296]	; (800ebd4 <draw_menu_buttons+0x264>)
 800eaaa:	89da      	ldrh	r2, [r3, #14]
 800eaac:	0792      	lsls	r2, r2, #30
 800eaae:	d5a4      	bpl.n	800e9fa <draw_menu_buttons+0x8a>
      domain_mode = (domain_mode & ~DOMAIN_MODE) | DOMAIN_FREQ;
 800eab0:	2001      	movs	r0, #1
 800eab2:	4947      	ldr	r1, [pc, #284]	; (800ebd0 <draw_menu_buttons+0x260>)
 800eab4:	5c5a      	ldrb	r2, [r3, r1]
 800eab6:	4382      	bics	r2, r0
 800eab8:	545a      	strb	r2, [r3, r1]
      *fg = 0xffff;
 800eaba:	4b4b      	ldr	r3, [pc, #300]	; (800ebe8 <draw_menu_buttons+0x278>)
 800eabc:	469a      	mov	sl, r3
      *bg = 0x0000;
 800eabe:	2300      	movs	r3, #0
 800eac0:	4699      	mov	r9, r3
 800eac2:	e79c      	b.n	800e9fe <draw_menu_buttons+0x8e>
        || (item == 1 && (cal_status & CALSTAT_SHORT))
 800eac4:	2c01      	cmp	r4, #1
 800eac6:	d01d      	beq.n	800eb04 <draw_menu_buttons+0x194>
        || (item == 2 && (cal_status & CALSTAT_LOAD))
 800eac8:	2c02      	cmp	r4, #2
 800eaca:	d042      	beq.n	800eb52 <draw_menu_buttons+0x1e2>
        || (item == 3 && (cal_status & CALSTAT_ISOLN))
 800eacc:	2c03      	cmp	r4, #3
 800eace:	d126      	bne.n	800eb1e <draw_menu_buttons+0x1ae>
 800ead0:	4b40      	ldr	r3, [pc, #256]	; (800ebd4 <draw_menu_buttons+0x264>)
 800ead2:	89da      	ldrh	r2, [r3, #14]
 800ead4:	06d2      	lsls	r2, r2, #27
 800ead6:	d4eb      	bmi.n	800eab0 <draw_menu_buttons+0x140>
 800ead8:	e78f      	b.n	800e9fa <draw_menu_buttons+0x8a>
    uint16_t fg = 0x0000;
 800eada:	2300      	movs	r3, #0
 800eadc:	469a      	mov	sl, r3
    if (item == 5 /* PAUSE */ && !sweep_enabled) {
 800eade:	2c05      	cmp	r4, #5
 800eae0:	d000      	beq.n	800eae4 <draw_menu_buttons+0x174>
 800eae2:	e78c      	b.n	800e9fe <draw_menu_buttons+0x8e>
 800eae4:	4b41      	ldr	r3, [pc, #260]	; (800ebec <draw_menu_buttons+0x27c>)
 800eae6:	781b      	ldrb	r3, [r3, #0]
 800eae8:	b25b      	sxtb	r3, r3
 800eaea:	2b00      	cmp	r3, #0
 800eaec:	d0d5      	beq.n	800ea9a <draw_menu_buttons+0x12a>
 800eaee:	e786      	b.n	800e9fe <draw_menu_buttons+0x8e>
    uint16_t fg = 0x0000;
 800eaf0:	2300      	movs	r3, #0
 800eaf2:	469a      	mov	sl, r3
    if (item == 3 /* CORRECTION */ && (cal_status & CALSTAT_APPLY)) {
 800eaf4:	2c03      	cmp	r4, #3
 800eaf6:	d000      	beq.n	800eafa <draw_menu_buttons+0x18a>
 800eaf8:	e781      	b.n	800e9fe <draw_menu_buttons+0x8e>
 800eafa:	4b36      	ldr	r3, [pc, #216]	; (800ebd4 <draw_menu_buttons+0x264>)
 800eafc:	89db      	ldrh	r3, [r3, #14]
 800eafe:	05db      	lsls	r3, r3, #23
 800eb00:	d4cb      	bmi.n	800ea9a <draw_menu_buttons+0x12a>
 800eb02:	e77c      	b.n	800e9fe <draw_menu_buttons+0x8e>
        || (item == 1 && (cal_status & CALSTAT_SHORT))
 800eb04:	4b33      	ldr	r3, [pc, #204]	; (800ebd4 <draw_menu_buttons+0x264>)
 800eb06:	89da      	ldrh	r2, [r3, #14]
 800eb08:	0752      	lsls	r2, r2, #29
 800eb0a:	d4d1      	bmi.n	800eab0 <draw_menu_buttons+0x140>
    uint16_t fg = 0x0000;
 800eb0c:	2300      	movs	r3, #0
 800eb0e:	469a      	mov	sl, r3
 800eb10:	e775      	b.n	800e9fe <draw_menu_buttons+0x8e>
      if ((item == 0 && (domain_mode & DOMAIN_MODE) == DOMAIN_TIME)
 800eb12:	4a30      	ldr	r2, [pc, #192]	; (800ebd4 <draw_menu_buttons+0x264>)
 800eb14:	4b2e      	ldr	r3, [pc, #184]	; (800ebd0 <draw_menu_buttons+0x260>)
 800eb16:	5cd3      	ldrb	r3, [r2, r3]
 800eb18:	07db      	lsls	r3, r3, #31
 800eb1a:	d4be      	bmi.n	800ea9a <draw_menu_buttons+0x12a>
 800eb1c:	e76d      	b.n	800e9fa <draw_menu_buttons+0x8a>
        || (item == 4 && (cal_status & CALSTAT_THRU))) {
 800eb1e:	2c04      	cmp	r4, #4
 800eb20:	d000      	beq.n	800eb24 <draw_menu_buttons+0x1b4>
 800eb22:	e76a      	b.n	800e9fa <draw_menu_buttons+0x8a>
    uint16_t fg = 0x0000;
 800eb24:	2100      	movs	r1, #0
        || (item == 4 && (cal_status & CALSTAT_THRU))) {
 800eb26:	4b2b      	ldr	r3, [pc, #172]	; (800ebd4 <draw_menu_buttons+0x264>)
    uint16_t fg = 0x0000;
 800eb28:	468a      	mov	sl, r1
        || (item == 4 && (cal_status & CALSTAT_THRU))) {
 800eb2a:	89da      	ldrh	r2, [r3, #14]
 800eb2c:	0712      	lsls	r2, r2, #28
 800eb2e:	d400      	bmi.n	800eb32 <draw_menu_buttons+0x1c2>
 800eb30:	e765      	b.n	800e9fe <draw_menu_buttons+0x8e>
 800eb32:	e7bd      	b.n	800eab0 <draw_menu_buttons+0x140>
  } else if (menu == menu_transform_window) {
 800eb34:	4b2e      	ldr	r3, [pc, #184]	; (800ebf0 <draw_menu_buttons+0x280>)
 800eb36:	4598      	cmp	r8, r3
 800eb38:	d000      	beq.n	800eb3c <draw_menu_buttons+0x1cc>
 800eb3a:	e75e      	b.n	800e9fa <draw_menu_buttons+0x8a>
      if ((item == 0 && (domain_mode & TD_WINDOW) == TD_WINDOW_MINIMUM)
 800eb3c:	2c00      	cmp	r4, #0
 800eb3e:	d10d      	bne.n	800eb5c <draw_menu_buttons+0x1ec>
 800eb40:	4b23      	ldr	r3, [pc, #140]	; (800ebd0 <draw_menu_buttons+0x260>)
 800eb42:	4a24      	ldr	r2, [pc, #144]	; (800ebd4 <draw_menu_buttons+0x264>)
 800eb44:	5cd2      	ldrb	r2, [r2, r3]
 800eb46:	2318      	movs	r3, #24
 800eb48:	4013      	ands	r3, r2
 800eb4a:	2b08      	cmp	r3, #8
 800eb4c:	d000      	beq.n	800eb50 <draw_menu_buttons+0x1e0>
 800eb4e:	e754      	b.n	800e9fa <draw_menu_buttons+0x8a>
 800eb50:	e7a3      	b.n	800ea9a <draw_menu_buttons+0x12a>
        || (item == 2 && (cal_status & CALSTAT_LOAD))
 800eb52:	4b20      	ldr	r3, [pc, #128]	; (800ebd4 <draw_menu_buttons+0x264>)
 800eb54:	89da      	ldrh	r2, [r3, #14]
 800eb56:	07d2      	lsls	r2, r2, #31
 800eb58:	d4aa      	bmi.n	800eab0 <draw_menu_buttons+0x140>
 800eb5a:	e74e      	b.n	800e9fa <draw_menu_buttons+0x8a>
       || (item == 1 && (domain_mode & TD_WINDOW) == TD_WINDOW_NORMAL)
 800eb5c:	2c01      	cmp	r4, #1
 800eb5e:	d11a      	bne.n	800eb96 <draw_menu_buttons+0x226>
 800eb60:	4a1c      	ldr	r2, [pc, #112]	; (800ebd4 <draw_menu_buttons+0x264>)
 800eb62:	4b1b      	ldr	r3, [pc, #108]	; (800ebd0 <draw_menu_buttons+0x260>)
 800eb64:	5cd3      	ldrb	r3, [r2, r3]
 800eb66:	2218      	movs	r2, #24
 800eb68:	421a      	tst	r2, r3
 800eb6a:	d096      	beq.n	800ea9a <draw_menu_buttons+0x12a>
 800eb6c:	e745      	b.n	800e9fa <draw_menu_buttons+0x8a>
       || (item == 1 && (domain_mode & TD_FUNC) == TD_FUNC_LOWPASS_IMPULSE)
 800eb6e:	4b18      	ldr	r3, [pc, #96]	; (800ebd0 <draw_menu_buttons+0x260>)
 800eb70:	4a18      	ldr	r2, [pc, #96]	; (800ebd4 <draw_menu_buttons+0x264>)
 800eb72:	5cd2      	ldrb	r2, [r2, r3]
 800eb74:	2306      	movs	r3, #6
 800eb76:	4013      	ands	r3, r2
 800eb78:	2b02      	cmp	r3, #2
 800eb7a:	d000      	beq.n	800eb7e <draw_menu_buttons+0x20e>
 800eb7c:	e73d      	b.n	800e9fa <draw_menu_buttons+0x8a>
 800eb7e:	e78c      	b.n	800ea9a <draw_menu_buttons+0x12a>
       || (item == 3 && (domain_mode & TD_FUNC) == TD_FUNC_BANDPASS)
 800eb80:	2c03      	cmp	r4, #3
 800eb82:	d000      	beq.n	800eb86 <draw_menu_buttons+0x216>
 800eb84:	e739      	b.n	800e9fa <draw_menu_buttons+0x8a>
 800eb86:	4a13      	ldr	r2, [pc, #76]	; (800ebd4 <draw_menu_buttons+0x264>)
 800eb88:	4b11      	ldr	r3, [pc, #68]	; (800ebd0 <draw_menu_buttons+0x260>)
 800eb8a:	5cd3      	ldrb	r3, [r2, r3]
 800eb8c:	2206      	movs	r2, #6
 800eb8e:	421a      	tst	r2, r3
 800eb90:	d100      	bne.n	800eb94 <draw_menu_buttons+0x224>
 800eb92:	e782      	b.n	800ea9a <draw_menu_buttons+0x12a>
 800eb94:	e731      	b.n	800e9fa <draw_menu_buttons+0x8a>
       || (item == 2 && (domain_mode & TD_WINDOW) == TD_WINDOW_MAXIMUM)
 800eb96:	2c02      	cmp	r4, #2
 800eb98:	d000      	beq.n	800eb9c <draw_menu_buttons+0x22c>
 800eb9a:	e72e      	b.n	800e9fa <draw_menu_buttons+0x8a>
 800eb9c:	4b0c      	ldr	r3, [pc, #48]	; (800ebd0 <draw_menu_buttons+0x260>)
 800eb9e:	4a0d      	ldr	r2, [pc, #52]	; (800ebd4 <draw_menu_buttons+0x264>)
 800eba0:	5cd2      	ldrb	r2, [r2, r3]
 800eba2:	2318      	movs	r3, #24
 800eba4:	4013      	ands	r3, r2
 800eba6:	2b10      	cmp	r3, #16
 800eba8:	d000      	beq.n	800ebac <draw_menu_buttons+0x23c>
 800ebaa:	e726      	b.n	800e9fa <draw_menu_buttons+0x8a>
 800ebac:	e775      	b.n	800ea9a <draw_menu_buttons+0x12a>
 800ebae:	46c0      	nop			; (mov r8, r8)
 800ebb0:	2000042c 	.word	0x2000042c
 800ebb4:	200030a5 	.word	0x200030a5
 800ebb8:	080152f4 	.word	0x080152f4
 800ebbc:	08015120 	.word	0x08015120
 800ebc0:	08014eb0 	.word	0x08014eb0
 800ebc4:	08015240 	.word	0x08015240
 800ebc8:	08014e68 	.word	0x08014e68
 800ebcc:	0801533c 	.word	0x0801533c
 800ebd0:	000011c4 	.word	0x000011c4
 800ebd4:	20000454 	.word	0x20000454
 800ebd8:	200030a4 	.word	0x200030a4
 800ebdc:	200015c4 	.word	0x200015c4
 800ebe0:	20000436 	.word	0x20000436
 800ebe4:	200015f4 	.word	0x200015f4
 800ebe8:	0000ffff 	.word	0x0000ffff
 800ebec:	20001630 	.word	0x20001630
 800ebf0:	0801539c 	.word	0x0801539c
	...

0800ec00 <ui_mode_menu>:
{
 800ec00:	b510      	push	{r4, lr}
  if (ui_mode == UI_MENU) 
 800ec02:	4b15      	ldr	r3, [pc, #84]	; (800ec58 <ui_mode_menu+0x58>)
 800ec04:	781a      	ldrb	r2, [r3, #0]
 800ec06:	2a01      	cmp	r2, #1
 800ec08:	d020      	beq.n	800ec4c <ui_mode_menu+0x4c>
  ui_mode = UI_MENU;
 800ec0a:	2201      	movs	r2, #1
 800ec0c:	701a      	strb	r2, [r3, #0]
   area_width = AREA_WIDTH_NORMAL - 72;
 800ec0e:	4b13      	ldr	r3, [pc, #76]	; (800ec5c <ui_mode_menu+0x5c>)
 800ec10:	32e4      	adds	r2, #228	; 0xe4
 800ec12:	601a      	str	r2, [r3, #0]
  area_height = HEIGHT;
 800ec14:	4b12      	ldr	r3, [pc, #72]	; (800ec60 <ui_mode_menu+0x60>)
 800ec16:	3202      	adds	r2, #2
 800ec18:	601a      	str	r2, [r3, #0]
  const menuitem_t *menu = menu_stack[menu_current_level];
 800ec1a:	4b12      	ldr	r3, [pc, #72]	; (800ec64 <ui_mode_menu+0x64>)
 800ec1c:	4a12      	ldr	r2, [pc, #72]	; (800ec68 <ui_mode_menu+0x68>)
 800ec1e:	781b      	ldrb	r3, [r3, #0]
 800ec20:	009b      	lsls	r3, r3, #2
 800ec22:	5898      	ldr	r0, [r3, r2]
  for (i = 0; menu[i].type != MT_NONE; i++)
 800ec24:	7803      	ldrb	r3, [r0, #0]
 800ec26:	2b00      	cmp	r3, #0
 800ec28:	d014      	beq.n	800ec54 <ui_mode_menu+0x54>
 800ec2a:	0003      	movs	r3, r0
 800ec2c:	2200      	movs	r2, #0
 800ec2e:	330c      	adds	r3, #12
    ;
 800ec30:	330c      	adds	r3, #12
  for (i = 0; menu[i].type != MT_NONE; i++)
 800ec32:	0019      	movs	r1, r3
 800ec34:	390c      	subs	r1, #12
 800ec36:	7809      	ldrb	r1, [r1, #0]
 800ec38:	3201      	adds	r2, #1
 800ec3a:	2900      	cmp	r1, #0
 800ec3c:	d1f8      	bne.n	800ec30 <ui_mode_menu+0x30>
  if (selection >= i)
 800ec3e:	2100      	movs	r1, #0
 800ec40:	4b0a      	ldr	r3, [pc, #40]	; (800ec6c <ui_mode_menu+0x6c>)
 800ec42:	5659      	ldrsb	r1, [r3, r1]
 800ec44:	4291      	cmp	r1, r2
 800ec46:	da02      	bge.n	800ec4e <ui_mode_menu+0x4e>
  draw_menu_buttons(menu_stack[menu_current_level]);
 800ec48:	f7ff fe92 	bl	800e970 <draw_menu_buttons>
}
 800ec4c:	bd10      	pop	{r4, pc}
    selection = i-1;
 800ec4e:	3a01      	subs	r2, #1
 800ec50:	701a      	strb	r2, [r3, #0]
 800ec52:	e7f9      	b.n	800ec48 <ui_mode_menu+0x48>
  for (i = 0; menu[i].type != MT_NONE; i++)
 800ec54:	2200      	movs	r2, #0
 800ec56:	e7f2      	b.n	800ec3e <ui_mode_menu+0x3e>
 800ec58:	200030a5 	.word	0x200030a5
 800ec5c:	2000163c 	.word	0x2000163c
 800ec60:	20001638 	.word	0x20001638
 800ec64:	200030a2 	.word	0x200030a2
 800ec68:	20001640 	.word	0x20001640
 800ec6c:	200030a4 	.word	0x200030a4

0800ec70 <menu_cal2_cb>:
{
 800ec70:	b510      	push	{r4, lr}
  switch (item) {
 800ec72:	2802      	cmp	r0, #2
 800ec74:	d013      	beq.n	800ec9e <menu_cal2_cb+0x2e>
 800ec76:	2803      	cmp	r0, #3
 800ec78:	d10e      	bne.n	800ec98 <menu_cal2_cb+0x28>
    if (cal_status)
 800ec7a:	4b0b      	ldr	r3, [pc, #44]	; (800eca8 <menu_cal2_cb+0x38>)
 800ec7c:	89da      	ldrh	r2, [r3, #14]
 800ec7e:	2a00      	cmp	r2, #0
 800ec80:	d003      	beq.n	800ec8a <menu_cal2_cb+0x1a>
      cal_status ^= CALSTAT_APPLY;
 800ec82:	2180      	movs	r1, #128	; 0x80
 800ec84:	0049      	lsls	r1, r1, #1
 800ec86:	404a      	eors	r2, r1
 800ec88:	81da      	strh	r2, [r3, #14]
  draw_menu_buttons(menu_stack[menu_current_level]);
 800ec8a:	4b08      	ldr	r3, [pc, #32]	; (800ecac <menu_cal2_cb+0x3c>)
 800ec8c:	4a08      	ldr	r2, [pc, #32]	; (800ecb0 <menu_cal2_cb+0x40>)
 800ec8e:	781b      	ldrb	r3, [r3, #0]
 800ec90:	009b      	lsls	r3, r3, #2
 800ec92:	5898      	ldr	r0, [r3, r2]
 800ec94:	f7ff fe6c 	bl	800e970 <draw_menu_buttons>
  draw_cal_status();
 800ec98:	f7ff f9da 	bl	800e050 <draw_cal_status>
}
 800ec9c:	bd10      	pop	{r4, pc}
    cal_status = 0;
 800ec9e:	2200      	movs	r2, #0
 800eca0:	4b01      	ldr	r3, [pc, #4]	; (800eca8 <menu_cal2_cb+0x38>)
 800eca2:	81da      	strh	r2, [r3, #14]
    break;
 800eca4:	e7f8      	b.n	800ec98 <menu_cal2_cb+0x28>
 800eca6:	46c0      	nop			; (mov r8, r8)
 800eca8:	20000454 	.word	0x20000454
 800ecac:	200030a2 	.word	0x200030a2
 800ecb0:	20001640 	.word	0x20001640
	...

0800ecc0 <menu_push_submenu>:
{
 800ecc0:	b530      	push	{r4, r5, lr}
  if (menu_current_level < MENU_STACK_DEPTH_MAX-1)
 800ecc2:	4c17      	ldr	r4, [pc, #92]	; (800ed20 <menu_push_submenu+0x60>)
{
 800ecc4:	b083      	sub	sp, #12
  if (menu_current_level < MENU_STACK_DEPTH_MAX-1)
 800ecc6:	7823      	ldrb	r3, [r4, #0]
 800ecc8:	2b02      	cmp	r3, #2
 800ecca:	d802      	bhi.n	800ecd2 <menu_push_submenu+0x12>
    menu_current_level++;
 800eccc:	3301      	adds	r3, #1
 800ecce:	b2db      	uxtb	r3, r3
 800ecd0:	7023      	strb	r3, [r4, #0]
  menu_stack[menu_current_level] = submenu;
 800ecd2:	4d14      	ldr	r5, [pc, #80]	; (800ed24 <menu_push_submenu+0x64>)
 800ecd4:	009b      	lsls	r3, r3, #2
 800ecd6:	50e8      	str	r0, [r5, r3]
  for (i = 0; menu[i].type != MT_NONE; i++)
 800ecd8:	7803      	ldrb	r3, [r0, #0]
 800ecda:	2b00      	cmp	r3, #0
 800ecdc:	d01e      	beq.n	800ed1c <menu_push_submenu+0x5c>
 800ecde:	2300      	movs	r3, #0
 800ece0:	300c      	adds	r0, #12
    ;
 800ece2:	300c      	adds	r0, #12
  for (i = 0; menu[i].type != MT_NONE; i++)
 800ece4:	0002      	movs	r2, r0
 800ece6:	3a0c      	subs	r2, #12
 800ece8:	7812      	ldrb	r2, [r2, #0]
 800ecea:	3301      	adds	r3, #1
 800ecec:	2a00      	cmp	r2, #0
 800ecee:	d1f8      	bne.n	800ece2 <menu_push_submenu+0x22>
  if (selection >= i)
 800ecf0:	2100      	movs	r1, #0
 800ecf2:	4a0d      	ldr	r2, [pc, #52]	; (800ed28 <menu_push_submenu+0x68>)
 800ecf4:	5651      	ldrsb	r1, [r2, r1]
 800ecf6:	4299      	cmp	r1, r3
 800ecf8:	db01      	blt.n	800ecfe <menu_push_submenu+0x3e>
    selection = i-1;
 800ecfa:	3b01      	subs	r3, #1
 800ecfc:	7013      	strb	r3, [r2, #0]
   ili9341_fill(320-72, 0, 72, 32*7, bg);
 800ecfe:	2300      	movs	r3, #0
 800ed00:	2248      	movs	r2, #72	; 0x48
 800ed02:	9300      	str	r3, [sp, #0]
 800ed04:	2100      	movs	r1, #0
 800ed06:	33e0      	adds	r3, #224	; 0xe0
 800ed08:	20f8      	movs	r0, #248	; 0xf8
 800ed0a:	f001 fc61 	bl	80105d0 <ili9341_fill>
  draw_menu_buttons(menu_stack[menu_current_level]);
 800ed0e:	7823      	ldrb	r3, [r4, #0]
 800ed10:	009b      	lsls	r3, r3, #2
 800ed12:	58e8      	ldr	r0, [r5, r3]
 800ed14:	f7ff fe2c 	bl	800e970 <draw_menu_buttons>
}
 800ed18:	b003      	add	sp, #12
 800ed1a:	bd30      	pop	{r4, r5, pc}
  for (i = 0; menu[i].type != MT_NONE; i++)
 800ed1c:	2300      	movs	r3, #0
 800ed1e:	e7e7      	b.n	800ecf0 <menu_push_submenu+0x30>
 800ed20:	200030a2 	.word	0x200030a2
 800ed24:	20001640 	.word	0x20001640
 800ed28:	200030a4 	.word	0x200030a4
 800ed2c:	00000000 	.word	0x00000000

0800ed30 <menu_calop_cb>:
{
 800ed30:	b510      	push	{r4, lr}
 800ed32:	0004      	movs	r4, r0
  switch (item) {
 800ed34:	2804      	cmp	r0, #4
 800ed36:	d806      	bhi.n	800ed46 <menu_calop_cb+0x16>
 800ed38:	4a11      	ldr	r2, [pc, #68]	; (800ed80 <menu_calop_cb+0x50>)
 800ed3a:	0083      	lsls	r3, r0, #2
 800ed3c:	58d3      	ldr	r3, [r2, r3]
 800ed3e:	469f      	mov	pc, r3
    cal_collect(CAL_THRU);
 800ed40:	2003      	movs	r0, #3
 800ed42:	f7fa ff25 	bl	8009b90 <cal_collect>
  selection = item+1;
 800ed46:	4b0f      	ldr	r3, [pc, #60]	; (800ed84 <menu_calop_cb+0x54>)
 800ed48:	3401      	adds	r4, #1
 800ed4a:	701c      	strb	r4, [r3, #0]
  draw_cal_status();
 800ed4c:	f7ff f980 	bl	800e050 <draw_cal_status>
  draw_menu_buttons(menu_stack[menu_current_level]);
 800ed50:	4b0d      	ldr	r3, [pc, #52]	; (800ed88 <menu_calop_cb+0x58>)
 800ed52:	4a0e      	ldr	r2, [pc, #56]	; (800ed8c <menu_calop_cb+0x5c>)
 800ed54:	781b      	ldrb	r3, [r3, #0]
 800ed56:	009b      	lsls	r3, r3, #2
 800ed58:	5898      	ldr	r0, [r3, r2]
 800ed5a:	f7ff fe09 	bl	800e970 <draw_menu_buttons>
}
 800ed5e:	bd10      	pop	{r4, pc}
    cal_collect(CAL_ISOLN);
 800ed60:	2004      	movs	r0, #4
 800ed62:	f7fa ff15 	bl	8009b90 <cal_collect>
    break;
 800ed66:	e7ee      	b.n	800ed46 <menu_calop_cb+0x16>
    cal_collect(CAL_OPEN);
 800ed68:	2001      	movs	r0, #1
 800ed6a:	f7fa ff11 	bl	8009b90 <cal_collect>
    break;
 800ed6e:	e7ea      	b.n	800ed46 <menu_calop_cb+0x16>
    cal_collect(CAL_SHORT);
 800ed70:	2002      	movs	r0, #2
 800ed72:	f7fa ff0d 	bl	8009b90 <cal_collect>
    break;
 800ed76:	e7e6      	b.n	800ed46 <menu_calop_cb+0x16>
    cal_collect(CAL_LOAD);
 800ed78:	2000      	movs	r0, #0
 800ed7a:	f7fa ff09 	bl	8009b90 <cal_collect>
    break;
 800ed7e:	e7e2      	b.n	800ed46 <menu_calop_cb+0x16>
 800ed80:	08014ad8 	.word	0x08014ad8
 800ed84:	200030a4 	.word	0x200030a4
 800ed88:	200030a2 	.word	0x200030a2
 800ed8c:	20001640 	.word	0x20001640

0800ed90 <ui_mode_keypad>:
{
 800ed90:	b510      	push	{r4, lr}
  if (ui_mode == UI_KEYPAD) 
 800ed92:	4c19      	ldr	r4, [pc, #100]	; (800edf8 <ui_mode_keypad+0x68>)
 800ed94:	7823      	ldrb	r3, [r4, #0]
 800ed96:	2b03      	cmp	r3, #3
 800ed98:	d02a      	beq.n	800edf0 <ui_mode_keypad+0x60>
  keypad_mode = _keypad_mode;
 800ed9a:	4b18      	ldr	r3, [pc, #96]	; (800edfc <ui_mode_keypad+0x6c>)
  keypads = keypads_mode_tbl[_keypad_mode];
 800ed9c:	4a18      	ldr	r2, [pc, #96]	; (800ee00 <ui_mode_keypad+0x70>)
  keypad_mode = _keypad_mode;
 800ed9e:	7018      	strb	r0, [r3, #0]
  keypads = keypads_mode_tbl[_keypad_mode];
 800eda0:	4b18      	ldr	r3, [pc, #96]	; (800ee04 <ui_mode_keypad+0x74>)
 800eda2:	0080      	lsls	r0, r0, #2
 800eda4:	58c3      	ldr	r3, [r0, r3]
 800eda6:	6013      	str	r3, [r2, #0]
  for (i = 0; keypads[i+1].c >= 0; i++)
 800eda8:	7a9a      	ldrb	r2, [r3, #10]
 800edaa:	2a7f      	cmp	r2, #127	; 0x7f
 800edac:	d821      	bhi.n	800edf2 <ui_mode_keypad+0x62>
 800edae:	2200      	movs	r2, #0
 800edb0:	3310      	adds	r3, #16
    ;
 800edb2:	3306      	adds	r3, #6
  for (i = 0; keypads[i+1].c >= 0; i++)
 800edb4:	1f99      	subs	r1, r3, #6
 800edb6:	7809      	ldrb	r1, [r1, #0]
 800edb8:	3201      	adds	r2, #1
 800edba:	297f      	cmp	r1, #127	; 0x7f
 800edbc:	d9f9      	bls.n	800edb2 <ui_mode_keypad+0x22>
 800edbe:	b2d2      	uxtb	r2, r2
  keypads_last_index = i;
 800edc0:	4b11      	ldr	r3, [pc, #68]	; (800ee08 <ui_mode_keypad+0x78>)
 800edc2:	701a      	strb	r2, [r3, #0]
  ui_mode = UI_KEYPAD;
 800edc4:	2303      	movs	r3, #3
  area_width = AREA_WIDTH_NORMAL - (64-8);
 800edc6:	22f5      	movs	r2, #245	; 0xf5
  ui_mode = UI_KEYPAD;
 800edc8:	7023      	strb	r3, [r4, #0]
  area_width = AREA_WIDTH_NORMAL - (64-8);
 800edca:	4b10      	ldr	r3, [pc, #64]	; (800ee0c <ui_mode_keypad+0x7c>)
 800edcc:	601a      	str	r2, [r3, #0]
  area_height = HEIGHT - 32;
 800edce:	4b10      	ldr	r3, [pc, #64]	; (800ee10 <ui_mode_keypad+0x80>)
 800edd0:	3a2e      	subs	r2, #46	; 0x2e
 800edd2:	601a      	str	r2, [r3, #0]
  draw_menu_buttons(menu_stack[menu_current_level]);
 800edd4:	4b0f      	ldr	r3, [pc, #60]	; (800ee14 <ui_mode_keypad+0x84>)
 800edd6:	4a10      	ldr	r2, [pc, #64]	; (800ee18 <ui_mode_keypad+0x88>)
 800edd8:	781b      	ldrb	r3, [r3, #0]
 800edda:	009b      	lsls	r3, r3, #2
 800eddc:	5898      	ldr	r0, [r3, r2]
 800edde:	f7ff fdc7 	bl	800e970 <draw_menu_buttons>
  draw_keypad();
 800ede2:	f7ff fd7d 	bl	800e8e0 <draw_keypad>
  draw_numeric_area_frame();
 800ede6:	f7ff fbe3 	bl	800e5b0 <draw_numeric_area_frame>
  draw_numeric_input("");
 800edea:	480c      	ldr	r0, [pc, #48]	; (800ee1c <ui_mode_keypad+0x8c>)
 800edec:	f7ff fc98 	bl	800e720 <draw_numeric_input>
}
 800edf0:	bd10      	pop	{r4, pc}
  for (i = 0; keypads[i+1].c >= 0; i++)
 800edf2:	2200      	movs	r2, #0
 800edf4:	e7e4      	b.n	800edc0 <ui_mode_keypad+0x30>
 800edf6:	46c0      	nop			; (mov r8, r8)
 800edf8:	200030a5 	.word	0x200030a5
 800edfc:	20003079 	.word	0x20003079
 800ee00:	2000307c 	.word	0x2000307c
 800ee04:	08014d8c 	.word	0x08014d8c
 800ee08:	20003080 	.word	0x20003080
 800ee0c:	2000163c 	.word	0x2000163c
 800ee10:	20001638 	.word	0x20001638
 800ee14:	200030a2 	.word	0x200030a2
 800ee18:	20001640 	.word	0x20001640
 800ee1c:	08013f2c 	.word	0x08013f2c

0800ee20 <keypad_click>:
{
 800ee20:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  int c = keypads[key].c;
 800ee22:	4b68      	ldr	r3, [pc, #416]	; (800efc4 <keypad_click+0x1a4>)
 800ee24:	681a      	ldr	r2, [r3, #0]
 800ee26:	0043      	lsls	r3, r0, #1
 800ee28:	181b      	adds	r3, r3, r0
 800ee2a:	005b      	lsls	r3, r3, #1
 800ee2c:	18d3      	adds	r3, r2, r3
 800ee2e:	791b      	ldrb	r3, [r3, #4]
 800ee30:	b25b      	sxtb	r3, r3
  if ((c >= KP_X1 && c <= KP_G) || c == KP_N || c == KP_P) {
 800ee32:	001a      	movs	r2, r3
 800ee34:	3a0c      	subs	r2, #12
 800ee36:	2a03      	cmp	r2, #3
 800ee38:	d913      	bls.n	800ee62 <keypad_click+0x42>
 800ee3a:	2b15      	cmp	r3, #21
 800ee3c:	d100      	bne.n	800ee40 <keypad_click+0x20>
 800ee3e:	e0ae      	b.n	800ef9e <keypad_click+0x17e>
 800ee40:	2b16      	cmp	r3, #22
 800ee42:	d03c      	beq.n	800eebe <keypad_click+0x9e>
  } else if (c <= 9 && kp_index < NUMINPUT_LEN)
 800ee44:	2200      	movs	r2, #0
 800ee46:	4c60      	ldr	r4, [pc, #384]	; (800efc8 <keypad_click+0x1a8>)
 800ee48:	56a2      	ldrsb	r2, [r4, r2]
 800ee4a:	2b09      	cmp	r3, #9
 800ee4c:	dc29      	bgt.n	800eea2 <keypad_click+0x82>
 800ee4e:	0011      	movs	r1, r2
 800ee50:	2a09      	cmp	r2, #9
 800ee52:	dd4f      	ble.n	800eef4 <keypad_click+0xd4>
 800ee54:	485d      	ldr	r0, [pc, #372]	; (800efcc <keypad_click+0x1ac>)
  kp_buf[kp_index] = '\0';
 800ee56:	2300      	movs	r3, #0
 800ee58:	5443      	strb	r3, [r0, r1]
  draw_numeric_input(kp_buf);
 800ee5a:	f7ff fc61 	bl	800e720 <draw_numeric_input>
  return KP_CONTINUE;
 800ee5e:	2000      	movs	r0, #0
}
 800ee60:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      while (n-- > 0)
 800ee62:	001a      	movs	r2, r3
    int32_t scale = 1;
 800ee64:	2401      	movs	r4, #1
      while (n-- > 0)
 800ee66:	3a0d      	subs	r2, #13
 800ee68:	2b0c      	cmp	r3, #12
 800ee6a:	dd06      	ble.n	800ee7a <keypad_click+0x5a>
        scale *= 1000;
 800ee6c:	0163      	lsls	r3, r4, #5
 800ee6e:	1b1b      	subs	r3, r3, r4
 800ee70:	009b      	lsls	r3, r3, #2
 800ee72:	191c      	adds	r4, r3, r4
 800ee74:	00e4      	lsls	r4, r4, #3
      while (n-- > 0)
 800ee76:	3a01      	subs	r2, #1
 800ee78:	d2f8      	bcs.n	800ee6c <keypad_click+0x4c>
    double value = my_atof(kp_buf) * (double)scale;
 800ee7a:	4854      	ldr	r0, [pc, #336]	; (800efcc <keypad_click+0x1ac>)
 800ee7c:	f7fb fc08 	bl	800a690 <my_atof>
 800ee80:	0006      	movs	r6, r0
 800ee82:	000f      	movs	r7, r1
 800ee84:	0020      	movs	r0, r4
 800ee86:	f7f4 fa33 	bl	80032f0 <__aeabi_i2d>
 800ee8a:	003b      	movs	r3, r7
 800ee8c:	0032      	movs	r2, r6
 800ee8e:	f7f3 fbb7 	bl	8002600 <__aeabi_dmul>
    switch (keypad_mode) {
 800ee92:	4b4f      	ldr	r3, [pc, #316]	; (800efd0 <keypad_click+0x1b0>)
 800ee94:	781b      	ldrb	r3, [r3, #0]
 800ee96:	2b09      	cmp	r3, #9
 800ee98:	d840      	bhi.n	800ef1c <keypad_click+0xfc>
 800ee9a:	4a4e      	ldr	r2, [pc, #312]	; (800efd4 <keypad_click+0x1b4>)
 800ee9c:	009b      	lsls	r3, r3, #2
 800ee9e:	58d3      	ldr	r3, [r2, r3]
 800eea0:	469f      	mov	pc, r3
  else if (c == KP_PERIOD && kp_index < NUMINPUT_LEN) {
 800eea2:	2b0a      	cmp	r3, #10
 800eea4:	d00d      	beq.n	800eec2 <keypad_click+0xa2>
  } else if (c == KP_MINUS) {
 800eea6:	2b0b      	cmp	r3, #11
 800eea8:	d17c      	bne.n	800efa4 <keypad_click+0x184>
    if (kp_index == 0)
 800eeaa:	2a00      	cmp	r2, #0
 800eeac:	d000      	beq.n	800eeb0 <keypad_click+0x90>
 800eeae:	e081      	b.n	800efb4 <keypad_click+0x194>
      kp_buf[kp_index++] = '-';    
 800eeb0:	2301      	movs	r3, #1
 800eeb2:	4846      	ldr	r0, [pc, #280]	; (800efcc <keypad_click+0x1ac>)
 800eeb4:	7023      	strb	r3, [r4, #0]
 800eeb6:	332c      	adds	r3, #44	; 0x2c
 800eeb8:	7003      	strb	r3, [r0, #0]
 800eeba:	2101      	movs	r1, #1
 800eebc:	e7cb      	b.n	800ee56 <keypad_click+0x36>
    int32_t scale = 1;
 800eebe:	2401      	movs	r4, #1
 800eec0:	e7db      	b.n	800ee7a <keypad_click+0x5a>
 800eec2:	0011      	movs	r1, r2
  else if (c == KP_PERIOD && kp_index < NUMINPUT_LEN) {
 800eec4:	2a09      	cmp	r2, #9
 800eec6:	dcc5      	bgt.n	800ee54 <keypad_click+0x34>
    for (j = 0; j < kp_index && kp_buf[j] != '.'; j++)
 800eec8:	2a00      	cmp	r2, #0
 800eeca:	dd78      	ble.n	800efbe <keypad_click+0x19e>
 800eecc:	483f      	ldr	r0, [pc, #252]	; (800efcc <keypad_click+0x1ac>)
 800eece:	7803      	ldrb	r3, [r0, #0]
 800eed0:	2b2e      	cmp	r3, #46	; 0x2e
 800eed2:	d0c0      	beq.n	800ee56 <keypad_click+0x36>
 800eed4:	2300      	movs	r3, #0
 800eed6:	e002      	b.n	800eede <keypad_click+0xbe>
 800eed8:	5cc5      	ldrb	r5, [r0, r3]
 800eeda:	2d2e      	cmp	r5, #46	; 0x2e
 800eedc:	d0bb      	beq.n	800ee56 <keypad_click+0x36>
 800eede:	3301      	adds	r3, #1
 800eee0:	4293      	cmp	r3, r2
 800eee2:	dbf9      	blt.n	800eed8 <keypad_click+0xb8>
    if (kp_index == j)
 800eee4:	4293      	cmp	r3, r2
 800eee6:	d1b6      	bne.n	800ee56 <keypad_click+0x36>
      kp_buf[kp_index++] = '.';
 800eee8:	222e      	movs	r2, #46	; 0x2e
 800eeea:	1c59      	adds	r1, r3, #1
 800eeec:	b249      	sxtb	r1, r1
 800eeee:	7021      	strb	r1, [r4, #0]
 800eef0:	54c2      	strb	r2, [r0, r3]
 800eef2:	e7b0      	b.n	800ee56 <keypad_click+0x36>
    kp_buf[kp_index++] = '0' + c;
 800eef4:	3201      	adds	r2, #1
 800eef6:	4835      	ldr	r0, [pc, #212]	; (800efcc <keypad_click+0x1ac>)
 800eef8:	b252      	sxtb	r2, r2
 800eefa:	3330      	adds	r3, #48	; 0x30
 800eefc:	5443      	strb	r3, [r0, r1]
 800eefe:	7022      	strb	r2, [r4, #0]
 800ef00:	0011      	movs	r1, r2
 800ef02:	e7a8      	b.n	800ee56 <keypad_click+0x36>
      set_trace_scale(uistat.current_trace, value * 1e-12); // pico second
 800ef04:	4a34      	ldr	r2, [pc, #208]	; (800efd8 <keypad_click+0x1b8>)
 800ef06:	4b35      	ldr	r3, [pc, #212]	; (800efdc <keypad_click+0x1bc>)
 800ef08:	f7f3 fb7a 	bl	8002600 <__aeabi_dmul>
 800ef0c:	f7f4 fac0 	bl	8003490 <__aeabi_d2f>
 800ef10:	1c01      	adds	r1, r0, #0
 800ef12:	2002      	movs	r0, #2
 800ef14:	4b32      	ldr	r3, [pc, #200]	; (800efe0 <keypad_click+0x1c0>)
 800ef16:	5618      	ldrsb	r0, [r3, r0]
 800ef18:	f7fb fb42 	bl	800a5a0 <set_trace_scale>
    return KP_DONE;
 800ef1c:	2001      	movs	r0, #1
      break;
 800ef1e:	e79f      	b.n	800ee60 <keypad_click+0x40>
      velocity_factor = (uint8_t)value;
 800ef20:	f7f1 fbee 	bl	8000700 <__aeabi_d2uiz>
 800ef24:	4a2f      	ldr	r2, [pc, #188]	; (800efe4 <keypad_click+0x1c4>)
 800ef26:	4b30      	ldr	r3, [pc, #192]	; (800efe8 <keypad_click+0x1c8>)
 800ef28:	54d0      	strb	r0, [r2, r3]
    return KP_DONE;
 800ef2a:	2001      	movs	r0, #1
      break;
 800ef2c:	e798      	b.n	800ee60 <keypad_click+0x40>
      set_electrical_delay(value); // pico seconds
 800ef2e:	f7f4 faaf 	bl	8003490 <__aeabi_d2f>
 800ef32:	f7fb fe35 	bl	800aba0 <set_electrical_delay>
    return KP_DONE;
 800ef36:	2001      	movs	r0, #1
      break;
 800ef38:	e792      	b.n	800ee60 <keypad_click+0x40>
      set_trace_refpos(uistat.current_trace, value);
 800ef3a:	f7f4 faa9 	bl	8003490 <__aeabi_d2f>
 800ef3e:	1c01      	adds	r1, r0, #0
 800ef40:	2002      	movs	r0, #2
 800ef42:	4b27      	ldr	r3, [pc, #156]	; (800efe0 <keypad_click+0x1c0>)
 800ef44:	5618      	ldrsb	r0, [r3, r0]
 800ef46:	f7fb fb7b 	bl	800a640 <set_trace_refpos>
    return KP_DONE;
 800ef4a:	2001      	movs	r0, #1
      break;
 800ef4c:	e788      	b.n	800ee60 <keypad_click+0x40>
      set_sweep_frequency(ST_CW, (int32_t)value);
 800ef4e:	f7f4 f997 	bl	8003280 <__aeabi_d2iz>
 800ef52:	0001      	movs	r1, r0
 800ef54:	2004      	movs	r0, #4
 800ef56:	f7fa fc7b 	bl	8009850 <set_sweep_frequency>
    return KP_DONE;
 800ef5a:	2001      	movs	r0, #1
      break;
 800ef5c:	e780      	b.n	800ee60 <keypad_click+0x40>
      set_sweep_frequency(ST_SPAN, (int32_t)value);
 800ef5e:	f7f4 f98f 	bl	8003280 <__aeabi_d2iz>
 800ef62:	0001      	movs	r1, r0
 800ef64:	2003      	movs	r0, #3
 800ef66:	f7fa fc73 	bl	8009850 <set_sweep_frequency>
    return KP_DONE;
 800ef6a:	2001      	movs	r0, #1
      break;
 800ef6c:	e778      	b.n	800ee60 <keypad_click+0x40>
      set_sweep_frequency(ST_CENTER, (int32_t)value);
 800ef6e:	f7f4 f987 	bl	8003280 <__aeabi_d2iz>
 800ef72:	0001      	movs	r1, r0
 800ef74:	2002      	movs	r0, #2
 800ef76:	f7fa fc6b 	bl	8009850 <set_sweep_frequency>
    return KP_DONE;
 800ef7a:	2001      	movs	r0, #1
      break;
 800ef7c:	e770      	b.n	800ee60 <keypad_click+0x40>
      set_sweep_frequency(ST_STOP, (int32_t)value);
 800ef7e:	f7f4 f97f 	bl	8003280 <__aeabi_d2iz>
 800ef82:	0001      	movs	r1, r0
 800ef84:	2001      	movs	r0, #1
 800ef86:	f7fa fc63 	bl	8009850 <set_sweep_frequency>
    return KP_DONE;
 800ef8a:	2001      	movs	r0, #1
      break;
 800ef8c:	e768      	b.n	800ee60 <keypad_click+0x40>
      set_sweep_frequency(ST_START, (int32_t)value);
 800ef8e:	f7f4 f977 	bl	8003280 <__aeabi_d2iz>
 800ef92:	0001      	movs	r1, r0
 800ef94:	2000      	movs	r0, #0
 800ef96:	f7fa fc5b 	bl	8009850 <set_sweep_frequency>
    return KP_DONE;
 800ef9a:	2001      	movs	r0, #1
      break;
 800ef9c:	e760      	b.n	800ee60 <keypad_click+0x40>
      scale *= 1000;
 800ef9e:	24fa      	movs	r4, #250	; 0xfa
 800efa0:	00a4      	lsls	r4, r4, #2
 800efa2:	e76a      	b.n	800ee7a <keypad_click+0x5a>
  } else if (c == KP_BS) {
 800efa4:	2b10      	cmp	r3, #16
 800efa6:	d105      	bne.n	800efb4 <keypad_click+0x194>
    if (kp_index == 0) {
 800efa8:	2a00      	cmp	r2, #0
 800efaa:	d006      	beq.n	800efba <keypad_click+0x19a>
    --kp_index;
 800efac:	3a01      	subs	r2, #1
 800efae:	b251      	sxtb	r1, r2
 800efb0:	7021      	strb	r1, [r4, #0]
 800efb2:	e74f      	b.n	800ee54 <keypad_click+0x34>
 800efb4:	0011      	movs	r1, r2
 800efb6:	4805      	ldr	r0, [pc, #20]	; (800efcc <keypad_click+0x1ac>)
 800efb8:	e74d      	b.n	800ee56 <keypad_click+0x36>
      return KP_CANCEL;
 800efba:	2002      	movs	r0, #2
 800efbc:	e750      	b.n	800ee60 <keypad_click+0x40>
    for (j = 0; j < kp_index && kp_buf[j] != '.'; j++)
 800efbe:	2300      	movs	r3, #0
 800efc0:	4802      	ldr	r0, [pc, #8]	; (800efcc <keypad_click+0x1ac>)
 800efc2:	e78f      	b.n	800eee4 <keypad_click+0xc4>
 800efc4:	2000307c 	.word	0x2000307c
 800efc8:	2000308f 	.word	0x2000308f
 800efcc:	20003084 	.word	0x20003084
 800efd0:	20003079 	.word	0x20003079
 800efd4:	08014aec 	.word	0x08014aec
 800efd8:	812dea11 	.word	0x812dea11
 800efdc:	3d719799 	.word	0x3d719799
 800efe0:	20001654 	.word	0x20001654
 800efe4:	20000454 	.word	0x20000454
 800efe8:	000011c5 	.word	0x000011c5
 800efec:	00000000 	.word	0x00000000

0800eff0 <active_marker_select.part.0>:
  for (i = 0; i < MARKER_COUNT; i++)
 800eff0:	2300      	movs	r3, #0
 800eff2:	4a0a      	ldr	r2, [pc, #40]	; (800f01c <active_marker_select.part.0+0x2c>)
    if (markers[i].enabled) {
 800eff4:	2100      	movs	r1, #0
 800eff6:	5651      	ldrsb	r1, [r2, r1]
 800eff8:	2900      	cmp	r1, #0
 800effa:	d10a      	bne.n	800f012 <active_marker_select.part.0+0x22>
  for (i = 0; i < MARKER_COUNT; i++)
 800effc:	3301      	adds	r3, #1
 800effe:	3208      	adds	r2, #8
 800f000:	2b04      	cmp	r3, #4
 800f002:	d1f7      	bne.n	800eff4 <active_marker_select.part.0+0x4>
  active_marker = -1;
 800f004:	238e      	movs	r3, #142	; 0x8e
 800f006:	2101      	movs	r1, #1
 800f008:	4a05      	ldr	r2, [pc, #20]	; (800f020 <active_marker_select.part.0+0x30>)
 800f00a:	015b      	lsls	r3, r3, #5
 800f00c:	4249      	negs	r1, r1
 800f00e:	50d1      	str	r1, [r2, r3]
}
 800f010:	4770      	bx	lr
      active_marker = i;
 800f012:	228e      	movs	r2, #142	; 0x8e
 800f014:	4902      	ldr	r1, [pc, #8]	; (800f020 <active_marker_select.part.0+0x30>)
 800f016:	0152      	lsls	r2, r2, #5
 800f018:	508b      	str	r3, [r1, r2]
      return;
 800f01a:	e7f9      	b.n	800f010 <active_marker_select.part.0+0x20>
 800f01c:	200015f4 	.word	0x200015f4
 800f020:	20000454 	.word	0x20000454
	...

0800f030 <active_marker_select>:
  if (item == -1) {
 800f030:	2200      	movs	r2, #0
{
 800f032:	b510      	push	{r4, lr}
 800f034:	4b0c      	ldr	r3, [pc, #48]	; (800f068 <active_marker_select+0x38>)
 800f036:	569a      	ldrsb	r2, [r3, r2]
  if (item == -1) {
 800f038:	1c41      	adds	r1, r0, #1
 800f03a:	d00a      	beq.n	800f052 <active_marker_select+0x22>
    if (previous_marker != active_marker)
 800f03c:	248e      	movs	r4, #142	; 0x8e
 800f03e:	490b      	ldr	r1, [pc, #44]	; (800f06c <active_marker_select+0x3c>)
 800f040:	0164      	lsls	r4, r4, #5
 800f042:	590c      	ldr	r4, [r1, r4]
 800f044:	4294      	cmp	r4, r2
 800f046:	d000      	beq.n	800f04a <active_marker_select+0x1a>
      previous_marker = active_marker;
 800f048:	701c      	strb	r4, [r3, #0]
    active_marker = item;
 800f04a:	238e      	movs	r3, #142	; 0x8e
 800f04c:	015b      	lsls	r3, r3, #5
 800f04e:	50c8      	str	r0, [r1, r3]
}
 800f050:	bd10      	pop	{r4, pc}
    active_marker = previous_marker;
 800f052:	218e      	movs	r1, #142	; 0x8e
 800f054:	4c05      	ldr	r4, [pc, #20]	; (800f06c <active_marker_select+0x3c>)
 800f056:	0149      	lsls	r1, r1, #5
 800f058:	5062      	str	r2, [r4, r1]
    previous_marker = -1;
 800f05a:	7018      	strb	r0, [r3, #0]
    if (active_marker == -1) {
 800f05c:	1c53      	adds	r3, r2, #1
 800f05e:	d1f7      	bne.n	800f050 <active_marker_select+0x20>
 800f060:	f7ff ffc6 	bl	800eff0 <active_marker_select.part.0>
 800f064:	e7f4      	b.n	800f050 <active_marker_select+0x20>
 800f066:	46c0      	nop			; (mov r8, r8)
 800f068:	20001650 	.word	0x20001650
 800f06c:	20000454 	.word	0x20000454

0800f070 <menu_marker_sel_cb>:
{
 800f070:	b570      	push	{r4, r5, r6, lr}
  if (item >= 0 && item < 4 && item < MARKER_COUNT) {
 800f072:	2803      	cmp	r0, #3
 800f074:	d81a      	bhi.n	800f0ac <menu_marker_sel_cb+0x3c>
    if (markers[item].enabled) {
 800f076:	238d      	movs	r3, #141	; 0x8d
 800f078:	009b      	lsls	r3, r3, #2
 800f07a:	4c25      	ldr	r4, [pc, #148]	; (800f110 <menu_marker_sel_cb+0xa0>)
 800f07c:	18c3      	adds	r3, r0, r3
 800f07e:	00db      	lsls	r3, r3, #3
 800f080:	571a      	ldrsb	r2, [r3, r4]
 800f082:	2a00      	cmp	r2, #0
 800f084:	d023      	beq.n	800f0ce <menu_marker_sel_cb+0x5e>
      if (item == active_marker) {
 800f086:	258e      	movs	r5, #142	; 0x8e
 800f088:	016d      	lsls	r5, r5, #5
 800f08a:	5962      	ldr	r2, [r4, r5]
 800f08c:	4282      	cmp	r2, r0
 800f08e:	d126      	bne.n	800f0de <menu_marker_sel_cb+0x6e>
        markers[item].enabled = FALSE;
 800f090:	2200      	movs	r2, #0
    active_marker = previous_marker;
 800f092:	2000      	movs	r0, #0
        markers[item].enabled = FALSE;
 800f094:	551a      	strb	r2, [r3, r4]
    active_marker = previous_marker;
 800f096:	4b1f      	ldr	r3, [pc, #124]	; (800f114 <menu_marker_sel_cb+0xa4>)
    previous_marker = -1;
 800f098:	32ff      	adds	r2, #255	; 0xff
    active_marker = previous_marker;
 800f09a:	5618      	ldrsb	r0, [r3, r0]
    previous_marker = -1;
 800f09c:	701a      	strb	r2, [r3, #0]
    active_marker = previous_marker;
 800f09e:	5160      	str	r0, [r4, r5]
    if (active_marker == -1) {
 800f0a0:	1c43      	adds	r3, r0, #1
 800f0a2:	d109      	bne.n	800f0b8 <menu_marker_sel_cb+0x48>
 800f0a4:	f7ff ffa4 	bl	800eff0 <active_marker_select.part.0>
 800f0a8:	5960      	ldr	r0, [r4, r5]
 800f0aa:	e005      	b.n	800f0b8 <menu_marker_sel_cb+0x48>
  } else if (item == 4) { /* all off */
 800f0ac:	2804      	cmp	r0, #4
 800f0ae:	d01a      	beq.n	800f0e6 <menu_marker_sel_cb+0x76>
 800f0b0:	238e      	movs	r3, #142	; 0x8e
 800f0b2:	4a17      	ldr	r2, [pc, #92]	; (800f110 <menu_marker_sel_cb+0xa0>)
 800f0b4:	015b      	lsls	r3, r3, #5
 800f0b6:	58d0      	ldr	r0, [r2, r3]
  redraw_marker(active_marker, TRUE);
 800f0b8:	2101      	movs	r1, #1
 800f0ba:	f7fe fe49 	bl	800dd50 <redraw_marker>
  draw_menu_buttons(menu_stack[menu_current_level]);
 800f0be:	4b16      	ldr	r3, [pc, #88]	; (800f118 <menu_marker_sel_cb+0xa8>)
 800f0c0:	4a16      	ldr	r2, [pc, #88]	; (800f11c <menu_marker_sel_cb+0xac>)
 800f0c2:	781b      	ldrb	r3, [r3, #0]
 800f0c4:	009b      	lsls	r3, r3, #2
 800f0c6:	5898      	ldr	r0, [r3, r2]
 800f0c8:	f7ff fc52 	bl	800e970 <draw_menu_buttons>
}
 800f0cc:	bd70      	pop	{r4, r5, r6, pc}
      markers[item].enabled = TRUE;
 800f0ce:	2201      	movs	r2, #1
 800f0d0:	551a      	strb	r2, [r3, r4]
      active_marker_select(item);
 800f0d2:	f7ff ffad 	bl	800f030 <active_marker_select>
 800f0d6:	238e      	movs	r3, #142	; 0x8e
 800f0d8:	015b      	lsls	r3, r3, #5
 800f0da:	58e0      	ldr	r0, [r4, r3]
 800f0dc:	e7ec      	b.n	800f0b8 <menu_marker_sel_cb+0x48>
        active_marker_select(item);
 800f0de:	f7ff ffa7 	bl	800f030 <active_marker_select>
 800f0e2:	5960      	ldr	r0, [r4, r5]
 800f0e4:	e7e8      	b.n	800f0b8 <menu_marker_sel_cb+0x48>
      markers[0].enabled = FALSE;
 800f0e6:	218d      	movs	r1, #141	; 0x8d
 800f0e8:	2200      	movs	r2, #0
 800f0ea:	4b09      	ldr	r3, [pc, #36]	; (800f110 <menu_marker_sel_cb+0xa0>)
 800f0ec:	0149      	lsls	r1, r1, #5
 800f0ee:	545a      	strb	r2, [r3, r1]
      markers[1].enabled = FALSE;
 800f0f0:	490b      	ldr	r1, [pc, #44]	; (800f120 <menu_marker_sel_cb+0xb0>)
      active_marker = -1;      
 800f0f2:	2001      	movs	r0, #1
      markers[1].enabled = FALSE;
 800f0f4:	545a      	strb	r2, [r3, r1]
      markers[2].enabled = FALSE;
 800f0f6:	490b      	ldr	r1, [pc, #44]	; (800f124 <menu_marker_sel_cb+0xb4>)
      active_marker = -1;      
 800f0f8:	4240      	negs	r0, r0
      markers[2].enabled = FALSE;
 800f0fa:	545a      	strb	r2, [r3, r1]
      markers[3].enabled = FALSE;
 800f0fc:	490a      	ldr	r1, [pc, #40]	; (800f128 <menu_marker_sel_cb+0xb8>)
 800f0fe:	545a      	strb	r2, [r3, r1]
      previous_marker = -1;
 800f100:	21ff      	movs	r1, #255	; 0xff
 800f102:	4a04      	ldr	r2, [pc, #16]	; (800f114 <menu_marker_sel_cb+0xa4>)
 800f104:	7011      	strb	r1, [r2, #0]
      active_marker = -1;      
 800f106:	228e      	movs	r2, #142	; 0x8e
 800f108:	0152      	lsls	r2, r2, #5
 800f10a:	5098      	str	r0, [r3, r2]
 800f10c:	e7d4      	b.n	800f0b8 <menu_marker_sel_cb+0x48>
 800f10e:	46c0      	nop			; (mov r8, r8)
 800f110:	20000454 	.word	0x20000454
 800f114:	20001650 	.word	0x20001650
 800f118:	200030a2 	.word	0x200030a2
 800f11c:	20001640 	.word	0x20001640
 800f120:	000011a8 	.word	0x000011a8
 800f124:	000011b0 	.word	0x000011b0
 800f128:	000011b8 	.word	0x000011b8
 800f12c:	00000000 	.word	0x00000000

0800f130 <leave_ui_mode>:
{
 800f130:	b500      	push	{lr}
  if (ui_mode == UI_MENU) {
 800f132:	4b11      	ldr	r3, [pc, #68]	; (800f178 <leave_ui_mode+0x48>)
{
 800f134:	b083      	sub	sp, #12
  if (ui_mode == UI_MENU) {
 800f136:	781b      	ldrb	r3, [r3, #0]
 800f138:	2b01      	cmp	r3, #1
 800f13a:	d003      	beq.n	800f144 <leave_ui_mode+0x14>
  } else if (ui_mode == UI_NUMERIC) {
 800f13c:	2b02      	cmp	r3, #2
 800f13e:	d00c      	beq.n	800f15a <leave_ui_mode+0x2a>
}
 800f140:	b003      	add	sp, #12
 800f142:	bd00      	pop	{pc}
    request_to_draw_cells_behind_menu();
 800f144:	f7fe fe24 	bl	800dd90 <request_to_draw_cells_behind_menu>
   ili9341_fill(320-72, 0, 72, 32*7, bg);
 800f148:	2300      	movs	r3, #0
 800f14a:	2248      	movs	r2, #72	; 0x48
 800f14c:	9300      	str	r3, [sp, #0]
 800f14e:	2100      	movs	r1, #0
 800f150:	33e0      	adds	r3, #224	; 0xe0
 800f152:	20f8      	movs	r0, #248	; 0xf8
 800f154:	f001 fa3c 	bl	80105d0 <ili9341_fill>
 800f158:	e7f2      	b.n	800f140 <leave_ui_mode+0x10>
    request_to_draw_cells_behind_numeric_input();
 800f15a:	f7fe fe41 	bl	800dde0 <request_to_draw_cells_behind_numeric_input>
  ili9341_fill(0, 240-32, 320, 32, bg);
 800f15e:	2300      	movs	r3, #0
 800f160:	22a0      	movs	r2, #160	; 0xa0
 800f162:	9300      	str	r3, [sp, #0]
 800f164:	0052      	lsls	r2, r2, #1
 800f166:	3320      	adds	r3, #32
 800f168:	21d0      	movs	r1, #208	; 0xd0
 800f16a:	2000      	movs	r0, #0
 800f16c:	f001 fa30 	bl	80105d0 <ili9341_fill>
    draw_frequencies();
 800f170:	f7fe fe5e 	bl	800de30 <draw_frequencies>
}
 800f174:	e7e4      	b.n	800f140 <leave_ui_mode+0x10>
 800f176:	46c0      	nop			; (mov r8, r8)
 800f178:	200030a5 	.word	0x200030a5
 800f17c:	00000000 	.word	0x00000000

0800f180 <ui_mode_normal.part.2>:
  area_width = AREA_WIDTH_NORMAL;
 800f180:	222e      	movs	r2, #46	; 0x2e
 800f182:	4b06      	ldr	r3, [pc, #24]	; (800f19c <ui_mode_normal.part.2+0x1c>)
 800f184:	32ff      	adds	r2, #255	; 0xff
static void ui_mode_normal(void)
 800f186:	b510      	push	{r4, lr}
  area_width = AREA_WIDTH_NORMAL;
 800f188:	601a      	str	r2, [r3, #0]
  area_height = HEIGHT;
 800f18a:	4b05      	ldr	r3, [pc, #20]	; (800f1a0 <ui_mode_normal.part.2+0x20>)
 800f18c:	3a46      	subs	r2, #70	; 0x46
 800f18e:	601a      	str	r2, [r3, #0]
  leave_ui_mode();
 800f190:	f7ff ffce 	bl	800f130 <leave_ui_mode>
  ui_mode = UI_NORMAL;
 800f194:	2200      	movs	r2, #0
 800f196:	4b03      	ldr	r3, [pc, #12]	; (800f1a4 <ui_mode_normal.part.2+0x24>)
 800f198:	701a      	strb	r2, [r3, #0]
}
 800f19a:	bd10      	pop	{r4, pc}
 800f19c:	2000163c 	.word	0x2000163c
 800f1a0:	20001638 	.word	0x20001638
 800f1a4:	200030a5 	.word	0x200030a5
	...

0800f1b0 <menu_marker_op_cb>:
  int32_t freq = get_marker_frequency(active_marker);
 800f1b0:	238e      	movs	r3, #142	; 0x8e
 800f1b2:	4a2d      	ldr	r2, [pc, #180]	; (800f268 <menu_marker_op_cb+0xb8>)
 800f1b4:	015b      	lsls	r3, r3, #5
{
 800f1b6:	b510      	push	{r4, lr}
  int32_t freq = get_marker_frequency(active_marker);
 800f1b8:	58d4      	ldr	r4, [r2, r3]
  if (marker < 0 || marker >= MARKER_COUNT)
 800f1ba:	2c03      	cmp	r4, #3
 800f1bc:	d83f      	bhi.n	800f23e <menu_marker_op_cb+0x8e>
  if (!markers[marker].enabled)
 800f1be:	238d      	movs	r3, #141	; 0x8d
 800f1c0:	009b      	lsls	r3, r3, #2
 800f1c2:	18e3      	adds	r3, r4, r3
 800f1c4:	00db      	lsls	r3, r3, #3
 800f1c6:	56d1      	ldrsb	r1, [r2, r3]
 800f1c8:	2900      	cmp	r1, #0
 800f1ca:	d038      	beq.n	800f23e <menu_marker_op_cb+0x8e>
  return frequencies[markers[marker].index];
 800f1cc:	18d3      	adds	r3, r2, r3
 800f1ce:	2102      	movs	r1, #2
 800f1d0:	5e5b      	ldrsh	r3, [r3, r1]
 800f1d2:	3304      	adds	r3, #4
 800f1d4:	009b      	lsls	r3, r3, #2
 800f1d6:	58d1      	ldr	r1, [r2, r3]
  if (freq < 0)
 800f1d8:	2900      	cmp	r1, #0
 800f1da:	db30      	blt.n	800f23e <menu_marker_op_cb+0x8e>
  switch (item) {
 800f1dc:	2802      	cmp	r0, #2
 800f1de:	d025      	beq.n	800f22c <menu_marker_op_cb+0x7c>
 800f1e0:	dd2e      	ble.n	800f240 <menu_marker_op_cb+0x90>
 800f1e2:	2803      	cmp	r0, #3
 800f1e4:	d038      	beq.n	800f258 <menu_marker_op_cb+0xa8>
 800f1e6:	2804      	cmp	r0, #4
 800f1e8:	d123      	bne.n	800f232 <menu_marker_op_cb+0x82>
      if (previous_marker == active_marker)
 800f1ea:	4b20      	ldr	r3, [pc, #128]	; (800f26c <menu_marker_op_cb+0xbc>)
 800f1ec:	781b      	ldrb	r3, [r3, #0]
 800f1ee:	b25b      	sxtb	r3, r3
 800f1f0:	429c      	cmp	r4, r3
 800f1f2:	d024      	beq.n	800f23e <menu_marker_op_cb+0x8e>
  if (marker < 0 || marker >= MARKER_COUNT)
 800f1f4:	2b03      	cmp	r3, #3
 800f1f6:	d822      	bhi.n	800f23e <menu_marker_op_cb+0x8e>
  if (!markers[marker].enabled)
 800f1f8:	208d      	movs	r0, #141	; 0x8d
 800f1fa:	0080      	lsls	r0, r0, #2
 800f1fc:	4684      	mov	ip, r0
 800f1fe:	4463      	add	r3, ip
 800f200:	00d8      	lsls	r0, r3, #3
 800f202:	5610      	ldrsb	r0, [r2, r0]
 800f204:	2800      	cmp	r0, #0
 800f206:	d01a      	beq.n	800f23e <menu_marker_op_cb+0x8e>
  return frequencies[markers[marker].index];
 800f208:	00db      	lsls	r3, r3, #3
 800f20a:	18d3      	adds	r3, r2, r3
 800f20c:	2002      	movs	r0, #2
 800f20e:	5e1b      	ldrsh	r3, [r3, r0]
 800f210:	3304      	adds	r3, #4
 800f212:	009b      	lsls	r3, r3, #2
 800f214:	58d4      	ldr	r4, [r2, r3]
      if (freq2 < 0)
 800f216:	2c00      	cmp	r4, #0
 800f218:	db11      	blt.n	800f23e <menu_marker_op_cb+0x8e>
      if (freq > freq2) {
 800f21a:	42a1      	cmp	r1, r4
 800f21c:	dd02      	ble.n	800f224 <menu_marker_op_cb+0x74>
 800f21e:	000b      	movs	r3, r1
 800f220:	0021      	movs	r1, r4
 800f222:	001c      	movs	r4, r3
      set_sweep_frequency(ST_START, freq);
 800f224:	2000      	movs	r0, #0
 800f226:	f7fa fb13 	bl	8009850 <set_sweep_frequency>
      set_sweep_frequency(ST_STOP, freq2);
 800f22a:	0021      	movs	r1, r4
 800f22c:	2001      	movs	r0, #1
 800f22e:	f7fa fb0f 	bl	8009850 <set_sweep_frequency>
  if (ui_mode == UI_NORMAL) 
 800f232:	4b0f      	ldr	r3, [pc, #60]	; (800f270 <menu_marker_op_cb+0xc0>)
 800f234:	781b      	ldrb	r3, [r3, #0]
 800f236:	2b00      	cmp	r3, #0
 800f238:	d10b      	bne.n	800f252 <menu_marker_op_cb+0xa2>
  draw_cal_status();
 800f23a:	f7fe ff09 	bl	800e050 <draw_cal_status>
}
 800f23e:	bd10      	pop	{r4, pc}
  switch (item) {
 800f240:	2801      	cmp	r0, #1
 800f242:	d1f6      	bne.n	800f232 <menu_marker_op_cb+0x82>
    set_sweep_frequency(ST_START, freq);
 800f244:	2000      	movs	r0, #0
 800f246:	f7fa fb03 	bl	8009850 <set_sweep_frequency>
  if (ui_mode == UI_NORMAL) 
 800f24a:	4b09      	ldr	r3, [pc, #36]	; (800f270 <menu_marker_op_cb+0xc0>)
 800f24c:	781b      	ldrb	r3, [r3, #0]
 800f24e:	2b00      	cmp	r3, #0
 800f250:	d0f3      	beq.n	800f23a <menu_marker_op_cb+0x8a>
 800f252:	f7ff ff95 	bl	800f180 <ui_mode_normal.part.2>
 800f256:	e7f0      	b.n	800f23a <menu_marker_op_cb+0x8a>
    set_sweep_frequency(ST_CENTER, freq);
 800f258:	2002      	movs	r0, #2
 800f25a:	f7fa faf9 	bl	8009850 <set_sweep_frequency>
  if (ui_mode == UI_NORMAL) 
 800f25e:	4b04      	ldr	r3, [pc, #16]	; (800f270 <menu_marker_op_cb+0xc0>)
 800f260:	781b      	ldrb	r3, [r3, #0]
 800f262:	2b00      	cmp	r3, #0
 800f264:	d0e9      	beq.n	800f23a <menu_marker_op_cb+0x8a>
 800f266:	e7f4      	b.n	800f252 <menu_marker_op_cb+0xa2>
 800f268:	20000454 	.word	0x20000454
 800f26c:	20001650 	.word	0x20001650
 800f270:	200030a5 	.word	0x200030a5
	...

0800f280 <menu_format2_cb>:
{
 800f280:	b510      	push	{r4, lr}
  switch (item) {
 800f282:	2805      	cmp	r0, #5
 800f284:	d809      	bhi.n	800f29a <menu_format2_cb+0x1a>
 800f286:	4b1b      	ldr	r3, [pc, #108]	; (800f2f4 <menu_format2_cb+0x74>)
 800f288:	0080      	lsls	r0, r0, #2
 800f28a:	581b      	ldr	r3, [r3, r0]
 800f28c:	469f      	mov	pc, r3
    set_trace_type(uistat.current_trace, TRC_X);
 800f28e:	2002      	movs	r0, #2
 800f290:	4b19      	ldr	r3, [pc, #100]	; (800f2f8 <menu_format2_cb+0x78>)
 800f292:	210a      	movs	r1, #10
 800f294:	5618      	ldrsb	r0, [r3, r0]
 800f296:	f7fb f8f3 	bl	800a480 <set_trace_type>
  request_to_redraw_grid();
 800f29a:	f7ff f851 	bl	800e340 <request_to_redraw_grid>
  if (ui_mode == UI_NORMAL) 
 800f29e:	4b17      	ldr	r3, [pc, #92]	; (800f2fc <menu_format2_cb+0x7c>)
 800f2a0:	781b      	ldrb	r3, [r3, #0]
 800f2a2:	2b00      	cmp	r3, #0
 800f2a4:	d001      	beq.n	800f2aa <menu_format2_cb+0x2a>
 800f2a6:	f7ff ff6b 	bl	800f180 <ui_mode_normal.part.2>
}
 800f2aa:	bd10      	pop	{r4, pc}
    set_trace_type(uistat.current_trace, TRC_R);
 800f2ac:	2002      	movs	r0, #2
 800f2ae:	4b12      	ldr	r3, [pc, #72]	; (800f2f8 <menu_format2_cb+0x78>)
 800f2b0:	2109      	movs	r1, #9
 800f2b2:	5618      	ldrsb	r0, [r3, r0]
 800f2b4:	f7fb f8e4 	bl	800a480 <set_trace_type>
    break;
 800f2b8:	e7ef      	b.n	800f29a <menu_format2_cb+0x1a>
    set_trace_type(uistat.current_trace, TRC_POLAR);
 800f2ba:	2002      	movs	r0, #2
 800f2bc:	4b0e      	ldr	r3, [pc, #56]	; (800f2f8 <menu_format2_cb+0x78>)
 800f2be:	2104      	movs	r1, #4
 800f2c0:	5618      	ldrsb	r0, [r3, r0]
 800f2c2:	f7fb f8dd 	bl	800a480 <set_trace_type>
    break;
 800f2c6:	e7e8      	b.n	800f29a <menu_format2_cb+0x1a>
    set_trace_type(uistat.current_trace, TRC_LINEAR);
 800f2c8:	2002      	movs	r0, #2
 800f2ca:	4b0b      	ldr	r3, [pc, #44]	; (800f2f8 <menu_format2_cb+0x78>)
 800f2cc:	2105      	movs	r1, #5
 800f2ce:	5618      	ldrsb	r0, [r3, r0]
 800f2d0:	f7fb f8d6 	bl	800a480 <set_trace_type>
    break;
 800f2d4:	e7e1      	b.n	800f29a <menu_format2_cb+0x1a>
    set_trace_type(uistat.current_trace, TRC_REAL);
 800f2d6:	2002      	movs	r0, #2
 800f2d8:	4b07      	ldr	r3, [pc, #28]	; (800f2f8 <menu_format2_cb+0x78>)
 800f2da:	2107      	movs	r1, #7
 800f2dc:	5618      	ldrsb	r0, [r3, r0]
 800f2de:	f7fb f8cf 	bl	800a480 <set_trace_type>
    break;
 800f2e2:	e7da      	b.n	800f29a <menu_format2_cb+0x1a>
    set_trace_type(uistat.current_trace, TRC_IMAG);
 800f2e4:	2002      	movs	r0, #2
 800f2e6:	4b04      	ldr	r3, [pc, #16]	; (800f2f8 <menu_format2_cb+0x78>)
 800f2e8:	2108      	movs	r1, #8
 800f2ea:	5618      	ldrsb	r0, [r3, r0]
 800f2ec:	f7fb f8c8 	bl	800a480 <set_trace_type>
    break;
 800f2f0:	e7d3      	b.n	800f29a <menu_format2_cb+0x1a>
 800f2f2:	46c0      	nop			; (mov r8, r8)
 800f2f4:	08014b14 	.word	0x08014b14
 800f2f8:	20001654 	.word	0x20001654
 800f2fc:	200030a5 	.word	0x200030a5

0800f300 <menu_format_cb>:
{
 800f300:	b510      	push	{r4, lr}
  switch (item) {
 800f302:	2804      	cmp	r0, #4
 800f304:	d809      	bhi.n	800f31a <menu_format_cb+0x1a>
 800f306:	4b17      	ldr	r3, [pc, #92]	; (800f364 <menu_format_cb+0x64>)
 800f308:	0080      	lsls	r0, r0, #2
 800f30a:	581b      	ldr	r3, [r3, r0]
 800f30c:	469f      	mov	pc, r3
    set_trace_type(uistat.current_trace, TRC_SWR);
 800f30e:	2002      	movs	r0, #2
 800f310:	4b15      	ldr	r3, [pc, #84]	; (800f368 <menu_format_cb+0x68>)
 800f312:	2106      	movs	r1, #6
 800f314:	5618      	ldrsb	r0, [r3, r0]
 800f316:	f7fb f8b3 	bl	800a480 <set_trace_type>
  request_to_redraw_grid();
 800f31a:	f7ff f811 	bl	800e340 <request_to_redraw_grid>
  if (ui_mode == UI_NORMAL) 
 800f31e:	4b13      	ldr	r3, [pc, #76]	; (800f36c <menu_format_cb+0x6c>)
 800f320:	781b      	ldrb	r3, [r3, #0]
 800f322:	2b00      	cmp	r3, #0
 800f324:	d001      	beq.n	800f32a <menu_format_cb+0x2a>
 800f326:	f7ff ff2b 	bl	800f180 <ui_mode_normal.part.2>
}
 800f32a:	bd10      	pop	{r4, pc}
    set_trace_type(uistat.current_trace, TRC_SMITH);
 800f32c:	2002      	movs	r0, #2
 800f32e:	4b0e      	ldr	r3, [pc, #56]	; (800f368 <menu_format_cb+0x68>)
 800f330:	2103      	movs	r1, #3
 800f332:	5618      	ldrsb	r0, [r3, r0]
 800f334:	f7fb f8a4 	bl	800a480 <set_trace_type>
    break;
 800f338:	e7ef      	b.n	800f31a <menu_format_cb+0x1a>
    set_trace_type(uistat.current_trace, TRC_LOGMAG);
 800f33a:	2002      	movs	r0, #2
 800f33c:	4b0a      	ldr	r3, [pc, #40]	; (800f368 <menu_format_cb+0x68>)
 800f33e:	2100      	movs	r1, #0
 800f340:	5618      	ldrsb	r0, [r3, r0]
 800f342:	f7fb f89d 	bl	800a480 <set_trace_type>
    break;
 800f346:	e7e8      	b.n	800f31a <menu_format_cb+0x1a>
    set_trace_type(uistat.current_trace, TRC_PHASE);
 800f348:	2002      	movs	r0, #2
 800f34a:	4b07      	ldr	r3, [pc, #28]	; (800f368 <menu_format_cb+0x68>)
 800f34c:	2101      	movs	r1, #1
 800f34e:	5618      	ldrsb	r0, [r3, r0]
 800f350:	f7fb f896 	bl	800a480 <set_trace_type>
    break;
 800f354:	e7e1      	b.n	800f31a <menu_format_cb+0x1a>
    set_trace_type(uistat.current_trace, TRC_DELAY);
 800f356:	2002      	movs	r0, #2
 800f358:	4b03      	ldr	r3, [pc, #12]	; (800f368 <menu_format_cb+0x68>)
 800f35a:	2102      	movs	r1, #2
 800f35c:	5618      	ldrsb	r0, [r3, r0]
 800f35e:	f7fb f88f 	bl	800a480 <set_trace_type>
    break;
 800f362:	e7da      	b.n	800f31a <menu_format_cb+0x1a>
 800f364:	08014b2c 	.word	0x08014b2c
 800f368:	20001654 	.word	0x20001654
 800f36c:	200030a5 	.word	0x200030a5

0800f370 <ui_process_keypad>:
{
 800f370:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800f372:	46ce      	mov	lr, r9
 800f374:	4647      	mov	r7, r8
  adc_stop(ADC1);
 800f376:	4850      	ldr	r0, [pc, #320]	; (800f4b8 <ui_process_keypad+0x148>)
{
 800f378:	b580      	push	{r7, lr}
  adc_stop(ADC1);
 800f37a:	f001 fea1 	bl	80110c0 <adc_stop>
  kp_index = 0;
 800f37e:	2200      	movs	r2, #0
 800f380:	4b4e      	ldr	r3, [pc, #312]	; (800f4bc <ui_process_keypad+0x14c>)
 800f382:	4d4f      	ldr	r5, [pc, #316]	; (800f4c0 <ui_process_keypad+0x150>)
 800f384:	701a      	strb	r2, [r3, #0]
            selection = keypads_last_index;
 800f386:	4b4f      	ldr	r3, [pc, #316]	; (800f4c4 <ui_process_keypad+0x154>)
          if (keypads[selection].c < 0) {
 800f388:	4f4f      	ldr	r7, [pc, #316]	; (800f4c8 <ui_process_keypad+0x158>)
            selection = keypads_last_index;
 800f38a:	4698      	mov	r8, r3
  *x = (last_touch_x - config.touch_cal[0]) * 16 / config.touch_cal[2];
 800f38c:	4b4f      	ldr	r3, [pc, #316]	; (800f4cc <ui_process_keypad+0x15c>)
 800f38e:	4699      	mov	r9, r3
 800f390:	e003      	b.n	800f39a <ui_process_keypad+0x2a>
    status = touch_check();
 800f392:	f7ff f97d 	bl	800e690 <touch_check>
    if (status == EVT_TOUCH_PRESSED) {
 800f396:	2802      	cmp	r0, #2
 800f398:	d04a      	beq.n	800f430 <ui_process_keypad+0xc0>
    status = btn_check();
 800f39a:	f7ff f811 	bl	800e3c0 <btn_check>
    if (status & (EVT_UP|EVT_DOWN)) {
 800f39e:	2330      	movs	r3, #48	; 0x30
    status = btn_check();
 800f3a0:	0004      	movs	r4, r0
    if (status & (EVT_UP|EVT_DOWN)) {
 800f3a2:	4203      	tst	r3, r0
 800f3a4:	d11b      	bne.n	800f3de <ui_process_keypad+0x6e>
    if (status == EVT_BUTTON_SINGLE_CLICK) {
 800f3a6:	2801      	cmp	r0, #1
 800f3a8:	d1f3      	bne.n	800f392 <ui_process_keypad+0x22>
      if (keypad_click(selection))
 800f3aa:	2000      	movs	r0, #0
 800f3ac:	5628      	ldrsb	r0, [r5, r0]
 800f3ae:	f7ff fd37 	bl	800ee20 <keypad_click>
 800f3b2:	2800      	cmp	r0, #0
 800f3b4:	d0ed      	beq.n	800f392 <ui_process_keypad+0x22>
  redraw_frame();
 800f3b6:	f7fe ffdb 	bl	800e370 <redraw_frame>
  request_to_redraw_grid();
 800f3ba:	f7fe ffc1 	bl	800e340 <request_to_redraw_grid>
  if (ui_mode == UI_NORMAL) 
 800f3be:	4b44      	ldr	r3, [pc, #272]	; (800f4d0 <ui_process_keypad+0x160>)
 800f3c0:	781b      	ldrb	r3, [r3, #0]
 800f3c2:	2b00      	cmp	r3, #0
 800f3c4:	d001      	beq.n	800f3ca <ui_process_keypad+0x5a>
 800f3c6:	f7ff fedb 	bl	800f180 <ui_mode_normal.part.2>
  touch_prepare_sense();
 800f3ca:	f7ff f8d1 	bl	800e570 <touch_prepare_sense>
  adc_start_analog_watchdogd(ADC1, ADC_CHSELR_CHSEL7);
 800f3ce:	2180      	movs	r1, #128	; 0x80
 800f3d0:	4839      	ldr	r0, [pc, #228]	; (800f4b8 <ui_process_keypad+0x148>)
 800f3d2:	f001 fe5d 	bl	8011090 <adc_start_analog_watchdogd>
}
 800f3d6:	bc0c      	pop	{r2, r3}
 800f3d8:	4690      	mov	r8, r2
 800f3da:	4699      	mov	r9, r3
 800f3dc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if (s & EVT_UP) {
 800f3de:	2610      	movs	r6, #16
 800f3e0:	4226      	tst	r6, r4
 800f3e2:	d00a      	beq.n	800f3fa <ui_process_keypad+0x8a>
          selection--;
 800f3e4:	782b      	ldrb	r3, [r5, #0]
 800f3e6:	3b01      	subs	r3, #1
 800f3e8:	b25b      	sxtb	r3, r3
 800f3ea:	702b      	strb	r3, [r5, #0]
          if (selection < 0)
 800f3ec:	2b00      	cmp	r3, #0
 800f3ee:	da02      	bge.n	800f3f6 <ui_process_keypad+0x86>
            selection = keypads_last_index;
 800f3f0:	4643      	mov	r3, r8
 800f3f2:	781b      	ldrb	r3, [r3, #0]
 800f3f4:	702b      	strb	r3, [r5, #0]
          draw_keypad();
 800f3f6:	f7ff fa73 	bl	800e8e0 <draw_keypad>
        if (s & EVT_DOWN) {
 800f3fa:	06a3      	lsls	r3, r4, #26
 800f3fc:	d510      	bpl.n	800f420 <ui_process_keypad+0xb0>
          selection++;
 800f3fe:	782b      	ldrb	r3, [r5, #0]
 800f400:	3301      	adds	r3, #1
 800f402:	b25b      	sxtb	r3, r3
          if (keypads[selection].c < 0) {
 800f404:	005a      	lsls	r2, r3, #1
          selection++;
 800f406:	702b      	strb	r3, [r5, #0]
          if (keypads[selection].c < 0) {
 800f408:	18d3      	adds	r3, r2, r3
 800f40a:	683a      	ldr	r2, [r7, #0]
 800f40c:	005b      	lsls	r3, r3, #1
 800f40e:	4694      	mov	ip, r2
 800f410:	4463      	add	r3, ip
 800f412:	791b      	ldrb	r3, [r3, #4]
 800f414:	2b7f      	cmp	r3, #127	; 0x7f
 800f416:	d901      	bls.n	800f41c <ui_process_keypad+0xac>
            selection = 0;
 800f418:	2300      	movs	r3, #0
 800f41a:	702b      	strb	r3, [r5, #0]
          draw_keypad();
 800f41c:	f7ff fa60 	bl	800e8e0 <draw_keypad>
        s = btn_wait_release();
 800f420:	f7ff f826 	bl	800e470 <btn_wait_release>
 800f424:	1e04      	subs	r4, r0, #0
      } while (s != 0);
 800f426:	d1db      	bne.n	800f3e0 <ui_process_keypad+0x70>
    status = touch_check();
 800f428:	f7ff f932 	bl	800e690 <touch_check>
    if (status == EVT_TOUCH_PRESSED) {
 800f42c:	2802      	cmp	r0, #2
 800f42e:	d1b4      	bne.n	800f39a <ui_process_keypad+0x2a>
  *x = (last_touch_x - config.touch_cal[0]) * 16 / config.touch_cal[2];
 800f430:	464b      	mov	r3, r9
 800f432:	4c28      	ldr	r4, [pc, #160]	; (800f4d4 <ui_process_keypad+0x164>)
 800f434:	2000      	movs	r0, #0
 800f436:	5e18      	ldrsh	r0, [r3, r0]
 800f438:	2212      	movs	r2, #18
 800f43a:	5ea3      	ldrsh	r3, [r4, r2]
 800f43c:	1ac0      	subs	r0, r0, r3
 800f43e:	0100      	lsls	r0, r0, #4
 800f440:	2316      	movs	r3, #22
 800f442:	5ee1      	ldrsh	r1, [r4, r3]
 800f444:	f7f0 ff54 	bl	80002f0 <__divsi3>
  *y = (last_touch_y - config.touch_cal[1]) * 16 / config.touch_cal[3];
 800f448:	4b23      	ldr	r3, [pc, #140]	; (800f4d8 <ui_process_keypad+0x168>)
  *x = (last_touch_x - config.touch_cal[0]) * 16 / config.touch_cal[2];
 800f44a:	0006      	movs	r6, r0
  *y = (last_touch_y - config.touch_cal[1]) * 16 / config.touch_cal[3];
 800f44c:	2000      	movs	r0, #0
 800f44e:	5e18      	ldrsh	r0, [r3, r0]
 800f450:	2214      	movs	r2, #20
 800f452:	5ea3      	ldrsh	r3, [r4, r2]
 800f454:	1ac0      	subs	r0, r0, r3
 800f456:	0100      	lsls	r0, r0, #4
 800f458:	2318      	movs	r3, #24
 800f45a:	5ee1      	ldrsh	r1, [r4, r3]
 800f45c:	f7f0 ff48 	bl	80002f0 <__divsi3>
  while (keypads[i].x) {
 800f460:	4b19      	ldr	r3, [pc, #100]	; (800f4c8 <ui_process_keypad+0x158>)
 800f462:	681a      	ldr	r2, [r3, #0]
 800f464:	8813      	ldrh	r3, [r2, #0]
 800f466:	2b00      	cmp	r3, #0
 800f468:	d097      	beq.n	800f39a <ui_process_keypad+0x2a>
  int i = 0;
 800f46a:	2400      	movs	r4, #0
 800f46c:	e005      	b.n	800f47a <ui_process_keypad+0x10a>
    i++;
 800f46e:	3206      	adds	r2, #6
  while (keypads[i].x) {
 800f470:	8813      	ldrh	r3, [r2, #0]
    i++;
 800f472:	3401      	adds	r4, #1
  while (keypads[i].x) {
 800f474:	2b00      	cmp	r3, #0
 800f476:	d100      	bne.n	800f47a <ui_process_keypad+0x10a>
 800f478:	e78f      	b.n	800f39a <ui_process_keypad+0x2a>
    if (keypads[i].x-2 < touch_x && touch_x < keypads[i].x+44+2
 800f47a:	1e59      	subs	r1, r3, #1
 800f47c:	428e      	cmp	r6, r1
 800f47e:	dbf6      	blt.n	800f46e <ui_process_keypad+0xfe>
 800f480:	332d      	adds	r3, #45	; 0x2d
 800f482:	429e      	cmp	r6, r3
 800f484:	dcf3      	bgt.n	800f46e <ui_process_keypad+0xfe>
        && keypads[i].y-2 < touch_y && touch_y < keypads[i].y+44+2) {
 800f486:	8853      	ldrh	r3, [r2, #2]
 800f488:	1e59      	subs	r1, r3, #1
 800f48a:	4288      	cmp	r0, r1
 800f48c:	dbef      	blt.n	800f46e <ui_process_keypad+0xfe>
 800f48e:	332d      	adds	r3, #45	; 0x2d
 800f490:	4298      	cmp	r0, r3
 800f492:	dcec      	bgt.n	800f46e <ui_process_keypad+0xfe>
      selection = i;
 800f494:	702c      	strb	r4, [r5, #0]
      draw_keypad();
 800f496:	f7ff fa23 	bl	800e8e0 <draw_keypad>
    status = touch_check();
 800f49a:	f7ff f8f9 	bl	800e690 <touch_check>
  } while(status != EVT_TOUCH_RELEASED);
 800f49e:	2803      	cmp	r0, #3
 800f4a0:	d1fb      	bne.n	800f49a <ui_process_keypad+0x12a>
      selection = -1;
 800f4a2:	23ff      	movs	r3, #255	; 0xff
 800f4a4:	702b      	strb	r3, [r5, #0]
      draw_keypad();
 800f4a6:	f7ff fa1b 	bl	800e8e0 <draw_keypad>
      if (key >= 0 && keypad_click(key))
 800f4aa:	0020      	movs	r0, r4
 800f4ac:	f7ff fcb8 	bl	800ee20 <keypad_click>
 800f4b0:	2800      	cmp	r0, #0
 800f4b2:	d100      	bne.n	800f4b6 <ui_process_keypad+0x146>
 800f4b4:	e771      	b.n	800f39a <ui_process_keypad+0x2a>
 800f4b6:	e77e      	b.n	800f3b6 <ui_process_keypad+0x46>
 800f4b8:	40012400 	.word	0x40012400
 800f4bc:	2000308f 	.word	0x2000308f
 800f4c0:	200030a4 	.word	0x200030a4
 800f4c4:	20003080 	.word	0x20003080
 800f4c8:	2000307c 	.word	0x2000307c
 800f4cc:	2000309e 	.word	0x2000309e
 800f4d0:	200030a5 	.word	0x200030a5
 800f4d4:	2000042c 	.word	0x2000042c
 800f4d8:	200030a0 	.word	0x200030a0
 800f4dc:	00000000 	.word	0x00000000

0800f4e0 <menu_transform_window_cb>:
{
 800f4e0:	b510      	push	{r4, lr}
  switch (item) {
 800f4e2:	2801      	cmp	r0, #1
 800f4e4:	d004      	beq.n	800f4f0 <menu_transform_window_cb+0x10>
 800f4e6:	2802      	cmp	r0, #2
 800f4e8:	d01c      	beq.n	800f524 <menu_transform_window_cb+0x44>
 800f4ea:	2800      	cmp	r0, #0
 800f4ec:	d00d      	beq.n	800f50a <menu_transform_window_cb+0x2a>
}
 800f4ee:	bd10      	pop	{r4, pc}
      domain_mode = (domain_mode & ~TD_WINDOW) | TD_WINDOW_NORMAL;
 800f4f0:	2018      	movs	r0, #24
 800f4f2:	4910      	ldr	r1, [pc, #64]	; (800f534 <menu_transform_window_cb+0x54>)
 800f4f4:	4a10      	ldr	r2, [pc, #64]	; (800f538 <menu_transform_window_cb+0x58>)
 800f4f6:	5c8b      	ldrb	r3, [r1, r2]
 800f4f8:	4383      	bics	r3, r0
 800f4fa:	548b      	strb	r3, [r1, r2]
  if (ui_mode == UI_NORMAL) 
 800f4fc:	4b0f      	ldr	r3, [pc, #60]	; (800f53c <menu_transform_window_cb+0x5c>)
 800f4fe:	781b      	ldrb	r3, [r3, #0]
 800f500:	2b00      	cmp	r3, #0
 800f502:	d0f4      	beq.n	800f4ee <menu_transform_window_cb+0xe>
 800f504:	f7ff fe3c 	bl	800f180 <ui_mode_normal.part.2>
 800f508:	e7f1      	b.n	800f4ee <menu_transform_window_cb+0xe>
      domain_mode = (domain_mode & ~TD_WINDOW) | TD_WINDOW_MINIMUM;
 800f50a:	490a      	ldr	r1, [pc, #40]	; (800f534 <menu_transform_window_cb+0x54>)
 800f50c:	4a0a      	ldr	r2, [pc, #40]	; (800f538 <menu_transform_window_cb+0x58>)
 800f50e:	3018      	adds	r0, #24
 800f510:	5c8b      	ldrb	r3, [r1, r2]
 800f512:	4383      	bics	r3, r0
 800f514:	2008      	movs	r0, #8
 800f516:	4303      	orrs	r3, r0
 800f518:	548b      	strb	r3, [r1, r2]
  if (ui_mode == UI_NORMAL) 
 800f51a:	4b08      	ldr	r3, [pc, #32]	; (800f53c <menu_transform_window_cb+0x5c>)
 800f51c:	781b      	ldrb	r3, [r3, #0]
 800f51e:	2b00      	cmp	r3, #0
 800f520:	d0e5      	beq.n	800f4ee <menu_transform_window_cb+0xe>
 800f522:	e7ef      	b.n	800f504 <menu_transform_window_cb+0x24>
      domain_mode = (domain_mode & ~TD_WINDOW) | TD_WINDOW_MAXIMUM;
 800f524:	2018      	movs	r0, #24
 800f526:	4903      	ldr	r1, [pc, #12]	; (800f534 <menu_transform_window_cb+0x54>)
 800f528:	4a03      	ldr	r2, [pc, #12]	; (800f538 <menu_transform_window_cb+0x58>)
 800f52a:	5c8b      	ldrb	r3, [r1, r2]
 800f52c:	4383      	bics	r3, r0
 800f52e:	2010      	movs	r0, #16
 800f530:	e7f1      	b.n	800f516 <menu_transform_window_cb+0x36>
 800f532:	46c0      	nop			; (mov r8, r8)
 800f534:	20000454 	.word	0x20000454
 800f538:	000011c4 	.word	0x000011c4
 800f53c:	200030a5 	.word	0x200030a5

0800f540 <ui_mode_numeric.part.4>:
static void ui_mode_numeric(int _keypad_mode)
 800f540:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800f542:	0005      	movs	r5, r0
  leave_ui_mode();
 800f544:	f7ff fdf4 	bl	800f130 <leave_ui_mode>
  ui_mode = UI_NUMERIC;
 800f548:	2202      	movs	r2, #2
 800f54a:	4b41      	ldr	r3, [pc, #260]	; (800f650 <ui_mode_numeric.part.4+0x110>)
  keypad_mode = _keypad_mode;
 800f54c:	4c41      	ldr	r4, [pc, #260]	; (800f654 <ui_mode_numeric.part.4+0x114>)
  ui_mode = UI_NUMERIC;
 800f54e:	701a      	strb	r2, [r3, #0]
  area_width = AREA_WIDTH_NORMAL;
 800f550:	222e      	movs	r2, #46	; 0x2e
 800f552:	4b41      	ldr	r3, [pc, #260]	; (800f658 <ui_mode_numeric.part.4+0x118>)
 800f554:	32ff      	adds	r2, #255	; 0xff
 800f556:	601a      	str	r2, [r3, #0]
  area_height = 240-32;//HEIGHT - 32;
 800f558:	4b40      	ldr	r3, [pc, #256]	; (800f65c <ui_mode_numeric.part.4+0x11c>)
 800f55a:	3a5d      	subs	r2, #93	; 0x5d
 800f55c:	601a      	str	r2, [r3, #0]
  keypad_mode = _keypad_mode;
 800f55e:	7025      	strb	r5, [r4, #0]
  draw_numeric_area_frame();
 800f560:	f7ff f826 	bl	800e5b0 <draw_numeric_area_frame>
  switch (keypad_mode) {
 800f564:	7823      	ldrb	r3, [r4, #0]
 800f566:	2b09      	cmp	r3, #9
 800f568:	d900      	bls.n	800f56c <ui_mode_numeric.part.4+0x2c>
 800f56a:	e06c      	b.n	800f646 <ui_mode_numeric.part.4+0x106>
 800f56c:	4a3c      	ldr	r2, [pc, #240]	; (800f660 <ui_mode_numeric.part.4+0x120>)
 800f56e:	009b      	lsls	r3, r3, #2
 800f570:	58d3      	ldr	r3, [r2, r3]
 800f572:	469f      	mov	pc, r3
    uistat.value = velocity_factor;
 800f574:	4a3b      	ldr	r2, [pc, #236]	; (800f664 <ui_mode_numeric.part.4+0x124>)
 800f576:	4b3c      	ldr	r3, [pc, #240]	; (800f668 <ui_mode_numeric.part.4+0x128>)
 800f578:	4e3c      	ldr	r6, [pc, #240]	; (800f66c <ui_mode_numeric.part.4+0x12c>)
 800f57a:	5cd5      	ldrb	r5, [r2, r3]
 800f57c:	6075      	str	r5, [r6, #4]
    for (; x >= 10 && n < 9; n++)
 800f57e:	2d09      	cmp	r5, #9
 800f580:	d964      	bls.n	800f64c <ui_mode_numeric.part.4+0x10c>
 800f582:	002f      	movs	r7, r5
    int n = 0;
 800f584:	2400      	movs	r4, #0
      x /= 10;
 800f586:	210a      	movs	r1, #10
 800f588:	0038      	movs	r0, r7
 800f58a:	f7f0 fe21 	bl	80001d0 <__udivsi3>
    for (; x >= 10 && n < 9; n++)
 800f58e:	3401      	adds	r4, #1
 800f590:	2f63      	cmp	r7, #99	; 0x63
 800f592:	d956      	bls.n	800f642 <ui_mode_numeric.part.4+0x102>
      x /= 10;
 800f594:	0007      	movs	r7, r0
    for (; x >= 10 && n < 9; n++)
 800f596:	2c09      	cmp	r4, #9
 800f598:	d1f5      	bne.n	800f586 <ui_mode_numeric.part.4+0x46>
  uistat.previous_value = uistat.value;
 800f59a:	60b5      	str	r5, [r6, #8]
    uistat.digit = n;
 800f59c:	7034      	strb	r4, [r6, #0]
  draw_numeric_area();
 800f59e:	f7ff f987 	bl	800e8b0 <draw_numeric_area>
}
 800f5a2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    uistat.value = get_trace_scale(uistat.current_trace) * 1e12;
 800f5a4:	2002      	movs	r0, #2
 800f5a6:	4e31      	ldr	r6, [pc, #196]	; (800f66c <ui_mode_numeric.part.4+0x12c>)
 800f5a8:	5630      	ldrsb	r0, [r6, r0]
 800f5aa:	f7fb f829 	bl	800a600 <get_trace_scale>
 800f5ae:	f7f3 ff17 	bl	80033e0 <__aeabi_f2d>
 800f5b2:	22a2      	movs	r2, #162	; 0xa2
 800f5b4:	4b2e      	ldr	r3, [pc, #184]	; (800f670 <ui_mode_numeric.part.4+0x130>)
 800f5b6:	0612      	lsls	r2, r2, #24
 800f5b8:	f7f3 f822 	bl	8002600 <__aeabi_dmul>
 800f5bc:	f7f1 f8a0 	bl	8000700 <__aeabi_d2uiz>
 800f5c0:	0005      	movs	r5, r0
 800f5c2:	6070      	str	r0, [r6, #4]
    break;
 800f5c4:	e7db      	b.n	800f57e <ui_mode_numeric.part.4+0x3e>
    uistat.value = get_sweep_frequency(ST_START);
 800f5c6:	2000      	movs	r0, #0
 800f5c8:	f7fa faaa 	bl	8009b20 <get_sweep_frequency>
 800f5cc:	4e27      	ldr	r6, [pc, #156]	; (800f66c <ui_mode_numeric.part.4+0x12c>)
 800f5ce:	0005      	movs	r5, r0
 800f5d0:	6070      	str	r0, [r6, #4]
    break;
 800f5d2:	e7d4      	b.n	800f57e <ui_mode_numeric.part.4+0x3e>
    uistat.value = get_sweep_frequency(ST_STOP);
 800f5d4:	2001      	movs	r0, #1
 800f5d6:	f7fa faa3 	bl	8009b20 <get_sweep_frequency>
 800f5da:	4e24      	ldr	r6, [pc, #144]	; (800f66c <ui_mode_numeric.part.4+0x12c>)
 800f5dc:	0005      	movs	r5, r0
 800f5de:	6070      	str	r0, [r6, #4]
    break;
 800f5e0:	e7cd      	b.n	800f57e <ui_mode_numeric.part.4+0x3e>
    uistat.value = get_sweep_frequency(ST_CENTER);
 800f5e2:	2002      	movs	r0, #2
 800f5e4:	f7fa fa9c 	bl	8009b20 <get_sweep_frequency>
 800f5e8:	4e20      	ldr	r6, [pc, #128]	; (800f66c <ui_mode_numeric.part.4+0x12c>)
 800f5ea:	0005      	movs	r5, r0
 800f5ec:	6070      	str	r0, [r6, #4]
    break;
 800f5ee:	e7c6      	b.n	800f57e <ui_mode_numeric.part.4+0x3e>
    uistat.value = get_sweep_frequency(ST_SPAN);
 800f5f0:	2003      	movs	r0, #3
 800f5f2:	f7fa fa95 	bl	8009b20 <get_sweep_frequency>
 800f5f6:	4e1d      	ldr	r6, [pc, #116]	; (800f66c <ui_mode_numeric.part.4+0x12c>)
 800f5f8:	0005      	movs	r5, r0
 800f5fa:	6070      	str	r0, [r6, #4]
    break;
 800f5fc:	e7bf      	b.n	800f57e <ui_mode_numeric.part.4+0x3e>
    uistat.value = get_sweep_frequency(ST_CW);
 800f5fe:	2004      	movs	r0, #4
 800f600:	f7fa fa8e 	bl	8009b20 <get_sweep_frequency>
 800f604:	4e19      	ldr	r6, [pc, #100]	; (800f66c <ui_mode_numeric.part.4+0x12c>)
 800f606:	0005      	movs	r5, r0
 800f608:	6070      	str	r0, [r6, #4]
    break;
 800f60a:	e7b8      	b.n	800f57e <ui_mode_numeric.part.4+0x3e>
    uistat.value = get_trace_scale(uistat.current_trace) * 1000;
 800f60c:	2002      	movs	r0, #2
 800f60e:	4e17      	ldr	r6, [pc, #92]	; (800f66c <ui_mode_numeric.part.4+0x12c>)
 800f610:	5630      	ldrsb	r0, [r6, r0]
 800f612:	f7fa fff5 	bl	800a600 <get_trace_scale>
    uistat.value = get_trace_refpos(uistat.current_trace) * 1000;
 800f616:	4917      	ldr	r1, [pc, #92]	; (800f674 <ui_mode_numeric.part.4+0x134>)
 800f618:	f7f1 fcea 	bl	8000ff0 <__aeabi_fmul>
 800f61c:	f7f1 f858 	bl	80006d0 <__aeabi_f2uiz>
 800f620:	0005      	movs	r5, r0
 800f622:	6070      	str	r0, [r6, #4]
    break;
 800f624:	e7ab      	b.n	800f57e <ui_mode_numeric.part.4+0x3e>
    uistat.value = get_trace_refpos(uistat.current_trace) * 1000;
 800f626:	2002      	movs	r0, #2
 800f628:	4e10      	ldr	r6, [pc, #64]	; (800f66c <ui_mode_numeric.part.4+0x12c>)
 800f62a:	5630      	ldrsb	r0, [r6, r0]
 800f62c:	f7fb f820 	bl	800a670 <get_trace_refpos>
 800f630:	e7f1      	b.n	800f616 <ui_mode_numeric.part.4+0xd6>
    uistat.value = get_electrical_delay();
 800f632:	f7fb facd 	bl	800abd0 <get_electrical_delay>
 800f636:	f7f1 f84b 	bl	80006d0 <__aeabi_f2uiz>
 800f63a:	4e0c      	ldr	r6, [pc, #48]	; (800f66c <ui_mode_numeric.part.4+0x12c>)
 800f63c:	0005      	movs	r5, r0
 800f63e:	6070      	str	r0, [r6, #4]
    break;
 800f640:	e79d      	b.n	800f57e <ui_mode_numeric.part.4+0x3e>
 800f642:	b264      	sxtb	r4, r4
 800f644:	e7a9      	b.n	800f59a <ui_mode_numeric.part.4+0x5a>
 800f646:	4e09      	ldr	r6, [pc, #36]	; (800f66c <ui_mode_numeric.part.4+0x12c>)
 800f648:	6875      	ldr	r5, [r6, #4]
 800f64a:	e798      	b.n	800f57e <ui_mode_numeric.part.4+0x3e>
    for (; x >= 10 && n < 9; n++)
 800f64c:	2400      	movs	r4, #0
 800f64e:	e7a4      	b.n	800f59a <ui_mode_numeric.part.4+0x5a>
 800f650:	200030a5 	.word	0x200030a5
 800f654:	20003079 	.word	0x20003079
 800f658:	2000163c 	.word	0x2000163c
 800f65c:	20001638 	.word	0x20001638
 800f660:	08014b40 	.word	0x08014b40
 800f664:	20000454 	.word	0x20000454
 800f668:	000011c5 	.word	0x000011c5
 800f66c:	20001654 	.word	0x20001654
 800f670:	426d1a94 	.word	0x426d1a94
 800f674:	447a0000 	.word	0x447a0000
	...

0800f680 <menu_transform_cb>:
{
 800f680:	b510      	push	{r4, lr}
  switch (item) {
 800f682:	2805      	cmp	r0, #5
 800f684:	d814      	bhi.n	800f6b0 <menu_transform_cb+0x30>
 800f686:	4b25      	ldr	r3, [pc, #148]	; (800f71c <menu_transform_cb+0x9c>)
 800f688:	0080      	lsls	r0, r0, #2
 800f68a:	581b      	ldr	r3, [r3, r0]
 800f68c:	469f      	mov	pc, r3
      if ((domain_mode & DOMAIN_MODE) == DOMAIN_TIME) {
 800f68e:	2101      	movs	r1, #1
 800f690:	4a23      	ldr	r2, [pc, #140]	; (800f720 <menu_transform_cb+0xa0>)
 800f692:	4b24      	ldr	r3, [pc, #144]	; (800f724 <menu_transform_cb+0xa4>)
 800f694:	5cd3      	ldrb	r3, [r2, r3]
 800f696:	4219      	tst	r1, r3
 800f698:	d036      	beq.n	800f708 <menu_transform_cb+0x88>
          domain_mode = (domain_mode & ~DOMAIN_MODE) | DOMAIN_FREQ;
 800f69a:	438b      	bics	r3, r1
 800f69c:	4921      	ldr	r1, [pc, #132]	; (800f724 <menu_transform_cb+0xa4>)
 800f69e:	5453      	strb	r3, [r2, r1]
      draw_frequencies();
 800f6a0:	f7fe fbc6 	bl	800de30 <draw_frequencies>
  if (ui_mode == UI_NORMAL) 
 800f6a4:	4b20      	ldr	r3, [pc, #128]	; (800f728 <menu_transform_cb+0xa8>)
 800f6a6:	781b      	ldrb	r3, [r3, #0]
 800f6a8:	2b00      	cmp	r3, #0
 800f6aa:	d001      	beq.n	800f6b0 <menu_transform_cb+0x30>
 800f6ac:	f7ff fd68 	bl	800f180 <ui_mode_normal.part.2>
}
 800f6b0:	bd10      	pop	{r4, pc}
      status = btn_wait_release();
 800f6b2:	f7fe fedd 	bl	800e470 <btn_wait_release>
      if (status & EVT_BUTTON_DOWN_LONG) {
 800f6b6:	0743      	lsls	r3, r0, #29
 800f6b8:	d529      	bpl.n	800f70e <menu_transform_cb+0x8e>
  if (ui_mode == UI_NUMERIC) 
 800f6ba:	4b1b      	ldr	r3, [pc, #108]	; (800f728 <menu_transform_cb+0xa8>)
 800f6bc:	781b      	ldrb	r3, [r3, #0]
 800f6be:	2b02      	cmp	r3, #2
 800f6c0:	d0f6      	beq.n	800f6b0 <menu_transform_cb+0x30>
 800f6c2:	2008      	movs	r0, #8
 800f6c4:	f7ff ff3c 	bl	800f540 <ui_mode_numeric.part.4>
 800f6c8:	e7f2      	b.n	800f6b0 <menu_transform_cb+0x30>
      domain_mode = (domain_mode & ~TD_FUNC) | TD_FUNC_LOWPASS_STEP;
 800f6ca:	2006      	movs	r0, #6
 800f6cc:	4914      	ldr	r1, [pc, #80]	; (800f720 <menu_transform_cb+0xa0>)
 800f6ce:	4a15      	ldr	r2, [pc, #84]	; (800f724 <menu_transform_cb+0xa4>)
 800f6d0:	5c8b      	ldrb	r3, [r1, r2]
 800f6d2:	4383      	bics	r3, r0
 800f6d4:	2004      	movs	r0, #4
 800f6d6:	4303      	orrs	r3, r0
 800f6d8:	548b      	strb	r3, [r1, r2]
  if (ui_mode == UI_NORMAL) 
 800f6da:	4b13      	ldr	r3, [pc, #76]	; (800f728 <menu_transform_cb+0xa8>)
 800f6dc:	781b      	ldrb	r3, [r3, #0]
 800f6de:	2b00      	cmp	r3, #0
 800f6e0:	d0e6      	beq.n	800f6b0 <menu_transform_cb+0x30>
 800f6e2:	e7e3      	b.n	800f6ac <menu_transform_cb+0x2c>
      domain_mode = (domain_mode & ~TD_FUNC) | TD_FUNC_LOWPASS_IMPULSE;
 800f6e4:	2006      	movs	r0, #6
 800f6e6:	490e      	ldr	r1, [pc, #56]	; (800f720 <menu_transform_cb+0xa0>)
 800f6e8:	4a0e      	ldr	r2, [pc, #56]	; (800f724 <menu_transform_cb+0xa4>)
 800f6ea:	5c8b      	ldrb	r3, [r1, r2]
 800f6ec:	4383      	bics	r3, r0
 800f6ee:	2002      	movs	r0, #2
 800f6f0:	e7f1      	b.n	800f6d6 <menu_transform_cb+0x56>
      domain_mode = (domain_mode & ~TD_FUNC) | TD_FUNC_BANDPASS;
 800f6f2:	2006      	movs	r0, #6
 800f6f4:	490a      	ldr	r1, [pc, #40]	; (800f720 <menu_transform_cb+0xa0>)
 800f6f6:	4a0b      	ldr	r2, [pc, #44]	; (800f724 <menu_transform_cb+0xa4>)
 800f6f8:	5c8b      	ldrb	r3, [r1, r2]
 800f6fa:	4383      	bics	r3, r0
 800f6fc:	548b      	strb	r3, [r1, r2]
  if (ui_mode == UI_NORMAL) 
 800f6fe:	4b0a      	ldr	r3, [pc, #40]	; (800f728 <menu_transform_cb+0xa8>)
 800f700:	781b      	ldrb	r3, [r3, #0]
 800f702:	2b00      	cmp	r3, #0
 800f704:	d0d4      	beq.n	800f6b0 <menu_transform_cb+0x30>
 800f706:	e7d1      	b.n	800f6ac <menu_transform_cb+0x2c>
          domain_mode = (domain_mode & ~DOMAIN_MODE) | DOMAIN_TIME;
 800f708:	2101      	movs	r1, #1
 800f70a:	430b      	orrs	r3, r1
 800f70c:	e7c6      	b.n	800f69c <menu_transform_cb+0x1c>
        ui_mode_keypad(KM_VELOCITY_FACTOR);
 800f70e:	2008      	movs	r0, #8
 800f710:	f7ff fb3e 	bl	800ed90 <ui_mode_keypad>
        ui_process_keypad();
 800f714:	f7ff fe2c 	bl	800f370 <ui_process_keypad>
}
 800f718:	e7ca      	b.n	800f6b0 <menu_transform_cb+0x30>
 800f71a:	46c0      	nop			; (mov r8, r8)
 800f71c:	08014b68 	.word	0x08014b68
 800f720:	20000454 	.word	0x20000454
 800f724:	000011c4 	.word	0x000011c4
 800f728:	200030a5 	.word	0x200030a5
 800f72c:	00000000 	.word	0x00000000

0800f730 <menu_scale_cb>:
{
 800f730:	b510      	push	{r4, lr}
  int km = KM_SCALE + item;
 800f732:	1d44      	adds	r4, r0, #5
  if (km == KM_SCALE && trace[uistat.current_trace].type == TRC_DELAY) {
 800f734:	2c05      	cmp	r4, #5
 800f736:	d00b      	beq.n	800f750 <menu_scale_cb+0x20>
  status = btn_wait_release();
 800f738:	f7fe fe9a 	bl	800e470 <btn_wait_release>
  if (status & EVT_BUTTON_DOWN_LONG) {
 800f73c:	0743      	lsls	r3, r0, #29
 800f73e:	d51a      	bpl.n	800f776 <menu_scale_cb+0x46>
  if (ui_mode == UI_NUMERIC) 
 800f740:	4b10      	ldr	r3, [pc, #64]	; (800f784 <menu_scale_cb+0x54>)
 800f742:	781b      	ldrb	r3, [r3, #0]
 800f744:	2b02      	cmp	r3, #2
 800f746:	d002      	beq.n	800f74e <menu_scale_cb+0x1e>
 800f748:	0020      	movs	r0, r4
 800f74a:	f7ff fef9 	bl	800f540 <ui_mode_numeric.part.4>
}
 800f74e:	bd10      	pop	{r4, pc}
  if (km == KM_SCALE && trace[uistat.current_trace].type == TRC_DELAY) {
 800f750:	2202      	movs	r2, #2
 800f752:	4b0d      	ldr	r3, [pc, #52]	; (800f788 <menu_scale_cb+0x58>)
 800f754:	569a      	ldrsb	r2, [r3, r2]
 800f756:	0053      	lsls	r3, r2, #1
 800f758:	189a      	adds	r2, r3, r2
 800f75a:	4b0c      	ldr	r3, [pc, #48]	; (800f78c <menu_scale_cb+0x5c>)
 800f75c:	0092      	lsls	r2, r2, #2
 800f75e:	189b      	adds	r3, r3, r2
 800f760:	4a0b      	ldr	r2, [pc, #44]	; (800f790 <menu_scale_cb+0x60>)
 800f762:	4694      	mov	ip, r2
 800f764:	4463      	add	r3, ip
 800f766:	781b      	ldrb	r3, [r3, #0]
 800f768:	2b02      	cmp	r3, #2
 800f76a:	d1e5      	bne.n	800f738 <menu_scale_cb+0x8>
    km = KM_SCALEDELAY;
 800f76c:	3404      	adds	r4, #4
  status = btn_wait_release();
 800f76e:	f7fe fe7f 	bl	800e470 <btn_wait_release>
  if (status & EVT_BUTTON_DOWN_LONG) {
 800f772:	0743      	lsls	r3, r0, #29
 800f774:	d4e4      	bmi.n	800f740 <menu_scale_cb+0x10>
    ui_mode_keypad(km);
 800f776:	0020      	movs	r0, r4
 800f778:	f7ff fb0a 	bl	800ed90 <ui_mode_keypad>
    ui_process_keypad();
 800f77c:	f7ff fdf8 	bl	800f370 <ui_process_keypad>
}
 800f780:	e7e5      	b.n	800f74e <menu_scale_cb+0x1e>
 800f782:	46c0      	nop			; (mov r8, r8)
 800f784:	200030a5 	.word	0x200030a5
 800f788:	20001654 	.word	0x20001654
 800f78c:	20000454 	.word	0x20000454
 800f790:	00001171 	.word	0x00001171
	...

0800f7a0 <menu_move_back>:
{
 800f7a0:	b530      	push	{r4, r5, lr}
  if (menu_current_level == 0)
 800f7a2:	4c18      	ldr	r4, [pc, #96]	; (800f804 <menu_move_back+0x64>)
{
 800f7a4:	b083      	sub	sp, #12
  if (menu_current_level == 0)
 800f7a6:	7823      	ldrb	r3, [r4, #0]
 800f7a8:	2b00      	cmp	r3, #0
 800f7aa:	d023      	beq.n	800f7f4 <menu_move_back+0x54>
  menu_current_level--;
 800f7ac:	3b01      	subs	r3, #1
 800f7ae:	b2db      	uxtb	r3, r3
  const menuitem_t *menu = menu_stack[menu_current_level];
 800f7b0:	4d15      	ldr	r5, [pc, #84]	; (800f808 <menu_move_back+0x68>)
  menu_current_level--;
 800f7b2:	7023      	strb	r3, [r4, #0]
  const menuitem_t *menu = menu_stack[menu_current_level];
 800f7b4:	009b      	lsls	r3, r3, #2
 800f7b6:	58eb      	ldr	r3, [r5, r3]
  for (i = 0; menu[i].type != MT_NONE; i++)
 800f7b8:	781a      	ldrb	r2, [r3, #0]
 800f7ba:	2a00      	cmp	r2, #0
 800f7bc:	d01f      	beq.n	800f7fe <menu_move_back+0x5e>
 800f7be:	2200      	movs	r2, #0
 800f7c0:	330c      	adds	r3, #12
    ;
 800f7c2:	330c      	adds	r3, #12
  for (i = 0; menu[i].type != MT_NONE; i++)
 800f7c4:	0019      	movs	r1, r3
 800f7c6:	390c      	subs	r1, #12
 800f7c8:	7809      	ldrb	r1, [r1, #0]
 800f7ca:	3201      	adds	r2, #1
 800f7cc:	2900      	cmp	r1, #0
 800f7ce:	d1f8      	bne.n	800f7c2 <menu_move_back+0x22>
  if (selection >= i)
 800f7d0:	2100      	movs	r1, #0
 800f7d2:	4b0e      	ldr	r3, [pc, #56]	; (800f80c <menu_move_back+0x6c>)
 800f7d4:	5659      	ldrsb	r1, [r3, r1]
 800f7d6:	4291      	cmp	r1, r2
 800f7d8:	da0e      	bge.n	800f7f8 <menu_move_back+0x58>
   ili9341_fill(320-72, 0, 72, 32*7, bg);
 800f7da:	2300      	movs	r3, #0
 800f7dc:	20f8      	movs	r0, #248	; 0xf8
 800f7de:	9300      	str	r3, [sp, #0]
 800f7e0:	2248      	movs	r2, #72	; 0x48
 800f7e2:	33e0      	adds	r3, #224	; 0xe0
 800f7e4:	2100      	movs	r1, #0
 800f7e6:	f000 fef3 	bl	80105d0 <ili9341_fill>
  draw_menu_buttons(menu_stack[menu_current_level]);
 800f7ea:	7823      	ldrb	r3, [r4, #0]
 800f7ec:	009b      	lsls	r3, r3, #2
 800f7ee:	58e8      	ldr	r0, [r5, r3]
 800f7f0:	f7ff f8be 	bl	800e970 <draw_menu_buttons>
}
 800f7f4:	b003      	add	sp, #12
 800f7f6:	bd30      	pop	{r4, r5, pc}
    selection = i-1;
 800f7f8:	3a01      	subs	r2, #1
 800f7fa:	701a      	strb	r2, [r3, #0]
 800f7fc:	e7ed      	b.n	800f7da <menu_move_back+0x3a>
  for (i = 0; menu[i].type != MT_NONE; i++)
 800f7fe:	2200      	movs	r2, #0
 800f800:	e7e6      	b.n	800f7d0 <menu_move_back+0x30>
 800f802:	46c0      	nop			; (mov r8, r8)
 800f804:	200030a2 	.word	0x200030a2
 800f808:	20001640 	.word	0x20001640
 800f80c:	200030a4 	.word	0x200030a4

0800f810 <menu_caldone_cb>:
{
 800f810:	b510      	push	{r4, lr}
	cal_done();
 800f812:	f7fa fa35 	bl	8009c80 <cal_done>
  draw_cal_status();
 800f816:	f7fe fc1b 	bl	800e050 <draw_cal_status>
  menu_move_back();
 800f81a:	f7ff ffc1 	bl	800f7a0 <menu_move_back>
  menu_push_submenu(menu_save);
 800f81e:	4802      	ldr	r0, [pc, #8]	; (800f828 <menu_caldone_cb+0x18>)
 800f820:	f7ff fa4e 	bl	800ecc0 <menu_push_submenu>
}
 800f824:	bd10      	pop	{r4, pc}
 800f826:	46c0      	nop			; (mov r8, r8)
 800f828:	080151bc 	.word	0x080151bc
 800f82c:	00000000 	.word	0x00000000

0800f830 <menu_recall_cb>:
{
 800f830:	b510      	push	{r4, lr}
  if (item < 0 || item >= 5)
 800f832:	2804      	cmp	r0, #4
 800f834:	d900      	bls.n	800f838 <menu_recall_cb+0x8>
}
 800f836:	bd10      	pop	{r4, pc}
  if (caldata_recall(item) == 0) {
 800f838:	f001 fad2 	bl	8010de0 <caldata_recall>
 800f83c:	2800      	cmp	r0, #0
 800f83e:	d1fa      	bne.n	800f836 <menu_recall_cb+0x6>
    menu_move_back();
 800f840:	f7ff ffae 	bl	800f7a0 <menu_move_back>
  if (ui_mode == UI_NORMAL) 
 800f844:	4b05      	ldr	r3, [pc, #20]	; (800f85c <menu_recall_cb+0x2c>)
 800f846:	781b      	ldrb	r3, [r3, #0]
 800f848:	2b00      	cmp	r3, #0
 800f84a:	d001      	beq.n	800f850 <menu_recall_cb+0x20>
 800f84c:	f7ff fc98 	bl	800f180 <ui_mode_normal.part.2>
    update_grid();
 800f850:	f7fc fba6 	bl	800bfa0 <update_grid>
    draw_cal_status();
 800f854:	f7fe fbfc 	bl	800e050 <draw_cal_status>
 800f858:	e7ed      	b.n	800f836 <menu_recall_cb+0x6>
 800f85a:	46c0      	nop			; (mov r8, r8)
 800f85c:	200030a5 	.word	0x200030a5

0800f860 <menu_save_cb>:
{
 800f860:	b510      	push	{r4, lr}
  if (item < 0 || item >= 5)
 800f862:	2804      	cmp	r0, #4
 800f864:	d900      	bls.n	800f868 <menu_save_cb+0x8>
}
 800f866:	bd10      	pop	{r4, pc}
  if (caldata_save(item) == 0) {
 800f868:	f001 fa32 	bl	8010cd0 <caldata_save>
 800f86c:	2800      	cmp	r0, #0
 800f86e:	d1fa      	bne.n	800f866 <menu_save_cb+0x6>
    menu_move_back();
 800f870:	f7ff ff96 	bl	800f7a0 <menu_move_back>
  if (ui_mode == UI_NORMAL) 
 800f874:	4b04      	ldr	r3, [pc, #16]	; (800f888 <menu_save_cb+0x28>)
 800f876:	781b      	ldrb	r3, [r3, #0]
 800f878:	2b00      	cmp	r3, #0
 800f87a:	d001      	beq.n	800f880 <menu_save_cb+0x20>
 800f87c:	f7ff fc80 	bl	800f180 <ui_mode_normal.part.2>
    draw_cal_status();
 800f880:	f7fe fbe6 	bl	800e050 <draw_cal_status>
 800f884:	e7ef      	b.n	800f866 <menu_save_cb+0x6>
 800f886:	46c0      	nop			; (mov r8, r8)
 800f888:	200030a5 	.word	0x200030a5
 800f88c:	00000000 	.word	0x00000000

0800f890 <menu_channel_cb>:
{
 800f890:	b510      	push	{r4, lr}
  if (item < 0 || item >= 2)
 800f892:	2801      	cmp	r0, #1
 800f894:	d900      	bls.n	800f898 <menu_channel_cb+0x8>
}
 800f896:	bd10      	pop	{r4, pc}
  set_trace_channel(uistat.current_trace, item);
 800f898:	4b07      	ldr	r3, [pc, #28]	; (800f8b8 <menu_channel_cb+0x28>)
 800f89a:	0001      	movs	r1, r0
 800f89c:	789b      	ldrb	r3, [r3, #2]
 800f89e:	b25b      	sxtb	r3, r3
 800f8a0:	0018      	movs	r0, r3
 800f8a2:	f7fa fe65 	bl	800a570 <set_trace_channel>
  menu_move_back();
 800f8a6:	f7ff ff7b 	bl	800f7a0 <menu_move_back>
  if (ui_mode == UI_NORMAL) 
 800f8aa:	4b04      	ldr	r3, [pc, #16]	; (800f8bc <menu_channel_cb+0x2c>)
 800f8ac:	781b      	ldrb	r3, [r3, #0]
 800f8ae:	2b00      	cmp	r3, #0
 800f8b0:	d0f1      	beq.n	800f896 <menu_channel_cb+0x6>
 800f8b2:	f7ff fc65 	bl	800f180 <ui_mode_normal.part.2>
 800f8b6:	e7ee      	b.n	800f896 <menu_channel_cb+0x6>
 800f8b8:	20001654 	.word	0x20001654
 800f8bc:	200030a5 	.word	0x200030a5

0800f8c0 <menu_invoke>:
{
 800f8c0:	b510      	push	{r4, lr}
  const menuitem_t *menu = menu_stack[menu_current_level];
 800f8c2:	4b11      	ldr	r3, [pc, #68]	; (800f908 <menu_invoke+0x48>)
 800f8c4:	4a11      	ldr	r2, [pc, #68]	; (800f90c <menu_invoke+0x4c>)
 800f8c6:	781b      	ldrb	r3, [r3, #0]
 800f8c8:	009b      	lsls	r3, r3, #2
 800f8ca:	589a      	ldr	r2, [r3, r2]
  menu = &menu[item];
 800f8cc:	0043      	lsls	r3, r0, #1
 800f8ce:	181b      	adds	r3, r3, r0
 800f8d0:	009b      	lsls	r3, r3, #2
 800f8d2:	18d3      	adds	r3, r2, r3
  switch (menu->type) {
 800f8d4:	781a      	ldrb	r2, [r3, #0]
 800f8d6:	2a04      	cmp	r2, #4
 800f8d8:	d806      	bhi.n	800f8e8 <menu_invoke+0x28>
 800f8da:	490d      	ldr	r1, [pc, #52]	; (800f910 <menu_invoke+0x50>)
 800f8dc:	0092      	lsls	r2, r2, #2
 800f8de:	588a      	ldr	r2, [r1, r2]
 800f8e0:	4697      	mov	pc, r2
    menu_push_submenu(menu->pMenu);
 800f8e2:	6898      	ldr	r0, [r3, #8]
 800f8e4:	f7ff f9ec 	bl	800ecc0 <menu_push_submenu>
}
 800f8e8:	bd10      	pop	{r4, pc}
    menuaction_cb_t cb = menu->pFunc;
 800f8ea:	689b      	ldr	r3, [r3, #8]
    if (cb == NULL)
 800f8ec:	2b00      	cmp	r3, #0
 800f8ee:	d0fb      	beq.n	800f8e8 <menu_invoke+0x28>
    (*cb)(item);
 800f8f0:	4798      	blx	r3
    break;
 800f8f2:	e7f9      	b.n	800f8e8 <menu_invoke+0x28>
  if (ui_mode == UI_NORMAL) 
 800f8f4:	4b07      	ldr	r3, [pc, #28]	; (800f914 <menu_invoke+0x54>)
 800f8f6:	781b      	ldrb	r3, [r3, #0]
 800f8f8:	2b00      	cmp	r3, #0
 800f8fa:	d0f5      	beq.n	800f8e8 <menu_invoke+0x28>
 800f8fc:	f7ff fc40 	bl	800f180 <ui_mode_normal.part.2>
 800f900:	e7f2      	b.n	800f8e8 <menu_invoke+0x28>
    menu_move_back();
 800f902:	f7ff ff4d 	bl	800f7a0 <menu_move_back>
    break;
 800f906:	e7ef      	b.n	800f8e8 <menu_invoke+0x28>
 800f908:	200030a2 	.word	0x200030a2
 800f90c:	20001640 	.word	0x20001640
 800f910:	08014b80 	.word	0x08014b80
 800f914:	200030a5 	.word	0x200030a5
	...

0800f920 <menu_trace_cb>:
{
 800f920:	b510      	push	{r4, lr}
  if (item < 0 || item >= TRACE_COUNT )
 800f922:	2803      	cmp	r0, #3
 800f924:	d81e      	bhi.n	800f964 <menu_trace_cb+0x44>
  if (trace[item].enabled) {
 800f926:	4917      	ldr	r1, [pc, #92]	; (800f984 <menu_trace_cb+0x64>)
 800f928:	0043      	lsls	r3, r0, #1
 800f92a:	468c      	mov	ip, r1
 800f92c:	4a16      	ldr	r2, [pc, #88]	; (800f988 <menu_trace_cb+0x68>)
 800f92e:	181b      	adds	r3, r3, r0
 800f930:	009b      	lsls	r3, r3, #2
 800f932:	18d3      	adds	r3, r2, r3
 800f934:	4463      	add	r3, ip
 800f936:	7819      	ldrb	r1, [r3, #0]
 800f938:	2900      	cmp	r1, #0
 800f93a:	d006      	beq.n	800f94a <menu_trace_cb+0x2a>
    if (item == uistat.current_trace) {
 800f93c:	2402      	movs	r4, #2
 800f93e:	4913      	ldr	r1, [pc, #76]	; (800f98c <menu_trace_cb+0x6c>)
 800f940:	570c      	ldrsb	r4, [r1, r4]
 800f942:	42a0      	cmp	r0, r4
 800f944:	d00f      	beq.n	800f966 <menu_trace_cb+0x46>
      uistat.current_trace = item;
 800f946:	7088      	strb	r0, [r1, #2]
 800f948:	e003      	b.n	800f952 <menu_trace_cb+0x32>
    trace[item].enabled = TRUE;
 800f94a:	2201      	movs	r2, #1
 800f94c:	701a      	strb	r2, [r3, #0]
    uistat.current_trace = item;
 800f94e:	4b0f      	ldr	r3, [pc, #60]	; (800f98c <menu_trace_cb+0x6c>)
 800f950:	7098      	strb	r0, [r3, #2]
  request_to_redraw_grid();
 800f952:	f7fe fcf5 	bl	800e340 <request_to_redraw_grid>
  draw_menu_buttons(menu_stack[menu_current_level]);
 800f956:	4b0e      	ldr	r3, [pc, #56]	; (800f990 <menu_trace_cb+0x70>)
 800f958:	4a0e      	ldr	r2, [pc, #56]	; (800f994 <menu_trace_cb+0x74>)
 800f95a:	781b      	ldrb	r3, [r3, #0]
 800f95c:	009b      	lsls	r3, r3, #2
 800f95e:	5898      	ldr	r0, [r3, r2]
 800f960:	f7ff f806 	bl	800e970 <draw_menu_buttons>
}
 800f964:	bd10      	pop	{r4, pc}
      trace[item].enabled = FALSE;
 800f966:	2000      	movs	r0, #0
 800f968:	7018      	strb	r0, [r3, #0]
  for (i = 0; i < TRACE_COUNT ; i++)
 800f96a:	2300      	movs	r3, #0
 800f96c:	4462      	add	r2, ip
    if (trace[i].enabled) {
 800f96e:	7810      	ldrb	r0, [r2, #0]
 800f970:	2800      	cmp	r0, #0
 800f972:	d104      	bne.n	800f97e <menu_trace_cb+0x5e>
  for (i = 0; i < TRACE_COUNT ; i++)
 800f974:	3301      	adds	r3, #1
 800f976:	320c      	adds	r2, #12
 800f978:	2b04      	cmp	r3, #4
 800f97a:	d1f8      	bne.n	800f96e <menu_trace_cb+0x4e>
 800f97c:	e7e9      	b.n	800f952 <menu_trace_cb+0x32>
      uistat.current_trace = i;
 800f97e:	708b      	strb	r3, [r1, #2]
      return;
 800f980:	e7e7      	b.n	800f952 <menu_trace_cb+0x32>
 800f982:	46c0      	nop			; (mov r8, r8)
 800f984:	00001170 	.word	0x00001170
 800f988:	20000454 	.word	0x20000454
 800f98c:	20001654 	.word	0x20001654
 800f990:	200030a2 	.word	0x200030a2
 800f994:	20001640 	.word	0x20001640
	...

0800f9a0 <menu_stimulus_cb>:
{
 800f9a0:	b510      	push	{r4, lr}
 800f9a2:	1e04      	subs	r4, r0, #0
  switch (item) {
 800f9a4:	db0c      	blt.n	800f9c0 <menu_stimulus_cb+0x20>
 800f9a6:	2804      	cmp	r0, #4
 800f9a8:	dd0b      	ble.n	800f9c2 <menu_stimulus_cb+0x22>
 800f9aa:	2805      	cmp	r0, #5
 800f9ac:	d108      	bne.n	800f9c0 <menu_stimulus_cb+0x20>
    toggle_sweep();
 800f9ae:	f7f9 ff3f 	bl	8009830 <toggle_sweep>
  draw_menu_buttons(menu_stack[menu_current_level]);
 800f9b2:	4b0d      	ldr	r3, [pc, #52]	; (800f9e8 <menu_stimulus_cb+0x48>)
 800f9b4:	4a0d      	ldr	r2, [pc, #52]	; (800f9ec <menu_stimulus_cb+0x4c>)
 800f9b6:	781b      	ldrb	r3, [r3, #0]
 800f9b8:	009b      	lsls	r3, r3, #2
 800f9ba:	5898      	ldr	r0, [r3, r2]
 800f9bc:	f7fe ffd8 	bl	800e970 <draw_menu_buttons>
}
 800f9c0:	bd10      	pop	{r4, pc}
    status = btn_wait_release();
 800f9c2:	f7fe fd55 	bl	800e470 <btn_wait_release>
    if (status & EVT_BUTTON_DOWN_LONG) {
 800f9c6:	0743      	lsls	r3, r0, #29
 800f9c8:	d507      	bpl.n	800f9da <menu_stimulus_cb+0x3a>
  if (ui_mode == UI_NUMERIC) 
 800f9ca:	4b09      	ldr	r3, [pc, #36]	; (800f9f0 <menu_stimulus_cb+0x50>)
 800f9cc:	781b      	ldrb	r3, [r3, #0]
 800f9ce:	2b02      	cmp	r3, #2
 800f9d0:	d0f6      	beq.n	800f9c0 <menu_stimulus_cb+0x20>
 800f9d2:	0020      	movs	r0, r4
 800f9d4:	f7ff fdb4 	bl	800f540 <ui_mode_numeric.part.4>
 800f9d8:	e7f2      	b.n	800f9c0 <menu_stimulus_cb+0x20>
      ui_mode_keypad(item);
 800f9da:	0020      	movs	r0, r4
 800f9dc:	f7ff f9d8 	bl	800ed90 <ui_mode_keypad>
      ui_process_keypad();
 800f9e0:	f7ff fcc6 	bl	800f370 <ui_process_keypad>
 800f9e4:	e7ec      	b.n	800f9c0 <menu_stimulus_cb+0x20>
 800f9e6:	46c0      	nop			; (mov r8, r8)
 800f9e8:	200030a2 	.word	0x200030a2
 800f9ec:	20001640 	.word	0x20001640
 800f9f0:	200030a5 	.word	0x200030a5
	...

0800fa00 <touch_start_watchdog>:
{
 800fa00:	b510      	push	{r4, lr}
  touch_prepare_sense();
 800fa02:	f7fe fdb5 	bl	800e570 <touch_prepare_sense>
  adc_start_analog_watchdogd(ADC1, ADC_CHSELR_CHSEL7);
 800fa06:	2180      	movs	r1, #128	; 0x80
 800fa08:	4801      	ldr	r0, [pc, #4]	; (800fa10 <touch_start_watchdog+0x10>)
 800fa0a:	f001 fb41 	bl	8011090 <adc_start_analog_watchdogd>
}
 800fa0e:	bd10      	pop	{r4, pc}
 800fa10:	40012400 	.word	0x40012400
	...

0800fa20 <touch_cal_exec>:
{
 800fa20:	b5f0      	push	{r4, r5, r6, r7, lr}
 800fa22:	46ce      	mov	lr, r9
 800fa24:	4647      	mov	r7, r8
 800fa26:	b580      	push	{r7, lr}
  adc_stop(ADC1);
 800fa28:	4839      	ldr	r0, [pc, #228]	; (800fb10 <touch_cal_exec+0xf0>)
{
 800fa2a:	b083      	sub	sp, #12
  adc_stop(ADC1);
 800fa2c:	f001 fb48 	bl	80110c0 <adc_stop>
  ili9341_fill(0, 0, 320, 240, 0);
 800fa30:	2500      	movs	r5, #0
 800fa32:	22a0      	movs	r2, #160	; 0xa0
  ili9341_line(0, 0, 0, 32, 0xffff);
 800fa34:	4c37      	ldr	r4, [pc, #220]	; (800fb14 <touch_cal_exec+0xf4>)
  ili9341_fill(0, 0, 320, 240, 0);
 800fa36:	23f0      	movs	r3, #240	; 0xf0
 800fa38:	0052      	lsls	r2, r2, #1
 800fa3a:	2100      	movs	r1, #0
 800fa3c:	2000      	movs	r0, #0
 800fa3e:	9500      	str	r5, [sp, #0]
 800fa40:	f000 fdc6 	bl	80105d0 <ili9341_fill>
  ili9341_line(0, 0, 0, 32, 0xffff);
 800fa44:	2320      	movs	r3, #32
 800fa46:	2200      	movs	r2, #0
 800fa48:	2100      	movs	r1, #0
 800fa4a:	2000      	movs	r0, #0
 800fa4c:	9400      	str	r4, [sp, #0]
 800fa4e:	f000 ffcf 	bl	80109f0 <ili9341_line>
  ili9341_line(0, 0, 32, 0, 0xffff);
 800fa52:	2300      	movs	r3, #0
 800fa54:	2220      	movs	r2, #32
 800fa56:	2100      	movs	r1, #0
 800fa58:	2000      	movs	r0, #0
 800fa5a:	9400      	str	r4, [sp, #0]
 800fa5c:	f000 ffc8 	bl	80109f0 <ili9341_line>
ili9341_drawstring_7x13("TOUCH UPPER LEFT", 10, 10, 0xffff, 0x0000);
 800fa60:	9500      	str	r5, [sp, #0]
 800fa62:	0023      	movs	r3, r4
 800fa64:	220a      	movs	r2, #10
 800fa66:	210a      	movs	r1, #10
 800fa68:	482b      	ldr	r0, [pc, #172]	; (800fb18 <touch_cal_exec+0xf8>)
 800fa6a:	f000 fef1 	bl	8010850 <ili9341_drawstring_7x13>
    status = touch_check();
 800fa6e:	f7fe fe0f 	bl	800e690 <touch_check>
  } while(status != EVT_TOUCH_RELEASED);
 800fa72:	2803      	cmp	r0, #3
 800fa74:	d1fb      	bne.n	800fa6e <touch_cal_exec+0x4e>
  x1 = last_touch_x;
 800fa76:	4b29      	ldr	r3, [pc, #164]	; (800fb1c <touch_cal_exec+0xfc>)
  y1 = last_touch_y;
 800fa78:	4d29      	ldr	r5, [pc, #164]	; (800fb20 <touch_cal_exec+0x100>)
  x1 = last_touch_x;
 800fa7a:	4698      	mov	r8, r3
  ili9341_fill(0, 0, 320, 240, 0);
 800fa7c:	22a0      	movs	r2, #160	; 0xa0
  x1 = last_touch_x;
 800fa7e:	2700      	movs	r7, #0
 800fa80:	5fdf      	ldrsh	r7, [r3, r7]
  y1 = last_touch_y;
 800fa82:	2300      	movs	r3, #0
 800fa84:	5eee      	ldrsh	r6, [r5, r3]
  ili9341_fill(0, 0, 320, 240, 0);
 800fa86:	2300      	movs	r3, #0
 800fa88:	0052      	lsls	r2, r2, #1
 800fa8a:	4699      	mov	r9, r3
 800fa8c:	9300      	str	r3, [sp, #0]
 800fa8e:	2100      	movs	r1, #0
 800fa90:	33f0      	adds	r3, #240	; 0xf0
 800fa92:	2000      	movs	r0, #0
 800fa94:	f000 fd9c 	bl	80105d0 <ili9341_fill>
  ili9341_line(320-1, 240-1, 320-1, 240-32, 0xffff);
 800fa98:	2240      	movs	r2, #64	; 0x40
 800fa9a:	4c1e      	ldr	r4, [pc, #120]	; (800fb14 <touch_cal_exec+0xf4>)
 800fa9c:	32ff      	adds	r2, #255	; 0xff
 800fa9e:	0010      	movs	r0, r2
 800faa0:	23d0      	movs	r3, #208	; 0xd0
 800faa2:	21ef      	movs	r1, #239	; 0xef
 800faa4:	9400      	str	r4, [sp, #0]
 800faa6:	f000 ffa3 	bl	80109f0 <ili9341_line>
  ili9341_line(320-1, 240-1, 320-32, 240-1, 0xffff);
 800faaa:	2290      	movs	r2, #144	; 0x90
 800faac:	2040      	movs	r0, #64	; 0x40
 800faae:	23ef      	movs	r3, #239	; 0xef
 800fab0:	0052      	lsls	r2, r2, #1
 800fab2:	21ef      	movs	r1, #239	; 0xef
 800fab4:	30ff      	adds	r0, #255	; 0xff
 800fab6:	9400      	str	r4, [sp, #0]
 800fab8:	f000 ff9a 	bl	80109f0 <ili9341_line>
ili9341_drawstring_7x13("TOUCH LOWER RIGHT", 196, 214, 0xffff, 0x0000);
 800fabc:	464b      	mov	r3, r9
 800fabe:	22d6      	movs	r2, #214	; 0xd6
 800fac0:	9300      	str	r3, [sp, #0]
 800fac2:	21c4      	movs	r1, #196	; 0xc4
 800fac4:	0023      	movs	r3, r4
 800fac6:	4817      	ldr	r0, [pc, #92]	; (800fb24 <touch_cal_exec+0x104>)
 800fac8:	f000 fec2 	bl	8010850 <ili9341_drawstring_7x13>
    status = touch_check();
 800facc:	f7fe fde0 	bl	800e690 <touch_check>
  } while(status != EVT_TOUCH_RELEASED);
 800fad0:	2803      	cmp	r0, #3
 800fad2:	d1fb      	bne.n	800facc <touch_cal_exec+0xac>
  x2 = last_touch_x;
 800fad4:	4643      	mov	r3, r8
  config.touch_cal[0] = x1;
 800fad6:	4c14      	ldr	r4, [pc, #80]	; (800fb28 <touch_cal_exec+0x108>)
  x2 = last_touch_x;
 800fad8:	2000      	movs	r0, #0
 800fada:	5e18      	ldrsh	r0, [r3, r0]
  config.touch_cal[0] = x1;
 800fadc:	8267      	strh	r7, [r4, #18]
  config.touch_cal[1] = y1;
 800fade:	82a6      	strh	r6, [r4, #20]
  config.touch_cal[2] = (x2 - x1) * 16 / 320;
 800fae0:	1bc0      	subs	r0, r0, r7
 800fae2:	2114      	movs	r1, #20
 800fae4:	f7f0 fc04 	bl	80002f0 <__divsi3>
  y2 = last_touch_y;
 800fae8:	2300      	movs	r3, #0
 800faea:	5eed      	ldrsh	r5, [r5, r3]
  config.touch_cal[2] = (x2 - x1) * 16 / 320;
 800faec:	82e0      	strh	r0, [r4, #22]
  config.touch_cal[3] = (y2 - y1) * 16 / 240;
 800faee:	210f      	movs	r1, #15
 800faf0:	1ba8      	subs	r0, r5, r6
 800faf2:	f7f0 fbfd 	bl	80002f0 <__divsi3>
 800faf6:	8320      	strh	r0, [r4, #24]
  touch_prepare_sense();
 800faf8:	f7fe fd3a 	bl	800e570 <touch_prepare_sense>
  adc_start_analog_watchdogd(ADC1, ADC_CHSELR_CHSEL7);
 800fafc:	2180      	movs	r1, #128	; 0x80
 800fafe:	4804      	ldr	r0, [pc, #16]	; (800fb10 <touch_cal_exec+0xf0>)
 800fb00:	f001 fac6 	bl	8011090 <adc_start_analog_watchdogd>
}
 800fb04:	b003      	add	sp, #12
 800fb06:	bc0c      	pop	{r2, r3}
 800fb08:	4690      	mov	r8, r2
 800fb0a:	4699      	mov	r9, r3
 800fb0c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800fb0e:	46c0      	nop			; (mov r8, r8)
 800fb10:	40012400 	.word	0x40012400
 800fb14:	0000ffff 	.word	0x0000ffff
 800fb18:	08015694 	.word	0x08015694
 800fb1c:	2000309e 	.word	0x2000309e
 800fb20:	200030a0 	.word	0x200030a0
 800fb24:	080156a8 	.word	0x080156a8
 800fb28:	2000042c 	.word	0x2000042c
 800fb2c:	00000000 	.word	0x00000000

0800fb30 <touch_draw_test>:
{
 800fb30:	b5f0      	push	{r4, r5, r6, r7, lr}
 800fb32:	46de      	mov	lr, fp
 800fb34:	4657      	mov	r7, sl
 800fb36:	464e      	mov	r6, r9
 800fb38:	4645      	mov	r5, r8
 800fb3a:	b5e0      	push	{r5, r6, r7, lr}
  adc_stop(ADC1);
 800fb3c:	4835      	ldr	r0, [pc, #212]	; (800fc14 <touch_draw_test+0xe4>)
{
 800fb3e:	b083      	sub	sp, #12
  adc_stop(ADC1);
 800fb40:	f001 fabe 	bl	80110c0 <adc_stop>
  ili9341_fill(0, 0, 320, 240, 0);
 800fb44:	2400      	movs	r4, #0
 800fb46:	22a0      	movs	r2, #160	; 0xa0
 800fb48:	23f0      	movs	r3, #240	; 0xf0
 800fb4a:	0052      	lsls	r2, r2, #1
 800fb4c:	2100      	movs	r1, #0
 800fb4e:	2000      	movs	r0, #0
 800fb50:	9400      	str	r4, [sp, #0]
 800fb52:	f000 fd3d 	bl	80105d0 <ili9341_fill>
ili9341_drawstring_7x13("TOUCH TEST: DRAG PANEL", OFFSETX, 227, 0xffff, 0x0000);
 800fb56:	9400      	str	r4, [sp, #0]
 800fb58:	4b2f      	ldr	r3, [pc, #188]	; (800fc18 <touch_draw_test+0xe8>)
 800fb5a:	22e3      	movs	r2, #227	; 0xe3
 800fb5c:	2112      	movs	r1, #18
 800fb5e:	482f      	ldr	r0, [pc, #188]	; (800fc1c <touch_draw_test+0xec>)
 800fb60:	f000 fe76 	bl	8010850 <ili9341_drawstring_7x13>
    status = touch_check();
 800fb64:	f7fe fd94 	bl	800e690 <touch_check>
  } while(status != EVT_TOUCH_PRESSED);
 800fb68:	2802      	cmp	r0, #2
 800fb6a:	d1fb      	bne.n	800fb64 <touch_draw_test+0x34>
  *x = (last_touch_x - config.touch_cal[0]) * 16 / config.touch_cal[2];
 800fb6c:	4c2c      	ldr	r4, [pc, #176]	; (800fc20 <touch_draw_test+0xf0>)
 800fb6e:	4b2d      	ldr	r3, [pc, #180]	; (800fc24 <touch_draw_test+0xf4>)
 800fb70:	469b      	mov	fp, r3
 800fb72:	2000      	movs	r0, #0
 800fb74:	5e18      	ldrsh	r0, [r3, r0]
 800fb76:	2212      	movs	r2, #18
 800fb78:	5ea3      	ldrsh	r3, [r4, r2]
 800fb7a:	1ac0      	subs	r0, r0, r3
 800fb7c:	0100      	lsls	r0, r0, #4
 800fb7e:	2316      	movs	r3, #22
 800fb80:	5ee1      	ldrsh	r1, [r4, r3]
 800fb82:	f7f0 fbb5 	bl	80002f0 <__divsi3>
  *y = (last_touch_y - config.touch_cal[1]) * 16 / config.touch_cal[3];
 800fb86:	4b28      	ldr	r3, [pc, #160]	; (800fc28 <touch_draw_test+0xf8>)
  *x = (last_touch_x - config.touch_cal[0]) * 16 / config.touch_cal[2];
 800fb88:	4680      	mov	r8, r0
  *y = (last_touch_y - config.touch_cal[1]) * 16 / config.touch_cal[3];
 800fb8a:	469a      	mov	sl, r3
 800fb8c:	2000      	movs	r0, #0
 800fb8e:	5e18      	ldrsh	r0, [r3, r0]
 800fb90:	2214      	movs	r2, #20
 800fb92:	5ea3      	ldrsh	r3, [r4, r2]
 800fb94:	1ac0      	subs	r0, r0, r3
 800fb96:	0100      	lsls	r0, r0, #4
 800fb98:	2318      	movs	r3, #24
 800fb9a:	5ee1      	ldrsh	r1, [r4, r3]
 800fb9c:	f7f0 fba8 	bl	80002f0 <__divsi3>
 800fba0:	0007      	movs	r7, r0
    status = touch_check();
 800fba2:	f7fe fd75 	bl	800e690 <touch_check>
  *x = (last_touch_x - config.touch_cal[0]) * 16 / config.touch_cal[2];
 800fba6:	465b      	mov	r3, fp
    status = touch_check();
 800fba8:	4681      	mov	r9, r0
  *x = (last_touch_x - config.touch_cal[0]) * 16 / config.touch_cal[2];
 800fbaa:	2000      	movs	r0, #0
 800fbac:	5e18      	ldrsh	r0, [r3, r0]
 800fbae:	2212      	movs	r2, #18
 800fbb0:	5ea3      	ldrsh	r3, [r4, r2]
 800fbb2:	1ac0      	subs	r0, r0, r3
 800fbb4:	0100      	lsls	r0, r0, #4
 800fbb6:	2316      	movs	r3, #22
 800fbb8:	5ee1      	ldrsh	r1, [r4, r3]
 800fbba:	f7f0 fb99 	bl	80002f0 <__divsi3>
  *y = (last_touch_y - config.touch_cal[1]) * 16 / config.touch_cal[3];
 800fbbe:	4653      	mov	r3, sl
  *x = (last_touch_x - config.touch_cal[0]) * 16 / config.touch_cal[2];
 800fbc0:	0006      	movs	r6, r0
  *y = (last_touch_y - config.touch_cal[1]) * 16 / config.touch_cal[3];
 800fbc2:	2000      	movs	r0, #0
 800fbc4:	5e18      	ldrsh	r0, [r3, r0]
 800fbc6:	2214      	movs	r2, #20
 800fbc8:	5ea3      	ldrsh	r3, [r4, r2]
 800fbca:	1ac0      	subs	r0, r0, r3
 800fbcc:	0100      	lsls	r0, r0, #4
 800fbce:	2318      	movs	r3, #24
 800fbd0:	5ee1      	ldrsh	r1, [r4, r3]
 800fbd2:	f7f0 fb8d 	bl	80002f0 <__divsi3>
    ili9341_line(x0, y0, x1, y1, 0xffff);
 800fbd6:	4b10      	ldr	r3, [pc, #64]	; (800fc18 <touch_draw_test+0xe8>)
 800fbd8:	0039      	movs	r1, r7
  *y = (last_touch_y - config.touch_cal[1]) * 16 / config.touch_cal[3];
 800fbda:	0005      	movs	r5, r0
    ili9341_line(x0, y0, x1, y1, 0xffff);
 800fbdc:	9300      	str	r3, [sp, #0]
 800fbde:	0032      	movs	r2, r6
 800fbe0:	0003      	movs	r3, r0
 800fbe2:	4640      	mov	r0, r8
 800fbe4:	f000 ff04 	bl	80109f0 <ili9341_line>
    chThdSleepMilliseconds(50);
 800fbe8:	20fa      	movs	r0, #250	; 0xfa
 800fbea:	0040      	lsls	r0, r0, #1
 800fbec:	f7f4 f990 	bl	8003f10 <chThdSleep>
  } while(status != EVT_TOUCH_RELEASED);
 800fbf0:	464b      	mov	r3, r9
    x0 = x1;
 800fbf2:	46b0      	mov	r8, r6
    y0 = y1;
 800fbf4:	002f      	movs	r7, r5
  } while(status != EVT_TOUCH_RELEASED);
 800fbf6:	2b03      	cmp	r3, #3
 800fbf8:	d1d3      	bne.n	800fba2 <touch_draw_test+0x72>
  touch_prepare_sense();
 800fbfa:	f7fe fcb9 	bl	800e570 <touch_prepare_sense>
  adc_start_analog_watchdogd(ADC1, ADC_CHSELR_CHSEL7);
 800fbfe:	2180      	movs	r1, #128	; 0x80
 800fc00:	4804      	ldr	r0, [pc, #16]	; (800fc14 <touch_draw_test+0xe4>)
 800fc02:	f001 fa45 	bl	8011090 <adc_start_analog_watchdogd>
}
 800fc06:	b003      	add	sp, #12
 800fc08:	bc3c      	pop	{r2, r3, r4, r5}
 800fc0a:	4690      	mov	r8, r2
 800fc0c:	4699      	mov	r9, r3
 800fc0e:	46a2      	mov	sl, r4
 800fc10:	46ab      	mov	fp, r5
 800fc12:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800fc14:	40012400 	.word	0x40012400
 800fc18:	0000ffff 	.word	0x0000ffff
 800fc1c:	080156bc 	.word	0x080156bc
 800fc20:	2000042c 	.word	0x2000042c
 800fc24:	2000309e 	.word	0x2000309e
 800fc28:	200030a0 	.word	0x200030a0
 800fc2c:	00000000 	.word	0x00000000

0800fc30 <touch_position>:
{
 800fc30:	b570      	push	{r4, r5, r6, lr}
  *x = (last_touch_x - config.touch_cal[0]) * 16 / config.touch_cal[2];
 800fc32:	4b0e      	ldr	r3, [pc, #56]	; (800fc6c <touch_position+0x3c>)
 800fc34:	4c0e      	ldr	r4, [pc, #56]	; (800fc70 <touch_position+0x40>)
{
 800fc36:	0006      	movs	r6, r0
  *x = (last_touch_x - config.touch_cal[0]) * 16 / config.touch_cal[2];
 800fc38:	2000      	movs	r0, #0
 800fc3a:	5e18      	ldrsh	r0, [r3, r0]
 800fc3c:	2212      	movs	r2, #18
 800fc3e:	5ea3      	ldrsh	r3, [r4, r2]
{
 800fc40:	000d      	movs	r5, r1
  *x = (last_touch_x - config.touch_cal[0]) * 16 / config.touch_cal[2];
 800fc42:	1ac0      	subs	r0, r0, r3
 800fc44:	0100      	lsls	r0, r0, #4
 800fc46:	2316      	movs	r3, #22
 800fc48:	5ee1      	ldrsh	r1, [r4, r3]
 800fc4a:	f7f0 fb51 	bl	80002f0 <__divsi3>
  *y = (last_touch_y - config.touch_cal[1]) * 16 / config.touch_cal[3];
 800fc4e:	4b09      	ldr	r3, [pc, #36]	; (800fc74 <touch_position+0x44>)
  *x = (last_touch_x - config.touch_cal[0]) * 16 / config.touch_cal[2];
 800fc50:	6030      	str	r0, [r6, #0]
  *y = (last_touch_y - config.touch_cal[1]) * 16 / config.touch_cal[3];
 800fc52:	2000      	movs	r0, #0
 800fc54:	5e18      	ldrsh	r0, [r3, r0]
 800fc56:	2214      	movs	r2, #20
 800fc58:	5ea3      	ldrsh	r3, [r4, r2]
 800fc5a:	1ac0      	subs	r0, r0, r3
 800fc5c:	0100      	lsls	r0, r0, #4
 800fc5e:	2318      	movs	r3, #24
 800fc60:	5ee1      	ldrsh	r1, [r4, r3]
 800fc62:	f7f0 fb45 	bl	80002f0 <__divsi3>
 800fc66:	6028      	str	r0, [r5, #0]
}
 800fc68:	bd70      	pop	{r4, r5, r6, pc}
 800fc6a:	46c0      	nop			; (mov r8, r8)
 800fc6c:	2000309e 	.word	0x2000309e
 800fc70:	2000042c 	.word	0x2000042c
 800fc74:	200030a0 	.word	0x200030a0
	...

0800fc80 <show_logo>:
{
 800fc80:	b530      	push	{r4, r5, lr}
  ili9341_fill(0, 0, 320, 240, 0);
 800fc82:	22a0      	movs	r2, #160	; 0xa0
 800fc84:	2400      	movs	r4, #0
  ili9341_drawstring_size("Nano", x, y, 0xffff, 0x0000, 3);
 800fc86:	2503      	movs	r5, #3
{
 800fc88:	b083      	sub	sp, #12
  ili9341_fill(0, 0, 320, 240, 0);
 800fc8a:	9400      	str	r4, [sp, #0]
 800fc8c:	23f0      	movs	r3, #240	; 0xf0
 800fc8e:	0052      	lsls	r2, r2, #1
 800fc90:	2100      	movs	r1, #0
 800fc92:	2000      	movs	r0, #0
 800fc94:	f000 fc9c 	bl	80105d0 <ili9341_fill>
  ili9341_drawstring_size("Nano", x, y, 0xffff, 0x0000, 3);
 800fc98:	9501      	str	r5, [sp, #4]
 800fc9a:	9400      	str	r4, [sp, #0]
 800fc9c:	4b30      	ldr	r3, [pc, #192]	; (800fd60 <show_logo+0xe0>)
 800fc9e:	2232      	movs	r2, #50	; 0x32
 800fca0:	2119      	movs	r1, #25
 800fca2:	4830      	ldr	r0, [pc, #192]	; (800fd64 <show_logo+0xe4>)
 800fca4:	f000 fe6c 	bl	8010980 <ili9341_drawstring_size>
  ili9341_drawstring_size("V", 105, y, 0xf00f, 0x0000, 3);
 800fca8:	9501      	str	r5, [sp, #4]
 800fcaa:	9400      	str	r4, [sp, #0]
 800fcac:	4b2e      	ldr	r3, [pc, #184]	; (800fd68 <show_logo+0xe8>)
 800fcae:	2232      	movs	r2, #50	; 0x32
 800fcb0:	2169      	movs	r1, #105	; 0x69
 800fcb2:	482e      	ldr	r0, [pc, #184]	; (800fd6c <show_logo+0xec>)
 800fcb4:	f000 fe64 	bl	8010980 <ili9341_drawstring_size>
  ili9341_drawstring_size("N", 125, y, 0xf0ff, 0x0000, 3);
 800fcb8:	9501      	str	r5, [sp, #4]
 800fcba:	9400      	str	r4, [sp, #0]
 800fcbc:	4b2c      	ldr	r3, [pc, #176]	; (800fd70 <show_logo+0xf0>)
 800fcbe:	2232      	movs	r2, #50	; 0x32
 800fcc0:	217d      	movs	r1, #125	; 0x7d
 800fcc2:	482c      	ldr	r0, [pc, #176]	; (800fd74 <show_logo+0xf4>)
 800fcc4:	f000 fe5c 	bl	8010980 <ili9341_drawstring_size>
  ili9341_drawstring_size("A", 145, y, 0xff00, 0x0000, 3);
 800fcc8:	23ff      	movs	r3, #255	; 0xff
 800fcca:	9501      	str	r5, [sp, #4]
 800fccc:	9400      	str	r4, [sp, #0]
 800fcce:	021b      	lsls	r3, r3, #8
 800fcd0:	2232      	movs	r2, #50	; 0x32
 800fcd2:	2191      	movs	r1, #145	; 0x91
 800fcd4:	4828      	ldr	r0, [pc, #160]	; (800fd78 <show_logo+0xf8>)
 800fcd6:	f000 fe53 	bl	8010980 <ili9341_drawstring_size>
  ili9341_drawstring_size(".com.br", 165, y, 0xffff, 0x0000, 3);
 800fcda:	9501      	str	r5, [sp, #4]
 800fcdc:	9400      	str	r4, [sp, #0]
 800fcde:	4b20      	ldr	r3, [pc, #128]	; (800fd60 <show_logo+0xe0>)
 800fce0:	2232      	movs	r2, #50	; 0x32
 800fce2:	21a5      	movs	r1, #165	; 0xa5
 800fce4:	4825      	ldr	r0, [pc, #148]	; (800fd7c <show_logo+0xfc>)
 800fce6:	f000 fe4b 	bl	8010980 <ili9341_drawstring_size>
  ili9341_drawstring_7x13("Versao: ", stx, y, 0xf00f, 0x0000);
 800fcea:	9400      	str	r4, [sp, #0]
 800fcec:	4b1e      	ldr	r3, [pc, #120]	; (800fd68 <show_logo+0xe8>)
 800fcee:	2269      	movs	r2, #105	; 0x69
 800fcf0:	2161      	movs	r1, #97	; 0x61
 800fcf2:	4823      	ldr	r0, [pc, #140]	; (800fd80 <show_logo+0x100>)
 800fcf4:	f000 fdac 	bl	8010850 <ili9341_drawstring_7x13>
  ili9341_drawstring_7x13(VERSION "-BR", stx + 54, y, 0xffff, 0x0000);
 800fcf8:	9400      	str	r4, [sp, #0]
 800fcfa:	4b19      	ldr	r3, [pc, #100]	; (800fd60 <show_logo+0xe0>)
 800fcfc:	2269      	movs	r2, #105	; 0x69
 800fcfe:	2197      	movs	r1, #151	; 0x97
 800fd00:	4820      	ldr	r0, [pc, #128]	; (800fd84 <show_logo+0x104>)
 800fd02:	f000 fda5 	bl	8010850 <ili9341_drawstring_7x13>
  ili9341_drawstring_7x13("Compilado em: ", stx, y, 0xf0ff, 0x0000);
 800fd06:	9400      	str	r4, [sp, #0]
 800fd08:	4b19      	ldr	r3, [pc, #100]	; (800fd70 <show_logo+0xf0>)
 800fd0a:	228c      	movs	r2, #140	; 0x8c
 800fd0c:	2122      	movs	r1, #34	; 0x22
 800fd0e:	481e      	ldr	r0, [pc, #120]	; (800fd88 <show_logo+0x108>)
 800fd10:	f000 fd9e 	bl	8010850 <ili9341_drawstring_7x13>
  ili9341_drawstring_7x13(__DATE__ " - " __TIME__, stx + 98, y, 0xffff, 0x0000);
 800fd14:	9400      	str	r4, [sp, #0]
 800fd16:	4b12      	ldr	r3, [pc, #72]	; (800fd60 <show_logo+0xe0>)
 800fd18:	228c      	movs	r2, #140	; 0x8c
 800fd1a:	2184      	movs	r1, #132	; 0x84
 800fd1c:	481b      	ldr	r0, [pc, #108]	; (800fd8c <show_logo+0x10c>)
 800fd1e:	f000 fd97 	bl	8010850 <ili9341_drawstring_7x13>
  ili9341_drawstring_7x13("2016-2020", stx, y, 0xff00, 0x0000);
 800fd22:	23ff      	movs	r3, #255	; 0xff
 800fd24:	9400      	str	r4, [sp, #0]
 800fd26:	021b      	lsls	r3, r3, #8
 800fd28:	22af      	movs	r2, #175	; 0xaf
 800fd2a:	2142      	movs	r1, #66	; 0x42
 800fd2c:	4818      	ldr	r0, [pc, #96]	; (800fd90 <show_logo+0x110>)
 800fd2e:	f000 fd8f 	bl	8010850 <ili9341_drawstring_7x13>
  ili9341_drawstring_7x13("Copyright @edy555", stx + 70, y, 0xffff, 0x0000);
 800fd32:	9400      	str	r4, [sp, #0]
 800fd34:	4b0a      	ldr	r3, [pc, #40]	; (800fd60 <show_logo+0xe0>)
 800fd36:	22af      	movs	r2, #175	; 0xaf
 800fd38:	2188      	movs	r1, #136	; 0x88
 800fd3a:	4816      	ldr	r0, [pc, #88]	; (800fd94 <show_logo+0x114>)
 800fd3c:	f000 fd88 	bl	8010850 <ili9341_drawstring_7x13>
  __ASM volatile ("cpsid i" : : : "memory");
 800fd40:	b672      	cpsid	i
 800fd42:	2280      	movs	r2, #128	; 0x80
 800fd44:	05d2      	lsls	r2, r2, #23
 800fd46:	6a51      	ldr	r1, [r2, #36]	; 0x24
  __ASM volatile ("cpsie i" : : : "memory");
 800fd48:	b662      	cpsie	i
  uint32_t ticks = chVTGetSystemTime() + 15000; // 1s = 5000
 800fd4a:	4b13      	ldr	r3, [pc, #76]	; (800fd98 <show_logo+0x118>)
 800fd4c:	469c      	mov	ip, r3
 800fd4e:	4461      	add	r1, ip
  __ASM volatile ("cpsid i" : : : "memory");
 800fd50:	b672      	cpsid	i
 800fd52:	6a53      	ldr	r3, [r2, #36]	; 0x24
  __ASM volatile ("cpsie i" : : : "memory");
 800fd54:	b662      	cpsie	i
  while (ticks > chVTGetSystemTime());
 800fd56:	4299      	cmp	r1, r3
 800fd58:	d8fa      	bhi.n	800fd50 <show_logo+0xd0>
}
 800fd5a:	b003      	add	sp, #12
 800fd5c:	bd30      	pop	{r4, r5, pc}
 800fd5e:	46c0      	nop			; (mov r8, r8)
 800fd60:	0000ffff 	.word	0x0000ffff
 800fd64:	080153d8 	.word	0x080153d8
 800fd68:	0000f00f 	.word	0x0000f00f
 800fd6c:	080155e0 	.word	0x080155e0
 800fd70:	0000f0ff 	.word	0x0000f0ff
 800fd74:	0801554c 	.word	0x0801554c
 800fd78:	080153e0 	.word	0x080153e0
 800fd7c:	080153e4 	.word	0x080153e4
 800fd80:	080153ec 	.word	0x080153ec
 800fd84:	080153f8 	.word	0x080153f8
 800fd88:	08015404 	.word	0x08015404
 800fd8c:	08015414 	.word	0x08015414
 800fd90:	0801542c 	.word	0x0801542c
 800fd94:	08015438 	.word	0x08015438
 800fd98:	00003a98 	.word	0x00003a98
 800fd9c:	00000000 	.word	0x00000000

0800fda0 <show_version>:
{
 800fda0:	b510      	push	{r4, lr}
  adc_stop(ADC1);
 800fda2:	480b      	ldr	r0, [pc, #44]	; (800fdd0 <show_version+0x30>)
 800fda4:	f001 f98c 	bl	80110c0 <adc_stop>
    if (btn_check() & EVT_BUTTON_SINGLE_CLICK)
 800fda8:	2401      	movs	r4, #1
  show_logo();
 800fdaa:	f7ff ff69 	bl	800fc80 <show_logo>
 800fdae:	e003      	b.n	800fdb8 <show_version+0x18>
    if (btn_check() & EVT_BUTTON_SINGLE_CLICK)
 800fdb0:	f7fe fb06 	bl	800e3c0 <btn_check>
 800fdb4:	4204      	tst	r4, r0
 800fdb6:	d103      	bne.n	800fdc0 <show_version+0x20>
    if (touch_check() == EVT_TOUCH_PRESSED)
 800fdb8:	f7fe fc6a 	bl	800e690 <touch_check>
 800fdbc:	2802      	cmp	r0, #2
 800fdbe:	d1f7      	bne.n	800fdb0 <show_version+0x10>
  touch_prepare_sense();
 800fdc0:	f7fe fbd6 	bl	800e570 <touch_prepare_sense>
  adc_start_analog_watchdogd(ADC1, ADC_CHSELR_CHSEL7);
 800fdc4:	2180      	movs	r1, #128	; 0x80
 800fdc6:	4802      	ldr	r0, [pc, #8]	; (800fdd0 <show_version+0x30>)
 800fdc8:	f001 f962 	bl	8011090 <adc_start_analog_watchdogd>
}
 800fdcc:	bd10      	pop	{r4, pc}
 800fdce:	46c0      	nop			; (mov r8, r8)
 800fdd0:	40012400 	.word	0x40012400
	...

0800fde0 <menu_config_cb>:
{
 800fde0:	b510      	push	{r4, lr}
  switch (item) {
 800fde2:	2801      	cmp	r0, #1
 800fde4:	d017      	beq.n	800fe16 <menu_config_cb+0x36>
 800fde6:	dd11      	ble.n	800fe0c <menu_config_cb+0x2c>
 800fde8:	2802      	cmp	r0, #2
 800fdea:	d017      	beq.n	800fe1c <menu_config_cb+0x3c>
 800fdec:	2803      	cmp	r0, #3
 800fdee:	d10c      	bne.n	800fe0a <menu_config_cb+0x2a>
      show_version();
 800fdf0:	f7ff ffd6 	bl	800fda0 <show_version>
      redraw_frame();
 800fdf4:	f7fe fabc 	bl	800e370 <redraw_frame>
      request_to_redraw_grid();
 800fdf8:	f7fe faa2 	bl	800e340 <request_to_redraw_grid>
  draw_menu_buttons(menu_stack[menu_current_level]);
 800fdfc:	4b0d      	ldr	r3, [pc, #52]	; (800fe34 <menu_config_cb+0x54>)
 800fdfe:	4a0e      	ldr	r2, [pc, #56]	; (800fe38 <menu_config_cb+0x58>)
 800fe00:	781b      	ldrb	r3, [r3, #0]
 800fe02:	009b      	lsls	r3, r3, #2
 800fe04:	5898      	ldr	r0, [r3, r2]
 800fe06:	f7fe fdb3 	bl	800e970 <draw_menu_buttons>
}
 800fe0a:	bd10      	pop	{r4, pc}
  switch (item) {
 800fe0c:	2800      	cmp	r0, #0
 800fe0e:	d1fc      	bne.n	800fe0a <menu_config_cb+0x2a>
      touch_cal_exec();
 800fe10:	f7ff fe06 	bl	800fa20 <touch_cal_exec>
      redraw_frame();
 800fe14:	e7ee      	b.n	800fdf4 <menu_config_cb+0x14>
      touch_draw_test();
 800fe16:	f7ff fe8b 	bl	800fb30 <touch_draw_test>
      redraw_frame();
 800fe1a:	e7eb      	b.n	800fdf4 <menu_config_cb+0x14>
      config_save();
 800fe1c:	f000 fee0 	bl	8010be0 <config_save>
      menu_move_back();
 800fe20:	f7ff fcbe 	bl	800f7a0 <menu_move_back>
  if (ui_mode == UI_NORMAL) 
 800fe24:	4b05      	ldr	r3, [pc, #20]	; (800fe3c <menu_config_cb+0x5c>)
 800fe26:	781b      	ldrb	r3, [r3, #0]
 800fe28:	2b00      	cmp	r3, #0
 800fe2a:	d0ee      	beq.n	800fe0a <menu_config_cb+0x2a>
 800fe2c:	f7ff f9a8 	bl	800f180 <ui_mode_normal.part.2>
 800fe30:	e7eb      	b.n	800fe0a <menu_config_cb+0x2a>
 800fe32:	46c0      	nop			; (mov r8, r8)
 800fe34:	200030a2 	.word	0x200030a2
 800fe38:	20001640 	.word	0x20001640
 800fe3c:	200030a5 	.word	0x200030a5

0800fe40 <enter_dfu>:
{
 800fe40:	b510      	push	{r4, lr}
  adc_stop(ADC1);
 800fe42:	4813      	ldr	r0, [pc, #76]	; (800fe90 <enter_dfu+0x50>)
{
 800fe44:	b082      	sub	sp, #8
  adc_stop(ADC1);
 800fe46:	f001 f93b 	bl	80110c0 <adc_stop>
  ili9341_fill(0, 0, 320, 240, 0);
 800fe4a:	2400      	movs	r4, #0
 800fe4c:	22a0      	movs	r2, #160	; 0xa0
 800fe4e:	9400      	str	r4, [sp, #0]
 800fe50:	23f0      	movs	r3, #240	; 0xf0
 800fe52:	0052      	lsls	r2, r2, #1
 800fe54:	2100      	movs	r1, #0
 800fe56:	2000      	movs	r0, #0
 800fe58:	f000 fbba 	bl	80105d0 <ili9341_fill>
  ili9341_drawstring_7x13("DFU: Device Firmware Update Mode", x, y += 15, 0xffff, 0x0000);
 800fe5c:	9400      	str	r4, [sp, #0]
 800fe5e:	4b0d      	ldr	r3, [pc, #52]	; (800fe94 <enter_dfu+0x54>)
 800fe60:	2214      	movs	r2, #20
 800fe62:	2105      	movs	r1, #5
 800fe64:	480c      	ldr	r0, [pc, #48]	; (800fe98 <enter_dfu+0x58>)
 800fe66:	f000 fcf3 	bl	8010850 <ili9341_drawstring_7x13>
   ili9341_drawstring_7x13("To exit DFU mode, please reset device yourself.", x, y += 15, 0xffff, 0x0000);
 800fe6a:	9400      	str	r4, [sp, #0]
 800fe6c:	4b09      	ldr	r3, [pc, #36]	; (800fe94 <enter_dfu+0x54>)
 800fe6e:	2223      	movs	r2, #35	; 0x23
 800fe70:	2105      	movs	r1, #5
 800fe72:	480a      	ldr	r0, [pc, #40]	; (800fe9c <enter_dfu+0x5c>)
 800fe74:	f000 fcec 	bl	8010850 <ili9341_drawstring_7x13>
     *((unsigned long *)BOOT_FROM_SYTEM_MEMORY_MAGIC_ADDRESS) = BOOT_FROM_SYTEM_MEMORY_MAGIC;
 800fe78:	4b09      	ldr	r3, [pc, #36]	; (800fea0 <enter_dfu+0x60>)
 800fe7a:	4a0a      	ldr	r2, [pc, #40]	; (800fea4 <enter_dfu+0x64>)
 800fe7c:	601a      	str	r2, [r3, #0]
    This function acts as a special kind of Data Memory Barrier.
    It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 800fe7e:	f3bf 8f4f 	dsb	sy
 */
__STATIC_INLINE void NVIC_SystemReset(void)
{
  __DSB();                                                     /* Ensure all outstanding memory accesses included
                                                                  buffered write are completed before reset */
  SCB->AIRCR  = ((0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 800fe82:	4b09      	ldr	r3, [pc, #36]	; (800fea8 <enter_dfu+0x68>)
 800fe84:	4a09      	ldr	r2, [pc, #36]	; (800feac <enter_dfu+0x6c>)
 800fe86:	60da      	str	r2, [r3, #12]
 800fe88:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("nop");
 800fe8c:	46c0      	nop			; (mov r8, r8)
 800fe8e:	e7fd      	b.n	800fe8c <enter_dfu+0x4c>
 800fe90:	40012400 	.word	0x40012400
 800fe94:	0000ffff 	.word	0x0000ffff
 800fe98:	08014b98 	.word	0x08014b98
 800fe9c:	08014bbc 	.word	0x08014bbc
 800fea0:	20003ff0 	.word	0x20003ff0
 800fea4:	deadbeef 	.word	0xdeadbeef
 800fea8:	e000ed00 	.word	0xe000ed00
 800feac:	05fa0004 	.word	0x05fa0004

0800feb0 <menu_dfu_cb>:
{
 800feb0:	b510      	push	{r4, lr}
  switch (item) {
 800feb2:	2800      	cmp	r0, #0
 800feb4:	d000      	beq.n	800feb8 <menu_dfu_cb+0x8>
}
 800feb6:	bd10      	pop	{r4, pc}
      enter_dfu();
 800feb8:	f7ff ffc2 	bl	800fe40 <enter_dfu>
 800febc:	0000      	movs	r0, r0
	...

0800fec0 <ui_process>:
{
 800fec0:	b5f0      	push	{r4, r5, r6, r7, lr}
 800fec2:	4645      	mov	r5, r8
 800fec4:	46de      	mov	lr, fp
 800fec6:	4657      	mov	r7, sl
 800fec8:	464e      	mov	r6, r9
 800feca:	b5e0      	push	{r5, r6, r7, lr}
  switch (operation_requested) {
 800fecc:	4cc7      	ldr	r4, [pc, #796]	; (80101ec <ui_process+0x32c>)
{
 800fece:	b085      	sub	sp, #20
  switch (operation_requested) {
 800fed0:	7825      	ldrb	r5, [r4, #0]
 800fed2:	2d01      	cmp	r5, #1
 800fed4:	d01c      	beq.n	800ff10 <ui_process+0x50>
 800fed6:	2d02      	cmp	r5, #2
 800fed8:	d111      	bne.n	800fefe <ui_process+0x3e>
  awd_count++;
 800feda:	4ac5      	ldr	r2, [pc, #788]	; (80101f0 <ui_process+0x330>)
  adc_stop(ADC1);
 800fedc:	48c5      	ldr	r0, [pc, #788]	; (80101f4 <ui_process+0x334>)
  awd_count++;
 800fede:	6813      	ldr	r3, [r2, #0]
 800fee0:	3301      	adds	r3, #1
 800fee2:	6013      	str	r3, [r2, #0]
  adc_stop(ADC1);
 800fee4:	f001 f8ec 	bl	80110c0 <adc_stop>
  int status = touch_check();
 800fee8:	f7fe fbd2 	bl	800e690 <touch_check>
  if (status == EVT_TOUCH_PRESSED || status == EVT_TOUCH_DOWN) {
 800feec:	3801      	subs	r0, #1
 800feee:	2801      	cmp	r0, #1
 800fef0:	d91a      	bls.n	800ff28 <ui_process+0x68>
  touch_prepare_sense();
 800fef2:	f7fe fb3d 	bl	800e570 <touch_prepare_sense>
  adc_start_analog_watchdogd(ADC1, ADC_CHSELR_CHSEL7);
 800fef6:	2180      	movs	r1, #128	; 0x80
 800fef8:	48be      	ldr	r0, [pc, #760]	; (80101f4 <ui_process+0x334>)
 800fefa:	f001 f8c9 	bl	8011090 <adc_start_analog_watchdogd>
  operation_requested = OP_NONE;
 800fefe:	2300      	movs	r3, #0
 800ff00:	7023      	strb	r3, [r4, #0]
}
 800ff02:	b005      	add	sp, #20
 800ff04:	bc3c      	pop	{r2, r3, r4, r5}
 800ff06:	4690      	mov	r8, r2
 800ff08:	4699      	mov	r9, r3
 800ff0a:	46a2      	mov	sl, r4
 800ff0c:	46ab      	mov	fp, r5
 800ff0e:	bdf0      	pop	{r4, r5, r6, r7, pc}
  switch (ui_mode) {
 800ff10:	4fb9      	ldr	r7, [pc, #740]	; (80101f8 <ui_process+0x338>)
 800ff12:	783e      	ldrb	r6, [r7, #0]
 800ff14:	2e01      	cmp	r6, #1
 800ff16:	d100      	bne.n	800ff1a <ui_process+0x5a>
 800ff18:	e08f      	b.n	801003a <ui_process+0x17a>
 800ff1a:	2e00      	cmp	r6, #0
 800ff1c:	d047      	beq.n	800ffae <ui_process+0xee>
 800ff1e:	2e03      	cmp	r6, #3
 800ff20:	d1ed      	bne.n	800fefe <ui_process+0x3e>
    ui_process_keypad();
 800ff22:	f7ff fa25 	bl	800f370 <ui_process_keypad>
    break;    
 800ff26:	e7ea      	b.n	800fefe <ui_process+0x3e>
    switch (ui_mode) {
 800ff28:	4fb3      	ldr	r7, [pc, #716]	; (80101f8 <ui_process+0x338>)
 800ff2a:	783b      	ldrb	r3, [r7, #0]
 800ff2c:	2b01      	cmp	r3, #1
 800ff2e:	d100      	bne.n	800ff32 <ui_process+0x72>
 800ff30:	e0ba      	b.n	80100a8 <ui_process+0x1e8>
 800ff32:	2b00      	cmp	r3, #0
 800ff34:	d100      	bne.n	800ff38 <ui_process+0x78>
 800ff36:	e0f5      	b.n	8010124 <ui_process+0x264>
 800ff38:	2b02      	cmp	r3, #2
 800ff3a:	d1da      	bne.n	800fef2 <ui_process+0x32>
  *x = (last_touch_x - config.touch_cal[0]) * 16 / config.touch_cal[2];
 800ff3c:	4baf      	ldr	r3, [pc, #700]	; (80101fc <ui_process+0x33c>)
 800ff3e:	4db0      	ldr	r5, [pc, #704]	; (8010200 <ui_process+0x340>)
 800ff40:	2000      	movs	r0, #0
 800ff42:	5e18      	ldrsh	r0, [r3, r0]
 800ff44:	2212      	movs	r2, #18
 800ff46:	5eab      	ldrsh	r3, [r5, r2]
 800ff48:	1ac0      	subs	r0, r0, r3
 800ff4a:	0100      	lsls	r0, r0, #4
 800ff4c:	2316      	movs	r3, #22
 800ff4e:	5ee9      	ldrsh	r1, [r5, r3]
 800ff50:	f7f0 f9ce 	bl	80002f0 <__divsi3>
 800ff54:	0006      	movs	r6, r0
  if (touch_x < 64) {
 800ff56:	283f      	cmp	r0, #63	; 0x3f
 800ff58:	dc00      	bgt.n	800ff5c <ui_process+0x9c>
 800ff5a:	e0e0      	b.n	801011e <ui_process+0x25e>
  if (touch_x > 64+9*20+8+8) {
 800ff5c:	2382      	movs	r3, #130	; 0x82
 800ff5e:	005b      	lsls	r3, r3, #1
 800ff60:	4298      	cmp	r0, r3
 800ff62:	dd00      	ble.n	800ff66 <ui_process+0xa6>
 800ff64:	e1c7      	b.n	80102f6 <ui_process+0x436>
  *y = (last_touch_y - config.touch_cal[1]) * 16 / config.touch_cal[3];
 800ff66:	4ba7      	ldr	r3, [pc, #668]	; (8010204 <ui_process+0x344>)
 800ff68:	2000      	movs	r0, #0
 800ff6a:	5e18      	ldrsh	r0, [r3, r0]
 800ff6c:	2214      	movs	r2, #20
 800ff6e:	5eab      	ldrsh	r3, [r5, r2]
 800ff70:	1ac0      	subs	r0, r0, r3
 800ff72:	0100      	lsls	r0, r0, #4
 800ff74:	2318      	movs	r3, #24
 800ff76:	5ee9      	ldrsh	r1, [r5, r3]
 800ff78:	f7f0 f9ba 	bl	80002f0 <__divsi3>
  if (touch_y > 240-40) {
 800ff7c:	28c8      	cmp	r0, #200	; 0xc8
 800ff7e:	dc00      	bgt.n	800ff82 <ui_process+0xc2>
 800ff80:	e15b      	b.n	801023a <ui_process+0x37a>
    int n = 9 - (touch_x - 64) / 20;
 800ff82:	0030      	movs	r0, r6
 800ff84:	2114      	movs	r1, #20
 800ff86:	3840      	subs	r0, #64	; 0x40
 800ff88:	4249      	negs	r1, r1
 800ff8a:	f7f0 f9b1 	bl	80002f0 <__divsi3>
    uistat.digit_mode = TRUE;
 800ff8e:	2301      	movs	r3, #1
    uistat.digit = n;
 800ff90:	4d9d      	ldr	r5, [pc, #628]	; (8010208 <ui_process+0x348>)
    int n = 9 - (touch_x - 64) / 20;
 800ff92:	3009      	adds	r0, #9
    uistat.digit = n;
 800ff94:	7028      	strb	r0, [r5, #0]
    uistat.digit_mode = TRUE;
 800ff96:	706b      	strb	r3, [r5, #1]
  draw_numeric_area();
 800ff98:	f7fe fc8a 	bl	800e8b0 <draw_numeric_area>
    status = touch_check();
 800ff9c:	f7fe fb78 	bl	800e690 <touch_check>
  } while(status != EVT_TOUCH_RELEASED);
 800ffa0:	2803      	cmp	r0, #3
 800ffa2:	d1fb      	bne.n	800ff9c <ui_process+0xdc>
  uistat.digit_mode = FALSE;
 800ffa4:	2300      	movs	r3, #0
 800ffa6:	706b      	strb	r3, [r5, #1]
  draw_numeric_area();
 800ffa8:	f7fe fc82 	bl	800e8b0 <draw_numeric_area>
  return;
 800ffac:	e7a1      	b.n	800fef2 <ui_process+0x32>
  int status = btn_check();
 800ffae:	f7fe fa07 	bl	800e3c0 <btn_check>
 800ffb2:	1e07      	subs	r7, r0, #0
  if (status != 0) {
 800ffb4:	d0a3      	beq.n	800fefe <ui_process+0x3e>
    if (status & EVT_BUTTON_SINGLE_CLICK) {
 800ffb6:	4205      	tst	r5, r0
 800ffb8:	d000      	beq.n	800ffbc <ui_process+0xfc>
 800ffba:	e114      	b.n	80101e6 <ui_process+0x326>
          if ((status & EVT_DOWN) && markers[active_marker].index > 0) {
 800ffbc:	2320      	movs	r3, #32
        if (active_marker >= 0 && markers[active_marker].enabled) {
 800ffbe:	258e      	movs	r5, #142	; 0x8e
          if ((status & EVT_DOWN) && markers[active_marker].index > 0) {
 800ffc0:	4699      	mov	r9, r3
          if ((status & EVT_UP) && markers[active_marker].index < (POINT_COUNT-1)) {
 800ffc2:	3b10      	subs	r3, #16
 800ffc4:	4698      	mov	r8, r3
 800ffc6:	4e91      	ldr	r6, [pc, #580]	; (801020c <ui_process+0x34c>)
        if (active_marker >= 0 && markers[active_marker].enabled) {
 800ffc8:	016d      	lsls	r5, r5, #5
 800ffca:	5970      	ldr	r0, [r6, r5]
 800ffcc:	2800      	cmp	r0, #0
 800ffce:	db26      	blt.n	801001e <ui_process+0x15e>
 800ffd0:	238d      	movs	r3, #141	; 0x8d
 800ffd2:	009b      	lsls	r3, r3, #2
 800ffd4:	18c3      	adds	r3, r0, r3
 800ffd6:	00db      	lsls	r3, r3, #3
 800ffd8:	56f2      	ldrsb	r2, [r6, r3]
 800ffda:	2a00      	cmp	r2, #0
 800ffdc:	d01f      	beq.n	801001e <ui_process+0x15e>
          if ((status & EVT_DOWN) && markers[active_marker].index > 0) {
 800ffde:	464a      	mov	r2, r9
 800ffe0:	423a      	tst	r2, r7
 800ffe2:	d00e      	beq.n	8010002 <ui_process+0x142>
 800ffe4:	18f3      	adds	r3, r6, r3
 800ffe6:	2102      	movs	r1, #2
 800ffe8:	5e5a      	ldrsh	r2, [r3, r1]
 800ffea:	2a00      	cmp	r2, #0
 800ffec:	dd09      	ble.n	8010002 <ui_process+0x142>
            markers[active_marker].index--;
 800ffee:	3a01      	subs	r2, #1
 800fff0:	b292      	uxth	r2, r2
 800fff2:	805a      	strh	r2, [r3, #2]
            markers[active_marker].frequency = frequencies[markers[active_marker].index];
 800fff4:	3204      	adds	r2, #4
 800fff6:	0092      	lsls	r2, r2, #2
 800fff8:	58b2      	ldr	r2, [r6, r2]
            redraw_marker(active_marker, FALSE);
 800fffa:	2100      	movs	r1, #0
            markers[active_marker].frequency = frequencies[markers[active_marker].index];
 800fffc:	605a      	str	r2, [r3, #4]
            redraw_marker(active_marker, FALSE);
 800fffe:	f7fd fea7 	bl	800dd50 <redraw_marker>
          if ((status & EVT_UP) && markers[active_marker].index < (POINT_COUNT-1)) {
 8010002:	4643      	mov	r3, r8
 8010004:	423b      	tst	r3, r7
 8010006:	d00a      	beq.n	801001e <ui_process+0x15e>
 8010008:	238d      	movs	r3, #141	; 0x8d
 801000a:	5970      	ldr	r0, [r6, r5]
 801000c:	009b      	lsls	r3, r3, #2
 801000e:	18c3      	adds	r3, r0, r3
 8010010:	00db      	lsls	r3, r3, #3
 8010012:	18f3      	adds	r3, r6, r3
 8010014:	2102      	movs	r1, #2
 8010016:	5e5a      	ldrsh	r2, [r3, r1]
 8010018:	2a63      	cmp	r2, #99	; 0x63
 801001a:	dc00      	bgt.n	801001e <ui_process+0x15e>
 801001c:	e102      	b.n	8010224 <ui_process+0x364>
        status = btn_wait_release();
 801001e:	f7fe fa27 	bl	800e470 <btn_wait_release>
 8010022:	1e07      	subs	r7, r0, #0
      } while (status != 0);
 8010024:	d1d1      	bne.n	800ffca <ui_process+0x10a>
      if (active_marker >= 0)
 8010026:	238e      	movs	r3, #142	; 0x8e
 8010028:	015b      	lsls	r3, r3, #5
 801002a:	58f0      	ldr	r0, [r6, r3]
 801002c:	2800      	cmp	r0, #0
 801002e:	da00      	bge.n	8010032 <ui_process+0x172>
 8010030:	e765      	b.n	800fefe <ui_process+0x3e>
        redraw_marker(active_marker, TRUE);
 8010032:	2101      	movs	r1, #1
 8010034:	f7fd fe8c 	bl	800dd50 <redraw_marker>
 8010038:	e761      	b.n	800fefe <ui_process+0x3e>
  int status = btn_check();
 801003a:	f7fe f9c1 	bl	800e3c0 <btn_check>
 801003e:	1e05      	subs	r5, r0, #0
  if (status != 0) {
 8010040:	d100      	bne.n	8010044 <ui_process+0x184>
 8010042:	e75c      	b.n	800fefe <ui_process+0x3e>
    if (status & EVT_BUTTON_SINGLE_CLICK) {
 8010044:	4206      	tst	r6, r0
 8010046:	d000      	beq.n	801004a <ui_process+0x18a>
 8010048:	e0c7      	b.n	80101da <ui_process+0x31a>
            if (menu_stack[menu_current_level][selection+1].type == MT_NONE) {
 801004a:	4b71      	ldr	r3, [pc, #452]	; (8010210 <ui_process+0x350>)
 801004c:	4e71      	ldr	r6, [pc, #452]	; (8010214 <ui_process+0x354>)
 801004e:	4699      	mov	r9, r3
 8010050:	4b71      	ldr	r3, [pc, #452]	; (8010218 <ui_process+0x358>)
 8010052:	4698      	mov	r8, r3
        if (status & EVT_UP){
 8010054:	06eb      	lsls	r3, r5, #27
 8010056:	d511      	bpl.n	801007c <ui_process+0x1bc>
            if (menu_stack[menu_current_level][selection+1].type == MT_NONE) {
 8010058:	4643      	mov	r3, r8
 801005a:	464a      	mov	r2, r9
 801005c:	781b      	ldrb	r3, [r3, #0]
 801005e:	009b      	lsls	r3, r3, #2
 8010060:	5898      	ldr	r0, [r3, r2]
 8010062:	2200      	movs	r2, #0
 8010064:	56b2      	ldrsb	r2, [r6, r2]
 8010066:	3201      	adds	r2, #1
 8010068:	0053      	lsls	r3, r2, #1
 801006a:	189b      	adds	r3, r3, r2
 801006c:	009b      	lsls	r3, r3, #2
 801006e:	5c1b      	ldrb	r3, [r3, r0]
 8010070:	2b00      	cmp	r3, #0
 8010072:	d100      	bne.n	8010076 <ui_process+0x1b6>
 8010074:	e0aa      	b.n	80101cc <ui_process+0x30c>
            	selection++;
 8010076:	7032      	strb	r2, [r6, #0]
  draw_menu_buttons(menu_stack[menu_current_level]);
 8010078:	f7fe fc7a 	bl	800e970 <draw_menu_buttons>
        if (status & EVT_DOWN){
 801007c:	06ab      	lsls	r3, r5, #26
 801007e:	d50e      	bpl.n	801009e <ui_process+0x1de>
        		if (selection == 0){
 8010080:	2300      	movs	r3, #0
 8010082:	4a64      	ldr	r2, [pc, #400]	; (8010214 <ui_process+0x354>)
 8010084:	56d3      	ldrsb	r3, [r2, r3]
 8010086:	2b00      	cmp	r3, #0
 8010088:	d100      	bne.n	801008c <ui_process+0x1cc>
 801008a:	e09f      	b.n	80101cc <ui_process+0x30c>
          selection--;
 801008c:	3b01      	subs	r3, #1
 801008e:	7013      	strb	r3, [r2, #0]
  draw_menu_buttons(menu_stack[menu_current_level]);
 8010090:	4b61      	ldr	r3, [pc, #388]	; (8010218 <ui_process+0x358>)
 8010092:	4a5f      	ldr	r2, [pc, #380]	; (8010210 <ui_process+0x350>)
 8010094:	781b      	ldrb	r3, [r3, #0]
 8010096:	009b      	lsls	r3, r3, #2
 8010098:	5898      	ldr	r0, [r3, r2]
 801009a:	f7fe fc69 	bl	800e970 <draw_menu_buttons>
        status = btn_wait_release();
 801009e:	f7fe f9e7 	bl	800e470 <btn_wait_release>
 80100a2:	1e05      	subs	r5, r0, #0
      } while (status != 0);
 80100a4:	d1d6      	bne.n	8010054 <ui_process+0x194>
 80100a6:	e72a      	b.n	800fefe <ui_process+0x3e>
  const menuitem_t *menu = menu_stack[menu_current_level];
 80100a8:	4b5b      	ldr	r3, [pc, #364]	; (8010218 <ui_process+0x358>)
 80100aa:	4a59      	ldr	r2, [pc, #356]	; (8010210 <ui_process+0x350>)
 80100ac:	781b      	ldrb	r3, [r3, #0]
  *x = (last_touch_x - config.touch_cal[0]) * 16 / config.touch_cal[2];
 80100ae:	4d54      	ldr	r5, [pc, #336]	; (8010200 <ui_process+0x340>)
  const menuitem_t *menu = menu_stack[menu_current_level];
 80100b0:	009b      	lsls	r3, r3, #2
 80100b2:	589e      	ldr	r6, [r3, r2]
  *x = (last_touch_x - config.touch_cal[0]) * 16 / config.touch_cal[2];
 80100b4:	4b51      	ldr	r3, [pc, #324]	; (80101fc <ui_process+0x33c>)
 80100b6:	2000      	movs	r0, #0
 80100b8:	5e18      	ldrsh	r0, [r3, r0]
 80100ba:	2212      	movs	r2, #18
 80100bc:	5eab      	ldrsh	r3, [r5, r2]
 80100be:	1ac0      	subs	r0, r0, r3
 80100c0:	0100      	lsls	r0, r0, #4
 80100c2:	2316      	movs	r3, #22
 80100c4:	5ee9      	ldrsh	r1, [r5, r3]
 80100c6:	f7f0 f913 	bl	80002f0 <__divsi3>
  *y = (last_touch_y - config.touch_cal[1]) * 16 / config.touch_cal[3];
 80100ca:	4b4e      	ldr	r3, [pc, #312]	; (8010204 <ui_process+0x344>)
  *x = (last_touch_x - config.touch_cal[0]) * 16 / config.touch_cal[2];
 80100cc:	4680      	mov	r8, r0
  *y = (last_touch_y - config.touch_cal[1]) * 16 / config.touch_cal[3];
 80100ce:	2000      	movs	r0, #0
 80100d0:	5e18      	ldrsh	r0, [r3, r0]
 80100d2:	2214      	movs	r2, #20
 80100d4:	5eab      	ldrsh	r3, [r5, r2]
 80100d6:	1ac0      	subs	r0, r0, r3
 80100d8:	0100      	lsls	r0, r0, #4
 80100da:	2318      	movs	r3, #24
 80100dc:	5ee9      	ldrsh	r1, [r5, r3]
 80100de:	f7f0 f907 	bl	80002f0 <__divsi3>
  for (i = 0; i < 7; i++) {
 80100e2:	2500      	movs	r5, #0
 80100e4:	0033      	movs	r3, r6
    if (menu[i].type == MT_NONE)
 80100e6:	781a      	ldrb	r2, [r3, #0]
 80100e8:	2a00      	cmp	r2, #0
 80100ea:	d010      	beq.n	801010e <ui_process+0x24e>
    if (menu[i].type == MT_BLANK) 
 80100ec:	2a01      	cmp	r2, #1
 80100ee:	d00a      	beq.n	8010106 <ui_process+0x246>
	if (y-2 < touch_y && touch_y < y+30+2
 80100f0:	016a      	lsls	r2, r5, #5
 80100f2:	1e51      	subs	r1, r2, #1
 80100f4:	4288      	cmp	r0, r1
 80100f6:	db06      	blt.n	8010106 <ui_process+0x246>
 80100f8:	321f      	adds	r2, #31
 80100fa:	4290      	cmp	r0, r2
 80100fc:	dc03      	bgt.n	8010106 <ui_process+0x246>
		&& 320-72 < touch_x) {
 80100fe:	4642      	mov	r2, r8
 8010100:	2af8      	cmp	r2, #248	; 0xf8
 8010102:	dd00      	ble.n	8010106 <ui_process+0x246>
 8010104:	e0fe      	b.n	8010304 <ui_process+0x444>
  for (i = 0; i < 7; i++) {
 8010106:	3501      	adds	r5, #1
 8010108:	330c      	adds	r3, #12
 801010a:	2d07      	cmp	r5, #7
 801010c:	d1eb      	bne.n	80100e6 <ui_process+0x226>
    status = touch_check();
 801010e:	f7fe fabf 	bl	800e690 <touch_check>
  } while(status != EVT_TOUCH_RELEASED);
 8010112:	2803      	cmp	r0, #3
 8010114:	d1fb      	bne.n	801010e <ui_process+0x24e>
  if (ui_mode == UI_NORMAL) 
 8010116:	783b      	ldrb	r3, [r7, #0]
 8010118:	2b00      	cmp	r3, #0
 801011a:	d100      	bne.n	801011e <ui_process+0x25e>
 801011c:	e6e9      	b.n	800fef2 <ui_process+0x32>
 801011e:	f7ff f82f 	bl	800f180 <ui_mode_normal.part.2>
 8010122:	e6e6      	b.n	800fef2 <ui_process+0x32>
  *y = (last_touch_y - config.touch_cal[1]) * 16 / config.touch_cal[3];
 8010124:	4b37      	ldr	r3, [pc, #220]	; (8010204 <ui_process+0x344>)
  for (m = 0; m < MARKER_COUNT; m++) {
 8010126:	2700      	movs	r7, #0
  *y = (last_touch_y - config.touch_cal[1]) * 16 / config.touch_cal[3];
 8010128:	2000      	movs	r0, #0
 801012a:	5e18      	ldrsh	r0, [r3, r0]
 801012c:	4b34      	ldr	r3, [pc, #208]	; (8010200 <ui_process+0x340>)
 801012e:	4699      	mov	r9, r3
 8010130:	2214      	movs	r2, #20
 8010132:	5e9b      	ldrsh	r3, [r3, r2]
 8010134:	1ac0      	subs	r0, r0, r3
 8010136:	464b      	mov	r3, r9
 8010138:	0100      	lsls	r0, r0, #4
 801013a:	2118      	movs	r1, #24
 801013c:	5e59      	ldrsh	r1, [r3, r1]
 801013e:	f7f0 f8d7 	bl	80002f0 <__divsi3>
  *x = (last_touch_x - config.touch_cal[0]) * 16 / config.touch_cal[2];
 8010142:	4b2e      	ldr	r3, [pc, #184]	; (80101fc <ui_process+0x33c>)
  *y = (last_touch_y - config.touch_cal[1]) * 16 / config.touch_cal[3];
 8010144:	4683      	mov	fp, r0
  *x = (last_touch_x - config.touch_cal[0]) * 16 / config.touch_cal[2];
 8010146:	2000      	movs	r0, #0
 8010148:	5e18      	ldrsh	r0, [r3, r0]
 801014a:	464b      	mov	r3, r9
 801014c:	2212      	movs	r2, #18
 801014e:	5e9b      	ldrsh	r3, [r3, r2]
 8010150:	1ac0      	subs	r0, r0, r3
 8010152:	464b      	mov	r3, r9
 8010154:	0100      	lsls	r0, r0, #4
 8010156:	2116      	movs	r1, #22
 8010158:	5e59      	ldrsh	r1, [r3, r1]
 801015a:	f7f0 f8c9 	bl	80002f0 <__divsi3>
 801015e:	4b2f      	ldr	r3, [pc, #188]	; (801021c <ui_process+0x35c>)
  touch_x -= OFFSETX;
 8010160:	3812      	subs	r0, #18
 8010162:	4698      	mov	r8, r3
 8010164:	9001      	str	r0, [sp, #4]
    if (!markers[m].enabled)
 8010166:	4643      	mov	r3, r8
 8010168:	781b      	ldrb	r3, [r3, #0]
 801016a:	b25b      	sxtb	r3, r3
 801016c:	2b00      	cmp	r3, #0
 801016e:	d10f      	bne.n	8010190 <ui_process+0x2d0>
 8010170:	2308      	movs	r3, #8
 8010172:	469c      	mov	ip, r3
  for (m = 0; m < MARKER_COUNT; m++) {
 8010174:	3701      	adds	r7, #1
 8010176:	44e0      	add	r8, ip
 8010178:	2f04      	cmp	r7, #4
 801017a:	d1f4      	bne.n	8010166 <ui_process+0x2a6>
    status = touch_check();
 801017c:	f7fe fa88 	bl	800e690 <touch_check>
  } while(status != EVT_TOUCH_RELEASED);
 8010180:	2803      	cmp	r0, #3
 8010182:	d1fb      	bne.n	801017c <ui_process+0x2bc>
      selection = -1;
 8010184:	22ff      	movs	r2, #255	; 0xff
 8010186:	4b23      	ldr	r3, [pc, #140]	; (8010214 <ui_process+0x354>)
 8010188:	701a      	strb	r2, [r3, #0]
      ui_mode_menu();
 801018a:	f7fe fd39 	bl	800ec00 <ui_mode_menu>
      break;
 801018e:	e6b0      	b.n	800fef2 <ui_process+0x32>
      if (sq_distance(x - touch_x, y - touch_y) < 400) {
 8010190:	2390      	movs	r3, #144	; 0x90
 8010192:	33ff      	adds	r3, #255	; 0xff
    for (t = 0; t < TRACE_COUNT; t++) {
 8010194:	2500      	movs	r5, #0
      if (sq_distance(x - touch_x, y - touch_y) < 400) {
 8010196:	469a      	mov	sl, r3
 8010198:	4e21      	ldr	r6, [pc, #132]	; (8010220 <ui_process+0x360>)
      if (!trace[t].enabled)
 801019a:	7833      	ldrb	r3, [r6, #0]
 801019c:	2b00      	cmp	r3, #0
 801019e:	d010      	beq.n	80101c2 <ui_process+0x302>
      marker_position(m, t, &x, &y);
 80101a0:	ab03      	add	r3, sp, #12
 80101a2:	aa02      	add	r2, sp, #8
 80101a4:	0029      	movs	r1, r5
 80101a6:	0038      	movs	r0, r7
 80101a8:	f7fd fd4a 	bl	800dc40 <marker_position>
      if (sq_distance(x - touch_x, y - touch_y) < 400) {
 80101ac:	4659      	mov	r1, fp
 80101ae:	9a01      	ldr	r2, [sp, #4]
 80101b0:	9b02      	ldr	r3, [sp, #8]
 80101b2:	1a9b      	subs	r3, r3, r2
 80101b4:	9a03      	ldr	r2, [sp, #12]
  return x0*x0 + y0*y0;
 80101b6:	435b      	muls	r3, r3
      if (sq_distance(x - touch_x, y - touch_y) < 400) {
 80101b8:	1a52      	subs	r2, r2, r1
  return x0*x0 + y0*y0;
 80101ba:	4352      	muls	r2, r2
 80101bc:	189b      	adds	r3, r3, r2
      if (sq_distance(x - touch_x, y - touch_y) < 400) {
 80101be:	4553      	cmp	r3, sl
 80101c0:	dd4f      	ble.n	8010262 <ui_process+0x3a2>
    for (t = 0; t < TRACE_COUNT; t++) {
 80101c2:	3501      	adds	r5, #1
 80101c4:	360c      	adds	r6, #12
 80101c6:	2d04      	cmp	r5, #4
 80101c8:	d1e7      	bne.n	801019a <ui_process+0x2da>
 80101ca:	e7d1      	b.n	8010170 <ui_process+0x2b0>
  if (ui_mode == UI_NORMAL) 
 80101cc:	783b      	ldrb	r3, [r7, #0]
 80101ce:	2b00      	cmp	r3, #0
 80101d0:	d100      	bne.n	80101d4 <ui_process+0x314>
 80101d2:	e694      	b.n	800fefe <ui_process+0x3e>
 80101d4:	f7fe ffd4 	bl	800f180 <ui_mode_normal.part.2>
 80101d8:	e691      	b.n	800fefe <ui_process+0x3e>
      menu_invoke(selection);
 80101da:	2000      	movs	r0, #0
 80101dc:	4b0d      	ldr	r3, [pc, #52]	; (8010214 <ui_process+0x354>)
 80101de:	5618      	ldrsb	r0, [r3, r0]
 80101e0:	f7ff fb6e 	bl	800f8c0 <menu_invoke>
 80101e4:	e68b      	b.n	800fefe <ui_process+0x3e>
      ui_mode_menu();
 80101e6:	f7fe fd0b 	bl	800ec00 <ui_mode_menu>
 80101ea:	e688      	b.n	800fefe <ui_process+0x3e>
 80101ec:	200030a3 	.word	0x200030a3
 80101f0:	20003074 	.word	0x20003074
 80101f4:	40012400 	.word	0x40012400
 80101f8:	200030a5 	.word	0x200030a5
 80101fc:	2000309e 	.word	0x2000309e
 8010200:	2000042c 	.word	0x2000042c
 8010204:	200030a0 	.word	0x200030a0
 8010208:	20001654 	.word	0x20001654
 801020c:	20000454 	.word	0x20000454
 8010210:	20001640 	.word	0x20001640
 8010214:	200030a4 	.word	0x200030a4
 8010218:	200030a2 	.word	0x200030a2
 801021c:	200015f4 	.word	0x200015f4
 8010220:	200015c4 	.word	0x200015c4
            markers[active_marker].index++;
 8010224:	3201      	adds	r2, #1
 8010226:	b212      	sxth	r2, r2
 8010228:	805a      	strh	r2, [r3, #2]
            markers[active_marker].frequency = frequencies[markers[active_marker].index];
 801022a:	3204      	adds	r2, #4
 801022c:	0092      	lsls	r2, r2, #2
 801022e:	58b2      	ldr	r2, [r6, r2]
            redraw_marker(active_marker, FALSE);
 8010230:	2100      	movs	r1, #0
            markers[active_marker].frequency = frequencies[markers[active_marker].index];
 8010232:	605a      	str	r2, [r3, #4]
            redraw_marker(active_marker, FALSE);
 8010234:	f7fd fd8c 	bl	800dd50 <redraw_marker>
 8010238:	e6f1      	b.n	801001e <ui_process+0x15e>
      step = 1;
 801023a:	2301      	movs	r3, #1
    if (touch_y < 100) {
 801023c:	2863      	cmp	r0, #99	; 0x63
 801023e:	dd00      	ble.n	8010242 <ui_process+0x382>
      step = -1;
 8010240:	3b02      	subs	r3, #2
    for (n = uistat.digit; n > 0; n--)
 8010242:	2100      	movs	r1, #0
 8010244:	4d37      	ldr	r5, [pc, #220]	; (8010324 <ui_process+0x464>)
 8010246:	5669      	ldrsb	r1, [r5, r1]
 8010248:	2900      	cmp	r1, #0
 801024a:	dd05      	ble.n	8010258 <ui_process+0x398>
      step *= 10;
 801024c:	009a      	lsls	r2, r3, #2
 801024e:	18d3      	adds	r3, r2, r3
    for (n = uistat.digit; n > 0; n--)
 8010250:	3901      	subs	r1, #1
      step *= 10;
 8010252:	005b      	lsls	r3, r3, #1
    for (n = uistat.digit; n > 0; n--)
 8010254:	2900      	cmp	r1, #0
 8010256:	d1f9      	bne.n	801024c <ui_process+0x38c>
    uistat.value += step;
 8010258:	686a      	ldr	r2, [r5, #4]
 801025a:	4694      	mov	ip, r2
 801025c:	4463      	add	r3, ip
 801025e:	606b      	str	r3, [r5, #4]
 8010260:	e69a      	b.n	800ff98 <ui_process+0xd8>
        if (active_marker != m) {
 8010262:	238e      	movs	r3, #142	; 0x8e
 8010264:	4e30      	ldr	r6, [pc, #192]	; (8010328 <ui_process+0x468>)
 8010266:	015b      	lsls	r3, r3, #5
 8010268:	58f2      	ldr	r2, [r6, r3]
 801026a:	42ba      	cmp	r2, r7
 801026c:	d006      	beq.n	801027c <ui_process+0x3bc>
          previous_marker = active_marker;
 801026e:	492f      	ldr	r1, [pc, #188]	; (801032c <ui_process+0x46c>)
          redraw_marker(active_marker, TRUE);
 8010270:	0038      	movs	r0, r7
          previous_marker = active_marker;
 8010272:	700a      	strb	r2, [r1, #0]
          redraw_marker(active_marker, TRUE);
 8010274:	2101      	movs	r1, #1
          active_marker = m;
 8010276:	50f7      	str	r7, [r6, r3]
          redraw_marker(active_marker, TRUE);
 8010278:	f7fd fd6a 	bl	800dd50 <redraw_marker>
        uistat.current_trace = t;
 801027c:	4b29      	ldr	r3, [pc, #164]	; (8010324 <ui_process+0x464>)
      markers[m].index = index;
 801027e:	46b8      	mov	r8, r7
        uistat.current_trace = t;
 8010280:	709d      	strb	r5, [r3, #2]
      markers[m].index = index;
 8010282:	238d      	movs	r3, #141	; 0x8d
 8010284:	009b      	lsls	r3, r3, #2
 8010286:	18fb      	adds	r3, r7, r3
 8010288:	00db      	lsls	r3, r3, #3
 801028a:	469a      	mov	sl, r3
 801028c:	44b2      	add	sl, r6
 801028e:	4657      	mov	r7, sl
 8010290:	46b2      	mov	sl, r6
 8010292:	002e      	movs	r6, r5
  *y = (last_touch_y - config.touch_cal[1]) * 16 / config.touch_cal[3];
 8010294:	4b26      	ldr	r3, [pc, #152]	; (8010330 <ui_process+0x470>)
 8010296:	2000      	movs	r0, #0
 8010298:	5e18      	ldrsh	r0, [r3, r0]
 801029a:	464b      	mov	r3, r9
 801029c:	2214      	movs	r2, #20
 801029e:	5e9b      	ldrsh	r3, [r3, r2]
 80102a0:	1ac0      	subs	r0, r0, r3
 80102a2:	464b      	mov	r3, r9
 80102a4:	0100      	lsls	r0, r0, #4
 80102a6:	2118      	movs	r1, #24
 80102a8:	5e59      	ldrsh	r1, [r3, r1]
 80102aa:	f7f0 f821 	bl	80002f0 <__divsi3>
  *x = (last_touch_x - config.touch_cal[0]) * 16 / config.touch_cal[2];
 80102ae:	4b21      	ldr	r3, [pc, #132]	; (8010334 <ui_process+0x474>)
  *y = (last_touch_y - config.touch_cal[1]) * 16 / config.touch_cal[3];
 80102b0:	0005      	movs	r5, r0
  *x = (last_touch_x - config.touch_cal[0]) * 16 / config.touch_cal[2];
 80102b2:	2000      	movs	r0, #0
 80102b4:	5e18      	ldrsh	r0, [r3, r0]
 80102b6:	464b      	mov	r3, r9
 80102b8:	2212      	movs	r2, #18
 80102ba:	5e9b      	ldrsh	r3, [r3, r2]
 80102bc:	1ac0      	subs	r0, r0, r3
 80102be:	464b      	mov	r3, r9
 80102c0:	0100      	lsls	r0, r0, #4
 80102c2:	2116      	movs	r1, #22
 80102c4:	5e59      	ldrsh	r1, [r3, r1]
 80102c6:	f7f0 f813 	bl	80002f0 <__divsi3>
    index = search_nearest_index(touch_x, touch_y, t);
 80102ca:	0032      	movs	r2, r6
    touch_x -= OFFSETX;
 80102cc:	3812      	subs	r0, #18
    index = search_nearest_index(touch_x, touch_y, t);
 80102ce:	0029      	movs	r1, r5
 80102d0:	f7fd fcde 	bl	800dc90 <search_nearest_index>
    if (index >= 0) {
 80102d4:	2800      	cmp	r0, #0
 80102d6:	db09      	blt.n	80102ec <ui_process+0x42c>
      markers[m].frequency = frequencies[index];
 80102d8:	4653      	mov	r3, sl
      markers[m].index = index;
 80102da:	8078      	strh	r0, [r7, #2]
      markers[m].frequency = frequencies[index];
 80102dc:	3004      	adds	r0, #4
 80102de:	0080      	lsls	r0, r0, #2
 80102e0:	581b      	ldr	r3, [r3, r0]
      redraw_marker(m, TRUE);
 80102e2:	2101      	movs	r1, #1
      markers[m].frequency = frequencies[index];
 80102e4:	607b      	str	r3, [r7, #4]
      redraw_marker(m, TRUE);
 80102e6:	4640      	mov	r0, r8
 80102e8:	f7fd fd32 	bl	800dd50 <redraw_marker>
    status = touch_check();
 80102ec:	f7fe f9d0 	bl	800e690 <touch_check>
  } while(status != EVT_TOUCH_RELEASED);
 80102f0:	2803      	cmp	r0, #3
 80102f2:	d1cf      	bne.n	8010294 <ui_process+0x3d4>
 80102f4:	e5fd      	b.n	800fef2 <ui_process+0x32>
    ui_mode_keypad(keypad_mode);
 80102f6:	4b10      	ldr	r3, [pc, #64]	; (8010338 <ui_process+0x478>)
 80102f8:	7818      	ldrb	r0, [r3, #0]
 80102fa:	f7fe fd49 	bl	800ed90 <ui_mode_keypad>
    ui_process_keypad();
 80102fe:	f7ff f837 	bl	800f370 <ui_process_keypad>
    return;
 8010302:	e5f6      	b.n	800fef2 <ui_process+0x32>
  selection = i;
 8010304:	4f0d      	ldr	r7, [pc, #52]	; (801033c <ui_process+0x47c>)
  draw_menu_buttons(menu_stack[menu_current_level]);
 8010306:	0030      	movs	r0, r6
  selection = i;
 8010308:	703d      	strb	r5, [r7, #0]
  draw_menu_buttons(menu_stack[menu_current_level]);
 801030a:	f7fe fb31 	bl	800e970 <draw_menu_buttons>
    status = touch_check();
 801030e:	f7fe f9bf 	bl	800e690 <touch_check>
  } while(status != EVT_TOUCH_RELEASED);
 8010312:	2803      	cmp	r0, #3
 8010314:	d1fb      	bne.n	801030e <ui_process+0x44e>
  selection = -1;
 8010316:	23ff      	movs	r3, #255	; 0xff
  menu_invoke(i);
 8010318:	0028      	movs	r0, r5
  selection = -1;
 801031a:	703b      	strb	r3, [r7, #0]
  menu_invoke(i);
 801031c:	f7ff fad0 	bl	800f8c0 <menu_invoke>
 8010320:	e5e7      	b.n	800fef2 <ui_process+0x32>
 8010322:	46c0      	nop			; (mov r8, r8)
 8010324:	20001654 	.word	0x20001654
 8010328:	20000454 	.word	0x20000454
 801032c:	20001650 	.word	0x20001650
 8010330:	200030a0 	.word	0x200030a0
 8010334:	2000309e 	.word	0x2000309e
 8010338:	20003079 	.word	0x20003079
 801033c:	200030a4 	.word	0x200030a4

08010340 <handle_touch_interrupt>:
  touch_start_watchdog();
}

void handle_touch_interrupt(void)
{
  operation_requested = OP_TOUCH;
 8010340:	2202      	movs	r2, #2
 8010342:	4b01      	ldr	r3, [pc, #4]	; (8010348 <handle_touch_interrupt+0x8>)
 8010344:	701a      	strb	r2, [r3, #0]
}
 8010346:	4770      	bx	lr
 8010348:	200030a3 	.word	0x200030a3
 801034c:	00000000 	.word	0x00000000

08010350 <ui_init>:

void ui_init()
{
 8010350:	b510      	push	{r4, lr}
  adc_init();
 8010352:	f000 fdd5 	bl	8010f00 <adc_init>
  
  /*
   * Activates the EXT driver 1.
   */
  extStart(&EXTD1, &extcfg);
 8010356:	490c      	ldr	r1, [pc, #48]	; (8010388 <ui_init+0x38>)
 8010358:	480c      	ldr	r0, [pc, #48]	; (801038c <ui_init+0x3c>)
 801035a:	f7f4 fb51 	bl	8004a00 <extStart>

#if 1
  gptStart(&GPTD3, &gpt3cfg);
 801035e:	4c0c      	ldr	r4, [pc, #48]	; (8010390 <ui_init+0x40>)
 8010360:	490c      	ldr	r1, [pc, #48]	; (8010394 <ui_init+0x44>)
 8010362:	0020      	movs	r0, r4
 8010364:	f7f4 fb6c 	bl	8004a40 <gptStart>
  gptPolledDelay(&GPTD3, 10); /* Small delay.*/
 8010368:	0020      	movs	r0, r4
 801036a:	210a      	movs	r1, #10
 801036c:	f7f4 fb80 	bl	8004a70 <gptPolledDelay>

  gptStartContinuous(&GPTD3, 10);
 8010370:	0020      	movs	r0, r4
 8010372:	210a      	movs	r1, #10
 8010374:	f7f4 fb74 	bl	8004a60 <gptStartContinuous>
  touch_prepare_sense();
 8010378:	f7fe f8fa 	bl	800e570 <touch_prepare_sense>
  adc_start_analog_watchdogd(ADC1, ADC_CHSELR_CHSEL7);
 801037c:	2180      	movs	r1, #128	; 0x80
 801037e:	4806      	ldr	r0, [pc, #24]	; (8010398 <ui_init+0x48>)
 8010380:	f000 fe86 	bl	8011090 <adc_start_analog_watchdogd>
#endif

  touch_start_watchdog();
}
 8010384:	bd10      	pop	{r4, pc}
 8010386:	46c0      	nop			; (mov r8, r8)
 8010388:	08014bec 	.word	0x08014bec
 801038c:	2000183c 	.word	0x2000183c
 8010390:	200018e0 	.word	0x200018e0
 8010394:	08014cec 	.word	0x08014cec
 8010398:	40012400 	.word	0x40012400
 801039c:	00000000 	.word	0x00000000

080103a0 <spi_lld_serve_tx_interrupt>:
static uint32_t txdmamode;

static void spi_lld_serve_tx_interrupt(SPIDriver *spip, uint32_t flags) {
  (void)spip;
  (void)flags;
}
 80103a0:	4770      	bx	lr
 80103a2:	46c0      	nop			; (mov r8, r8)
	...

080103b0 <send_command>:
  SPI1->CR2 = 0x0700 | SPI_CR2_TXDMAEN | SPI_CR2_FRXTH;
  SPI1->CR1 |= SPI_CR1_SPE;  
}

static void send_command(uint8_t cmd, int len, const uint8_t *data)
{
 80103b0:	b530      	push	{r4, r5, lr}
	CS_LOW;
 80103b2:	2440      	movs	r4, #64	; 0x40
 80103b4:	4b11      	ldr	r3, [pc, #68]	; (80103fc <send_command+0x4c>)
  SPI1->CR2 = (SPI1->CR2 & 0xf0ff) | 0x0700;
 80103b6:	4d12      	ldr	r5, [pc, #72]	; (8010400 <send_command+0x50>)
	CS_LOW;
 80103b8:	835c      	strh	r4, [r3, #26]
	DC_CMD;
 80103ba:	3440      	adds	r4, #64	; 0x40
 80103bc:	835c      	strh	r4, [r3, #26]
  SPI1->CR2 = (SPI1->CR2 & 0xf0ff) | 0x0700;
 80103be:	4b11      	ldr	r3, [pc, #68]	; (8010404 <send_command+0x54>)
 80103c0:	685c      	ldr	r4, [r3, #4]
 80103c2:	4025      	ands	r5, r4
 80103c4:	24e0      	movs	r4, #224	; 0xe0
 80103c6:	00e4      	lsls	r4, r4, #3
 80103c8:	432c      	orrs	r4, r5
 80103ca:	605c      	str	r4, [r3, #4]
  *(uint8_t*)(&SPI1->DR) = x;
 80103cc:	4c0e      	ldr	r4, [pc, #56]	; (8010408 <send_command+0x58>)
 80103ce:	7020      	strb	r0, [r4, #0]
  while (SPI1->SR & SPI_SR_BSY)
 80103d0:	0018      	movs	r0, r3
 80103d2:	2480      	movs	r4, #128	; 0x80
 80103d4:	6883      	ldr	r3, [r0, #8]
 80103d6:	421c      	tst	r4, r3
 80103d8:	d1fc      	bne.n	80103d4 <send_command+0x24>
    ssp_databit8();
	ssp_senddata(cmd);
	DC_DATA;
 80103da:	4b08      	ldr	r3, [pc, #32]	; (80103fc <send_command+0x4c>)
 80103dc:	1851      	adds	r1, r2, r1
 80103de:	831c      	strh	r4, [r3, #24]
  *(uint8_t*)(&SPI1->DR) = x;
 80103e0:	4d09      	ldr	r5, [pc, #36]	; (8010408 <send_command+0x58>)
  while (SPI1->SR & SPI_SR_BSY)
 80103e2:	4c08      	ldr	r4, [pc, #32]	; (8010404 <send_command+0x54>)
 80103e4:	2080      	movs	r0, #128	; 0x80
	while (len-- > 0) {
 80103e6:	428a      	cmp	r2, r1
 80103e8:	d007      	beq.n	80103fa <send_command+0x4a>
      ssp_senddata(*data++);
 80103ea:	7813      	ldrb	r3, [r2, #0]
  *(uint8_t*)(&SPI1->DR) = x;
 80103ec:	702b      	strb	r3, [r5, #0]
  while (SPI1->SR & SPI_SR_BSY)
 80103ee:	68a3      	ldr	r3, [r4, #8]
 80103f0:	4218      	tst	r0, r3
 80103f2:	d1fc      	bne.n	80103ee <send_command+0x3e>
 80103f4:	3201      	adds	r2, #1
	while (len-- > 0) {
 80103f6:	428a      	cmp	r2, r1
 80103f8:	d1f7      	bne.n	80103ea <send_command+0x3a>
	}
	//CS_HIGH;
}
 80103fa:	bd30      	pop	{r4, r5, pc}
 80103fc:	48000400 	.word	0x48000400
 8010400:	0000f0ff 	.word	0x0000f0ff
 8010404:	40013000 	.word	0x40013000
 8010408:	4001300c 	.word	0x4001300c
 801040c:	00000000 	.word	0x00000000

08010410 <ssp_sendrecvdata.constprop.3>:
    while (!(SPI1->SR & SPI_SR_TXE));
 8010410:	2102      	movs	r1, #2
 8010412:	4a0c      	ldr	r2, [pc, #48]	; (8010444 <ssp_sendrecvdata.constprop.3+0x34>)
 8010414:	6893      	ldr	r3, [r2, #8]
 8010416:	4219      	tst	r1, r3
 8010418:	d0fc      	beq.n	8010414 <ssp_sendrecvdata.constprop.3+0x4>
    while (SPI1->SR & SPI_SR_RXNE) (void)SPI1->DR;
 801041a:	6893      	ldr	r3, [r2, #8]
 801041c:	07db      	lsls	r3, r3, #31
 801041e:	d505      	bpl.n	801042c <ssp_sendrecvdata.constprop.3+0x1c>
 8010420:	2101      	movs	r1, #1
 8010422:	4b08      	ldr	r3, [pc, #32]	; (8010444 <ssp_sendrecvdata.constprop.3+0x34>)
 8010424:	68da      	ldr	r2, [r3, #12]
 8010426:	689a      	ldr	r2, [r3, #8]
 8010428:	4211      	tst	r1, r2
 801042a:	d1fb      	bne.n	8010424 <ssp_sendrecvdata.constprop.3+0x14>
    *(uint8_t*)(&SPI1->DR) = x;
 801042c:	2200      	movs	r2, #0
    while (!(SPI1->SR & SPI_SR_RXNE));
 801042e:	2101      	movs	r1, #1
    *(uint8_t*)(&SPI1->DR) = x;
 8010430:	4b05      	ldr	r3, [pc, #20]	; (8010448 <ssp_sendrecvdata.constprop.3+0x38>)
 8010432:	701a      	strb	r2, [r3, #0]
    while (!(SPI1->SR & SPI_SR_RXNE));
 8010434:	4a03      	ldr	r2, [pc, #12]	; (8010444 <ssp_sendrecvdata.constprop.3+0x34>)
 8010436:	6893      	ldr	r3, [r2, #8]
 8010438:	4219      	tst	r1, r3
 801043a:	d0fc      	beq.n	8010436 <ssp_sendrecvdata.constprop.3+0x26>
    return SPI1->DR;
 801043c:	68d0      	ldr	r0, [r2, #12]
}
 801043e:	b2c0      	uxtb	r0, r0
 8010440:	4770      	bx	lr
 8010442:	46c0      	nop			; (mov r8, r8)
 8010444:	40013000 	.word	0x40013000
 8010448:	4001300c 	.word	0x4001300c
 801044c:	00000000 	.word	0x00000000

08010450 <ili9341_read_memory_raw>:
    chMtxUnlock(&mutex_ili9341);
}
#endif

static void ili9341_read_memory_raw(uint8_t cmd, int len, uint16_t* out)
{
 8010450:	b5f0      	push	{r4, r5, r6, r7, lr}
 8010452:	46c6      	mov	lr, r8
 8010454:	000e      	movs	r6, r1
 8010456:	b500      	push	{lr}
    uint8_t r, g, b;
    send_command(cmd, 0, NULL);
 8010458:	2100      	movs	r1, #0
{
 801045a:	0015      	movs	r5, r2
    send_command(cmd, 0, NULL);
 801045c:	2200      	movs	r2, #0
 801045e:	f7ff ffa7 	bl	80103b0 <send_command>
  SPI1->CR2 = (SPI1->CR2 & 0xf0ff) | 0x0700;
 8010462:	4a1c      	ldr	r2, [pc, #112]	; (80104d4 <ili9341_read_memory_raw+0x84>)
 8010464:	491c      	ldr	r1, [pc, #112]	; (80104d8 <ili9341_read_memory_raw+0x88>)
 8010466:	6853      	ldr	r3, [r2, #4]
 8010468:	4019      	ands	r1, r3
 801046a:	23e0      	movs	r3, #224	; 0xe0
 801046c:	00db      	lsls	r3, r3, #3
 801046e:	430b      	orrs	r3, r1
    ssp_databit8();

    // consume old data
    while (!(SPI1->SR & SPI_SR_TXE));
 8010470:	2102      	movs	r1, #2
  SPI1->CR2 = (SPI1->CR2 & 0xf0ff) | 0x0700;
 8010472:	6053      	str	r3, [r2, #4]
    while (!(SPI1->SR & SPI_SR_TXE));
 8010474:	6893      	ldr	r3, [r2, #8]
 8010476:	4219      	tst	r1, r3
 8010478:	d0fc      	beq.n	8010474 <ili9341_read_memory_raw+0x24>
    // clear OVR
    while (SPI1->SR & SPI_SR_RXNE) r = SPI1->DR;
 801047a:	6893      	ldr	r3, [r2, #8]
 801047c:	07db      	lsls	r3, r3, #31
 801047e:	d505      	bpl.n	801048c <ili9341_read_memory_raw+0x3c>
 8010480:	2101      	movs	r1, #1
 8010482:	4b14      	ldr	r3, [pc, #80]	; (80104d4 <ili9341_read_memory_raw+0x84>)
 8010484:	68da      	ldr	r2, [r3, #12]
 8010486:	689a      	ldr	r2, [r3, #8]
 8010488:	4211      	tst	r1, r2
 801048a:	d1fb      	bne.n	8010484 <ili9341_read_memory_raw+0x34>

    // require 8bit dummy clock
    r = ssp_sendrecvdata(0);
 801048c:	f7ff ffc0 	bl	8010410 <ssp_sendrecvdata.constprop.3>

    while (len-- > 0) {
 8010490:	2e00      	cmp	r6, #0
 8010492:	dd19      	ble.n	80104c8 <ili9341_read_memory_raw+0x78>
        // read data is always 18bit
        r = ssp_sendrecvdata(0);
        g = ssp_sendrecvdata(0);
        b = ssp_sendrecvdata(0);
        *out++ = ((r & 0xF8) << 8) | ((g & 0xFC) << 3) | (b >> 3);
 8010494:	27fc      	movs	r7, #252	; 0xfc
 8010496:	0076      	lsls	r6, r6, #1
 8010498:	19ae      	adds	r6, r5, r6
 801049a:	00ff      	lsls	r7, r7, #3
        r = ssp_sendrecvdata(0);
 801049c:	f7ff ffb8 	bl	8010410 <ssp_sendrecvdata.constprop.3>
 80104a0:	0004      	movs	r4, r0
        g = ssp_sendrecvdata(0);
 80104a2:	f7ff ffb5 	bl	8010410 <ssp_sendrecvdata.constprop.3>
 80104a6:	4680      	mov	r8, r0
        b = ssp_sendrecvdata(0);
 80104a8:	f7ff ffb2 	bl	8010410 <ssp_sendrecvdata.constprop.3>
        *out++ = ((r & 0xF8) << 8) | ((g & 0xFC) << 3) | (b >> 3);
 80104ac:	4643      	mov	r3, r8
 80104ae:	0224      	lsls	r4, r4, #8
 80104b0:	0ae4      	lsrs	r4, r4, #11
 80104b2:	00db      	lsls	r3, r3, #3
 80104b4:	02e4      	lsls	r4, r4, #11
 80104b6:	403b      	ands	r3, r7
 80104b8:	08c0      	lsrs	r0, r0, #3
 80104ba:	431c      	orrs	r4, r3
 80104bc:	b2c0      	uxtb	r0, r0
 80104be:	4304      	orrs	r4, r0
 80104c0:	802c      	strh	r4, [r5, #0]
 80104c2:	3502      	adds	r5, #2
    while (len-- > 0) {
 80104c4:	42b5      	cmp	r5, r6
 80104c6:	d1e9      	bne.n	801049c <ili9341_read_memory_raw+0x4c>
    }

    CS_HIGH;
 80104c8:	2240      	movs	r2, #64	; 0x40
 80104ca:	4b04      	ldr	r3, [pc, #16]	; (80104dc <ili9341_read_memory_raw+0x8c>)
 80104cc:	831a      	strh	r2, [r3, #24]
}
 80104ce:	bc04      	pop	{r2}
 80104d0:	4690      	mov	r8, r2
 80104d2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80104d4:	40013000 	.word	0x40013000
 80104d8:	0000f0ff 	.word	0x0000f0ff
 80104dc:	48000400 	.word	0x48000400

080104e0 <ili9341_init>:
{
 80104e0:	b570      	push	{r4, r5, r6, lr}
    chMtxLock(&mutex_ili9341);
 80104e2:	4d2d      	ldr	r5, [pc, #180]	; (8010598 <ili9341_init+0xb8>)
    RESET_ASSERT;
 80104e4:	4e2d      	ldr	r6, [pc, #180]	; (801059c <ili9341_init+0xbc>)
    chMtxLock(&mutex_ili9341);
 80104e6:	0028      	movs	r0, r5
 80104e8:	f7f3 fdea 	bl	80040c0 <chMtxLock>
  rccEnableSPI1(FALSE);
 80104ec:	2380      	movs	r3, #128	; 0x80
 80104ee:	4a2c      	ldr	r2, [pc, #176]	; (80105a0 <ili9341_init+0xc0>)
 80104f0:	015b      	lsls	r3, r3, #5
 80104f2:	6991      	ldr	r1, [r2, #24]
  dmatx     = STM32_DMA_STREAM(STM32_SPI_SPI1_TX_DMA_STREAM);
 80104f4:	4c2b      	ldr	r4, [pc, #172]	; (80105a4 <ili9341_init+0xc4>)
  rccEnableSPI1(FALSE);
 80104f6:	430b      	orrs	r3, r1
 80104f8:	6193      	str	r3, [r2, #24]
  txdmamode = STM32_DMA_CR_CHSEL(SPI1_TX_DMA_CHANNEL) |
 80104fa:	4b2b      	ldr	r3, [pc, #172]	; (80105a8 <ili9341_init+0xc8>)
 80104fc:	4a2b      	ldr	r2, [pc, #172]	; (80105ac <ili9341_init+0xcc>)
  dmatx     = STM32_DMA_STREAM(STM32_SPI_SPI1_TX_DMA_STREAM);
 80104fe:	482c      	ldr	r0, [pc, #176]	; (80105b0 <ili9341_init+0xd0>)
  txdmamode = STM32_DMA_CR_CHSEL(SPI1_TX_DMA_CHANNEL) |
 8010500:	601a      	str	r2, [r3, #0]
  dmaStreamAllocate(dmatx,
 8010502:	2102      	movs	r1, #2
 8010504:	2300      	movs	r3, #0
 8010506:	4a2b      	ldr	r2, [pc, #172]	; (80105b4 <ili9341_init+0xd4>)
  dmatx     = STM32_DMA_STREAM(STM32_SPI_SPI1_TX_DMA_STREAM);
 8010508:	6020      	str	r0, [r4, #0]
  dmaStreamAllocate(dmatx,
 801050a:	f7f5 fac9 	bl	8005aa0 <dmaStreamAllocate>
  dmaStreamSetPeripheral(dmatx, &SPI1->DR);
 801050e:	6823      	ldr	r3, [r4, #0]
 8010510:	4a29      	ldr	r2, [pc, #164]	; (80105b8 <ili9341_init+0xd8>)
 8010512:	685b      	ldr	r3, [r3, #4]
  SPI1->CR1 |= SPI_CR1_SPE;  
 8010514:	2140      	movs	r1, #64	; 0x40
  dmaStreamSetPeripheral(dmatx, &SPI1->DR);
 8010516:	609a      	str	r2, [r3, #8]
  SPI1->CR1 = 0;
 8010518:	2200      	movs	r2, #0
 801051a:	4b28      	ldr	r3, [pc, #160]	; (80105bc <ili9341_init+0xdc>)
    RESET_ASSERT;
 801051c:	2490      	movs	r4, #144	; 0x90
  SPI1->CR1 = 0;
 801051e:	601a      	str	r2, [r3, #0]
  SPI1->CR1 = SPI_CR1_MSTR | SPI_CR1_SSM | SPI_CR1_SSI;// | SPI_CR1_BR_1;
 8010520:	22c1      	movs	r2, #193	; 0xc1
 8010522:	0092      	lsls	r2, r2, #2
 8010524:	601a      	str	r2, [r3, #0]
  SPI1->CR2 = 0x0700 | SPI_CR2_TXDMAEN | SPI_CR2_FRXTH;
 8010526:	4a26      	ldr	r2, [pc, #152]	; (80105c0 <ili9341_init+0xe0>)
    RESET_ASSERT;
 8010528:	05e4      	lsls	r4, r4, #23
  SPI1->CR2 = 0x0700 | SPI_CR2_TXDMAEN | SPI_CR2_FRXTH;
 801052a:	605a      	str	r2, [r3, #4]
  SPI1->CR1 |= SPI_CR1_SPE;  
 801052c:	681a      	ldr	r2, [r3, #0]
    chThdSleepMilliseconds(10);
 801052e:	2064      	movs	r0, #100	; 0x64
  SPI1->CR1 |= SPI_CR1_SPE;  
 8010530:	430a      	orrs	r2, r1
 8010532:	601a      	str	r2, [r3, #0]
    DC_DATA;
 8010534:	2280      	movs	r2, #128	; 0x80
 8010536:	4b23      	ldr	r3, [pc, #140]	; (80105c4 <ili9341_init+0xe4>)
 8010538:	831a      	strh	r2, [r3, #24]
    RESET_ASSERT;
 801053a:	8366      	strh	r6, [r4, #26]
    chThdSleepMilliseconds(10);
 801053c:	f7f3 fce8 	bl	8003f10 <chThdSleep>
    send_command(0x01, 0, NULL); // SW reset
 8010540:	2200      	movs	r2, #0
 8010542:	2100      	movs	r1, #0
    RESET_NEGATE;
 8010544:	8326      	strh	r6, [r4, #24]
    send_command(0x01, 0, NULL); // SW reset
 8010546:	2001      	movs	r0, #1
 8010548:	f7ff ff32 	bl	80103b0 <send_command>
    chThdSleepMilliseconds(5);
 801054c:	2032      	movs	r0, #50	; 0x32
 801054e:	f7f3 fcdf 	bl	8003f10 <chThdSleep>
    send_command(0x28, 0, NULL); // display off
 8010552:	2100      	movs	r1, #0
 8010554:	2028      	movs	r0, #40	; 0x28
 8010556:	2200      	movs	r2, #0
 8010558:	f7ff ff2a 	bl	80103b0 <send_command>
 801055c:	2103      	movs	r1, #3
    for (p = ili9341_init_seq; *p; ) {
 801055e:	4c1a      	ldr	r4, [pc, #104]	; (80105c8 <ili9341_init+0xe8>)
 8010560:	20cf      	movs	r0, #207	; 0xcf
 8010562:	e000      	b.n	8010566 <ili9341_init+0x86>
 8010564:	7861      	ldrb	r1, [r4, #1]
        send_command(p[0], p[1], &p[2]);
 8010566:	1ca2      	adds	r2, r4, #2
 8010568:	f7ff ff22 	bl	80103b0 <send_command>
        p += 2 + p[1];
 801056c:	7863      	ldrb	r3, [r4, #1]
        chThdSleepMilliseconds(5);
 801056e:	2032      	movs	r0, #50	; 0x32
        p += 2 + p[1];
 8010570:	3302      	adds	r3, #2
 8010572:	18e4      	adds	r4, r4, r3
        chThdSleepMilliseconds(5);
 8010574:	f7f3 fccc 	bl	8003f10 <chThdSleep>
    for (p = ili9341_init_seq; *p; ) {
 8010578:	7820      	ldrb	r0, [r4, #0]
 801057a:	2800      	cmp	r0, #0
 801057c:	d1f2      	bne.n	8010564 <ili9341_init+0x84>
    chThdSleepMilliseconds(100);
 801057e:	20fa      	movs	r0, #250	; 0xfa
 8010580:	0080      	lsls	r0, r0, #2
 8010582:	f7f3 fcc5 	bl	8003f10 <chThdSleep>
    send_command(0x29, 0, NULL); // display on
 8010586:	2200      	movs	r2, #0
 8010588:	2100      	movs	r1, #0
 801058a:	2029      	movs	r0, #41	; 0x29
 801058c:	f7ff ff10 	bl	80103b0 <send_command>
    chMtxUnlock(&mutex_ili9341);
 8010590:	0028      	movs	r0, r5
 8010592:	f7f3 fd9d 	bl	80040d0 <chMtxUnlock>
}
 8010596:	bd70      	pop	{r4, r5, r6, pc}
 8010598:	2000220c 	.word	0x2000220c
 801059c:	ffff8000 	.word	0xffff8000
 80105a0:	40021000 	.word	0x40021000
 80105a4:	200030a8 	.word	0x200030a8
 80105a8:	200038ac 	.word	0x200038ac
 80105ac:	00001518 	.word	0x00001518
 80105b0:	0801368c 	.word	0x0801368c
 80105b4:	080103a1 	.word	0x080103a1
 80105b8:	4001300c 	.word	0x4001300c
 80105bc:	40013000 	.word	0x40013000
 80105c0:	00001702 	.word	0x00001702
 80105c4:	48000400 	.word	0x48000400
 80105c8:	080156e0 	.word	0x080156e0
 80105cc:	00000000 	.word	0x00000000

080105d0 <ili9341_fill>:
{
 80105d0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80105d2:	46c6      	mov	lr, r8
 80105d4:	b500      	push	{lr}
    chMtxLock(&mutex_ili9341);
 80105d6:	4d22      	ldr	r5, [pc, #136]	; (8010660 <ili9341_fill+0x90>)
{
 80105d8:	b082      	sub	sp, #8
 80105da:	0007      	movs	r7, r0
    chMtxLock(&mutex_ili9341);
 80105dc:	0028      	movs	r0, r5
{
 80105de:	001c      	movs	r4, r3
 80105e0:	4688      	mov	r8, r1
 80105e2:	0016      	movs	r6, r2
    chMtxLock(&mutex_ili9341);
 80105e4:	f7f3 fd6c 	bl	80040c0 <chMtxLock>
	uint8_t xx[4] = { x >> 8, x, (x+w-1) >> 8, (x+w-1) };
 80105e8:	466a      	mov	r2, sp
 80105ea:	ba7b      	rev16	r3, r7
 80105ec:	8013      	strh	r3, [r2, #0]
 80105ee:	19bb      	adds	r3, r7, r6
 80105f0:	3b01      	subs	r3, #1
 80105f2:	121b      	asrs	r3, r3, #8
 80105f4:	7093      	strb	r3, [r2, #2]
	uint8_t yy[4] = { y >> 8, y, (y+h-1) >> 8, (y+h-1) };
 80105f6:	4643      	mov	r3, r8
	uint8_t xx[4] = { x >> 8, x, (x+w-1) >> 8, (x+w-1) };
 80105f8:	1e70      	subs	r0, r6, #1
 80105fa:	19c0      	adds	r0, r0, r7
	uint8_t yy[4] = { y >> 8, y, (y+h-1) >> 8, (y+h-1) };
 80105fc:	ba5b      	rev16	r3, r3
 80105fe:	af01      	add	r7, sp, #4
 8010600:	803b      	strh	r3, [r7, #0]
 8010602:	4643      	mov	r3, r8
 8010604:	191b      	adds	r3, r3, r4
 8010606:	3b01      	subs	r3, #1
 8010608:	121b      	asrs	r3, r3, #8
 801060a:	70bb      	strb	r3, [r7, #2]
 801060c:	1e63      	subs	r3, r4, #1
 801060e:	4443      	add	r3, r8
	uint8_t xx[4] = { x >> 8, x, (x+w-1) >> 8, (x+w-1) };
 8010610:	70d0      	strb	r0, [r2, #3]
	send_command(0x2A, 4, xx);
 8010612:	2104      	movs	r1, #4
 8010614:	202a      	movs	r0, #42	; 0x2a
	uint8_t yy[4] = { y >> 8, y, (y+h-1) >> 8, (y+h-1) };
 8010616:	70fb      	strb	r3, [r7, #3]
	send_command(0x2A, 4, xx);
 8010618:	f7ff feca 	bl	80103b0 <send_command>
    send_command(0x2B, 4, yy);
 801061c:	003a      	movs	r2, r7
 801061e:	2104      	movs	r1, #4
 8010620:	202b      	movs	r0, #43	; 0x2b
 8010622:	f7ff fec5 	bl	80103b0 <send_command>
    int len = w * h;
 8010626:	4366      	muls	r6, r4
    send_command(0x2C, 0, NULL);
 8010628:	202c      	movs	r0, #44	; 0x2c
 801062a:	2200      	movs	r2, #0
 801062c:	2100      	movs	r1, #0
 801062e:	f7ff febf 	bl	80103b0 <send_command>
    while (len-- > 0) 
 8010632:	9b08      	ldr	r3, [sp, #32]
 8010634:	1e70      	subs	r0, r6, #1
 8010636:	041c      	lsls	r4, r3, #16
 8010638:	0c24      	lsrs	r4, r4, #16
 801063a:	2e00      	cmp	r6, #0
 801063c:	dd09      	ble.n	8010652 <ili9341_fill+0x82>
  while ((SPI1->SR & 0x1800) == 0x1800)
 801063e:	22c0      	movs	r2, #192	; 0xc0
 8010640:	4908      	ldr	r1, [pc, #32]	; (8010664 <ili9341_fill+0x94>)
 8010642:	0152      	lsls	r2, r2, #5
 8010644:	688b      	ldr	r3, [r1, #8]
 8010646:	4013      	ands	r3, r2
 8010648:	4293      	cmp	r3, r2
 801064a:	d0fb      	beq.n	8010644 <ili9341_fill+0x74>
  SPI1->DR = x;
 801064c:	60cc      	str	r4, [r1, #12]
    while (len-- > 0) 
 801064e:	3801      	subs	r0, #1
 8010650:	d2f8      	bcs.n	8010644 <ili9341_fill+0x74>
    chMtxUnlock(&mutex_ili9341);
 8010652:	0028      	movs	r0, r5
 8010654:	f7f3 fd3c 	bl	80040d0 <chMtxUnlock>
}
 8010658:	b002      	add	sp, #8
 801065a:	bc04      	pop	{r2}
 801065c:	4690      	mov	r8, r2
 801065e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8010660:	2000220c 	.word	0x2000220c
 8010664:	40013000 	.word	0x40013000
	...

08010670 <ili9341_bulk>:
{
 8010670:	b5f0      	push	{r4, r5, r6, r7, lr}
 8010672:	46c6      	mov	lr, r8
 8010674:	b500      	push	{lr}
    chMtxLock(&mutex_ili9341);
 8010676:	4e27      	ldr	r6, [pc, #156]	; (8010714 <ili9341_bulk+0xa4>)
{
 8010678:	b082      	sub	sp, #8
 801067a:	0005      	movs	r5, r0
    chMtxLock(&mutex_ili9341);
 801067c:	0030      	movs	r0, r6
{
 801067e:	4688      	mov	r8, r1
 8010680:	0017      	movs	r7, r2
 8010682:	001c      	movs	r4, r3
    chMtxLock(&mutex_ili9341);
 8010684:	f7f3 fd1c 	bl	80040c0 <chMtxLock>
	uint8_t xx[4] = { x >> 8, x, (x+w-1) >> 8, (x+w-1) };
 8010688:	466a      	mov	r2, sp
 801068a:	ba6b      	rev16	r3, r5
 801068c:	8013      	strh	r3, [r2, #0]
 801068e:	19eb      	adds	r3, r5, r7
 8010690:	3b01      	subs	r3, #1
 8010692:	121b      	asrs	r3, r3, #8
 8010694:	7093      	strb	r3, [r2, #2]
	uint8_t yy[4] = { y >> 8, y, (y+h-1) >> 8, (y+h-1) };
 8010696:	4643      	mov	r3, r8
	uint8_t xx[4] = { x >> 8, x, (x+w-1) >> 8, (x+w-1) };
 8010698:	1e78      	subs	r0, r7, #1
 801069a:	1940      	adds	r0, r0, r5
	uint8_t yy[4] = { y >> 8, y, (y+h-1) >> 8, (y+h-1) };
 801069c:	ba5b      	rev16	r3, r3
 801069e:	ad01      	add	r5, sp, #4
 80106a0:	802b      	strh	r3, [r5, #0]
 80106a2:	4643      	mov	r3, r8
 80106a4:	191b      	adds	r3, r3, r4
 80106a6:	3b01      	subs	r3, #1
 80106a8:	121b      	asrs	r3, r3, #8
 80106aa:	70ab      	strb	r3, [r5, #2]
 80106ac:	1e63      	subs	r3, r4, #1
 80106ae:	4443      	add	r3, r8
	uint8_t xx[4] = { x >> 8, x, (x+w-1) >> 8, (x+w-1) };
 80106b0:	70d0      	strb	r0, [r2, #3]
	send_command(0x2A, 4, xx);
 80106b2:	2104      	movs	r1, #4
 80106b4:	202a      	movs	r0, #42	; 0x2a
	uint8_t yy[4] = { y >> 8, y, (y+h-1) >> 8, (y+h-1) };
 80106b6:	70eb      	strb	r3, [r5, #3]
	send_command(0x2A, 4, xx);
 80106b8:	f7ff fe7a 	bl	80103b0 <send_command>
	send_command(0x2B, 4, yy);
 80106bc:	002a      	movs	r2, r5
 80106be:	2104      	movs	r1, #4
 80106c0:	202b      	movs	r0, #43	; 0x2b
 80106c2:	f7ff fe75 	bl	80103b0 <send_command>
	send_command(0x2C, 0, NULL);
 80106c6:	2200      	movs	r2, #0
 80106c8:	2100      	movs	r1, #0
 80106ca:	202c      	movs	r0, #44	; 0x2c
 80106cc:	f7ff fe70 	bl	80103b0 <send_command>
    dmaStreamSetMemory0(dmatx, spi_buffer);
 80106d0:	4b11      	ldr	r3, [pc, #68]	; (8010718 <ili9341_bulk+0xa8>)
    int len = w * h;
 80106d2:	437c      	muls	r4, r7
    dmaStreamSetMemory0(dmatx, spi_buffer);
 80106d4:	681a      	ldr	r2, [r3, #0]
 80106d6:	4b11      	ldr	r3, [pc, #68]	; (801071c <ili9341_bulk+0xac>)
 80106d8:	6851      	ldr	r1, [r2, #4]
 80106da:	60cb      	str	r3, [r1, #12]
    dmaStreamSetMode(dmatx, txdmamode | STM32_DMA_CR_MINC);
 80106dc:	4b10      	ldr	r3, [pc, #64]	; (8010720 <ili9341_bulk+0xb0>)
    dmaStreamSetTransactionSize(dmatx, len);
 80106de:	604c      	str	r4, [r1, #4]
    dmaStreamSetMode(dmatx, txdmamode | STM32_DMA_CR_MINC);
 80106e0:	6818      	ldr	r0, [r3, #0]
 80106e2:	2380      	movs	r3, #128	; 0x80
 80106e4:	4303      	orrs	r3, r0
    dmaStreamEnable(dmatx);
 80106e6:	2001      	movs	r0, #1
    dmaStreamSetMode(dmatx, txdmamode | STM32_DMA_CR_MINC);
 80106e8:	600b      	str	r3, [r1, #0]
    dmaStreamEnable(dmatx);
 80106ea:	680b      	ldr	r3, [r1, #0]
 80106ec:	4303      	orrs	r3, r0
 80106ee:	600b      	str	r3, [r1, #0]
    dmaWaitCompletion(dmatx);
 80106f0:	684b      	ldr	r3, [r1, #4]
 80106f2:	2b00      	cmp	r3, #0
 80106f4:	d1fc      	bne.n	80106f0 <ili9341_bulk+0x80>
 80106f6:	6808      	ldr	r0, [r1, #0]
 80106f8:	330f      	adds	r3, #15
 80106fa:	4398      	bics	r0, r3
 80106fc:	6008      	str	r0, [r1, #0]
 80106fe:	6811      	ldr	r1, [r2, #0]
 8010700:	7c12      	ldrb	r2, [r2, #16]
    chMtxUnlock(&mutex_ili9341);
 8010702:	0030      	movs	r0, r6
    dmaWaitCompletion(dmatx);
 8010704:	4093      	lsls	r3, r2
 8010706:	604b      	str	r3, [r1, #4]
    chMtxUnlock(&mutex_ili9341);
 8010708:	f7f3 fce2 	bl	80040d0 <chMtxUnlock>
}
 801070c:	b002      	add	sp, #8
 801070e:	bc04      	pop	{r2}
 8010710:	4690      	mov	r8, r2
 8010712:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8010714:	2000220c 	.word	0x2000220c
 8010718:	200030a8 	.word	0x200030a8
 801071c:	200030ac 	.word	0x200030ac
 8010720:	200038ac 	.word	0x200038ac
	...

08010730 <ili9341_read_memory>:

void ili9341_read_memory(int x, int y, int w, int h, int len, uint16_t *out)
{
 8010730:	b5f0      	push	{r4, r5, r6, r7, lr}
 8010732:	46c6      	mov	lr, r8
 8010734:	4680      	mov	r8, r0
 8010736:	b500      	push	{lr}
    chMtxLock(&mutex_ili9341);
 8010738:	4e19      	ldr	r6, [pc, #100]	; (80107a0 <ili9341_read_memory+0x70>)
{
 801073a:	b082      	sub	sp, #8
    chMtxLock(&mutex_ili9341);
 801073c:	0030      	movs	r0, r6
{
 801073e:	000f      	movs	r7, r1
 8010740:	0015      	movs	r5, r2
 8010742:	001c      	movs	r4, r3
    chMtxLock(&mutex_ili9341);
 8010744:	f7f3 fcbc 	bl	80040c0 <chMtxLock>
    uint8_t xx[4] = { x >> 8, x, (x+w-1) >> 8, (x+w-1) };
 8010748:	4643      	mov	r3, r8
 801074a:	466a      	mov	r2, sp
 801074c:	ba5b      	rev16	r3, r3
 801074e:	8013      	strh	r3, [r2, #0]
 8010750:	4643      	mov	r3, r8
 8010752:	195b      	adds	r3, r3, r5
 8010754:	3b01      	subs	r3, #1
 8010756:	3d01      	subs	r5, #1
 8010758:	4445      	add	r5, r8
 801075a:	121b      	asrs	r3, r3, #8
 801075c:	7093      	strb	r3, [r2, #2]
 801075e:	70d5      	strb	r5, [r2, #3]
    uint8_t yy[4] = { y >> 8, y, (y+h-1) >> 8, (y+h-1) };
 8010760:	ba7b      	rev16	r3, r7
 8010762:	ad01      	add	r5, sp, #4
 8010764:	802b      	strh	r3, [r5, #0]
 8010766:	193b      	adds	r3, r7, r4
 8010768:	3b01      	subs	r3, #1
 801076a:	3c01      	subs	r4, #1
 801076c:	121b      	asrs	r3, r3, #8
 801076e:	19e4      	adds	r4, r4, r7

    send_command(0x2A, 4, xx);
 8010770:	2104      	movs	r1, #4
 8010772:	202a      	movs	r0, #42	; 0x2a
    uint8_t yy[4] = { y >> 8, y, (y+h-1) >> 8, (y+h-1) };
 8010774:	70ab      	strb	r3, [r5, #2]
 8010776:	70ec      	strb	r4, [r5, #3]
    send_command(0x2A, 4, xx);
 8010778:	f7ff fe1a 	bl	80103b0 <send_command>
    send_command(0x2B, 4, yy);
 801077c:	002a      	movs	r2, r5
 801077e:	2104      	movs	r1, #4
 8010780:	202b      	movs	r0, #43	; 0x2b
 8010782:	f7ff fe15 	bl	80103b0 <send_command>

    ili9341_read_memory_raw(0x2E, len, out);
 8010786:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8010788:	9908      	ldr	r1, [sp, #32]
 801078a:	202e      	movs	r0, #46	; 0x2e
 801078c:	f7ff fe60 	bl	8010450 <ili9341_read_memory_raw>
    chMtxUnlock(&mutex_ili9341);
 8010790:	0030      	movs	r0, r6
 8010792:	f7f3 fc9d 	bl	80040d0 <chMtxUnlock>
}
 8010796:	b002      	add	sp, #8
 8010798:	bc04      	pop	{r2}
 801079a:	4690      	mov	r8, r2
 801079c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801079e:	46c0      	nop			; (mov r8, r8)
 80107a0:	2000220c 	.word	0x2000220c
	...

080107b0 <ili9341_read_memory_continue>:

void ili9341_read_memory_continue(int len, uint16_t* out)
{
 80107b0:	b570      	push	{r4, r5, r6, lr}
 80107b2:	000e      	movs	r6, r1
 80107b4:	0005      	movs	r5, r0
    chMtxLock(&mutex_ili9341);
 80107b6:	4c06      	ldr	r4, [pc, #24]	; (80107d0 <ili9341_read_memory_continue+0x20>)
 80107b8:	0020      	movs	r0, r4
 80107ba:	f7f3 fc81 	bl	80040c0 <chMtxLock>
    ili9341_read_memory_raw(0x3E, len, out);
 80107be:	0032      	movs	r2, r6
 80107c0:	0029      	movs	r1, r5
 80107c2:	203e      	movs	r0, #62	; 0x3e
 80107c4:	f7ff fe44 	bl	8010450 <ili9341_read_memory_raw>
    chMtxUnlock(&mutex_ili9341);
 80107c8:	0020      	movs	r0, r4
 80107ca:	f7f3 fc81 	bl	80040d0 <chMtxUnlock>
}
 80107ce:	bd70      	pop	{r4, r5, r6, pc}
 80107d0:	2000220c 	.word	0x2000220c
	...

080107e0 <ili9341_drawchar_7x13>:
}

#else

void ili9341_drawchar_7x13(uint8_t ch, int x, int y, uint16_t fg, uint16_t bg)
{
 80107e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80107e2:	4647      	mov	r7, r8
 80107e4:	46ce      	mov	lr, r9
 80107e6:	b580      	push	{r7, lr}
 80107e8:	4694      	mov	ip, r2
 80107ea:	aa08      	add	r2, sp, #32
 80107ec:	4688      	mov	r8, r1
 80107ee:	8811      	ldrh	r1, [r2, #0]
  uint16_t *buf = spi_buffer;
  uint16_t bits;
  int c, r;
  for(c = 0; c < 13; c++) {
    bits = x7x13b_bits[(ch * 13) + c];
 80107f0:	0042      	lsls	r2, r0, #1
 80107f2:	1812      	adds	r2, r2, r0
 80107f4:	0092      	lsls	r2, r2, #2
 80107f6:	1812      	adds	r2, r2, r0
 80107f8:	4811      	ldr	r0, [pc, #68]	; (8010840 <ili9341_drawchar_7x13+0x60>)
 80107fa:	0052      	lsls	r2, r2, #1
 80107fc:	1810      	adds	r0, r2, r0
 80107fe:	22b6      	movs	r2, #182	; 0xb6
 8010800:	4691      	mov	r9, r2
 8010802:	4f10      	ldr	r7, [pc, #64]	; (8010844 <ili9341_drawchar_7x13+0x64>)
 8010804:	44b9      	add	r9, r7
 8010806:	003c      	movs	r4, r7
 8010808:	8802      	ldrh	r2, [r0, #0]
    for (r = 0; r < 7; r++) {
 801080a:	3c0e      	subs	r4, #14
      *buf++ = (0x8000 & bits) ? fg : bg;
 801080c:	b215      	sxth	r5, r2
 801080e:	001e      	movs	r6, r3
 8010810:	2d00      	cmp	r5, #0
 8010812:	db00      	blt.n	8010816 <ili9341_drawchar_7x13+0x36>
 8010814:	000e      	movs	r6, r1
 8010816:	8026      	strh	r6, [r4, #0]
      bits <<= 1;
 8010818:	0052      	lsls	r2, r2, #1
 801081a:	3402      	adds	r4, #2
 801081c:	b292      	uxth	r2, r2
    for (r = 0; r < 7; r++) {
 801081e:	42bc      	cmp	r4, r7
 8010820:	d1f4      	bne.n	801080c <ili9341_drawchar_7x13+0x2c>
 8010822:	340e      	adds	r4, #14
 8010824:	0027      	movs	r7, r4
 8010826:	3002      	adds	r0, #2
  for(c = 0; c < 13; c++) {
 8010828:	454c      	cmp	r4, r9
 801082a:	d1ec      	bne.n	8010806 <ili9341_drawchar_7x13+0x26>
    }
  }
  ili9341_bulk(x, y, 7, 13);
 801082c:	4640      	mov	r0, r8
 801082e:	230d      	movs	r3, #13
 8010830:	2207      	movs	r2, #7
 8010832:	4661      	mov	r1, ip
 8010834:	f7ff ff1c 	bl	8010670 <ili9341_bulk>
}
 8010838:	bc0c      	pop	{r2, r3}
 801083a:	4690      	mov	r8, r2
 801083c:	4699      	mov	r9, r3
 801083e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8010840:	08015d48 	.word	0x08015d48
 8010844:	200030ba 	.word	0x200030ba
	...

08010850 <ili9341_drawstring_7x13>:

void
ili9341_drawstring_7x13(const char *str, int x, int y, uint16_t fg, uint16_t bg)
{
 8010850:	b5f0      	push	{r4, r5, r6, r7, lr}
 8010852:	46ce      	mov	lr, r9
 8010854:	4647      	mov	r7, r8
 8010856:	0004      	movs	r4, r0
 8010858:	b580      	push	{r7, lr}
 801085a:	b083      	sub	sp, #12
 801085c:	001f      	movs	r7, r3
 801085e:	ab0a      	add	r3, sp, #40	; 0x28
 8010860:	881e      	ldrh	r6, [r3, #0]
chMtxLock(&mutex_ili9341);
 8010862:	4b0e      	ldr	r3, [pc, #56]	; (801089c <ili9341_drawstring_7x13+0x4c>)
{
 8010864:	000d      	movs	r5, r1
chMtxLock(&mutex_ili9341);
 8010866:	0018      	movs	r0, r3
{
 8010868:	4690      	mov	r8, r2
chMtxLock(&mutex_ili9341);
 801086a:	4699      	mov	r9, r3
 801086c:	f7f3 fc28 	bl	80040c0 <chMtxLock>
  while (*str) {
 8010870:	7820      	ldrb	r0, [r4, #0]
 8010872:	2800      	cmp	r0, #0
 8010874:	d00a      	beq.n	801088c <ili9341_drawstring_7x13+0x3c>
    ili9341_drawchar_7x13(*str, x, y, fg, bg);
 8010876:	0029      	movs	r1, r5
 8010878:	9600      	str	r6, [sp, #0]
 801087a:	003b      	movs	r3, r7
 801087c:	4642      	mov	r2, r8
    x += 7;
    str++;
 801087e:	3401      	adds	r4, #1
    ili9341_drawchar_7x13(*str, x, y, fg, bg);
 8010880:	f7ff ffae 	bl	80107e0 <ili9341_drawchar_7x13>
  while (*str) {
 8010884:	7820      	ldrb	r0, [r4, #0]
    x += 7;
 8010886:	3507      	adds	r5, #7
  while (*str) {
 8010888:	2800      	cmp	r0, #0
 801088a:	d1f4      	bne.n	8010876 <ili9341_drawstring_7x13+0x26>
  }
chMtxUnlock(&mutex_ili9341);
 801088c:	4648      	mov	r0, r9
 801088e:	f7f3 fc1f 	bl	80040d0 <chMtxUnlock>
}
 8010892:	b003      	add	sp, #12
 8010894:	bc0c      	pop	{r2, r3}
 8010896:	4690      	mov	r8, r2
 8010898:	4699      	mov	r9, r3
 801089a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801089c:	2000220c 	.word	0x2000220c

080108a0 <ili9341_drawchar_size>:


void
ili9341_drawchar_size(uint8_t ch, int x, int y, uint16_t fg, uint16_t bg, uint8_t size)
{
 80108a0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80108a2:	46de      	mov	lr, fp
 80108a4:	4657      	mov	r7, sl
 80108a6:	464e      	mov	r6, r9
 80108a8:	4645      	mov	r5, r8
 80108aa:	b5e0      	push	{r5, r6, r7, lr}
 80108ac:	b087      	sub	sp, #28
 80108ae:	4699      	mov	r9, r3
 80108b0:	ab10      	add	r3, sp, #64	; 0x40
 80108b2:	881b      	ldrh	r3, [r3, #0]
 80108b4:	0004      	movs	r4, r0
 80108b6:	469b      	mov	fp, r3
 80108b8:	ab11      	add	r3, sp, #68	; 0x44
 80108ba:	781f      	ldrb	r7, [r3, #0]
  chMtxLock(&mutex_ili9341);
 80108bc:	482b      	ldr	r0, [pc, #172]	; (801096c <ili9341_drawchar_size+0xcc>)
{
 80108be:	9205      	str	r2, [sp, #20]
 80108c0:	9104      	str	r1, [sp, #16]
  chMtxLock(&mutex_ili9341);
 80108c2:	f7f3 fbfd 	bl	80040c0 <chMtxLock>
  uint16_t *buf = spi_buffer;
  uint16_t bits;
  int c, r;
  for(c = 0; c < 13*size; c++) {
 80108c6:	007b      	lsls	r3, r7, #1
 80108c8:	19db      	adds	r3, r3, r7
 80108ca:	009b      	lsls	r3, r3, #2
 80108cc:	19da      	adds	r2, r3, r7
 80108ce:	00fb      	lsls	r3, r7, #3
 80108d0:	1bdb      	subs	r3, r3, r7
 80108d2:	9201      	str	r2, [sp, #4]
 80108d4:	4698      	mov	r8, r3
 80108d6:	2a00      	cmp	r2, #0
 80108d8:	d038      	beq.n	801094c <ili9341_drawchar_size+0xac>
    bits = x7x13b_bits[(ch * 13) + (c / size)];
 80108da:	0063      	lsls	r3, r4, #1
 80108dc:	191b      	adds	r3, r3, r4
 80108de:	009b      	lsls	r3, r3, #2
 80108e0:	191b      	adds	r3, r3, r4
 80108e2:	9302      	str	r3, [sp, #8]
 80108e4:	4643      	mov	r3, r8
 80108e6:	005b      	lsls	r3, r3, #1
 80108e8:	9303      	str	r3, [sp, #12]
  for(c = 0; c < 13*size; c++) {
 80108ea:	2300      	movs	r3, #0
 80108ec:	9300      	str	r3, [sp, #0]
 80108ee:	1e7b      	subs	r3, r7, #1
 80108f0:	469a      	mov	sl, r3
 80108f2:	003b      	movs	r3, r7
 80108f4:	4647      	mov	r7, r8
 80108f6:	4698      	mov	r8, r3
  uint16_t *buf = spi_buffer;
 80108f8:	4e1d      	ldr	r6, [pc, #116]	; (8010970 <ili9341_drawchar_size+0xd0>)
    bits = x7x13b_bits[(ch * 13) + (c / size)];
 80108fa:	4641      	mov	r1, r8
 80108fc:	9800      	ldr	r0, [sp, #0]
 80108fe:	f7ef fcf7 	bl	80002f0 <__divsi3>
 8010902:	9b02      	ldr	r3, [sp, #8]
 8010904:	469c      	mov	ip, r3
 8010906:	4b1b      	ldr	r3, [pc, #108]	; (8010974 <ili9341_drawchar_size+0xd4>)
 8010908:	4460      	add	r0, ip
 801090a:	0040      	lsls	r0, r0, #1
 801090c:	5a1d      	ldrh	r5, [r3, r0]
    for (r = 0; r < 7*size; r++) {
 801090e:	2f00      	cmp	r7, #0
 8010910:	d015      	beq.n	801093e <ili9341_drawchar_size+0x9e>
 8010912:	2400      	movs	r4, #0
      *buf++ = (0x8000 & bits) ? fg : bg;
 8010914:	b22b      	sxth	r3, r5
 8010916:	464a      	mov	r2, r9
 8010918:	2b00      	cmp	r3, #0
 801091a:	db00      	blt.n	801091e <ili9341_drawchar_size+0x7e>
 801091c:	465a      	mov	r2, fp
 801091e:	0063      	lsls	r3, r4, #1
 8010920:	52f2      	strh	r2, [r6, r3]
      if (r % size == (size-1)) {
 8010922:	4641      	mov	r1, r8
 8010924:	0020      	movs	r0, r4
 8010926:	f7ef fdc9 	bl	80004bc <__aeabi_idivmod>
 801092a:	4551      	cmp	r1, sl
 801092c:	d101      	bne.n	8010932 <ili9341_drawchar_size+0x92>
          bits <<= 1;
 801092e:	006d      	lsls	r5, r5, #1
 8010930:	b2ad      	uxth	r5, r5
    for (r = 0; r < 7*size; r++) {
 8010932:	3401      	adds	r4, #1
 8010934:	42a7      	cmp	r7, r4
 8010936:	d1ed      	bne.n	8010914 <ili9341_drawchar_size+0x74>
 8010938:	9b03      	ldr	r3, [sp, #12]
 801093a:	469c      	mov	ip, r3
 801093c:	4466      	add	r6, ip
  for(c = 0; c < 13*size; c++) {
 801093e:	9b00      	ldr	r3, [sp, #0]
 8010940:	9a01      	ldr	r2, [sp, #4]
 8010942:	3301      	adds	r3, #1
 8010944:	9300      	str	r3, [sp, #0]
 8010946:	4293      	cmp	r3, r2
 8010948:	d1d7      	bne.n	80108fa <ili9341_drawchar_size+0x5a>
 801094a:	46b8      	mov	r8, r7
      }
    }
  }
  ili9341_bulk(x, y, 7*size, 13*size);
 801094c:	9b01      	ldr	r3, [sp, #4]
 801094e:	4642      	mov	r2, r8
 8010950:	9905      	ldr	r1, [sp, #20]
 8010952:	9804      	ldr	r0, [sp, #16]
 8010954:	f7ff fe8c 	bl	8010670 <ili9341_bulk>
chMtxUnlock(&mutex_ili9341);
 8010958:	4804      	ldr	r0, [pc, #16]	; (801096c <ili9341_drawchar_size+0xcc>)
 801095a:	f7f3 fbb9 	bl	80040d0 <chMtxUnlock>
}
 801095e:	b007      	add	sp, #28
 8010960:	bc3c      	pop	{r2, r3, r4, r5}
 8010962:	4690      	mov	r8, r2
 8010964:	4699      	mov	r9, r3
 8010966:	46a2      	mov	sl, r4
 8010968:	46ab      	mov	fp, r5
 801096a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801096c:	2000220c 	.word	0x2000220c
 8010970:	200030ac 	.word	0x200030ac
 8010974:	08015d48 	.word	0x08015d48
	...

08010980 <ili9341_drawstring_size>:

void
ili9341_drawstring_size(const char *str, int x, int y, uint16_t fg, uint16_t bg, uint8_t size)
{
 8010980:	b5f0      	push	{r4, r5, r6, r7, lr}
 8010982:	46de      	mov	lr, fp
 8010984:	464e      	mov	r6, r9
 8010986:	4645      	mov	r5, r8
 8010988:	4657      	mov	r7, sl
 801098a:	0004      	movs	r4, r0
 801098c:	b5e0      	push	{r5, r6, r7, lr}
 801098e:	b083      	sub	sp, #12
 8010990:	4699      	mov	r9, r3
 8010992:	ab0c      	add	r3, sp, #48	; 0x30
 8010994:	881b      	ldrh	r3, [r3, #0]
 8010996:	000d      	movs	r5, r1
 8010998:	469a      	mov	sl, r3
 801099a:	ab0d      	add	r3, sp, #52	; 0x34
 801099c:	781e      	ldrb	r6, [r3, #0]
    chMtxLock(&mutex_ili9341);
 801099e:	4b11      	ldr	r3, [pc, #68]	; (80109e4 <ili9341_drawstring_size+0x64>)
{
 80109a0:	4690      	mov	r8, r2
    chMtxLock(&mutex_ili9341);
 80109a2:	0018      	movs	r0, r3
 80109a4:	469b      	mov	fp, r3
 80109a6:	f7f3 fb8b 	bl	80040c0 <chMtxLock>
  while (*str) {
 80109aa:	7820      	ldrb	r0, [r4, #0]
 80109ac:	2800      	cmp	r0, #0
 80109ae:	d00e      	beq.n	80109ce <ili9341_drawstring_size+0x4e>
    ili9341_drawchar_size(*str, x, y, fg, bg, size);
    x += 7 * size;
 80109b0:	00f7      	lsls	r7, r6, #3
 80109b2:	1bbf      	subs	r7, r7, r6
    ili9341_drawchar_size(*str, x, y, fg, bg, size);
 80109b4:	4653      	mov	r3, sl
 80109b6:	0029      	movs	r1, r5
 80109b8:	9300      	str	r3, [sp, #0]
 80109ba:	9601      	str	r6, [sp, #4]
 80109bc:	464b      	mov	r3, r9
 80109be:	4642      	mov	r2, r8
    str++;
 80109c0:	3401      	adds	r4, #1
    ili9341_drawchar_size(*str, x, y, fg, bg, size);
 80109c2:	f7ff ff6d 	bl	80108a0 <ili9341_drawchar_size>
  while (*str) {
 80109c6:	7820      	ldrb	r0, [r4, #0]
    x += 7 * size;
 80109c8:	19ed      	adds	r5, r5, r7
  while (*str) {
 80109ca:	2800      	cmp	r0, #0
 80109cc:	d1f2      	bne.n	80109b4 <ili9341_drawstring_size+0x34>
  }
  chMtxUnlock(&mutex_ili9341);
 80109ce:	4658      	mov	r0, fp
 80109d0:	f7f3 fb7e 	bl	80040d0 <chMtxUnlock>
}
 80109d4:	b003      	add	sp, #12
 80109d6:	bc3c      	pop	{r2, r3, r4, r5}
 80109d8:	4690      	mov	r8, r2
 80109da:	4699      	mov	r9, r3
 80109dc:	46a2      	mov	sl, r4
 80109de:	46ab      	mov	fp, r5
 80109e0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80109e2:	46c0      	nop			; (mov r8, r8)
 80109e4:	2000220c 	.word	0x2000220c
	...

080109f0 <ili9341_line>:


#define SWAP(x,y) { int z=x; x = y; y = z; }

void ili9341_line(int x0, int y0, int x1, int y1, uint16_t fg)
{
 80109f0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80109f2:	4645      	mov	r5, r8
 80109f4:	4657      	mov	r7, sl
 80109f6:	464e      	mov	r6, r9
 80109f8:	46de      	mov	lr, fp
 80109fa:	4690      	mov	r8, r2
 80109fc:	b5e0      	push	{r5, r6, r7, lr}
 80109fe:	b083      	sub	sp, #12
 8010a00:	4699      	mov	r9, r3
 8010a02:	ab0c      	add	r3, sp, #48	; 0x30
 8010a04:	881b      	ldrh	r3, [r3, #0]
 8010a06:	0004      	movs	r4, r0
    chMtxLock(&mutex_ili9341);
 8010a08:	482f      	ldr	r0, [pc, #188]	; (8010ac8 <ili9341_line+0xd8>)
{
 8010a0a:	000d      	movs	r5, r1
 8010a0c:	469a      	mov	sl, r3
    chMtxLock(&mutex_ili9341);
 8010a0e:	f7f3 fb57 	bl	80040c0 <chMtxLock>
    if (x0 > x1) {
 8010a12:	4544      	cmp	r4, r8
 8010a14:	dd05      	ble.n	8010a22 <ili9341_line+0x32>
 8010a16:	002b      	movs	r3, r5
        SWAP(x0, x1);
        SWAP(y0, y1);
 8010a18:	464d      	mov	r5, r9
 8010a1a:	4699      	mov	r9, r3
    if (x0 > x1) {
 8010a1c:	0023      	movs	r3, r4
 8010a1e:	4644      	mov	r4, r8
 8010a20:	4698      	mov	r8, r3
            } else {
                dx /= dy; dy = 1;
            }
        } else {
            dy--;
            if (-dy > dx) {
 8010a22:	2301      	movs	r3, #1
 8010a24:	4646      	mov	r6, r8
 8010a26:	469b      	mov	fp, r3
 8010a28:	e016      	b.n	8010a58 <ili9341_line+0x68>
            dy++;
 8010a2a:	1c5f      	adds	r7, r3, #1
            if (dy > dx) {
 8010a2c:	429a      	cmp	r2, r3
 8010a2e:	da39      	bge.n	8010aa4 <ili9341_line+0xb4>
                dy /= dx; dx = 1;
 8010a30:	0001      	movs	r1, r0
 8010a32:	0038      	movs	r0, r7
 8010a34:	f7ef fc5c 	bl	80002f0 <__divsi3>
 8010a38:	2701      	movs	r7, #1
 8010a3a:	4680      	mov	r8, r0
                    dy /= dx; dx = 1;
            } else {
                dx /= -dy; dy = -1;
            }
        }
        if (dy > 0)
 8010a3c:	1e03      	subs	r3, r0, #0
 8010a3e:	d040      	beq.n	8010ac2 <ili9341_line+0xd2>
            ili9341_fill(x0, y0, dx, dy, fg);
 8010a40:	4653      	mov	r3, sl
 8010a42:	0029      	movs	r1, r5
 8010a44:	9300      	str	r3, [sp, #0]
 8010a46:	0020      	movs	r0, r4
 8010a48:	4643      	mov	r3, r8
 8010a4a:	003a      	movs	r2, r7
        else
            ili9341_fill(x0, y0+dy, dx, -dy, fg);
        x0 += dx;
 8010a4c:	19e4      	adds	r4, r4, r7
            ili9341_fill(x0, y0, dx, dy, fg);
 8010a4e:	f7ff fdbf 	bl	80105d0 <ili9341_fill>
 8010a52:	4445      	add	r5, r8
    while (x0 <= x1) {
 8010a54:	42b4      	cmp	r4, r6
 8010a56:	dc1b      	bgt.n	8010a90 <ili9341_line+0xa0>
        int dy = y1 - y0;
 8010a58:	464b      	mov	r3, r9
        int dx = x1 - x0 + 1;
 8010a5a:	1b32      	subs	r2, r6, r4
 8010a5c:	1c50      	adds	r0, r2, #1
        int dy = y1 - y0;
 8010a5e:	1b5b      	subs	r3, r3, r5
        if (dy >= 0) {
 8010a60:	d5e3      	bpl.n	8010a2a <ili9341_line+0x3a>
            if (-dy > dx) {
 8010a62:	465a      	mov	r2, fp
 8010a64:	1ad1      	subs	r1, r2, r3
 8010a66:	4281      	cmp	r1, r0
 8010a68:	dd23      	ble.n	8010ab2 <ili9341_line+0xc2>
            dy--;
 8010a6a:	3b01      	subs	r3, #1
                    dy /= dx; dx = 1;
 8010a6c:	0001      	movs	r1, r0
 8010a6e:	0018      	movs	r0, r3
 8010a70:	f7ef fc3e 	bl	80002f0 <__divsi3>
 8010a74:	2701      	movs	r7, #1
 8010a76:	4680      	mov	r8, r0
        if (dy > 0)
 8010a78:	4243      	negs	r3, r0
            ili9341_fill(x0, y0+dy, dx, -dy, fg);
 8010a7a:	4652      	mov	r2, sl
 8010a7c:	4445      	add	r5, r8
 8010a7e:	9200      	str	r2, [sp, #0]
 8010a80:	0020      	movs	r0, r4
 8010a82:	003a      	movs	r2, r7
 8010a84:	0029      	movs	r1, r5
        x0 += dx;
 8010a86:	19e4      	adds	r4, r4, r7
            ili9341_fill(x0, y0+dy, dx, -dy, fg);
 8010a88:	f7ff fda2 	bl	80105d0 <ili9341_fill>
    while (x0 <= x1) {
 8010a8c:	42b4      	cmp	r4, r6
 8010a8e:	dde3      	ble.n	8010a58 <ili9341_line+0x68>
        y0 += dy;
    }
    chMtxUnlock(&mutex_ili9341);
 8010a90:	480d      	ldr	r0, [pc, #52]	; (8010ac8 <ili9341_line+0xd8>)
 8010a92:	f7f3 fb1d 	bl	80040d0 <chMtxUnlock>
}
 8010a96:	b003      	add	sp, #12
 8010a98:	bc3c      	pop	{r2, r3, r4, r5}
 8010a9a:	4690      	mov	r8, r2
 8010a9c:	4699      	mov	r9, r3
 8010a9e:	46a2      	mov	sl, r4
 8010aa0:	46ab      	mov	fp, r5
 8010aa2:	bdf0      	pop	{r4, r5, r6, r7, pc}
                dx /= dy; dy = 1;
 8010aa4:	0039      	movs	r1, r7
 8010aa6:	f7ef fc23 	bl	80002f0 <__divsi3>
 8010aaa:	2301      	movs	r3, #1
 8010aac:	0007      	movs	r7, r0
 8010aae:	4698      	mov	r8, r3
 8010ab0:	e7c6      	b.n	8010a40 <ili9341_line+0x50>
                dx /= -dy; dy = -1;
 8010ab2:	f7ef fc1d 	bl	80002f0 <__divsi3>
 8010ab6:	2201      	movs	r2, #1
 8010ab8:	4252      	negs	r2, r2
 8010aba:	0007      	movs	r7, r0
 8010abc:	2301      	movs	r3, #1
 8010abe:	4690      	mov	r8, r2
 8010ac0:	e7db      	b.n	8010a7a <ili9341_line+0x8a>
 8010ac2:	465f      	mov	r7, fp
 8010ac4:	e7d9      	b.n	8010a7a <ili9341_line+0x8a>
 8010ac6:	46c0      	nop			; (mov r8, r8)
 8010ac8:	2000220c 	.word	0x2000220c
 8010acc:	00000000 	.word	0x00000000

08010ad0 <ili9341_drawfont>:


const font_t NF20x22 = { 20, 22, 1, 3*22, (const uint8_t *)numfont20x22 };

void ili9341_drawfont(uint8_t ch, const font_t *font, int x, int y, uint16_t fg, uint16_t bg)
{
 8010ad0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8010ad2:	46de      	mov	lr, fp
 8010ad4:	4657      	mov	r7, sl
 8010ad6:	464e      	mov	r6, r9
 8010ad8:	4645      	mov	r5, r8
 8010ada:	b5e0      	push	{r5, r6, r7, lr}
 8010adc:	000f      	movs	r7, r1
 8010ade:	b083      	sub	sp, #12
 8010ae0:	9301      	str	r3, [sp, #4]
 8010ae2:	ab0c      	add	r3, sp, #48	; 0x30
 8010ae4:	881b      	ldrh	r3, [r3, #0]
 8010ae6:	0004      	movs	r4, r0
 8010ae8:	4698      	mov	r8, r3
 8010aea:	ab0d      	add	r3, sp, #52	; 0x34
 8010aec:	881b      	ldrh	r3, [r3, #0]
    chMtxLock(&mutex_ili9341);
 8010aee:	4829      	ldr	r0, [pc, #164]	; (8010b94 <ili9341_drawfont+0xc4>)
{
 8010af0:	4699      	mov	r9, r3
 8010af2:	9200      	str	r2, [sp, #0]
    chMtxLock(&mutex_ili9341);
 8010af4:	f7f3 fae4 	bl	80040c0 <chMtxLock>
    uint16_t *buf = spi_buffer;
    const uint8_t *bitmap = &font->bitmap[font->slide * ch];
 8010af8:	68bb      	ldr	r3, [r7, #8]
 8010afa:	88f8      	ldrh	r0, [r7, #6]
 8010afc:	469c      	mov	ip, r3
 8010afe:	4360      	muls	r0, r4
    int c, r;

    for (c = 0; c < font->height; c++) {
 8010b00:	887c      	ldrh	r4, [r7, #2]
    const uint8_t *bitmap = &font->bitmap[font->slide * ch];
 8010b02:	4460      	add	r0, ip
    for (c = 0; c < font->height; c++) {
 8010b04:	2c00      	cmp	r4, #0
 8010b06:	d040      	beq.n	8010b8a <ili9341_drawfont+0xba>
 8010b08:	2300      	movs	r3, #0
 8010b0a:	469b      	mov	fp, r3
    uint16_t *buf = spi_buffer;
 8010b0c:	4b22      	ldr	r3, [pc, #136]	; (8010b98 <ili9341_drawfont+0xc8>)
 8010b0e:	8839      	ldrh	r1, [r7, #0]
 8010b10:	469c      	mov	ip, r3
 8010b12:	003b      	movs	r3, r7
 8010b14:	4667      	mov	r7, ip
 8010b16:	469c      	mov	ip, r3
        uint8_t bits = *bitmap++;
 8010b18:	1c43      	adds	r3, r0, #1
 8010b1a:	7806      	ldrb	r6, [r0, #0]
        uint8_t m = 0x80;
        for (r = 0; r < font->width; r++) {
 8010b1c:	2900      	cmp	r1, #0
 8010b1e:	d030      	beq.n	8010b82 <ili9341_drawfont+0xb2>
 8010b20:	003c      	movs	r4, r7
        uint8_t bits = *bitmap++;
 8010b22:	0018      	movs	r0, r3
        for (r = 0; r < font->width; r++) {
 8010b24:	2200      	movs	r2, #0
        uint8_t m = 0x80;
 8010b26:	2380      	movs	r3, #128	; 0x80
        for (r = 0; r < font->width; r++) {
 8010b28:	4667      	mov	r7, ip
            *buf++ = (bits & m) ? fg : bg;
 8010b2a:	4641      	mov	r1, r8
 8010b2c:	4233      	tst	r3, r6
 8010b2e:	d100      	bne.n	8010b32 <ili9341_drawfont+0x62>
 8010b30:	4649      	mov	r1, r9
 8010b32:	1ca5      	adds	r5, r4, #2
 8010b34:	46ac      	mov	ip, r5
 8010b36:	8021      	strh	r1, [r4, #0]
            m >>= 1;
 8010b38:	085b      	lsrs	r3, r3, #1

            if (m == 0) {
 8010b3a:	d102      	bne.n	8010b42 <ili9341_drawfont+0x72>
                bits = *bitmap++;
 8010b3c:	7806      	ldrb	r6, [r0, #0]
                m = 0x80;
 8010b3e:	3380      	adds	r3, #128	; 0x80
                bits = *bitmap++;
 8010b40:	3001      	adds	r0, #1
        for (r = 0; r < font->width; r++) {
 8010b42:	8839      	ldrh	r1, [r7, #0]
 8010b44:	3201      	adds	r2, #1
 8010b46:	002c      	movs	r4, r5
 8010b48:	4291      	cmp	r1, r2
 8010b4a:	dcee      	bgt.n	8010b2a <ili9341_drawfont+0x5a>
 8010b4c:	003b      	movs	r3, r7
 8010b4e:	000a      	movs	r2, r1
 8010b50:	4667      	mov	r7, ip
 8010b52:	469c      	mov	ip, r3
 8010b54:	885c      	ldrh	r4, [r3, #2]
    for (c = 0; c < font->height; c++) {
 8010b56:	2301      	movs	r3, #1
 8010b58:	469a      	mov	sl, r3
 8010b5a:	44d3      	add	fp, sl
 8010b5c:	0023      	movs	r3, r4
 8010b5e:	455c      	cmp	r4, fp
 8010b60:	dcda      	bgt.n	8010b18 <ili9341_drawfont+0x48>
 8010b62:	4692      	mov	sl, r2
            }
        }
    }
    ili9341_bulk(x, y, font->width, font->height);
 8010b64:	4652      	mov	r2, sl
 8010b66:	9901      	ldr	r1, [sp, #4]
 8010b68:	9800      	ldr	r0, [sp, #0]
 8010b6a:	f7ff fd81 	bl	8010670 <ili9341_bulk>
    chMtxUnlock(&mutex_ili9341);
 8010b6e:	4809      	ldr	r0, [pc, #36]	; (8010b94 <ili9341_drawfont+0xc4>)
 8010b70:	f7f3 faae 	bl	80040d0 <chMtxUnlock>
}
 8010b74:	b003      	add	sp, #12
 8010b76:	bc3c      	pop	{r2, r3, r4, r5}
 8010b78:	4690      	mov	r8, r2
 8010b7a:	4699      	mov	r9, r3
 8010b7c:	46a2      	mov	sl, r4
 8010b7e:	46ab      	mov	fp, r5
 8010b80:	bdf0      	pop	{r4, r5, r6, r7, pc}
        uint8_t bits = *bitmap++;
 8010b82:	0018      	movs	r0, r3
        for (r = 0; r < font->width; r++) {
 8010b84:	2300      	movs	r3, #0
 8010b86:	001a      	movs	r2, r3
 8010b88:	e7e5      	b.n	8010b56 <ili9341_drawfont+0x86>
 8010b8a:	883b      	ldrh	r3, [r7, #0]
 8010b8c:	469a      	mov	sl, r3
    for (c = 0; c < font->height; c++) {
 8010b8e:	2300      	movs	r3, #0
 8010b90:	e7e8      	b.n	8010b64 <ili9341_drawfont+0x94>
 8010b92:	46c0      	nop			; (mov r8, r8)
 8010b94:	2000220c 	.word	0x2000220c
 8010b98:	200030ac 	.word	0x200030ac
 8010b9c:	00000000 	.word	0x00000000

08010ba0 <flash_erase_page0>:
#include "nanovna.h"
#include <string.h>

static int flash_wait_for_last_operation(void)
{
  while (FLASH->SR == FLASH_SR_BSY) {
 8010ba0:	4a0b      	ldr	r2, [pc, #44]	; (8010bd0 <flash_erase_page0+0x30>)
 8010ba2:	68d3      	ldr	r3, [r2, #12]
 8010ba4:	2b01      	cmp	r3, #1
 8010ba6:	d0fc      	beq.n	8010ba2 <flash_erase_page0+0x2>
}

static void flash_erase_page0(uint32_t page_address)
{
	flash_wait_for_last_operation();
	FLASH->CR |= FLASH_CR_PER;
 8010ba8:	2102      	movs	r1, #2
  return FLASH->SR;
 8010baa:	68d3      	ldr	r3, [r2, #12]
	FLASH->CR |= FLASH_CR_PER;
 8010bac:	6913      	ldr	r3, [r2, #16]
 8010bae:	430b      	orrs	r3, r1
 8010bb0:	6113      	str	r3, [r2, #16]
	FLASH->AR = page_address;
 8010bb2:	6150      	str	r0, [r2, #20]
	FLASH->CR |= FLASH_CR_STRT;
 8010bb4:	6913      	ldr	r3, [r2, #16]
 8010bb6:	313e      	adds	r1, #62	; 0x3e
 8010bb8:	430b      	orrs	r3, r1
 8010bba:	6113      	str	r3, [r2, #16]
  while (FLASH->SR == FLASH_SR_BSY) {
 8010bbc:	4a04      	ldr	r2, [pc, #16]	; (8010bd0 <flash_erase_page0+0x30>)
 8010bbe:	68d3      	ldr	r3, [r2, #12]
 8010bc0:	2b01      	cmp	r3, #1
 8010bc2:	d0fc      	beq.n	8010bbe <flash_erase_page0+0x1e>
	flash_wait_for_last_operation();
	FLASH->CR &= ~FLASH_CR_PER;
 8010bc4:	2102      	movs	r1, #2
  return FLASH->SR;
 8010bc6:	68d3      	ldr	r3, [r2, #12]
	FLASH->CR &= ~FLASH_CR_PER;
 8010bc8:	6913      	ldr	r3, [r2, #16]
 8010bca:	438b      	bics	r3, r1
 8010bcc:	6113      	str	r3, [r2, #16]
}
 8010bce:	4770      	bx	lr
 8010bd0:	40022000 	.word	0x40022000
	...

08010be0 <config_save>:
#else
const uint32_t save_config_area = 0x08019800;
#endif

int config_save(void)
{
 8010be0:	b570      	push	{r4, r5, r6, lr}
  uint16_t *src = (uint16_t*)&config;
  uint16_t *dst = (uint16_t*)save_config_area;
  int count = sizeof(config_t) / sizeof(uint16_t);

  config.magic = CONFIG_MAGIC;
 8010be2:	4c1a      	ldr	r4, [pc, #104]	; (8010c4c <config_save+0x6c>)
  config.checksum = 0;
 8010be4:	2200      	movs	r2, #0
 8010be6:	0021      	movs	r1, r4
  config.magic = CONFIG_MAGIC;
 8010be8:	4b19      	ldr	r3, [pc, #100]	; (8010c50 <config_save+0x70>)
  config.checksum = 0;
 8010bea:	6262      	str	r2, [r4, #36]	; 0x24
  config.magic = CONFIG_MAGIC;
 8010bec:	6023      	str	r3, [r4, #0]
  while (p < tail)
 8010bee:	3128      	adds	r1, #40	; 0x28
 8010bf0:	e000      	b.n	8010bf4 <config_save+0x14>
 8010bf2:	6823      	ldr	r3, [r4, #0]
    value ^= *p++;
 8010bf4:	3404      	adds	r4, #4
 8010bf6:	405a      	eors	r2, r3
  while (p < tail)
 8010bf8:	428c      	cmp	r4, r1
 8010bfa:	d1fa      	bne.n	8010bf2 <config_save+0x12>
  config.checksum = checksum(&config, sizeof config);
 8010bfc:	0023      	movs	r3, r4
 8010bfe:	3b28      	subs	r3, #40	; 0x28
 8010c00:	625a      	str	r2, [r3, #36]	; 0x24
  FLASH->KEYR = 0x45670123;
 8010c02:	4e14      	ldr	r6, [pc, #80]	; (8010c54 <config_save+0x74>)
 8010c04:	4b14      	ldr	r3, [pc, #80]	; (8010c58 <config_save+0x78>)
 8010c06:	6073      	str	r3, [r6, #4]
  FLASH->KEYR = 0xCDEF89AB;
 8010c08:	4b14      	ldr	r3, [pc, #80]	; (8010c5c <config_save+0x7c>)
 8010c0a:	6073      	str	r3, [r6, #4]
  __ASM volatile ("cpsid i" : : : "memory");
 8010c0c:	b672      	cpsid	i
  flash_erase_page0(page_address);
 8010c0e:	4814      	ldr	r0, [pc, #80]	; (8010c60 <config_save+0x80>)
 8010c10:	f7ff ffc6 	bl	8010ba0 <flash_erase_page0>
  __ASM volatile ("cpsie i" : : : "memory");
 8010c14:	b662      	cpsie	i
	FLASH->CR |= FLASH_CR_PG;
 8010c16:	2001      	movs	r0, #1
 8010c18:	4b12      	ldr	r3, [pc, #72]	; (8010c64 <config_save+0x84>)
  uint16_t *dst = (uint16_t*)save_config_area;
 8010c1a:	4911      	ldr	r1, [pc, #68]	; (8010c60 <config_save+0x80>)
 8010c1c:	18e5      	adds	r5, r4, r3
  while (FLASH->SR == FLASH_SR_BSY) {
 8010c1e:	0033      	movs	r3, r6

  /* erase flash pages */
  flash_erase_page((uint32_t)dst);

  /* write to flahs */
  while(count-- > 0) {
 8010c20:	4e11      	ldr	r6, [pc, #68]	; (8010c68 <config_save+0x88>)
    flash_program_half_word((uint32_t)dst, *src++);
 8010c22:	5b4c      	ldrh	r4, [r1, r5]
  while (FLASH->SR == FLASH_SR_BSY) {
 8010c24:	68da      	ldr	r2, [r3, #12]
 8010c26:	2a01      	cmp	r2, #1
 8010c28:	d0fc      	beq.n	8010c24 <config_save+0x44>
  return FLASH->SR;
 8010c2a:	68da      	ldr	r2, [r3, #12]
	FLASH->CR |= FLASH_CR_PG;
 8010c2c:	691a      	ldr	r2, [r3, #16]
 8010c2e:	4302      	orrs	r2, r0
 8010c30:	611a      	str	r2, [r3, #16]
    *(__IO uint16_t*)address = data;
 8010c32:	800c      	strh	r4, [r1, #0]
  while (FLASH->SR == FLASH_SR_BSY) {
 8010c34:	68da      	ldr	r2, [r3, #12]
 8010c36:	2a01      	cmp	r2, #1
 8010c38:	d0fc      	beq.n	8010c34 <config_save+0x54>
  return FLASH->SR;
 8010c3a:	68da      	ldr	r2, [r3, #12]
	FLASH->CR &= ~FLASH_CR_PG;
 8010c3c:	691a      	ldr	r2, [r3, #16]
    dst++;
 8010c3e:	3102      	adds	r1, #2
	FLASH->CR &= ~FLASH_CR_PG;
 8010c40:	4382      	bics	r2, r0
 8010c42:	611a      	str	r2, [r3, #16]
  while(count-- > 0) {
 8010c44:	42b1      	cmp	r1, r6
 8010c46:	d1ec      	bne.n	8010c22 <config_save+0x42>
  }

  return 0;
}
 8010c48:	2000      	movs	r0, #0
 8010c4a:	bd70      	pop	{r4, r5, r6, pc}
 8010c4c:	2000042c 	.word	0x2000042c
 8010c50:	434f4e4a 	.word	0x434f4e4a
 8010c54:	40022000 	.word	0x40022000
 8010c58:	45670123 	.word	0x45670123
 8010c5c:	cdef89ab 	.word	0xcdef89ab
 8010c60:	08019800 	.word	0x08019800
 8010c64:	f7fe67d8 	.word	0xf7fe67d8
 8010c68:	08019828 	.word	0x08019828
 8010c6c:	00000000 	.word	0x00000000

08010c70 <config_recall>:
int config_recall(void)
{
  const config_t *src = (const config_t*)save_config_area;
  void *dst = &config;

  if (src->magic != CONFIG_MAGIC)
 8010c70:	4b10      	ldr	r3, [pc, #64]	; (8010cb4 <config_recall+0x44>)
 8010c72:	4a11      	ldr	r2, [pc, #68]	; (8010cb8 <config_recall+0x48>)
 8010c74:	6819      	ldr	r1, [r3, #0]
{
 8010c76:	b510      	push	{r4, lr}
  if (src->magic != CONFIG_MAGIC)
 8010c78:	4291      	cmp	r1, r2
 8010c7a:	d117      	bne.n	8010cac <config_recall+0x3c>
  uint32_t value = 0;
 8010c7c:	2200      	movs	r2, #0
  while (p < tail)
 8010c7e:	4c0f      	ldr	r4, [pc, #60]	; (8010cbc <config_recall+0x4c>)
 8010c80:	e000      	b.n	8010c84 <config_recall+0x14>
    value ^= *p++;
 8010c82:	0002      	movs	r2, r0
 8010c84:	cb02      	ldmia	r3!, {r1}
 8010c86:	0008      	movs	r0, r1
 8010c88:	4050      	eors	r0, r2
  while (p < tail)
 8010c8a:	42a3      	cmp	r3, r4
 8010c8c:	d1f9      	bne.n	8010c82 <config_recall+0x12>
    return -1;
  if (checksum(src, sizeof(config_t)) != 0)
 8010c8e:	4291      	cmp	r1, r2
 8010c90:	d10c      	bne.n	8010cac <config_recall+0x3c>
    return -1;

  /* duplicated saved data onto sram to be able to modify marker/trace */
  memcpy(dst, src, sizeof(config_t));
 8010c92:	490b      	ldr	r1, [pc, #44]	; (8010cc0 <config_recall+0x50>)
 8010c94:	4b07      	ldr	r3, [pc, #28]	; (8010cb4 <config_recall+0x44>)
 8010c96:	000a      	movs	r2, r1
 8010c98:	cb13      	ldmia	r3!, {r0, r1, r4}
 8010c9a:	c213      	stmia	r2!, {r0, r1, r4}
 8010c9c:	cb13      	ldmia	r3!, {r0, r1, r4}
 8010c9e:	c213      	stmia	r2!, {r0, r1, r4}
 8010ca0:	cb13      	ldmia	r3!, {r0, r1, r4}
 8010ca2:	c213      	stmia	r2!, {r0, r1, r4}
  return 0;
 8010ca4:	2000      	movs	r0, #0
  memcpy(dst, src, sizeof(config_t));
 8010ca6:	681b      	ldr	r3, [r3, #0]
 8010ca8:	6013      	str	r3, [r2, #0]
}
 8010caa:	bd10      	pop	{r4, pc}
    return -1;
 8010cac:	2001      	movs	r0, #1
 8010cae:	4240      	negs	r0, r0
 8010cb0:	e7fb      	b.n	8010caa <config_recall+0x3a>
 8010cb2:	46c0      	nop			; (mov r8, r8)
 8010cb4:	08019800 	.word	0x08019800
 8010cb8:	434f4e4a 	.word	0x434f4e4a
 8010cbc:	08019828 	.word	0x08019828
 8010cc0:	2000042c 	.word	0x2000042c
	...

08010cd0 <caldata_save>:

int16_t lastsaveid = 0;


int caldata_save(int id)
{
 8010cd0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8010cd2:	4645      	mov	r5, r8
 8010cd4:	46de      	mov	lr, fp
 8010cd6:	4657      	mov	r7, sl
 8010cd8:	464e      	mov	r6, r9
 8010cda:	b5e0      	push	{r5, r6, r7, lr}
 8010cdc:	0005      	movs	r5, r0
  uint16_t *src = (uint16_t*)&current_props;
  uint16_t *dst;
  int count = sizeof(properties_t) / sizeof(uint16_t);

  if (id < 0 || id >= SAVEAREA_MAX)
 8010cde:	2803      	cmp	r0, #3
 8010ce0:	d865      	bhi.n	8010dae <caldata_save+0xde>
    return -1;
  dst = (uint16_t*)saveareas[id];
 8010ce2:	4b34      	ldr	r3, [pc, #208]	; (8010db4 <caldata_save+0xe4>)

  current_props.magic = CONFIG_MAGIC;
 8010ce4:	4934      	ldr	r1, [pc, #208]	; (8010db8 <caldata_save+0xe8>)
  dst = (uint16_t*)saveareas[id];
 8010ce6:	469a      	mov	sl, r3
 8010ce8:	0083      	lsls	r3, r0, #2
 8010cea:	4698      	mov	r8, r3
 8010cec:	4653      	mov	r3, sl
 8010cee:	4642      	mov	r2, r8
 8010cf0:	589e      	ldr	r6, [r3, r2]
  current_props.magic = CONFIG_MAGIC;
 8010cf2:	4b32      	ldr	r3, [pc, #200]	; (8010dbc <caldata_save+0xec>)
  current_props.checksum = 0;
 8010cf4:	2200      	movs	r2, #0
  current_props.magic = CONFIG_MAGIC;
 8010cf6:	4699      	mov	r9, r3
  current_props.checksum = 0;
 8010cf8:	4648      	mov	r0, r9
  current_props.magic = CONFIG_MAGIC;
 8010cfa:	6019      	str	r1, [r3, #0]
  current_props.checksum = 0;
 8010cfc:	4b30      	ldr	r3, [pc, #192]	; (8010dc0 <caldata_save+0xf0>)
  dst = (uint16_t*)saveareas[id];
 8010cfe:	0034      	movs	r4, r6
  current_props.checksum = 0;
 8010d00:	50c2      	str	r2, [r0, r3]
  while (p < tail)
 8010d02:	4830      	ldr	r0, [pc, #192]	; (8010dc4 <caldata_save+0xf4>)
  uint32_t *p = (uint32_t*)start;
 8010d04:	464b      	mov	r3, r9
 8010d06:	4448      	add	r0, r9
 8010d08:	e000      	b.n	8010d0c <caldata_save+0x3c>
 8010d0a:	6819      	ldr	r1, [r3, #0]
    value ^= *p++;
 8010d0c:	3304      	adds	r3, #4
 8010d0e:	404a      	eors	r2, r1
  while (p < tail)
 8010d10:	4283      	cmp	r3, r0
 8010d12:	d1fa      	bne.n	8010d0a <caldata_save+0x3a>
  current_props.checksum = checksum(&current_props, sizeof current_props);
 8010d14:	492c      	ldr	r1, [pc, #176]	; (8010dc8 <caldata_save+0xf8>)

  flash_unlock();

  /* erase flash pages */
  uint8_t* p = (uint8_t*)dst;
 8010d16:	0037      	movs	r7, r6
  current_props.checksum = checksum(&current_props, sizeof current_props);
 8010d18:	468c      	mov	ip, r1
 8010d1a:	4929      	ldr	r1, [pc, #164]	; (8010dc0 <caldata_save+0xf0>)
 8010d1c:	4463      	add	r3, ip
 8010d1e:	505a      	str	r2, [r3, r1]
  FLASH->KEYR = 0x45670123;
 8010d20:	4b2a      	ldr	r3, [pc, #168]	; (8010dcc <caldata_save+0xfc>)
 8010d22:	4a2b      	ldr	r2, [pc, #172]	; (8010dd0 <caldata_save+0x100>)
 8010d24:	605a      	str	r2, [r3, #4]
  FLASH->KEYR = 0xCDEF89AB;
 8010d26:	4a2b      	ldr	r2, [pc, #172]	; (8010dd4 <caldata_save+0x104>)
 8010d28:	605a      	str	r2, [r3, #4]
  uint8_t* tail = p + sizeof(properties_t);
  while (p < tail) {
 8010d2a:	23c0      	movs	r3, #192	; 0xc0
 8010d2c:	015b      	lsls	r3, r3, #5
 8010d2e:	18f1      	adds	r1, r6, r3
 8010d30:	2380      	movs	r3, #128	; 0x80
 8010d32:	011b      	lsls	r3, r3, #4
 8010d34:	18f2      	adds	r2, r6, r3
 8010d36:	2300      	movs	r3, #0
 8010d38:	4291      	cmp	r1, r2
 8010d3a:	415b      	adcs	r3, r3
 8010d3c:	425a      	negs	r2, r3
 8010d3e:	2302      	movs	r3, #2
 8010d40:	4013      	ands	r3, r2
 8010d42:	3301      	adds	r3, #1
 8010d44:	02db      	lsls	r3, r3, #11
 8010d46:	469b      	mov	fp, r3
 8010d48:	44b3      	add	fp, r6
  __ASM volatile ("cpsid i" : : : "memory");
 8010d4a:	b672      	cpsid	i
  flash_erase_page0(page_address);
 8010d4c:	0038      	movs	r0, r7
 8010d4e:	f7ff ff27 	bl	8010ba0 <flash_erase_page0>
  __ASM volatile ("cpsie i" : : : "memory");
 8010d52:	b662      	cpsie	i
    flash_erase_page((uint32_t)p);
    p += FLASH_PAGESIZE;
 8010d54:	2380      	movs	r3, #128	; 0x80
 8010d56:	011b      	lsls	r3, r3, #4
 8010d58:	469c      	mov	ip, r3
 8010d5a:	4467      	add	r7, ip
  while (p < tail) {
 8010d5c:	455f      	cmp	r7, fp
 8010d5e:	d1f4      	bne.n	8010d4a <caldata_save+0x7a>
 8010d60:	4b18      	ldr	r3, [pc, #96]	; (8010dc4 <caldata_save+0xf4>)
	FLASH->CR |= FLASH_CR_PG;
 8010d62:	2101      	movs	r1, #1
 8010d64:	18f7      	adds	r7, r6, r3
  }

  /* write to flahs */
  while(count-- > 0) {
    flash_program_half_word((uint32_t)dst, *src++);
 8010d66:	464b      	mov	r3, r9
 8010d68:	1b98      	subs	r0, r3, r6
  while (FLASH->SR == FLASH_SR_BSY) {
 8010d6a:	4b18      	ldr	r3, [pc, #96]	; (8010dcc <caldata_save+0xfc>)
    flash_program_half_word((uint32_t)dst, *src++);
 8010d6c:	5a26      	ldrh	r6, [r4, r0]
  while (FLASH->SR == FLASH_SR_BSY) {
 8010d6e:	68da      	ldr	r2, [r3, #12]
 8010d70:	2a01      	cmp	r2, #1
 8010d72:	d0fc      	beq.n	8010d6e <caldata_save+0x9e>
  return FLASH->SR;
 8010d74:	68da      	ldr	r2, [r3, #12]
	FLASH->CR |= FLASH_CR_PG;
 8010d76:	691a      	ldr	r2, [r3, #16]
 8010d78:	430a      	orrs	r2, r1
 8010d7a:	611a      	str	r2, [r3, #16]
    *(__IO uint16_t*)address = data;
 8010d7c:	8026      	strh	r6, [r4, #0]
  while (FLASH->SR == FLASH_SR_BSY) {
 8010d7e:	68da      	ldr	r2, [r3, #12]
 8010d80:	2a01      	cmp	r2, #1
 8010d82:	d0fc      	beq.n	8010d7e <caldata_save+0xae>
  return FLASH->SR;
 8010d84:	68da      	ldr	r2, [r3, #12]
	FLASH->CR &= ~FLASH_CR_PG;
 8010d86:	691a      	ldr	r2, [r3, #16]
    dst++;
 8010d88:	3402      	adds	r4, #2
	FLASH->CR &= ~FLASH_CR_PG;
 8010d8a:	438a      	bics	r2, r1
 8010d8c:	611a      	str	r2, [r3, #16]
  while(count-- > 0) {
 8010d8e:	42bc      	cmp	r4, r7
 8010d90:	d1ec      	bne.n	8010d6c <caldata_save+0x9c>
  }

  /* after saving data, make active configuration points to flash */
  active_props = (properties_t*)saveareas[id];
 8010d92:	4653      	mov	r3, sl
 8010d94:	4642      	mov	r2, r8
  lastsaveid = id;

  return 0;
 8010d96:	2000      	movs	r0, #0
  active_props = (properties_t*)saveareas[id];
 8010d98:	589a      	ldr	r2, [r3, r2]
 8010d9a:	4b0f      	ldr	r3, [pc, #60]	; (8010dd8 <caldata_save+0x108>)
 8010d9c:	601a      	str	r2, [r3, #0]
  lastsaveid = id;
 8010d9e:	4b0f      	ldr	r3, [pc, #60]	; (8010ddc <caldata_save+0x10c>)
 8010da0:	801d      	strh	r5, [r3, #0]
}
 8010da2:	bc3c      	pop	{r2, r3, r4, r5}
 8010da4:	4690      	mov	r8, r2
 8010da6:	4699      	mov	r9, r3
 8010da8:	46a2      	mov	sl, r4
 8010daa:	46ab      	mov	fp, r5
 8010dac:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return -1;
 8010dae:	2001      	movs	r0, #1
 8010db0:	4240      	negs	r0, r0
 8010db2:	e7f6      	b.n	8010da2 <caldata_save+0xd2>
 8010db4:	08016a30 	.word	0x08016a30
 8010db8:	434f4e4a 	.word	0x434f4e4a
 8010dbc:	20000454 	.word	0x20000454
 8010dc0:	000011c8 	.word	0x000011c8
 8010dc4:	000011cc 	.word	0x000011cc
 8010dc8:	ffffee34 	.word	0xffffee34
 8010dcc:	40022000 	.word	0x40022000
 8010dd0:	45670123 	.word	0x45670123
 8010dd4:	cdef89ab 	.word	0xcdef89ab
 8010dd8:	20000428 	.word	0x20000428
 8010ddc:	200038b0 	.word	0x200038b0

08010de0 <caldata_recall>:

int caldata_recall(int id)
{
 8010de0:	b570      	push	{r4, r5, r6, lr}
  properties_t *src;
  void *dst = &current_props;

  if (id < 0 || id >= SAVEAREA_MAX)
 8010de2:	2803      	cmp	r0, #3
 8010de4:	d827      	bhi.n	8010e36 <caldata_recall+0x56>
    return -1;

  // point to saved area on the flash memory
  src = (properties_t*)saveareas[id];
 8010de6:	4b15      	ldr	r3, [pc, #84]	; (8010e3c <caldata_recall+0x5c>)
 8010de8:	0082      	lsls	r2, r0, #2
 8010dea:	58d1      	ldr	r1, [r2, r3]

  if (src->magic != CONFIG_MAGIC)
 8010dec:	4b14      	ldr	r3, [pc, #80]	; (8010e40 <caldata_recall+0x60>)
 8010dee:	680a      	ldr	r2, [r1, #0]
 8010df0:	429a      	cmp	r2, r3
 8010df2:	d120      	bne.n	8010e36 <caldata_recall+0x56>
  while (p < tail)
 8010df4:	4a13      	ldr	r2, [pc, #76]	; (8010e44 <caldata_recall+0x64>)
 8010df6:	1d0b      	adds	r3, r1, #4
 8010df8:	188c      	adds	r4, r1, r2
 8010dfa:	2200      	movs	r2, #0
 8010dfc:	429c      	cmp	r4, r3
 8010dfe:	4152      	adcs	r2, r2
 8010e00:	4b11      	ldr	r3, [pc, #68]	; (8010e48 <caldata_recall+0x68>)
 8010e02:	4252      	negs	r2, r2
 8010e04:	401a      	ands	r2, r3
 8010e06:	3201      	adds	r2, #1
 8010e08:	0092      	lsls	r2, r2, #2
 8010e0a:	1852      	adds	r2, r2, r1
  if (src->magic != CONFIG_MAGIC)
 8010e0c:	000b      	movs	r3, r1
  uint32_t value = 0;
 8010e0e:	2400      	movs	r4, #0
 8010e10:	e000      	b.n	8010e14 <caldata_recall+0x34>
    value ^= *p++;
 8010e12:	0034      	movs	r4, r6
 8010e14:	cb20      	ldmia	r3!, {r5}
 8010e16:	002e      	movs	r6, r5
 8010e18:	4066      	eors	r6, r4
  while (p < tail)
 8010e1a:	4293      	cmp	r3, r2
 8010e1c:	d1f9      	bne.n	8010e12 <caldata_recall+0x32>
    return -1;
  if (checksum(src, sizeof(properties_t)) != 0)
 8010e1e:	42a5      	cmp	r5, r4
 8010e20:	d109      	bne.n	8010e36 <caldata_recall+0x56>
    return -1;

  /* active configuration points to save data on flash memory */
  active_props = src;
 8010e22:	4b0a      	ldr	r3, [pc, #40]	; (8010e4c <caldata_recall+0x6c>)
  lastsaveid = id;

  /* duplicated saved data onto sram to be able to modify marker/trace */
  memcpy(dst, src, sizeof(properties_t));
 8010e24:	4a07      	ldr	r2, [pc, #28]	; (8010e44 <caldata_recall+0x64>)
  active_props = src;
 8010e26:	6019      	str	r1, [r3, #0]
  lastsaveid = id;
 8010e28:	4b09      	ldr	r3, [pc, #36]	; (8010e50 <caldata_recall+0x70>)
 8010e2a:	8018      	strh	r0, [r3, #0]
  memcpy(dst, src, sizeof(properties_t));
 8010e2c:	4809      	ldr	r0, [pc, #36]	; (8010e54 <caldata_recall+0x74>)
 8010e2e:	f002 f94f 	bl	80130d0 <memcpy>

  return 0;
 8010e32:	2000      	movs	r0, #0
}
 8010e34:	bd70      	pop	{r4, r5, r6, pc}
    return -1;
 8010e36:	2001      	movs	r0, #1
 8010e38:	4240      	negs	r0, r0
 8010e3a:	e7fb      	b.n	8010e34 <caldata_recall+0x54>
 8010e3c:	08016a30 	.word	0x08016a30
 8010e40:	434f4e4a 	.word	0x434f4e4a
 8010e44:	000011cc 	.word	0x000011cc
 8010e48:	00000472 	.word	0x00000472
 8010e4c:	20000428 	.word	0x20000428
 8010e50:	200038b0 	.word	0x200038b0
 8010e54:	20000454 	.word	0x20000454
	...

08010e60 <caldata_ref>:

const properties_t* caldata_ref(int id)
{
 8010e60:	b530      	push	{r4, r5, lr}
  const properties_t *src;
  if (id < 0 || id >= SAVEAREA_MAX)
 8010e62:	2803      	cmp	r0, #3
 8010e64:	d821      	bhi.n	8010eaa <caldata_ref+0x4a>
    return NULL;
  src = (const properties_t*)saveareas[id];
 8010e66:	4b12      	ldr	r3, [pc, #72]	; (8010eb0 <caldata_ref+0x50>)
 8010e68:	0080      	lsls	r0, r0, #2
 8010e6a:	58c0      	ldr	r0, [r0, r3]

  if (src->magic != CONFIG_MAGIC)
 8010e6c:	4b11      	ldr	r3, [pc, #68]	; (8010eb4 <caldata_ref+0x54>)
 8010e6e:	6802      	ldr	r2, [r0, #0]
 8010e70:	429a      	cmp	r2, r3
 8010e72:	d11a      	bne.n	8010eaa <caldata_ref+0x4a>
  while (p < tail)
 8010e74:	2100      	movs	r1, #0
 8010e76:	4a10      	ldr	r2, [pc, #64]	; (8010eb8 <caldata_ref+0x58>)
 8010e78:	1d03      	adds	r3, r0, #4
 8010e7a:	1882      	adds	r2, r0, r2
 8010e7c:	429a      	cmp	r2, r3
 8010e7e:	4149      	adcs	r1, r1
 8010e80:	4b0e      	ldr	r3, [pc, #56]	; (8010ebc <caldata_ref+0x5c>)
 8010e82:	4249      	negs	r1, r1
 8010e84:	4019      	ands	r1, r3
 8010e86:	3101      	adds	r1, #1
 8010e88:	0089      	lsls	r1, r1, #2
 8010e8a:	1841      	adds	r1, r0, r1
  if (src->magic != CONFIG_MAGIC)
 8010e8c:	0003      	movs	r3, r0
  uint32_t value = 0;
 8010e8e:	2400      	movs	r4, #0
 8010e90:	e000      	b.n	8010e94 <caldata_ref+0x34>
    value ^= *p++;
 8010e92:	002c      	movs	r4, r5
 8010e94:	cb04      	ldmia	r3!, {r2}
 8010e96:	0015      	movs	r5, r2
 8010e98:	4065      	eors	r5, r4
  while (p < tail)
 8010e9a:	428b      	cmp	r3, r1
 8010e9c:	d1f9      	bne.n	8010e92 <caldata_ref+0x32>
    return NULL;
  if (checksum(src, sizeof(properties_t)) != 0)
    return NULL;
 8010e9e:	1b12      	subs	r2, r2, r4
 8010ea0:	4253      	negs	r3, r2
 8010ea2:	415a      	adcs	r2, r3
 8010ea4:	4252      	negs	r2, r2
 8010ea6:	4010      	ands	r0, r2
  return src;
}
 8010ea8:	bd30      	pop	{r4, r5, pc}
    return NULL;
 8010eaa:	2000      	movs	r0, #0
 8010eac:	e7fc      	b.n	8010ea8 <caldata_ref+0x48>
 8010eae:	46c0      	nop			; (mov r8, r8)
 8010eb0:	08016a30 	.word	0x08016a30
 8010eb4:	434f4e4a 	.word	0x434f4e4a
 8010eb8:	000011cc 	.word	0x000011cc
 8010ebc:	00000472 	.word	0x00000472

08010ec0 <clear_all_config_prop_data>:
  FLASH->KEYR = 0x45670123;
 8010ec0:	4b09      	ldr	r3, [pc, #36]	; (8010ee8 <clear_all_config_prop_data+0x28>)
 8010ec2:	4a0a      	ldr	r2, [pc, #40]	; (8010eec <clear_all_config_prop_data+0x2c>)
#else
const uint32_t save_config_prop_area_size = 0x8000;
#endif

void clear_all_config_prop_data(void)
{
 8010ec4:	b570      	push	{r4, r5, r6, lr}
  FLASH->KEYR = 0x45670123;
 8010ec6:	605a      	str	r2, [r3, #4]
  FLASH->KEYR = 0xCDEF89AB;
 8010ec8:	4a09      	ldr	r2, [pc, #36]	; (8010ef0 <clear_all_config_prop_data+0x30>)
  flash_unlock();

  /* erase flash pages */
  uint8_t* p = (uint8_t*)save_config_area;
 8010eca:	4c0a      	ldr	r4, [pc, #40]	; (8010ef4 <clear_all_config_prop_data+0x34>)
  uint8_t* tail = p + save_config_prop_area_size;
  while (p < tail) {
 8010ecc:	4d0a      	ldr	r5, [pc, #40]	; (8010ef8 <clear_all_config_prop_data+0x38>)
  FLASH->KEYR = 0xCDEF89AB;
 8010ece:	605a      	str	r2, [r3, #4]
  __ASM volatile ("cpsid i" : : : "memory");
 8010ed0:	b672      	cpsid	i
  flash_erase_page0(page_address);
 8010ed2:	0020      	movs	r0, r4
 8010ed4:	f7ff fe64 	bl	8010ba0 <flash_erase_page0>
  __ASM volatile ("cpsie i" : : : "memory");
 8010ed8:	b662      	cpsie	i
    flash_erase_page((uint32_t)p);
    p += FLASH_PAGESIZE;
 8010eda:	2380      	movs	r3, #128	; 0x80
 8010edc:	011b      	lsls	r3, r3, #4
 8010ede:	469c      	mov	ip, r3
 8010ee0:	4464      	add	r4, ip
  while (p < tail) {
 8010ee2:	42ac      	cmp	r4, r5
 8010ee4:	d1f4      	bne.n	8010ed0 <clear_all_config_prop_data+0x10>
  }
}
 8010ee6:	bd70      	pop	{r4, r5, r6, pc}
 8010ee8:	40022000 	.word	0x40022000
 8010eec:	45670123 	.word	0x45670123
 8010ef0:	cdef89ab 	.word	0xcdef89ab
 8010ef4:	08019800 	.word	0x08019800
 8010ef8:	08020000 	.word	0x08020000
 8010efc:	00000000 	.word	0x00000000

08010f00 <adc_init>:
#define ADC_SMPR_SMP_239P5      7U  /**< @brief 252 cycles conversion time. */ 
#define ADC_CFGR1_RES_12BIT             (0U << 3U)

void adc_init(void)
{
  rccEnableADC1(FALSE);
 8010f00:	2380      	movs	r3, #128	; 0x80
 8010f02:	4a1a      	ldr	r2, [pc, #104]	; (8010f6c <adc_init+0x6c>)
 8010f04:	009b      	lsls	r3, r3, #2
 8010f06:	6991      	ldr	r1, [r2, #24]
 8010f08:	430b      	orrs	r3, r1
 8010f0a:	6193      	str	r3, [r2, #24]

  /* Ensure flag states */
  ADC1->IER = 0;
 8010f0c:	2200      	movs	r2, #0
 8010f0e:	4b18      	ldr	r3, [pc, #96]	; (8010f70 <adc_init+0x70>)

  /* Calibration procedure.*/
  ADC->CCR = 0;
 8010f10:	4918      	ldr	r1, [pc, #96]	; (8010f74 <adc_init+0x74>)
  ADC1->IER = 0;
 8010f12:	605a      	str	r2, [r3, #4]
  ADC->CCR = 0;
 8010f14:	600a      	str	r2, [r1, #0]
  if (ADC1->CR & ADC_CR_ADEN) {
 8010f16:	689a      	ldr	r2, [r3, #8]
 8010f18:	07d2      	lsls	r2, r2, #31
 8010f1a:	d504      	bpl.n	8010f26 <adc_init+0x26>
      ADC1->CR |= ~ADC_CR_ADDIS; /* Disable ADC */
 8010f1c:	2203      	movs	r2, #3
 8010f1e:	6899      	ldr	r1, [r3, #8]
 8010f20:	4252      	negs	r2, r2
 8010f22:	430a      	orrs	r2, r1
 8010f24:	609a      	str	r2, [r3, #8]
  }
  while (ADC1->CR & ADC_CR_ADEN)
 8010f26:	2101      	movs	r1, #1
 8010f28:	4a11      	ldr	r2, [pc, #68]	; (8010f70 <adc_init+0x70>)
 8010f2a:	6893      	ldr	r3, [r2, #8]
 8010f2c:	4219      	tst	r1, r3
 8010f2e:	d1fc      	bne.n	8010f2a <adc_init+0x2a>
    ;
  ADC1->CFGR1 &= ~ADC_CFGR1_DMAEN;
 8010f30:	68d3      	ldr	r3, [r2, #12]
 8010f32:	438b      	bics	r3, r1
 8010f34:	60d3      	str	r3, [r2, #12]
  ADC1->CR |= ADC_CR_ADCAL;
 8010f36:	2380      	movs	r3, #128	; 0x80
 8010f38:	6891      	ldr	r1, [r2, #8]
 8010f3a:	061b      	lsls	r3, r3, #24
 8010f3c:	430b      	orrs	r3, r1
 8010f3e:	6093      	str	r3, [r2, #8]
  while (ADC1->CR & ADC_CR_ADCAL)
 8010f40:	4a0b      	ldr	r2, [pc, #44]	; (8010f70 <adc_init+0x70>)
 8010f42:	6893      	ldr	r3, [r2, #8]
 8010f44:	2b00      	cmp	r3, #0
 8010f46:	dbfc      	blt.n	8010f42 <adc_init+0x42>
    ;

  if (ADC1->ISR & ADC_ISR_ADRDY) {
 8010f48:	2301      	movs	r3, #1
 8010f4a:	6811      	ldr	r1, [r2, #0]
 8010f4c:	420b      	tst	r3, r1
 8010f4e:	d108      	bne.n	8010f62 <adc_init+0x62>
      ADC1->ISR |= ADC_ISR_ADRDY; /* clear ADRDY */
  }
  /* Enable ADC */
  ADC1->CR |= ADC_CR_ADEN;
 8010f50:	2101      	movs	r1, #1
 8010f52:	4a07      	ldr	r2, [pc, #28]	; (8010f70 <adc_init+0x70>)
 8010f54:	6893      	ldr	r3, [r2, #8]
 8010f56:	430b      	orrs	r3, r1
 8010f58:	6093      	str	r3, [r2, #8]
  while (!(ADC1->ISR & ADC_ISR_ADRDY))
 8010f5a:	6813      	ldr	r3, [r2, #0]
 8010f5c:	4219      	tst	r1, r3
 8010f5e:	d0fc      	beq.n	8010f5a <adc_init+0x5a>
    ;
}
 8010f60:	4770      	bx	lr
      ADC1->ISR |= ADC_ISR_ADRDY; /* clear ADRDY */
 8010f62:	6811      	ldr	r1, [r2, #0]
 8010f64:	430b      	orrs	r3, r1
 8010f66:	6013      	str	r3, [r2, #0]
 8010f68:	e7f2      	b.n	8010f50 <adc_init+0x50>
 8010f6a:	46c0      	nop			; (mov r8, r8)
 8010f6c:	40021000 	.word	0x40021000
 8010f70:	40012400 	.word	0x40012400
 8010f74:	40012708 	.word	0x40012708
	...

08010f80 <adc_single_read>:

uint16_t adc_single_read(ADC_TypeDef *adc, uint32_t chsel)
{
  /* ADC setup */
  adc->ISR    = adc->ISR;
 8010f80:	6803      	ldr	r3, [r0, #0]
  adc->IER    = 0;
  adc->TR     = ADC_TR(0, 0);
  adc->SMPR   = ADC_SMPR_SMP_239P5;
 8010f82:	2207      	movs	r2, #7
  adc->ISR    = adc->ISR;
 8010f84:	6003      	str	r3, [r0, #0]
  adc->IER    = 0;
 8010f86:	2300      	movs	r3, #0
 8010f88:	6043      	str	r3, [r0, #4]
  adc->TR     = ADC_TR(0, 0);
 8010f8a:	6203      	str	r3, [r0, #32]
  adc->SMPR   = ADC_SMPR_SMP_239P5;
 8010f8c:	6142      	str	r2, [r0, #20]
  adc->CFGR1  = ADC_CFGR1_RES_12BIT;
 8010f8e:	60c3      	str	r3, [r0, #12]
  adc->CHSELR = chsel;
 8010f90:	6281      	str	r1, [r0, #40]	; 0x28

  /* ADC conversion start.*/
  adc->CR |= ADC_CR_ADSTART;
 8010f92:	6883      	ldr	r3, [r0, #8]
 8010f94:	3a03      	subs	r2, #3
 8010f96:	4313      	orrs	r3, r2
 8010f98:	6083      	str	r3, [r0, #8]

  while (adc->CR & ADC_CR_ADSTART)
 8010f9a:	6883      	ldr	r3, [r0, #8]
 8010f9c:	421a      	tst	r2, r3
 8010f9e:	d1fc      	bne.n	8010f9a <adc_single_read+0x1a>
    ;

  return adc->DR;
 8010fa0:	6c00      	ldr	r0, [r0, #64]	; 0x40
 8010fa2:	b280      	uxth	r0, r0
}
 8010fa4:	4770      	bx	lr
 8010fa6:	46c0      	nop			; (mov r8, r8)
	...

08010fb0 <adc_vbat_read>:
int16_t adc_vbat_read(ADC_TypeDef *adc)
{
    // VREFINT == ADC_IN17
    // VBAT == ADC_IN18
    // VBATEN enables resiter devider circuit. It consume vbat power.
    ADC->CCR |= ADC_CCR_VREFEN | ADC_CCR_VBATEN;
 8010fb0:	23a0      	movs	r3, #160	; 0xa0
{
 8010fb2:	b5f0      	push	{r4, r5, r6, r7, lr}
 8010fb4:	46c6      	mov	lr, r8
    ADC->CCR |= ADC_CCR_VREFEN | ADC_CCR_VBATEN;
 8010fb6:	4a2f      	ldr	r2, [pc, #188]	; (8011074 <adc_vbat_read+0xc4>)
 8010fb8:	045b      	lsls	r3, r3, #17
 8010fba:	6811      	ldr	r1, [r2, #0]
  adc->CHSELR = chsel;
 8010fbc:	2680      	movs	r6, #128	; 0x80
    ADC->CCR |= ADC_CCR_VREFEN | ADC_CCR_VBATEN;
 8010fbe:	430b      	orrs	r3, r1
{
 8010fc0:	b500      	push	{lr}
    ADC->CCR |= ADC_CCR_VREFEN | ADC_CCR_VBATEN;
 8010fc2:	2520      	movs	r5, #32
 8010fc4:	6013      	str	r3, [r2, #0]
    uint32_t value = 0;
 8010fc6:	2400      	movs	r4, #0
  adc->IER    = 0;
 8010fc8:	2100      	movs	r1, #0
  adc->SMPR   = ADC_SMPR_SMP_239P5;
 8010fca:	2707      	movs	r7, #7
  adc->CR |= ADC_CR_ADSTART;
 8010fcc:	2204      	movs	r2, #4
  adc->CHSELR = chsel;
 8010fce:	02b6      	lsls	r6, r6, #10
  adc->ISR    = adc->ISR;
 8010fd0:	6803      	ldr	r3, [r0, #0]
 8010fd2:	6003      	str	r3, [r0, #0]
  adc->IER    = 0;
 8010fd4:	6041      	str	r1, [r0, #4]
  adc->TR     = ADC_TR(0, 0);
 8010fd6:	6201      	str	r1, [r0, #32]
  adc->SMPR   = ADC_SMPR_SMP_239P5;
 8010fd8:	6147      	str	r7, [r0, #20]
  adc->CFGR1  = ADC_CFGR1_RES_12BIT;
 8010fda:	60c1      	str	r1, [r0, #12]
  adc->CHSELR = chsel;
 8010fdc:	6286      	str	r6, [r0, #40]	; 0x28
  adc->CR |= ADC_CR_ADSTART;
 8010fde:	6883      	ldr	r3, [r0, #8]
 8010fe0:	4313      	orrs	r3, r2
 8010fe2:	6083      	str	r3, [r0, #8]
  while (adc->CR & ADC_CR_ADSTART)
 8010fe4:	6883      	ldr	r3, [r0, #8]
 8010fe6:	421a      	tst	r2, r3
 8010fe8:	d1fc      	bne.n	8010fe4 <adc_vbat_read+0x34>
  return adc->DR;
 8010fea:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8010fec:	3d01      	subs	r5, #1
        value += adc_single_read(adc, chsel);
 8010fee:	041b      	lsls	r3, r3, #16
 8010ff0:	0c1b      	lsrs	r3, r3, #16
 8010ff2:	18e4      	adds	r4, r4, r3
    for (int i=0; i < ADCFILTER; i++) 
 8010ff4:	2d00      	cmp	r5, #0
 8010ff6:	d1eb      	bne.n	8010fd0 <adc_vbat_read+0x20>
    return (uint16_t)value;
 8010ff8:	02e4      	lsls	r4, r4, #11
 8010ffa:	0c23      	lsrs	r3, r4, #16
  adc->CHSELR = chsel;
 8010ffc:	2780      	movs	r7, #128	; 0x80
 8010ffe:	4698      	mov	r8, r3
    uint32_t value = 0;
 8011000:	2600      	movs	r6, #0
  adc->IER    = 0;
 8011002:	2100      	movs	r1, #0
  adc->SMPR   = ADC_SMPR_SMP_239P5;
 8011004:	2407      	movs	r4, #7
  adc->CR |= ADC_CR_ADSTART;
 8011006:	2204      	movs	r2, #4
    value /= ADCFILTER;
 8011008:	3520      	adds	r5, #32
  adc->CHSELR = chsel;
 801100a:	02ff      	lsls	r7, r7, #11
  adc->ISR    = adc->ISR;
 801100c:	6803      	ldr	r3, [r0, #0]
 801100e:	6003      	str	r3, [r0, #0]
  adc->IER    = 0;
 8011010:	6041      	str	r1, [r0, #4]
  adc->TR     = ADC_TR(0, 0);
 8011012:	6201      	str	r1, [r0, #32]
  adc->SMPR   = ADC_SMPR_SMP_239P5;
 8011014:	6144      	str	r4, [r0, #20]
  adc->CFGR1  = ADC_CFGR1_RES_12BIT;
 8011016:	60c1      	str	r1, [r0, #12]
  adc->CHSELR = chsel;
 8011018:	6287      	str	r7, [r0, #40]	; 0x28
  adc->CR |= ADC_CR_ADSTART;
 801101a:	6883      	ldr	r3, [r0, #8]
 801101c:	4313      	orrs	r3, r2
 801101e:	6083      	str	r3, [r0, #8]
  while (adc->CR & ADC_CR_ADSTART)
 8011020:	6883      	ldr	r3, [r0, #8]
 8011022:	421a      	tst	r2, r3
 8011024:	d1fc      	bne.n	8011020 <adc_vbat_read+0x70>
  return adc->DR;
 8011026:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8011028:	3d01      	subs	r5, #1
        value += adc_single_read(adc, chsel);
 801102a:	041b      	lsls	r3, r3, #16
 801102c:	0c1b      	lsrs	r3, r3, #16
 801102e:	18f6      	adds	r6, r6, r3
    for (int i=0; i < ADCFILTER; i++) 
 8011030:	2d00      	cmp	r5, #0
 8011032:	d1eb      	bne.n	801100c <adc_vbat_read+0x5c>
    int32_t adc_ref = adc_single_read_filtered(adc, ADC_CHSELR_CHSEL17);
    int32_t adc_bat = adc_single_read_filtered(adc, ADC_CHSELR_CHSEL18);
    ADC->CCR &= ~(ADC_CCR_VREFEN | ADC_CCR_VBATEN);

    int16_t vbat_raw = (int16_t)((2 * 3300 * (int64_t)(*VREFINT_CAL_ADDR) * adc_bat) / ((int64_t)adc_ref * ((1<<12)-1)));
 8011034:	02f0      	lsls	r0, r6, #11
 8011036:	4646      	mov	r6, r8
 8011038:	2700      	movs	r7, #0
    ADC->CCR &= ~(ADC_CCR_VREFEN | ADC_CCR_VBATEN);
 801103a:	4a0e      	ldr	r2, [pc, #56]	; (8011074 <adc_vbat_read+0xc4>)
 801103c:	490e      	ldr	r1, [pc, #56]	; (8011078 <adc_vbat_read+0xc8>)
 801103e:	6813      	ldr	r3, [r2, #0]
    int16_t vbat_raw = (int16_t)((2 * 3300 * (int64_t)(*VREFINT_CAL_ADDR) * adc_bat) / ((int64_t)adc_ref * ((1<<12)-1)));
 8011040:	0c00      	lsrs	r0, r0, #16
    ADC->CCR &= ~(ADC_CCR_VREFEN | ADC_CCR_VBATEN);
 8011042:	400b      	ands	r3, r1
 8011044:	6013      	str	r3, [r2, #0]
    int16_t vbat_raw = (int16_t)((2 * 3300 * (int64_t)(*VREFINT_CAL_ADDR) * adc_bat) / ((int64_t)adc_ref * ((1<<12)-1)));
 8011046:	4b0d      	ldr	r3, [pc, #52]	; (801107c <adc_vbat_read+0xcc>)
 8011048:	2100      	movs	r1, #0
 801104a:	881a      	ldrh	r2, [r3, #0]
 801104c:	2300      	movs	r3, #0
 801104e:	f7ef fb0f 	bl	8000670 <__aeabi_lmul>
 8011052:	4a0b      	ldr	r2, [pc, #44]	; (8011080 <adc_vbat_read+0xd0>)
 8011054:	2300      	movs	r3, #0
 8011056:	f7ef fb0b 	bl	8000670 <__aeabi_lmul>
 801105a:	0d33      	lsrs	r3, r6, #20
 801105c:	0332      	lsls	r2, r6, #12
 801105e:	1b92      	subs	r2, r2, r6
 8011060:	41bb      	sbcs	r3, r7
 8011062:	f7ef fabd 	bl	80005e0 <__aeabi_ldivmod>
    return vbat_raw + config.vbat_offset;
 8011066:	4b07      	ldr	r3, [pc, #28]	; (8011084 <adc_vbat_read+0xd4>)
 8011068:	8c1b      	ldrh	r3, [r3, #32]
 801106a:	18c0      	adds	r0, r0, r3
 801106c:	b200      	sxth	r0, r0
}
 801106e:	bc04      	pop	{r2}
 8011070:	4690      	mov	r8, r2
 8011072:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8011074:	40012708 	.word	0x40012708
 8011078:	febfffff 	.word	0xfebfffff
 801107c:	1ffff7ba 	.word	0x1ffff7ba
 8011080:	000019c8 	.word	0x000019c8
 8011084:	2000042c 	.word	0x2000042c
	...

08011090 <adc_start_analog_watchdogd>:
    | ADC_CFGR1_EXTEN_0 // rising edge of external trigger
    | ADC_CFGR1_EXTSEL_0 | ADC_CFGR1_EXTSEL_1; // TRG3  , /* CFGR1 */

  /* ADC setup, if it is defined a callback for the analog watch dog then it
     is enabled.*/
  adc->ISR    = adc->ISR;
 8011090:	6803      	ldr	r3, [r0, #0]

  /* ADC configuration and start.*/
  adc->CFGR1  = cfgr1;

  /* ADC conversion start.*/
  adc->CR |= ADC_CR_ADSTART;
 8011092:	2204      	movs	r2, #4
  adc->ISR    = adc->ISR;
 8011094:	6003      	str	r3, [r0, #0]
  adc->IER    = ADC_IER_AWDIE;
 8011096:	2380      	movs	r3, #128	; 0x80
 8011098:	6043      	str	r3, [r0, #4]
  adc->TR     = ADC_TR(0, TOUCH_THRESHOLD);
 801109a:	23fa      	movs	r3, #250	; 0xfa
 801109c:	04db      	lsls	r3, r3, #19
 801109e:	6203      	str	r3, [r0, #32]
  adc->SMPR   = ADC_SMPR_SMP_1P5;
 80110a0:	2300      	movs	r3, #0
 80110a2:	6143      	str	r3, [r0, #20]
  adc->CFGR1  = cfgr1;
 80110a4:	4b03      	ldr	r3, [pc, #12]	; (80110b4 <adc_start_analog_watchdogd+0x24>)
  adc->CHSELR = chsel;
 80110a6:	6281      	str	r1, [r0, #40]	; 0x28
  adc->CFGR1  = cfgr1;
 80110a8:	60c3      	str	r3, [r0, #12]
  adc->CR |= ADC_CR_ADSTART;
 80110aa:	6883      	ldr	r3, [r0, #8]
 80110ac:	4313      	orrs	r3, r2
 80110ae:	6083      	str	r3, [r0, #8]
}
 80110b0:	4770      	bx	lr
 80110b2:	46c0      	nop			; (mov r8, r8)
 80110b4:	008004c0 	.word	0x008004c0
	...

080110c0 <adc_stop>:

void adc_stop(ADC_TypeDef *adc)
{
  if (adc->CR & ADC_CR_ADEN) {
 80110c0:	6883      	ldr	r3, [r0, #8]
 80110c2:	07db      	lsls	r3, r3, #31
 80110c4:	d509      	bpl.n	80110da <adc_stop+0x1a>
    if (adc->CR & ADC_CR_ADSTART) {
 80110c6:	6883      	ldr	r3, [r0, #8]
 80110c8:	075b      	lsls	r3, r3, #29
 80110ca:	d506      	bpl.n	80110da <adc_stop+0x1a>
      adc->CR |= ADC_CR_ADSTP;
 80110cc:	2210      	movs	r2, #16
 80110ce:	6883      	ldr	r3, [r0, #8]
 80110d0:	4313      	orrs	r3, r2
 80110d2:	6083      	str	r3, [r0, #8]
      while (adc->CR & ADC_CR_ADSTP)
 80110d4:	6883      	ldr	r3, [r0, #8]
 80110d6:	421a      	tst	r2, r3
 80110d8:	d1fc      	bne.n	80110d4 <adc_stop+0x14>

    /*    adc->CR |= ADC_CR_ADDIS;
    while (adc->CR & ADC_CR_ADDIS)
    ;*/
  }
}
 80110da:	4770      	bx	lr
 80110dc:	0000      	movs	r0, r0
	...

080110e0 <Vector70>:

static void adc_interrupt(ADC_TypeDef *adc)
{
  uint32_t isr = adc->ISR;
 80110e0:	4a06      	ldr	r2, [pc, #24]	; (80110fc <Vector70+0x1c>)
    handle_touch_interrupt();
  }
}

OSAL_IRQ_HANDLER(STM32_ADC1_HANDLER)
{
 80110e2:	b510      	push	{r4, lr}
  uint32_t isr = adc->ISR;
 80110e4:	6813      	ldr	r3, [r2, #0]
  OSAL_IRQ_PROLOGUE();
 80110e6:	4674      	mov	r4, lr
  adc->ISR = isr;
 80110e8:	6013      	str	r3, [r2, #0]
  if (isr & ADC_ISR_AWD) {
 80110ea:	061b      	lsls	r3, r3, #24
 80110ec:	d403      	bmi.n	80110f6 <Vector70+0x16>

  adc_interrupt(ADC1);

  OSAL_IRQ_EPILOGUE();
 80110ee:	0020      	movs	r0, r4
 80110f0:	f7f3 f866 	bl	80041c0 <_port_irq_epilogue>
}
 80110f4:	bd10      	pop	{r4, pc}
    handle_touch_interrupt();
 80110f6:	f7ff f923 	bl	8010340 <handle_touch_interrupt>
 80110fa:	e7f8      	b.n	80110ee <Vector70+0xe>
 80110fc:	40012400 	.word	0x40012400

08011100 <cos>:
 8011100:	b530      	push	{r4, r5, lr}
 8011102:	4a20      	ldr	r2, [pc, #128]	; (8011184 <cos+0x84>)
 8011104:	004b      	lsls	r3, r1, #1
 8011106:	b087      	sub	sp, #28
 8011108:	085b      	lsrs	r3, r3, #1
 801110a:	4293      	cmp	r3, r2
 801110c:	dd1c      	ble.n	8011148 <cos+0x48>
 801110e:	4a1e      	ldr	r2, [pc, #120]	; (8011188 <cos+0x88>)
 8011110:	4293      	cmp	r3, r2
 8011112:	dd05      	ble.n	8011120 <cos+0x20>
 8011114:	0002      	movs	r2, r0
 8011116:	000b      	movs	r3, r1
 8011118:	f7f1 fcfa 	bl	8002b10 <__aeabi_dsub>
 801111c:	b007      	add	sp, #28
 801111e:	bd30      	pop	{r4, r5, pc}
 8011120:	aa02      	add	r2, sp, #8
 8011122:	f000 f9c5 	bl	80114b0 <__ieee754_rem_pio2>
 8011126:	2303      	movs	r3, #3
 8011128:	4018      	ands	r0, r3
 801112a:	9a04      	ldr	r2, [sp, #16]
 801112c:	9b05      	ldr	r3, [sp, #20]
 801112e:	2801      	cmp	r0, #1
 8011130:	d00f      	beq.n	8011152 <cos+0x52>
 8011132:	2802      	cmp	r0, #2
 8011134:	d01c      	beq.n	8011170 <cos+0x70>
 8011136:	2800      	cmp	r0, #0
 8011138:	d015      	beq.n	8011166 <cos+0x66>
 801113a:	9802      	ldr	r0, [sp, #8]
 801113c:	9903      	ldr	r1, [sp, #12]
 801113e:	2401      	movs	r4, #1
 8011140:	9400      	str	r4, [sp, #0]
 8011142:	f001 fb6d 	bl	8012820 <__kernel_sin>
 8011146:	e7e9      	b.n	801111c <cos+0x1c>
 8011148:	2200      	movs	r2, #0
 801114a:	2300      	movs	r3, #0
 801114c:	f000 fde8 	bl	8011d20 <__kernel_cos>
 8011150:	e7e4      	b.n	801111c <cos+0x1c>
 8011152:	9000      	str	r0, [sp, #0]
 8011154:	9802      	ldr	r0, [sp, #8]
 8011156:	9903      	ldr	r1, [sp, #12]
 8011158:	f001 fb62 	bl	8012820 <__kernel_sin>
 801115c:	2380      	movs	r3, #128	; 0x80
 801115e:	061b      	lsls	r3, r3, #24
 8011160:	469c      	mov	ip, r3
 8011162:	4461      	add	r1, ip
 8011164:	e7da      	b.n	801111c <cos+0x1c>
 8011166:	9802      	ldr	r0, [sp, #8]
 8011168:	9903      	ldr	r1, [sp, #12]
 801116a:	f000 fdd9 	bl	8011d20 <__kernel_cos>
 801116e:	e7d5      	b.n	801111c <cos+0x1c>
 8011170:	9802      	ldr	r0, [sp, #8]
 8011172:	9903      	ldr	r1, [sp, #12]
 8011174:	f000 fdd4 	bl	8011d20 <__kernel_cos>
 8011178:	2380      	movs	r3, #128	; 0x80
 801117a:	061b      	lsls	r3, r3, #24
 801117c:	469c      	mov	ip, r3
 801117e:	4461      	add	r1, ip
 8011180:	e7cc      	b.n	801111c <cos+0x1c>
 8011182:	46c0      	nop			; (mov r8, r8)
 8011184:	3fe921fb 	.word	0x3fe921fb
 8011188:	7fefffff 	.word	0x7fefffff
 801118c:	00000000 	.word	0x00000000

08011190 <sin>:
 8011190:	b530      	push	{r4, r5, lr}
 8011192:	4a21      	ldr	r2, [pc, #132]	; (8011218 <sin+0x88>)
 8011194:	004b      	lsls	r3, r1, #1
 8011196:	b087      	sub	sp, #28
 8011198:	085b      	lsrs	r3, r3, #1
 801119a:	4293      	cmp	r3, r2
 801119c:	dd1e      	ble.n	80111dc <sin+0x4c>
 801119e:	4a1f      	ldr	r2, [pc, #124]	; (801121c <sin+0x8c>)
 80111a0:	4293      	cmp	r3, r2
 80111a2:	dd05      	ble.n	80111b0 <sin+0x20>
 80111a4:	0002      	movs	r2, r0
 80111a6:	000b      	movs	r3, r1
 80111a8:	f7f1 fcb2 	bl	8002b10 <__aeabi_dsub>
 80111ac:	b007      	add	sp, #28
 80111ae:	bd30      	pop	{r4, r5, pc}
 80111b0:	aa02      	add	r2, sp, #8
 80111b2:	f000 f97d 	bl	80114b0 <__ieee754_rem_pio2>
 80111b6:	2303      	movs	r3, #3
 80111b8:	4018      	ands	r0, r3
 80111ba:	9a04      	ldr	r2, [sp, #16]
 80111bc:	9b05      	ldr	r3, [sp, #20]
 80111be:	2801      	cmp	r0, #1
 80111c0:	d013      	beq.n	80111ea <sin+0x5a>
 80111c2:	2802      	cmp	r0, #2
 80111c4:	d01d      	beq.n	8011202 <sin+0x72>
 80111c6:	2800      	cmp	r0, #0
 80111c8:	d014      	beq.n	80111f4 <sin+0x64>
 80111ca:	9802      	ldr	r0, [sp, #8]
 80111cc:	9903      	ldr	r1, [sp, #12]
 80111ce:	f000 fda7 	bl	8011d20 <__kernel_cos>
 80111d2:	2380      	movs	r3, #128	; 0x80
 80111d4:	061b      	lsls	r3, r3, #24
 80111d6:	469c      	mov	ip, r3
 80111d8:	4461      	add	r1, ip
 80111da:	e7e7      	b.n	80111ac <sin+0x1c>
 80111dc:	2300      	movs	r3, #0
 80111de:	2200      	movs	r2, #0
 80111e0:	9300      	str	r3, [sp, #0]
 80111e2:	2300      	movs	r3, #0
 80111e4:	f001 fb1c 	bl	8012820 <__kernel_sin>
 80111e8:	e7e0      	b.n	80111ac <sin+0x1c>
 80111ea:	9802      	ldr	r0, [sp, #8]
 80111ec:	9903      	ldr	r1, [sp, #12]
 80111ee:	f000 fd97 	bl	8011d20 <__kernel_cos>
 80111f2:	e7db      	b.n	80111ac <sin+0x1c>
 80111f4:	2401      	movs	r4, #1
 80111f6:	9802      	ldr	r0, [sp, #8]
 80111f8:	9903      	ldr	r1, [sp, #12]
 80111fa:	9400      	str	r4, [sp, #0]
 80111fc:	f001 fb10 	bl	8012820 <__kernel_sin>
 8011200:	e7d4      	b.n	80111ac <sin+0x1c>
 8011202:	2401      	movs	r4, #1
 8011204:	9802      	ldr	r0, [sp, #8]
 8011206:	9903      	ldr	r1, [sp, #12]
 8011208:	9400      	str	r4, [sp, #0]
 801120a:	f001 fb09 	bl	8012820 <__kernel_sin>
 801120e:	2380      	movs	r3, #128	; 0x80
 8011210:	061b      	lsls	r3, r3, #24
 8011212:	469c      	mov	ip, r3
 8011214:	4461      	add	r1, ip
 8011216:	e7c9      	b.n	80111ac <sin+0x1c>
 8011218:	3fe921fb 	.word	0x3fe921fb
 801121c:	7fefffff 	.word	0x7fefffff

08011220 <sqrt>:
 8011220:	b5f0      	push	{r4, r5, r6, r7, lr}
 8011222:	4647      	mov	r7, r8
 8011224:	46ce      	mov	lr, r9
 8011226:	b580      	push	{r7, lr}
 8011228:	b08d      	sub	sp, #52	; 0x34
 801122a:	0004      	movs	r4, r0
 801122c:	000d      	movs	r5, r1
 801122e:	f000 fb4f 	bl	80118d0 <__ieee754_sqrt>
 8011232:	4b2b      	ldr	r3, [pc, #172]	; (80112e0 <sqrt+0xc0>)
 8011234:	0006      	movs	r6, r0
 8011236:	781b      	ldrb	r3, [r3, #0]
 8011238:	000f      	movs	r7, r1
 801123a:	b25b      	sxtb	r3, r3
 801123c:	4698      	mov	r8, r3
 801123e:	3301      	adds	r3, #1
 8011240:	d010      	beq.n	8011264 <sqrt+0x44>
 8011242:	0022      	movs	r2, r4
 8011244:	002b      	movs	r3, r5
 8011246:	0020      	movs	r0, r4
 8011248:	0029      	movs	r1, r5
 801124a:	f7f1 fff9 	bl	8003240 <__aeabi_dcmpun>
 801124e:	4681      	mov	r9, r0
 8011250:	2800      	cmp	r0, #0
 8011252:	d107      	bne.n	8011264 <sqrt+0x44>
 8011254:	2200      	movs	r2, #0
 8011256:	2300      	movs	r3, #0
 8011258:	0020      	movs	r0, r4
 801125a:	0029      	movs	r1, r5
 801125c:	f7ef f956 	bl	800050c <__aeabi_dcmplt>
 8011260:	2800      	cmp	r0, #0
 8011262:	d106      	bne.n	8011272 <sqrt+0x52>
 8011264:	0030      	movs	r0, r6
 8011266:	0039      	movs	r1, r7
 8011268:	b00d      	add	sp, #52	; 0x34
 801126a:	bc0c      	pop	{r2, r3}
 801126c:	4690      	mov	r8, r2
 801126e:	4699      	mov	r9, r3
 8011270:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8011272:	2301      	movs	r3, #1
 8011274:	9302      	str	r3, [sp, #8]
 8011276:	4b1b      	ldr	r3, [pc, #108]	; (80112e4 <sqrt+0xc4>)
 8011278:	9406      	str	r4, [sp, #24]
 801127a:	9507      	str	r5, [sp, #28]
 801127c:	9303      	str	r3, [sp, #12]
 801127e:	464b      	mov	r3, r9
 8011280:	930a      	str	r3, [sp, #40]	; 0x28
 8011282:	4643      	mov	r3, r8
 8011284:	9404      	str	r4, [sp, #16]
 8011286:	9505      	str	r5, [sp, #20]
 8011288:	2b00      	cmp	r3, #0
 801128a:	d015      	beq.n	80112b8 <sqrt+0x98>
 801128c:	2300      	movs	r3, #0
 801128e:	2200      	movs	r2, #0
 8011290:	0019      	movs	r1, r3
 8011292:	0010      	movs	r0, r2
 8011294:	f7f0 fdac 	bl	8001df0 <__aeabi_ddiv>
 8011298:	4643      	mov	r3, r8
 801129a:	9008      	str	r0, [sp, #32]
 801129c:	9109      	str	r1, [sp, #36]	; 0x24
 801129e:	2b02      	cmp	r3, #2
 80112a0:	d10e      	bne.n	80112c0 <sqrt+0xa0>
 80112a2:	f001 ff0d 	bl	80130c0 <__errno>
 80112a6:	2321      	movs	r3, #33	; 0x21
 80112a8:	6003      	str	r3, [r0, #0]
 80112aa:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80112ac:	9301      	str	r3, [sp, #4]
 80112ae:	2b00      	cmp	r3, #0
 80112b0:	d10f      	bne.n	80112d2 <sqrt+0xb2>
 80112b2:	9e08      	ldr	r6, [sp, #32]
 80112b4:	9f09      	ldr	r7, [sp, #36]	; 0x24
 80112b6:	e7d5      	b.n	8011264 <sqrt+0x44>
 80112b8:	2300      	movs	r3, #0
 80112ba:	2400      	movs	r4, #0
 80112bc:	9308      	str	r3, [sp, #32]
 80112be:	9409      	str	r4, [sp, #36]	; 0x24
 80112c0:	a802      	add	r0, sp, #8
 80112c2:	f001 fbfd 	bl	8012ac0 <matherr>
 80112c6:	2800      	cmp	r0, #0
 80112c8:	d0eb      	beq.n	80112a2 <sqrt+0x82>
 80112ca:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80112cc:	9301      	str	r3, [sp, #4]
 80112ce:	2b00      	cmp	r3, #0
 80112d0:	d0ef      	beq.n	80112b2 <sqrt+0x92>
 80112d2:	f001 fef5 	bl	80130c0 <__errno>
 80112d6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80112d8:	9301      	str	r3, [sp, #4]
 80112da:	6003      	str	r3, [r0, #0]
 80112dc:	e7e9      	b.n	80112b2 <sqrt+0x92>
 80112de:	46c0      	nop			; (mov r8, r8)
 80112e0:	20001660 	.word	0x20001660
 80112e4:	08016a40 	.word	0x08016a40
	...

080112f0 <atan2f>:
 80112f0:	b510      	push	{r4, lr}
 80112f2:	f000 fbcd 	bl	8011a90 <__ieee754_atan2f>
 80112f6:	bd10      	pop	{r4, pc}
	...

08011300 <log10f>:
 8011300:	b5f0      	push	{r4, r5, r6, r7, lr}
 8011302:	2500      	movs	r5, #0
 8011304:	b08d      	sub	sp, #52	; 0x34
 8011306:	1c04      	adds	r4, r0, #0
 8011308:	f000 fc52 	bl	8011bb0 <__ieee754_log10f>
 801130c:	4b36      	ldr	r3, [pc, #216]	; (80113e8 <log10f+0xe8>)
 801130e:	1c06      	adds	r6, r0, #0
 8011310:	575d      	ldrsb	r5, [r3, r5]
 8011312:	1c6b      	adds	r3, r5, #1
 8011314:	d00b      	beq.n	801132e <log10f+0x2e>
 8011316:	1c21      	adds	r1, r4, #0
 8011318:	1c20      	adds	r0, r4, #0
 801131a:	f7f0 f929 	bl	8001570 <__aeabi_fcmpun>
 801131e:	1e07      	subs	r7, r0, #0
 8011320:	d105      	bne.n	801132e <log10f+0x2e>
 8011322:	2100      	movs	r1, #0
 8011324:	1c20      	adds	r0, r4, #0
 8011326:	f7ef f937 	bl	8000598 <__aeabi_fcmple>
 801132a:	2800      	cmp	r0, #0
 801132c:	d102      	bne.n	8011334 <log10f+0x34>
 801132e:	1c30      	adds	r0, r6, #0
 8011330:	b00d      	add	sp, #52	; 0x34
 8011332:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8011334:	4b2d      	ldr	r3, [pc, #180]	; (80113ec <log10f+0xec>)
 8011336:	1c20      	adds	r0, r4, #0
 8011338:	9303      	str	r3, [sp, #12]
 801133a:	970a      	str	r7, [sp, #40]	; 0x28
 801133c:	f7f2 f850 	bl	80033e0 <__aeabi_f2d>
 8011340:	9006      	str	r0, [sp, #24]
 8011342:	9107      	str	r1, [sp, #28]
 8011344:	9004      	str	r0, [sp, #16]
 8011346:	9105      	str	r1, [sp, #20]
 8011348:	2d00      	cmp	r5, #0
 801134a:	d01b      	beq.n	8011384 <log10f+0x84>
 801134c:	2200      	movs	r2, #0
 801134e:	4b28      	ldr	r3, [pc, #160]	; (80113f0 <log10f+0xf0>)
 8011350:	2100      	movs	r1, #0
 8011352:	1c20      	adds	r0, r4, #0
 8011354:	9208      	str	r2, [sp, #32]
 8011356:	9309      	str	r3, [sp, #36]	; 0x24
 8011358:	f7ef f90e 	bl	8000578 <__aeabi_fcmpeq>
 801135c:	2800      	cmp	r0, #0
 801135e:	d03a      	beq.n	80113d6 <log10f+0xd6>
 8011360:	2302      	movs	r3, #2
 8011362:	9302      	str	r3, [sp, #8]
 8011364:	2d02      	cmp	r5, #2
 8011366:	d130      	bne.n	80113ca <log10f+0xca>
 8011368:	f001 feaa 	bl	80130c0 <__errno>
 801136c:	2322      	movs	r3, #34	; 0x22
 801136e:	6003      	str	r3, [r0, #0]
 8011370:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8011372:	9301      	str	r3, [sp, #4]
 8011374:	2b00      	cmp	r3, #0
 8011376:	d120      	bne.n	80113ba <log10f+0xba>
 8011378:	9808      	ldr	r0, [sp, #32]
 801137a:	9909      	ldr	r1, [sp, #36]	; 0x24
 801137c:	f7f2 f888 	bl	8003490 <__aeabi_d2f>
 8011380:	1c06      	adds	r6, r0, #0
 8011382:	e7d4      	b.n	801132e <log10f+0x2e>
 8011384:	22e0      	movs	r2, #224	; 0xe0
 8011386:	4b1b      	ldr	r3, [pc, #108]	; (80113f4 <log10f+0xf4>)
 8011388:	0612      	lsls	r2, r2, #24
 801138a:	2100      	movs	r1, #0
 801138c:	1c20      	adds	r0, r4, #0
 801138e:	9208      	str	r2, [sp, #32]
 8011390:	9309      	str	r3, [sp, #36]	; 0x24
 8011392:	f7ef f8f1 	bl	8000578 <__aeabi_fcmpeq>
 8011396:	2800      	cmp	r0, #0
 8011398:	d115      	bne.n	80113c6 <log10f+0xc6>
 801139a:	2301      	movs	r3, #1
 801139c:	9302      	str	r3, [sp, #8]
 801139e:	a802      	add	r0, sp, #8
 80113a0:	f001 fb8e 	bl	8012ac0 <matherr>
 80113a4:	2800      	cmp	r0, #0
 80113a6:	d01a      	beq.n	80113de <log10f+0xde>
 80113a8:	4813      	ldr	r0, [pc, #76]	; (80113f8 <log10f+0xf8>)
 80113aa:	f001 fb91 	bl	8012ad0 <nan>
 80113ae:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80113b0:	9008      	str	r0, [sp, #32]
 80113b2:	9109      	str	r1, [sp, #36]	; 0x24
 80113b4:	9301      	str	r3, [sp, #4]
 80113b6:	2b00      	cmp	r3, #0
 80113b8:	d0de      	beq.n	8011378 <log10f+0x78>
 80113ba:	f001 fe81 	bl	80130c0 <__errno>
 80113be:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80113c0:	9301      	str	r3, [sp, #4]
 80113c2:	6003      	str	r3, [r0, #0]
 80113c4:	e7d8      	b.n	8011378 <log10f+0x78>
 80113c6:	2302      	movs	r3, #2
 80113c8:	9302      	str	r3, [sp, #8]
 80113ca:	a802      	add	r0, sp, #8
 80113cc:	f001 fb78 	bl	8012ac0 <matherr>
 80113d0:	2800      	cmp	r0, #0
 80113d2:	d1cd      	bne.n	8011370 <log10f+0x70>
 80113d4:	e7c8      	b.n	8011368 <log10f+0x68>
 80113d6:	2301      	movs	r3, #1
 80113d8:	9302      	str	r3, [sp, #8]
 80113da:	2d02      	cmp	r5, #2
 80113dc:	d1df      	bne.n	801139e <log10f+0x9e>
 80113de:	f001 fe6f 	bl	80130c0 <__errno>
 80113e2:	2321      	movs	r3, #33	; 0x21
 80113e4:	6003      	str	r3, [r0, #0]
 80113e6:	e7df      	b.n	80113a8 <log10f+0xa8>
 80113e8:	20001660 	.word	0x20001660
 80113ec:	08016a48 	.word	0x08016a48
 80113f0:	fff00000 	.word	0xfff00000
 80113f4:	c7efffff 	.word	0xc7efffff
 80113f8:	08013f2c 	.word	0x08013f2c
 80113fc:	00000000 	.word	0x00000000

08011400 <sqrtf>:
 8011400:	b5f0      	push	{r4, r5, r6, r7, lr}
 8011402:	2500      	movs	r5, #0
 8011404:	b08d      	sub	sp, #52	; 0x34
 8011406:	1c04      	adds	r4, r0, #0
 8011408:	f000 fc2a 	bl	8011c60 <__ieee754_sqrtf>
 801140c:	4b25      	ldr	r3, [pc, #148]	; (80114a4 <sqrtf+0xa4>)
 801140e:	1c06      	adds	r6, r0, #0
 8011410:	575d      	ldrsb	r5, [r3, r5]
 8011412:	1c6b      	adds	r3, r5, #1
 8011414:	d00b      	beq.n	801142e <sqrtf+0x2e>
 8011416:	1c21      	adds	r1, r4, #0
 8011418:	1c20      	adds	r0, r4, #0
 801141a:	f7f0 f8a9 	bl	8001570 <__aeabi_fcmpun>
 801141e:	1e07      	subs	r7, r0, #0
 8011420:	d105      	bne.n	801142e <sqrtf+0x2e>
 8011422:	2100      	movs	r1, #0
 8011424:	1c20      	adds	r0, r4, #0
 8011426:	f7ef f8ad 	bl	8000584 <__aeabi_fcmplt>
 801142a:	2800      	cmp	r0, #0
 801142c:	d102      	bne.n	8011434 <sqrtf+0x34>
 801142e:	1c30      	adds	r0, r6, #0
 8011430:	b00d      	add	sp, #52	; 0x34
 8011432:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8011434:	2301      	movs	r3, #1
 8011436:	9302      	str	r3, [sp, #8]
 8011438:	4b1b      	ldr	r3, [pc, #108]	; (80114a8 <sqrtf+0xa8>)
 801143a:	1c20      	adds	r0, r4, #0
 801143c:	9303      	str	r3, [sp, #12]
 801143e:	970a      	str	r7, [sp, #40]	; 0x28
 8011440:	f7f1 ffce 	bl	80033e0 <__aeabi_f2d>
 8011444:	2200      	movs	r2, #0
 8011446:	9006      	str	r0, [sp, #24]
 8011448:	9107      	str	r1, [sp, #28]
 801144a:	9004      	str	r0, [sp, #16]
 801144c:	9105      	str	r1, [sp, #20]
 801144e:	2300      	movs	r3, #0
 8011450:	2d00      	cmp	r5, #0
 8011452:	d015      	beq.n	8011480 <sqrtf+0x80>
 8011454:	0010      	movs	r0, r2
 8011456:	0019      	movs	r1, r3
 8011458:	f7f0 fcca 	bl	8001df0 <__aeabi_ddiv>
 801145c:	9008      	str	r0, [sp, #32]
 801145e:	9109      	str	r1, [sp, #36]	; 0x24
 8011460:	2d02      	cmp	r5, #2
 8011462:	d10f      	bne.n	8011484 <sqrtf+0x84>
 8011464:	f001 fe2c 	bl	80130c0 <__errno>
 8011468:	2321      	movs	r3, #33	; 0x21
 801146a:	6003      	str	r3, [r0, #0]
 801146c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801146e:	9301      	str	r3, [sp, #4]
 8011470:	2b00      	cmp	r3, #0
 8011472:	d110      	bne.n	8011496 <sqrtf+0x96>
 8011474:	9808      	ldr	r0, [sp, #32]
 8011476:	9909      	ldr	r1, [sp, #36]	; 0x24
 8011478:	f7f2 f80a 	bl	8003490 <__aeabi_d2f>
 801147c:	1c06      	adds	r6, r0, #0
 801147e:	e7d6      	b.n	801142e <sqrtf+0x2e>
 8011480:	9208      	str	r2, [sp, #32]
 8011482:	9309      	str	r3, [sp, #36]	; 0x24
 8011484:	a802      	add	r0, sp, #8
 8011486:	f001 fb1b 	bl	8012ac0 <matherr>
 801148a:	2800      	cmp	r0, #0
 801148c:	d0ea      	beq.n	8011464 <sqrtf+0x64>
 801148e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8011490:	9301      	str	r3, [sp, #4]
 8011492:	2b00      	cmp	r3, #0
 8011494:	d0ee      	beq.n	8011474 <sqrtf+0x74>
 8011496:	f001 fe13 	bl	80130c0 <__errno>
 801149a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801149c:	9301      	str	r3, [sp, #4]
 801149e:	6003      	str	r3, [r0, #0]
 80114a0:	e7e8      	b.n	8011474 <sqrtf+0x74>
 80114a2:	46c0      	nop			; (mov r8, r8)
 80114a4:	20001660 	.word	0x20001660
 80114a8:	08016a50 	.word	0x08016a50
 80114ac:	00000000 	.word	0x00000000

080114b0 <__ieee754_rem_pio2>:
 80114b0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80114b2:	464e      	mov	r6, r9
 80114b4:	4645      	mov	r5, r8
 80114b6:	46de      	mov	lr, fp
 80114b8:	4657      	mov	r7, sl
 80114ba:	b5e0      	push	{r5, r6, r7, lr}
 80114bc:	4bd0      	ldr	r3, [pc, #832]	; (8011800 <__ieee754_rem_pio2+0x350>)
 80114be:	004c      	lsls	r4, r1, #1
 80114c0:	b08f      	sub	sp, #60	; 0x3c
 80114c2:	0015      	movs	r5, r2
 80114c4:	4689      	mov	r9, r1
 80114c6:	0864      	lsrs	r4, r4, #1
 80114c8:	429c      	cmp	r4, r3
 80114ca:	dc00      	bgt.n	80114ce <__ieee754_rem_pio2+0x1e>
 80114cc:	e084      	b.n	80115d8 <__ieee754_rem_pio2+0x128>
 80114ce:	4bcd      	ldr	r3, [pc, #820]	; (8011804 <__ieee754_rem_pio2+0x354>)
 80114d0:	429c      	cmp	r4, r3
 80114d2:	dc28      	bgt.n	8011526 <__ieee754_rem_pio2+0x76>
 80114d4:	4acc      	ldr	r2, [pc, #816]	; (8011808 <__ieee754_rem_pio2+0x358>)
 80114d6:	2900      	cmp	r1, #0
 80114d8:	dc00      	bgt.n	80114dc <__ieee754_rem_pio2+0x2c>
 80114da:	e1b7      	b.n	801184c <__ieee754_rem_pio2+0x39c>
 80114dc:	4bcb      	ldr	r3, [pc, #812]	; (801180c <__ieee754_rem_pio2+0x35c>)
 80114de:	f7f1 fb17 	bl	8002b10 <__aeabi_dsub>
 80114e2:	4bca      	ldr	r3, [pc, #808]	; (801180c <__ieee754_rem_pio2+0x35c>)
 80114e4:	0006      	movs	r6, r0
 80114e6:	000f      	movs	r7, r1
 80114e8:	429c      	cmp	r4, r3
 80114ea:	d100      	bne.n	80114ee <__ieee754_rem_pio2+0x3e>
 80114ec:	e08a      	b.n	8011604 <__ieee754_rem_pio2+0x154>
 80114ee:	4ac8      	ldr	r2, [pc, #800]	; (8011810 <__ieee754_rem_pio2+0x360>)
 80114f0:	4bc8      	ldr	r3, [pc, #800]	; (8011814 <__ieee754_rem_pio2+0x364>)
 80114f2:	f7f1 fb0d 	bl	8002b10 <__aeabi_dsub>
 80114f6:	0002      	movs	r2, r0
 80114f8:	000b      	movs	r3, r1
 80114fa:	0030      	movs	r0, r6
 80114fc:	602a      	str	r2, [r5, #0]
 80114fe:	606b      	str	r3, [r5, #4]
 8011500:	0039      	movs	r1, r7
 8011502:	f7f1 fb05 	bl	8002b10 <__aeabi_dsub>
 8011506:	4bc3      	ldr	r3, [pc, #780]	; (8011814 <__ieee754_rem_pio2+0x364>)
 8011508:	4ac1      	ldr	r2, [pc, #772]	; (8011810 <__ieee754_rem_pio2+0x360>)
 801150a:	f7f1 fb01 	bl	8002b10 <__aeabi_dsub>
 801150e:	2301      	movs	r3, #1
 8011510:	4698      	mov	r8, r3
 8011512:	60a8      	str	r0, [r5, #8]
 8011514:	60e9      	str	r1, [r5, #12]
 8011516:	4640      	mov	r0, r8
 8011518:	b00f      	add	sp, #60	; 0x3c
 801151a:	bc3c      	pop	{r2, r3, r4, r5}
 801151c:	4690      	mov	r8, r2
 801151e:	4699      	mov	r9, r3
 8011520:	46a2      	mov	sl, r4
 8011522:	46ab      	mov	fp, r5
 8011524:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8011526:	4bbc      	ldr	r3, [pc, #752]	; (8011818 <__ieee754_rem_pio2+0x368>)
 8011528:	429c      	cmp	r4, r3
 801152a:	dc00      	bgt.n	801152e <__ieee754_rem_pio2+0x7e>
 801152c:	e086      	b.n	801163c <__ieee754_rem_pio2+0x18c>
 801152e:	4bbb      	ldr	r3, [pc, #748]	; (801181c <__ieee754_rem_pio2+0x36c>)
 8011530:	429c      	cmp	r4, r3
 8011532:	dc5c      	bgt.n	80115ee <__ieee754_rem_pio2+0x13e>
 8011534:	49ba      	ldr	r1, [pc, #744]	; (8011820 <__ieee754_rem_pio2+0x370>)
 8011536:	1522      	asrs	r2, r4, #20
 8011538:	4688      	mov	r8, r1
 801153a:	4490      	add	r8, r2
 801153c:	4643      	mov	r3, r8
 801153e:	051b      	lsls	r3, r3, #20
 8011540:	1ae7      	subs	r7, r4, r3
 8011542:	0039      	movs	r1, r7
 8011544:	0006      	movs	r6, r0
 8011546:	f7f1 fe9b 	bl	8003280 <__aeabi_d2iz>
 801154a:	f7f1 fed1 	bl	80032f0 <__aeabi_i2d>
 801154e:	0002      	movs	r2, r0
 8011550:	000b      	movs	r3, r1
 8011552:	0030      	movs	r0, r6
 8011554:	0039      	movs	r1, r7
 8011556:	9208      	str	r2, [sp, #32]
 8011558:	9309      	str	r3, [sp, #36]	; 0x24
 801155a:	f7f1 fad9 	bl	8002b10 <__aeabi_dsub>
 801155e:	2200      	movs	r2, #0
 8011560:	4bb0      	ldr	r3, [pc, #704]	; (8011824 <__ieee754_rem_pio2+0x374>)
 8011562:	f7f1 f84d 	bl	8002600 <__aeabi_dmul>
 8011566:	000f      	movs	r7, r1
 8011568:	0006      	movs	r6, r0
 801156a:	f7f1 fe89 	bl	8003280 <__aeabi_d2iz>
 801156e:	0004      	movs	r4, r0
 8011570:	f7f1 febe 	bl	80032f0 <__aeabi_i2d>
 8011574:	0002      	movs	r2, r0
 8011576:	000b      	movs	r3, r1
 8011578:	0030      	movs	r0, r6
 801157a:	0039      	movs	r1, r7
 801157c:	920a      	str	r2, [sp, #40]	; 0x28
 801157e:	930b      	str	r3, [sp, #44]	; 0x2c
 8011580:	f7f1 fac6 	bl	8002b10 <__aeabi_dsub>
 8011584:	2200      	movs	r2, #0
 8011586:	4ba7      	ldr	r3, [pc, #668]	; (8011824 <__ieee754_rem_pio2+0x374>)
 8011588:	f7f1 f83a 	bl	8002600 <__aeabi_dmul>
 801158c:	2200      	movs	r2, #0
 801158e:	2300      	movs	r3, #0
 8011590:	900c      	str	r0, [sp, #48]	; 0x30
 8011592:	910d      	str	r1, [sp, #52]	; 0x34
 8011594:	f7ee ffb4 	bl	8000500 <__aeabi_dcmpeq>
 8011598:	2800      	cmp	r0, #0
 801159a:	d100      	bne.n	801159e <__ieee754_rem_pio2+0xee>
 801159c:	e0fa      	b.n	8011794 <__ieee754_rem_pio2+0x2e4>
 801159e:	0023      	movs	r3, r4
 80115a0:	1e5c      	subs	r4, r3, #1
 80115a2:	41a3      	sbcs	r3, r4
 80115a4:	3301      	adds	r3, #1
 80115a6:	4aa0      	ldr	r2, [pc, #640]	; (8011828 <__ieee754_rem_pio2+0x378>)
 80115a8:	0029      	movs	r1, r5
 80115aa:	9201      	str	r2, [sp, #4]
 80115ac:	2202      	movs	r2, #2
 80115ae:	a808      	add	r0, sp, #32
 80115b0:	9200      	str	r2, [sp, #0]
 80115b2:	4642      	mov	r2, r8
 80115b4:	f000 fcd4 	bl	8011f60 <__kernel_rem_pio2>
 80115b8:	464b      	mov	r3, r9
 80115ba:	4680      	mov	r8, r0
 80115bc:	2b00      	cmp	r3, #0
 80115be:	daaa      	bge.n	8011516 <__ieee754_rem_pio2+0x66>
 80115c0:	2280      	movs	r2, #128	; 0x80
 80115c2:	0612      	lsls	r2, r2, #24
 80115c4:	4694      	mov	ip, r2
 80115c6:	686b      	ldr	r3, [r5, #4]
 80115c8:	4463      	add	r3, ip
 80115ca:	606b      	str	r3, [r5, #4]
 80115cc:	68eb      	ldr	r3, [r5, #12]
 80115ce:	4463      	add	r3, ip
 80115d0:	60eb      	str	r3, [r5, #12]
 80115d2:	4243      	negs	r3, r0
 80115d4:	4698      	mov	r8, r3
 80115d6:	e79e      	b.n	8011516 <__ieee754_rem_pio2+0x66>
 80115d8:	0002      	movs	r2, r0
 80115da:	000b      	movs	r3, r1
 80115dc:	602a      	str	r2, [r5, #0]
 80115de:	606b      	str	r3, [r5, #4]
 80115e0:	2300      	movs	r3, #0
 80115e2:	2200      	movs	r2, #0
 80115e4:	60aa      	str	r2, [r5, #8]
 80115e6:	60eb      	str	r3, [r5, #12]
 80115e8:	2300      	movs	r3, #0
 80115ea:	4698      	mov	r8, r3
 80115ec:	e793      	b.n	8011516 <__ieee754_rem_pio2+0x66>
 80115ee:	000b      	movs	r3, r1
 80115f0:	0002      	movs	r2, r0
 80115f2:	f7f1 fa8d 	bl	8002b10 <__aeabi_dsub>
 80115f6:	2300      	movs	r3, #0
 80115f8:	60a8      	str	r0, [r5, #8]
 80115fa:	60e9      	str	r1, [r5, #12]
 80115fc:	6028      	str	r0, [r5, #0]
 80115fe:	6069      	str	r1, [r5, #4]
 8011600:	4698      	mov	r8, r3
 8011602:	e788      	b.n	8011516 <__ieee754_rem_pio2+0x66>
 8011604:	22d3      	movs	r2, #211	; 0xd3
 8011606:	4b83      	ldr	r3, [pc, #524]	; (8011814 <__ieee754_rem_pio2+0x364>)
 8011608:	0552      	lsls	r2, r2, #21
 801160a:	f7f1 fa81 	bl	8002b10 <__aeabi_dsub>
 801160e:	4a87      	ldr	r2, [pc, #540]	; (801182c <__ieee754_rem_pio2+0x37c>)
 8011610:	4b87      	ldr	r3, [pc, #540]	; (8011830 <__ieee754_rem_pio2+0x380>)
 8011612:	0006      	movs	r6, r0
 8011614:	000f      	movs	r7, r1
 8011616:	f7f1 fa7b 	bl	8002b10 <__aeabi_dsub>
 801161a:	0002      	movs	r2, r0
 801161c:	000b      	movs	r3, r1
 801161e:	0030      	movs	r0, r6
 8011620:	602a      	str	r2, [r5, #0]
 8011622:	606b      	str	r3, [r5, #4]
 8011624:	0039      	movs	r1, r7
 8011626:	f7f1 fa73 	bl	8002b10 <__aeabi_dsub>
 801162a:	4b81      	ldr	r3, [pc, #516]	; (8011830 <__ieee754_rem_pio2+0x380>)
 801162c:	4a7f      	ldr	r2, [pc, #508]	; (801182c <__ieee754_rem_pio2+0x37c>)
 801162e:	f7f1 fa6f 	bl	8002b10 <__aeabi_dsub>
 8011632:	2301      	movs	r3, #1
 8011634:	60a8      	str	r0, [r5, #8]
 8011636:	60e9      	str	r1, [r5, #12]
 8011638:	4698      	mov	r8, r3
 801163a:	e76c      	b.n	8011516 <__ieee754_rem_pio2+0x66>
 801163c:	f001 f9a8 	bl	8012990 <fabs>
 8011640:	4a7c      	ldr	r2, [pc, #496]	; (8011834 <__ieee754_rem_pio2+0x384>)
 8011642:	4b7d      	ldr	r3, [pc, #500]	; (8011838 <__ieee754_rem_pio2+0x388>)
 8011644:	0006      	movs	r6, r0
 8011646:	000f      	movs	r7, r1
 8011648:	f7f0 ffda 	bl	8002600 <__aeabi_dmul>
 801164c:	2200      	movs	r2, #0
 801164e:	4b7b      	ldr	r3, [pc, #492]	; (801183c <__ieee754_rem_pio2+0x38c>)
 8011650:	f7f0 f856 	bl	8001700 <__aeabi_dadd>
 8011654:	f7f1 fe14 	bl	8003280 <__aeabi_d2iz>
 8011658:	4680      	mov	r8, r0
 801165a:	f7f1 fe49 	bl	80032f0 <__aeabi_i2d>
 801165e:	4a6a      	ldr	r2, [pc, #424]	; (8011808 <__ieee754_rem_pio2+0x358>)
 8011660:	4b6a      	ldr	r3, [pc, #424]	; (801180c <__ieee754_rem_pio2+0x35c>)
 8011662:	9004      	str	r0, [sp, #16]
 8011664:	9105      	str	r1, [sp, #20]
 8011666:	f7f0 ffcb 	bl	8002600 <__aeabi_dmul>
 801166a:	0002      	movs	r2, r0
 801166c:	000b      	movs	r3, r1
 801166e:	0030      	movs	r0, r6
 8011670:	0039      	movs	r1, r7
 8011672:	f7f1 fa4d 	bl	8002b10 <__aeabi_dsub>
 8011676:	4a66      	ldr	r2, [pc, #408]	; (8011810 <__ieee754_rem_pio2+0x360>)
 8011678:	9002      	str	r0, [sp, #8]
 801167a:	9103      	str	r1, [sp, #12]
 801167c:	9804      	ldr	r0, [sp, #16]
 801167e:	9905      	ldr	r1, [sp, #20]
 8011680:	4b64      	ldr	r3, [pc, #400]	; (8011814 <__ieee754_rem_pio2+0x364>)
 8011682:	f7f0 ffbd 	bl	8002600 <__aeabi_dmul>
 8011686:	4643      	mov	r3, r8
 8011688:	0006      	movs	r6, r0
 801168a:	000f      	movs	r7, r1
 801168c:	0002      	movs	r2, r0
 801168e:	2b1f      	cmp	r3, #31
 8011690:	dc33      	bgt.n	80116fa <__ieee754_rem_pio2+0x24a>
 8011692:	000b      	movs	r3, r1
 8011694:	9802      	ldr	r0, [sp, #8]
 8011696:	9903      	ldr	r1, [sp, #12]
 8011698:	f7f1 fa3a 	bl	8002b10 <__aeabi_dsub>
 801169c:	4643      	mov	r3, r8
 801169e:	4a68      	ldr	r2, [pc, #416]	; (8011840 <__ieee754_rem_pio2+0x390>)
 80116a0:	3b01      	subs	r3, #1
 80116a2:	009b      	lsls	r3, r3, #2
 80116a4:	589b      	ldr	r3, [r3, r2]
 80116a6:	4683      	mov	fp, r0
 80116a8:	468a      	mov	sl, r1
 80116aa:	42a3      	cmp	r3, r4
 80116ac:	d02c      	beq.n	8011708 <__ieee754_rem_pio2+0x258>
 80116ae:	465a      	mov	r2, fp
 80116b0:	4653      	mov	r3, sl
 80116b2:	602a      	str	r2, [r5, #0]
 80116b4:	606b      	str	r3, [r5, #4]
 80116b6:	9802      	ldr	r0, [sp, #8]
 80116b8:	9903      	ldr	r1, [sp, #12]
 80116ba:	465a      	mov	r2, fp
 80116bc:	4653      	mov	r3, sl
 80116be:	f7f1 fa27 	bl	8002b10 <__aeabi_dsub>
 80116c2:	0032      	movs	r2, r6
 80116c4:	003b      	movs	r3, r7
 80116c6:	f7f1 fa23 	bl	8002b10 <__aeabi_dsub>
 80116ca:	000b      	movs	r3, r1
 80116cc:	0002      	movs	r2, r0
 80116ce:	60aa      	str	r2, [r5, #8]
 80116d0:	60eb      	str	r3, [r5, #12]
 80116d2:	464b      	mov	r3, r9
 80116d4:	2b00      	cmp	r3, #0
 80116d6:	db00      	blt.n	80116da <__ieee754_rem_pio2+0x22a>
 80116d8:	e71d      	b.n	8011516 <__ieee754_rem_pio2+0x66>
 80116da:	465b      	mov	r3, fp
 80116dc:	602b      	str	r3, [r5, #0]
 80116de:	2380      	movs	r3, #128	; 0x80
 80116e0:	061b      	lsls	r3, r3, #24
 80116e2:	4453      	add	r3, sl
 80116e4:	606b      	str	r3, [r5, #4]
 80116e6:	2380      	movs	r3, #128	; 0x80
 80116e8:	061b      	lsls	r3, r3, #24
 80116ea:	469c      	mov	ip, r3
 80116ec:	4643      	mov	r3, r8
 80116ee:	4461      	add	r1, ip
 80116f0:	425b      	negs	r3, r3
 80116f2:	60a8      	str	r0, [r5, #8]
 80116f4:	60e9      	str	r1, [r5, #12]
 80116f6:	4698      	mov	r8, r3
 80116f8:	e70d      	b.n	8011516 <__ieee754_rem_pio2+0x66>
 80116fa:	000b      	movs	r3, r1
 80116fc:	9802      	ldr	r0, [sp, #8]
 80116fe:	9903      	ldr	r1, [sp, #12]
 8011700:	f7f1 fa06 	bl	8002b10 <__aeabi_dsub>
 8011704:	4683      	mov	fp, r0
 8011706:	468a      	mov	sl, r1
 8011708:	4653      	mov	r3, sl
 801170a:	005b      	lsls	r3, r3, #1
 801170c:	1524      	asrs	r4, r4, #20
 801170e:	0d5b      	lsrs	r3, r3, #21
 8011710:	1ae3      	subs	r3, r4, r3
 8011712:	2b10      	cmp	r3, #16
 8011714:	ddcb      	ble.n	80116ae <__ieee754_rem_pio2+0x1fe>
 8011716:	9804      	ldr	r0, [sp, #16]
 8011718:	9905      	ldr	r1, [sp, #20]
 801171a:	22d3      	movs	r2, #211	; 0xd3
 801171c:	4b3d      	ldr	r3, [pc, #244]	; (8011814 <__ieee754_rem_pio2+0x364>)
 801171e:	0552      	lsls	r2, r2, #21
 8011720:	f7f0 ff6e 	bl	8002600 <__aeabi_dmul>
 8011724:	0006      	movs	r6, r0
 8011726:	000f      	movs	r7, r1
 8011728:	0002      	movs	r2, r0
 801172a:	000b      	movs	r3, r1
 801172c:	9802      	ldr	r0, [sp, #8]
 801172e:	9903      	ldr	r1, [sp, #12]
 8011730:	f7f1 f9ee 	bl	8002b10 <__aeabi_dsub>
 8011734:	0002      	movs	r2, r0
 8011736:	000b      	movs	r3, r1
 8011738:	9802      	ldr	r0, [sp, #8]
 801173a:	9903      	ldr	r1, [sp, #12]
 801173c:	9206      	str	r2, [sp, #24]
 801173e:	9307      	str	r3, [sp, #28]
 8011740:	f7f1 f9e6 	bl	8002b10 <__aeabi_dsub>
 8011744:	0032      	movs	r2, r6
 8011746:	003b      	movs	r3, r7
 8011748:	f7f1 f9e2 	bl	8002b10 <__aeabi_dsub>
 801174c:	0006      	movs	r6, r0
 801174e:	000f      	movs	r7, r1
 8011750:	9804      	ldr	r0, [sp, #16]
 8011752:	9905      	ldr	r1, [sp, #20]
 8011754:	4a35      	ldr	r2, [pc, #212]	; (801182c <__ieee754_rem_pio2+0x37c>)
 8011756:	4b36      	ldr	r3, [pc, #216]	; (8011830 <__ieee754_rem_pio2+0x380>)
 8011758:	f7f0 ff52 	bl	8002600 <__aeabi_dmul>
 801175c:	0032      	movs	r2, r6
 801175e:	003b      	movs	r3, r7
 8011760:	f7f1 f9d6 	bl	8002b10 <__aeabi_dsub>
 8011764:	000b      	movs	r3, r1
 8011766:	0002      	movs	r2, r0
 8011768:	0006      	movs	r6, r0
 801176a:	000f      	movs	r7, r1
 801176c:	9806      	ldr	r0, [sp, #24]
 801176e:	9907      	ldr	r1, [sp, #28]
 8011770:	f7f1 f9ce 	bl	8002b10 <__aeabi_dsub>
 8011774:	004b      	lsls	r3, r1, #1
 8011776:	0d5b      	lsrs	r3, r3, #21
 8011778:	4683      	mov	fp, r0
 801177a:	468a      	mov	sl, r1
 801177c:	1ae4      	subs	r4, r4, r3
 801177e:	2c31      	cmp	r4, #49	; 0x31
 8011780:	dc0a      	bgt.n	8011798 <__ieee754_rem_pio2+0x2e8>
 8011782:	000b      	movs	r3, r1
 8011784:	0002      	movs	r2, r0
 8011786:	602a      	str	r2, [r5, #0]
 8011788:	606b      	str	r3, [r5, #4]
 801178a:	9b06      	ldr	r3, [sp, #24]
 801178c:	9c07      	ldr	r4, [sp, #28]
 801178e:	9302      	str	r3, [sp, #8]
 8011790:	9403      	str	r4, [sp, #12]
 8011792:	e790      	b.n	80116b6 <__ieee754_rem_pio2+0x206>
 8011794:	2303      	movs	r3, #3
 8011796:	e706      	b.n	80115a6 <__ieee754_rem_pio2+0xf6>
 8011798:	22b8      	movs	r2, #184	; 0xb8
 801179a:	9804      	ldr	r0, [sp, #16]
 801179c:	9905      	ldr	r1, [sp, #20]
 801179e:	0592      	lsls	r2, r2, #22
 80117a0:	4b23      	ldr	r3, [pc, #140]	; (8011830 <__ieee754_rem_pio2+0x380>)
 80117a2:	f7f0 ff2d 	bl	8002600 <__aeabi_dmul>
 80117a6:	0006      	movs	r6, r0
 80117a8:	000f      	movs	r7, r1
 80117aa:	0002      	movs	r2, r0
 80117ac:	000b      	movs	r3, r1
 80117ae:	9806      	ldr	r0, [sp, #24]
 80117b0:	9907      	ldr	r1, [sp, #28]
 80117b2:	f7f1 f9ad 	bl	8002b10 <__aeabi_dsub>
 80117b6:	0003      	movs	r3, r0
 80117b8:	000c      	movs	r4, r1
 80117ba:	0002      	movs	r2, r0
 80117bc:	9302      	str	r3, [sp, #8]
 80117be:	9403      	str	r4, [sp, #12]
 80117c0:	000b      	movs	r3, r1
 80117c2:	9806      	ldr	r0, [sp, #24]
 80117c4:	9907      	ldr	r1, [sp, #28]
 80117c6:	f7f1 f9a3 	bl	8002b10 <__aeabi_dsub>
 80117ca:	0032      	movs	r2, r6
 80117cc:	003b      	movs	r3, r7
 80117ce:	f7f1 f99f 	bl	8002b10 <__aeabi_dsub>
 80117d2:	0006      	movs	r6, r0
 80117d4:	000f      	movs	r7, r1
 80117d6:	9804      	ldr	r0, [sp, #16]
 80117d8:	9905      	ldr	r1, [sp, #20]
 80117da:	4a1a      	ldr	r2, [pc, #104]	; (8011844 <__ieee754_rem_pio2+0x394>)
 80117dc:	4b1a      	ldr	r3, [pc, #104]	; (8011848 <__ieee754_rem_pio2+0x398>)
 80117de:	f7f0 ff0f 	bl	8002600 <__aeabi_dmul>
 80117e2:	0032      	movs	r2, r6
 80117e4:	003b      	movs	r3, r7
 80117e6:	f7f1 f993 	bl	8002b10 <__aeabi_dsub>
 80117ea:	0002      	movs	r2, r0
 80117ec:	000b      	movs	r3, r1
 80117ee:	0006      	movs	r6, r0
 80117f0:	000f      	movs	r7, r1
 80117f2:	9802      	ldr	r0, [sp, #8]
 80117f4:	9903      	ldr	r1, [sp, #12]
 80117f6:	f7f1 f98b 	bl	8002b10 <__aeabi_dsub>
 80117fa:	4683      	mov	fp, r0
 80117fc:	468a      	mov	sl, r1
 80117fe:	e756      	b.n	80116ae <__ieee754_rem_pio2+0x1fe>
 8011800:	3fe921fb 	.word	0x3fe921fb
 8011804:	4002d97b 	.word	0x4002d97b
 8011808:	54400000 	.word	0x54400000
 801180c:	3ff921fb 	.word	0x3ff921fb
 8011810:	1a626331 	.word	0x1a626331
 8011814:	3dd0b461 	.word	0x3dd0b461
 8011818:	413921fb 	.word	0x413921fb
 801181c:	7fefffff 	.word	0x7fefffff
 8011820:	fffffbea 	.word	0xfffffbea
 8011824:	41700000 	.word	0x41700000
 8011828:	08016ad8 	.word	0x08016ad8
 801182c:	2e037073 	.word	0x2e037073
 8011830:	3ba3198a 	.word	0x3ba3198a
 8011834:	6dc9c883 	.word	0x6dc9c883
 8011838:	3fe45f30 	.word	0x3fe45f30
 801183c:	3fe00000 	.word	0x3fe00000
 8011840:	08016a58 	.word	0x08016a58
 8011844:	252049c1 	.word	0x252049c1
 8011848:	397b839a 	.word	0x397b839a
 801184c:	4b19      	ldr	r3, [pc, #100]	; (80118b4 <__ieee754_rem_pio2+0x404>)
 801184e:	f7ef ff57 	bl	8001700 <__aeabi_dadd>
 8011852:	4b18      	ldr	r3, [pc, #96]	; (80118b4 <__ieee754_rem_pio2+0x404>)
 8011854:	0006      	movs	r6, r0
 8011856:	000f      	movs	r7, r1
 8011858:	429c      	cmp	r4, r3
 801185a:	d015      	beq.n	8011888 <__ieee754_rem_pio2+0x3d8>
 801185c:	4a16      	ldr	r2, [pc, #88]	; (80118b8 <__ieee754_rem_pio2+0x408>)
 801185e:	4b17      	ldr	r3, [pc, #92]	; (80118bc <__ieee754_rem_pio2+0x40c>)
 8011860:	f7ef ff4e 	bl	8001700 <__aeabi_dadd>
 8011864:	0002      	movs	r2, r0
 8011866:	000b      	movs	r3, r1
 8011868:	0030      	movs	r0, r6
 801186a:	602a      	str	r2, [r5, #0]
 801186c:	606b      	str	r3, [r5, #4]
 801186e:	0039      	movs	r1, r7
 8011870:	f7f1 f94e 	bl	8002b10 <__aeabi_dsub>
 8011874:	4a10      	ldr	r2, [pc, #64]	; (80118b8 <__ieee754_rem_pio2+0x408>)
 8011876:	4b11      	ldr	r3, [pc, #68]	; (80118bc <__ieee754_rem_pio2+0x40c>)
 8011878:	f7ef ff42 	bl	8001700 <__aeabi_dadd>
 801187c:	2301      	movs	r3, #1
 801187e:	425b      	negs	r3, r3
 8011880:	60a8      	str	r0, [r5, #8]
 8011882:	60e9      	str	r1, [r5, #12]
 8011884:	4698      	mov	r8, r3
 8011886:	e646      	b.n	8011516 <__ieee754_rem_pio2+0x66>
 8011888:	22d3      	movs	r2, #211	; 0xd3
 801188a:	4b0c      	ldr	r3, [pc, #48]	; (80118bc <__ieee754_rem_pio2+0x40c>)
 801188c:	0552      	lsls	r2, r2, #21
 801188e:	f7ef ff37 	bl	8001700 <__aeabi_dadd>
 8011892:	4a0b      	ldr	r2, [pc, #44]	; (80118c0 <__ieee754_rem_pio2+0x410>)
 8011894:	4b0b      	ldr	r3, [pc, #44]	; (80118c4 <__ieee754_rem_pio2+0x414>)
 8011896:	0006      	movs	r6, r0
 8011898:	000f      	movs	r7, r1
 801189a:	f7ef ff31 	bl	8001700 <__aeabi_dadd>
 801189e:	0002      	movs	r2, r0
 80118a0:	000b      	movs	r3, r1
 80118a2:	0030      	movs	r0, r6
 80118a4:	602a      	str	r2, [r5, #0]
 80118a6:	606b      	str	r3, [r5, #4]
 80118a8:	0039      	movs	r1, r7
 80118aa:	f7f1 f931 	bl	8002b10 <__aeabi_dsub>
 80118ae:	4a04      	ldr	r2, [pc, #16]	; (80118c0 <__ieee754_rem_pio2+0x410>)
 80118b0:	4b04      	ldr	r3, [pc, #16]	; (80118c4 <__ieee754_rem_pio2+0x414>)
 80118b2:	e7e1      	b.n	8011878 <__ieee754_rem_pio2+0x3c8>
 80118b4:	3ff921fb 	.word	0x3ff921fb
 80118b8:	1a626331 	.word	0x1a626331
 80118bc:	3dd0b461 	.word	0x3dd0b461
 80118c0:	2e037073 	.word	0x2e037073
 80118c4:	3ba3198a 	.word	0x3ba3198a
	...

080118d0 <__ieee754_sqrt>:
 80118d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80118d2:	4647      	mov	r7, r8
 80118d4:	46ce      	mov	lr, r9
 80118d6:	4a6a      	ldr	r2, [pc, #424]	; (8011a80 <__ieee754_sqrt+0x1b0>)
 80118d8:	b580      	push	{r7, lr}
 80118da:	000b      	movs	r3, r1
 80118dc:	000f      	movs	r7, r1
 80118de:	0011      	movs	r1, r2
 80118e0:	0005      	movs	r5, r0
 80118e2:	0004      	movs	r4, r0
 80118e4:	4039      	ands	r1, r7
 80118e6:	4291      	cmp	r1, r2
 80118e8:	d100      	bne.n	80118ec <__ieee754_sqrt+0x1c>
 80118ea:	e0a1      	b.n	8011a30 <__ieee754_sqrt+0x160>
 80118ec:	2f00      	cmp	r7, #0
 80118ee:	dd69      	ble.n	80119c4 <__ieee754_sqrt+0xf4>
 80118f0:	153f      	asrs	r7, r7, #20
 80118f2:	d100      	bne.n	80118f6 <__ieee754_sqrt+0x26>
 80118f4:	e0b4      	b.n	8011a60 <__ieee754_sqrt+0x190>
 80118f6:	4a63      	ldr	r2, [pc, #396]	; (8011a84 <__ieee754_sqrt+0x1b4>)
 80118f8:	031b      	lsls	r3, r3, #12
 80118fa:	4694      	mov	ip, r2
 80118fc:	2280      	movs	r2, #128	; 0x80
 80118fe:	0b1b      	lsrs	r3, r3, #12
 8011900:	0352      	lsls	r2, r2, #13
 8011902:	4313      	orrs	r3, r2
 8011904:	005b      	lsls	r3, r3, #1
 8011906:	0fe2      	lsrs	r2, r4, #31
 8011908:	4467      	add	r7, ip
 801190a:	189b      	adds	r3, r3, r2
 801190c:	0062      	lsls	r2, r4, #1
 801190e:	07f9      	lsls	r1, r7, #31
 8011910:	d503      	bpl.n	801191a <__ieee754_sqrt+0x4a>
 8011912:	0fd2      	lsrs	r2, r2, #31
 8011914:	005b      	lsls	r3, r3, #1
 8011916:	189b      	adds	r3, r3, r2
 8011918:	00a2      	lsls	r2, r4, #2
 801191a:	1079      	asrs	r1, r7, #1
 801191c:	468c      	mov	ip, r1
 801191e:	2100      	movs	r1, #0
 8011920:	2080      	movs	r0, #128	; 0x80
 8011922:	2416      	movs	r4, #22
 8011924:	4689      	mov	r9, r1
 8011926:	0380      	lsls	r0, r0, #14
 8011928:	180d      	adds	r5, r1, r0
 801192a:	429d      	cmp	r5, r3
 801192c:	dc02      	bgt.n	8011934 <__ieee754_sqrt+0x64>
 801192e:	1829      	adds	r1, r5, r0
 8011930:	1b5b      	subs	r3, r3, r5
 8011932:	4481      	add	r9, r0
 8011934:	0fd5      	lsrs	r5, r2, #31
 8011936:	005b      	lsls	r3, r3, #1
 8011938:	3c01      	subs	r4, #1
 801193a:	18eb      	adds	r3, r5, r3
 801193c:	0052      	lsls	r2, r2, #1
 801193e:	0840      	lsrs	r0, r0, #1
 8011940:	2c00      	cmp	r4, #0
 8011942:	d1f1      	bne.n	8011928 <__ieee754_sqrt+0x58>
 8011944:	2000      	movs	r0, #0
 8011946:	4680      	mov	r8, r0
 8011948:	2080      	movs	r0, #128	; 0x80
 801194a:	2520      	movs	r5, #32
 801194c:	2700      	movs	r7, #0
 801194e:	0600      	lsls	r0, r0, #24
 8011950:	e009      	b.n	8011966 <__ieee754_sqrt+0x96>
 8011952:	428b      	cmp	r3, r1
 8011954:	d05d      	beq.n	8011a12 <__ieee754_sqrt+0x142>
 8011956:	0fd4      	lsrs	r4, r2, #31
 8011958:	005b      	lsls	r3, r3, #1
 801195a:	3d01      	subs	r5, #1
 801195c:	191b      	adds	r3, r3, r4
 801195e:	0052      	lsls	r2, r2, #1
 8011960:	0840      	lsrs	r0, r0, #1
 8011962:	2d00      	cmp	r5, #0
 8011964:	d016      	beq.n	8011994 <__ieee754_sqrt+0xc4>
 8011966:	19c4      	adds	r4, r0, r7
 8011968:	428b      	cmp	r3, r1
 801196a:	ddf2      	ble.n	8011952 <__ieee754_sqrt+0x82>
 801196c:	1827      	adds	r7, r4, r0
 801196e:	000e      	movs	r6, r1
 8011970:	2c00      	cmp	r4, #0
 8011972:	db4a      	blt.n	8011a0a <__ieee754_sqrt+0x13a>
 8011974:	1a5b      	subs	r3, r3, r1
 8011976:	42a2      	cmp	r2, r4
 8011978:	4189      	sbcs	r1, r1
 801197a:	4249      	negs	r1, r1
 801197c:	1a5b      	subs	r3, r3, r1
 801197e:	1b12      	subs	r2, r2, r4
 8011980:	0fd4      	lsrs	r4, r2, #31
 8011982:	005b      	lsls	r3, r3, #1
 8011984:	3d01      	subs	r5, #1
 8011986:	4480      	add	r8, r0
 8011988:	0031      	movs	r1, r6
 801198a:	191b      	adds	r3, r3, r4
 801198c:	0052      	lsls	r2, r2, #1
 801198e:	0840      	lsrs	r0, r0, #1
 8011990:	2d00      	cmp	r5, #0
 8011992:	d1e8      	bne.n	8011966 <__ieee754_sqrt+0x96>
 8011994:	4313      	orrs	r3, r2
 8011996:	d144      	bne.n	8011a22 <__ieee754_sqrt+0x152>
 8011998:	4643      	mov	r3, r8
 801199a:	085b      	lsrs	r3, r3, #1
 801199c:	493a      	ldr	r1, [pc, #232]	; (8011a88 <__ieee754_sqrt+0x1b8>)
 801199e:	464a      	mov	r2, r9
 80119a0:	4688      	mov	r8, r1
 80119a2:	4649      	mov	r1, r9
 80119a4:	1052      	asrs	r2, r2, #1
 80119a6:	4442      	add	r2, r8
 80119a8:	07c9      	lsls	r1, r1, #31
 80119aa:	d502      	bpl.n	80119b2 <__ieee754_sqrt+0xe2>
 80119ac:	2180      	movs	r1, #128	; 0x80
 80119ae:	0609      	lsls	r1, r1, #24
 80119b0:	430b      	orrs	r3, r1
 80119b2:	4661      	mov	r1, ip
 80119b4:	001d      	movs	r5, r3
 80119b6:	050f      	lsls	r7, r1, #20
 80119b8:	18b9      	adds	r1, r7, r2
 80119ba:	0028      	movs	r0, r5
 80119bc:	bc0c      	pop	{r2, r3}
 80119be:	4690      	mov	r8, r2
 80119c0:	4699      	mov	r9, r3
 80119c2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80119c4:	007a      	lsls	r2, r7, #1
 80119c6:	0852      	lsrs	r2, r2, #1
 80119c8:	4302      	orrs	r2, r0
 80119ca:	d04c      	beq.n	8011a66 <__ieee754_sqrt+0x196>
 80119cc:	2f00      	cmp	r7, #0
 80119ce:	d13b      	bne.n	8011a48 <__ieee754_sqrt+0x178>
 80119d0:	0ae0      	lsrs	r0, r4, #11
 80119d2:	3b15      	subs	r3, #21
 80119d4:	0002      	movs	r2, r0
 80119d6:	0564      	lsls	r4, r4, #21
 80119d8:	2800      	cmp	r0, #0
 80119da:	d0f9      	beq.n	80119d0 <__ieee754_sqrt+0x100>
 80119dc:	2180      	movs	r1, #128	; 0x80
 80119de:	0349      	lsls	r1, r1, #13
 80119e0:	4208      	tst	r0, r1
 80119e2:	d147      	bne.n	8011a74 <__ieee754_sqrt+0x1a4>
 80119e4:	2080      	movs	r0, #128	; 0x80
 80119e6:	2700      	movs	r7, #0
 80119e8:	0340      	lsls	r0, r0, #13
 80119ea:	e000      	b.n	80119ee <__ieee754_sqrt+0x11e>
 80119ec:	002f      	movs	r7, r5
 80119ee:	0052      	lsls	r2, r2, #1
 80119f0:	1c7d      	adds	r5, r7, #1
 80119f2:	4202      	tst	r2, r0
 80119f4:	d0fa      	beq.n	80119ec <__ieee754_sqrt+0x11c>
 80119f6:	2620      	movs	r6, #32
 80119f8:	0010      	movs	r0, r2
 80119fa:	0022      	movs	r2, r4
 80119fc:	40ac      	lsls	r4, r5
 80119fe:	1b76      	subs	r6, r6, r5
 8011a00:	1bdf      	subs	r7, r3, r7
 8011a02:	0013      	movs	r3, r2
 8011a04:	40f3      	lsrs	r3, r6
 8011a06:	4303      	orrs	r3, r0
 8011a08:	e775      	b.n	80118f6 <__ieee754_sqrt+0x26>
 8011a0a:	43fe      	mvns	r6, r7
 8011a0c:	0ff6      	lsrs	r6, r6, #31
 8011a0e:	198e      	adds	r6, r1, r6
 8011a10:	e7b0      	b.n	8011974 <__ieee754_sqrt+0xa4>
 8011a12:	4294      	cmp	r4, r2
 8011a14:	d89f      	bhi.n	8011956 <__ieee754_sqrt+0x86>
 8011a16:	1827      	adds	r7, r4, r0
 8011a18:	2c00      	cmp	r4, #0
 8011a1a:	dbf6      	blt.n	8011a0a <__ieee754_sqrt+0x13a>
 8011a1c:	001e      	movs	r6, r3
 8011a1e:	2300      	movs	r3, #0
 8011a20:	e7ad      	b.n	801197e <__ieee754_sqrt+0xae>
 8011a22:	4643      	mov	r3, r8
 8011a24:	3301      	adds	r3, #1
 8011a26:	d020      	beq.n	8011a6a <__ieee754_sqrt+0x19a>
 8011a28:	4643      	mov	r3, r8
 8011a2a:	3301      	adds	r3, #1
 8011a2c:	085b      	lsrs	r3, r3, #1
 8011a2e:	e7b5      	b.n	801199c <__ieee754_sqrt+0xcc>
 8011a30:	0002      	movs	r2, r0
 8011a32:	003b      	movs	r3, r7
 8011a34:	0028      	movs	r0, r5
 8011a36:	0039      	movs	r1, r7
 8011a38:	f7f0 fde2 	bl	8002600 <__aeabi_dmul>
 8011a3c:	002a      	movs	r2, r5
 8011a3e:	003b      	movs	r3, r7
 8011a40:	f7ef fe5e 	bl	8001700 <__aeabi_dadd>
 8011a44:	0005      	movs	r5, r0
 8011a46:	e7b8      	b.n	80119ba <__ieee754_sqrt+0xea>
 8011a48:	0002      	movs	r2, r0
 8011a4a:	003b      	movs	r3, r7
 8011a4c:	0028      	movs	r0, r5
 8011a4e:	0039      	movs	r1, r7
 8011a50:	f7f1 f85e 	bl	8002b10 <__aeabi_dsub>
 8011a54:	0002      	movs	r2, r0
 8011a56:	000b      	movs	r3, r1
 8011a58:	f7f0 f9ca 	bl	8001df0 <__aeabi_ddiv>
 8011a5c:	0005      	movs	r5, r0
 8011a5e:	e7ac      	b.n	80119ba <__ieee754_sqrt+0xea>
 8011a60:	001a      	movs	r2, r3
 8011a62:	2300      	movs	r3, #0
 8011a64:	e7be      	b.n	80119e4 <__ieee754_sqrt+0x114>
 8011a66:	0039      	movs	r1, r7
 8011a68:	e7a7      	b.n	80119ba <__ieee754_sqrt+0xea>
 8011a6a:	2301      	movs	r3, #1
 8011a6c:	4698      	mov	r8, r3
 8011a6e:	2300      	movs	r3, #0
 8011a70:	44c1      	add	r9, r8
 8011a72:	e793      	b.n	801199c <__ieee754_sqrt+0xcc>
 8011a74:	2701      	movs	r7, #1
 8011a76:	0022      	movs	r2, r4
 8011a78:	2620      	movs	r6, #32
 8011a7a:	427f      	negs	r7, r7
 8011a7c:	e7c0      	b.n	8011a00 <__ieee754_sqrt+0x130>
 8011a7e:	46c0      	nop			; (mov r8, r8)
 8011a80:	7ff00000 	.word	0x7ff00000
 8011a84:	fffffc01 	.word	0xfffffc01
 8011a88:	3fe00000 	.word	0x3fe00000
 8011a8c:	00000000 	.word	0x00000000

08011a90 <__ieee754_atan2f>:
 8011a90:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8011a92:	004b      	lsls	r3, r1, #1
 8011a94:	1c0c      	adds	r4, r1, #0
 8011a96:	21ff      	movs	r1, #255	; 0xff
 8011a98:	085b      	lsrs	r3, r3, #1
 8011a9a:	05c9      	lsls	r1, r1, #23
 8011a9c:	428b      	cmp	r3, r1
 8011a9e:	dc15      	bgt.n	8011acc <__ieee754_atan2f+0x3c>
 8011aa0:	0042      	lsls	r2, r0, #1
 8011aa2:	4684      	mov	ip, r0
 8011aa4:	0852      	lsrs	r2, r2, #1
 8011aa6:	428a      	cmp	r2, r1
 8011aa8:	dc10      	bgt.n	8011acc <__ieee754_atan2f+0x3c>
 8011aaa:	25fe      	movs	r5, #254	; 0xfe
 8011aac:	05ad      	lsls	r5, r5, #22
 8011aae:	42ac      	cmp	r4, r5
 8011ab0:	d03e      	beq.n	8011b30 <__ieee754_atan2f+0xa0>
 8011ab2:	2502      	movs	r5, #2
 8011ab4:	17a7      	asrs	r7, r4, #30
 8011ab6:	403d      	ands	r5, r7
 8011ab8:	0fc7      	lsrs	r7, r0, #31
 8011aba:	433d      	orrs	r5, r7
 8011abc:	2a00      	cmp	r2, #0
 8011abe:	d10a      	bne.n	8011ad6 <__ieee754_atan2f+0x46>
 8011ac0:	2d02      	cmp	r5, #2
 8011ac2:	d029      	beq.n	8011b18 <__ieee754_atan2f+0x88>
 8011ac4:	2d03      	cmp	r5, #3
 8011ac6:	d105      	bne.n	8011ad4 <__ieee754_atan2f+0x44>
 8011ac8:	4830      	ldr	r0, [pc, #192]	; (8011b8c <__ieee754_atan2f+0xfc>)
 8011aca:	e003      	b.n	8011ad4 <__ieee754_atan2f+0x44>
 8011acc:	1c01      	adds	r1, r0, #0
 8011ace:	1c20      	adds	r0, r4, #0
 8011ad0:	f7ee ff2e 	bl	8000930 <__aeabi_fadd>
 8011ad4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8011ad6:	2b00      	cmp	r3, #0
 8011ad8:	d019      	beq.n	8011b0e <__ieee754_atan2f+0x7e>
 8011ada:	428b      	cmp	r3, r1
 8011adc:	d01e      	beq.n	8011b1c <__ieee754_atan2f+0x8c>
 8011ade:	428a      	cmp	r2, r1
 8011ae0:	d015      	beq.n	8011b0e <__ieee754_atan2f+0x7e>
 8011ae2:	1ad3      	subs	r3, r2, r3
 8011ae4:	15db      	asrs	r3, r3, #23
 8011ae6:	2b3c      	cmp	r3, #60	; 0x3c
 8011ae8:	dc25      	bgt.n	8011b36 <__ieee754_atan2f+0xa6>
 8011aea:	2c00      	cmp	r4, #0
 8011aec:	da2f      	bge.n	8011b4e <__ieee754_atan2f+0xbe>
 8011aee:	333c      	adds	r3, #60	; 0x3c
 8011af0:	da2d      	bge.n	8011b4e <__ieee754_atan2f+0xbe>
 8011af2:	2000      	movs	r0, #0
 8011af4:	2d01      	cmp	r5, #1
 8011af6:	d03a      	beq.n	8011b6e <__ieee754_atan2f+0xde>
 8011af8:	2d02      	cmp	r5, #2
 8011afa:	d030      	beq.n	8011b5e <__ieee754_atan2f+0xce>
 8011afc:	2d00      	cmp	r5, #0
 8011afe:	d0e9      	beq.n	8011ad4 <__ieee754_atan2f+0x44>
 8011b00:	4923      	ldr	r1, [pc, #140]	; (8011b90 <__ieee754_atan2f+0x100>)
 8011b02:	f7ee ff15 	bl	8000930 <__aeabi_fadd>
 8011b06:	4923      	ldr	r1, [pc, #140]	; (8011b94 <__ieee754_atan2f+0x104>)
 8011b08:	f7ef fb8a 	bl	8001220 <__aeabi_fsub>
 8011b0c:	e7e2      	b.n	8011ad4 <__ieee754_atan2f+0x44>
 8011b0e:	4663      	mov	r3, ip
 8011b10:	2b00      	cmp	r3, #0
 8011b12:	db1a      	blt.n	8011b4a <__ieee754_atan2f+0xba>
 8011b14:	4820      	ldr	r0, [pc, #128]	; (8011b98 <__ieee754_atan2f+0x108>)
 8011b16:	e7dd      	b.n	8011ad4 <__ieee754_atan2f+0x44>
 8011b18:	481e      	ldr	r0, [pc, #120]	; (8011b94 <__ieee754_atan2f+0x104>)
 8011b1a:	e7db      	b.n	8011ad4 <__ieee754_atan2f+0x44>
 8011b1c:	429a      	cmp	r2, r3
 8011b1e:	d00c      	beq.n	8011b3a <__ieee754_atan2f+0xaa>
 8011b20:	2d02      	cmp	r5, #2
 8011b22:	d0f9      	beq.n	8011b18 <__ieee754_atan2f+0x88>
 8011b24:	2d03      	cmp	r5, #3
 8011b26:	d0cf      	beq.n	8011ac8 <__ieee754_atan2f+0x38>
 8011b28:	2d01      	cmp	r5, #1
 8011b2a:	d025      	beq.n	8011b78 <__ieee754_atan2f+0xe8>
 8011b2c:	2000      	movs	r0, #0
 8011b2e:	e7d1      	b.n	8011ad4 <__ieee754_atan2f+0x44>
 8011b30:	f001 f856 	bl	8012be0 <atanf>
 8011b34:	e7ce      	b.n	8011ad4 <__ieee754_atan2f+0x44>
 8011b36:	4818      	ldr	r0, [pc, #96]	; (8011b98 <__ieee754_atan2f+0x108>)
 8011b38:	e7dc      	b.n	8011af4 <__ieee754_atan2f+0x64>
 8011b3a:	2d02      	cmp	r5, #2
 8011b3c:	d023      	beq.n	8011b86 <__ieee754_atan2f+0xf6>
 8011b3e:	2d03      	cmp	r5, #3
 8011b40:	d01f      	beq.n	8011b82 <__ieee754_atan2f+0xf2>
 8011b42:	2d01      	cmp	r5, #1
 8011b44:	d01b      	beq.n	8011b7e <__ieee754_atan2f+0xee>
 8011b46:	4815      	ldr	r0, [pc, #84]	; (8011b9c <__ieee754_atan2f+0x10c>)
 8011b48:	e7c4      	b.n	8011ad4 <__ieee754_atan2f+0x44>
 8011b4a:	4815      	ldr	r0, [pc, #84]	; (8011ba0 <__ieee754_atan2f+0x110>)
 8011b4c:	e7c2      	b.n	8011ad4 <__ieee754_atan2f+0x44>
 8011b4e:	1c21      	adds	r1, r4, #0
 8011b50:	f7ef f86e 	bl	8000c30 <__aeabi_fdiv>
 8011b54:	f001 f95c 	bl	8012e10 <fabsf>
 8011b58:	f001 f842 	bl	8012be0 <atanf>
 8011b5c:	e7ca      	b.n	8011af4 <__ieee754_atan2f+0x64>
 8011b5e:	490c      	ldr	r1, [pc, #48]	; (8011b90 <__ieee754_atan2f+0x100>)
 8011b60:	f7ee fee6 	bl	8000930 <__aeabi_fadd>
 8011b64:	1c01      	adds	r1, r0, #0
 8011b66:	480b      	ldr	r0, [pc, #44]	; (8011b94 <__ieee754_atan2f+0x104>)
 8011b68:	f7ef fb5a 	bl	8001220 <__aeabi_fsub>
 8011b6c:	e7b2      	b.n	8011ad4 <__ieee754_atan2f+0x44>
 8011b6e:	2380      	movs	r3, #128	; 0x80
 8011b70:	061b      	lsls	r3, r3, #24
 8011b72:	469c      	mov	ip, r3
 8011b74:	4460      	add	r0, ip
 8011b76:	e7ad      	b.n	8011ad4 <__ieee754_atan2f+0x44>
 8011b78:	2080      	movs	r0, #128	; 0x80
 8011b7a:	0600      	lsls	r0, r0, #24
 8011b7c:	e7aa      	b.n	8011ad4 <__ieee754_atan2f+0x44>
 8011b7e:	4809      	ldr	r0, [pc, #36]	; (8011ba4 <__ieee754_atan2f+0x114>)
 8011b80:	e7a8      	b.n	8011ad4 <__ieee754_atan2f+0x44>
 8011b82:	4809      	ldr	r0, [pc, #36]	; (8011ba8 <__ieee754_atan2f+0x118>)
 8011b84:	e7a6      	b.n	8011ad4 <__ieee754_atan2f+0x44>
 8011b86:	4809      	ldr	r0, [pc, #36]	; (8011bac <__ieee754_atan2f+0x11c>)
 8011b88:	e7a4      	b.n	8011ad4 <__ieee754_atan2f+0x44>
 8011b8a:	46c0      	nop			; (mov r8, r8)
 8011b8c:	c0490fdb 	.word	0xc0490fdb
 8011b90:	33bbbd2e 	.word	0x33bbbd2e
 8011b94:	40490fdb 	.word	0x40490fdb
 8011b98:	3fc90fdb 	.word	0x3fc90fdb
 8011b9c:	3f490fdb 	.word	0x3f490fdb
 8011ba0:	bfc90fdb 	.word	0xbfc90fdb
 8011ba4:	bf490fdb 	.word	0xbf490fdb
 8011ba8:	c016cbe4 	.word	0xc016cbe4
 8011bac:	4016cbe4 	.word	0x4016cbe4

08011bb0 <__ieee754_log10f>:
 8011bb0:	b570      	push	{r4, r5, r6, lr}
 8011bb2:	0003      	movs	r3, r0
 8011bb4:	0042      	lsls	r2, r0, #1
 8011bb6:	d030      	beq.n	8011c1a <__ieee754_log10f+0x6a>
 8011bb8:	2800      	cmp	r0, #0
 8011bba:	db34      	blt.n	8011c26 <__ieee754_log10f+0x76>
 8011bbc:	4a23      	ldr	r2, [pc, #140]	; (8011c4c <__ieee754_log10f+0x9c>)
 8011bbe:	4290      	cmp	r0, r2
 8011bc0:	dc40      	bgt.n	8011c44 <__ieee754_log10f+0x94>
 8011bc2:	4923      	ldr	r1, [pc, #140]	; (8011c50 <__ieee754_log10f+0xa0>)
 8011bc4:	2200      	movs	r2, #0
 8011bc6:	4288      	cmp	r0, r1
 8011bc8:	dd34      	ble.n	8011c34 <__ieee754_log10f+0x84>
 8011bca:	15d8      	asrs	r0, r3, #23
 8011bcc:	387f      	subs	r0, #127	; 0x7f
 8011bce:	1880      	adds	r0, r0, r2
 8011bd0:	0fc6      	lsrs	r6, r0, #31
 8011bd2:	025b      	lsls	r3, r3, #9
 8011bd4:	1980      	adds	r0, r0, r6
 8011bd6:	0a5c      	lsrs	r4, r3, #9
 8011bd8:	f7ef fd02 	bl	80015e0 <__aeabi_i2f>
 8011bdc:	1c05      	adds	r5, r0, #0
 8011bde:	207f      	movs	r0, #127	; 0x7f
 8011be0:	1b80      	subs	r0, r0, r6
 8011be2:	05c0      	lsls	r0, r0, #23
 8011be4:	4320      	orrs	r0, r4
 8011be6:	f001 f91b 	bl	8012e20 <__ieee754_logf>
 8011bea:	491a      	ldr	r1, [pc, #104]	; (8011c54 <__ieee754_log10f+0xa4>)
 8011bec:	1c06      	adds	r6, r0, #0
 8011bee:	1c28      	adds	r0, r5, #0
 8011bf0:	f7ef f9fe 	bl	8000ff0 <__aeabi_fmul>
 8011bf4:	4918      	ldr	r1, [pc, #96]	; (8011c58 <__ieee754_log10f+0xa8>)
 8011bf6:	1c04      	adds	r4, r0, #0
 8011bf8:	1c30      	adds	r0, r6, #0
 8011bfa:	f7ef f9f9 	bl	8000ff0 <__aeabi_fmul>
 8011bfe:	1c01      	adds	r1, r0, #0
 8011c00:	1c20      	adds	r0, r4, #0
 8011c02:	f7ee fe95 	bl	8000930 <__aeabi_fadd>
 8011c06:	4915      	ldr	r1, [pc, #84]	; (8011c5c <__ieee754_log10f+0xac>)
 8011c08:	1c04      	adds	r4, r0, #0
 8011c0a:	1c28      	adds	r0, r5, #0
 8011c0c:	f7ef f9f0 	bl	8000ff0 <__aeabi_fmul>
 8011c10:	1c01      	adds	r1, r0, #0
 8011c12:	1c20      	adds	r0, r4, #0
 8011c14:	f7ee fe8c 	bl	8000930 <__aeabi_fadd>
 8011c18:	bd70      	pop	{r4, r5, r6, pc}
 8011c1a:	20cc      	movs	r0, #204	; 0xcc
 8011c1c:	2100      	movs	r1, #0
 8011c1e:	0600      	lsls	r0, r0, #24
 8011c20:	f7ef f806 	bl	8000c30 <__aeabi_fdiv>
 8011c24:	e7f8      	b.n	8011c18 <__ieee754_log10f+0x68>
 8011c26:	1c01      	adds	r1, r0, #0
 8011c28:	f7ef fafa 	bl	8001220 <__aeabi_fsub>
 8011c2c:	2100      	movs	r1, #0
 8011c2e:	f7ee ffff 	bl	8000c30 <__aeabi_fdiv>
 8011c32:	e7f1      	b.n	8011c18 <__ieee754_log10f+0x68>
 8011c34:	2198      	movs	r1, #152	; 0x98
 8011c36:	05c9      	lsls	r1, r1, #23
 8011c38:	f7ef f9da 	bl	8000ff0 <__aeabi_fmul>
 8011c3c:	2219      	movs	r2, #25
 8011c3e:	0003      	movs	r3, r0
 8011c40:	4252      	negs	r2, r2
 8011c42:	e7c2      	b.n	8011bca <__ieee754_log10f+0x1a>
 8011c44:	1c01      	adds	r1, r0, #0
 8011c46:	f7ee fe73 	bl	8000930 <__aeabi_fadd>
 8011c4a:	e7e5      	b.n	8011c18 <__ieee754_log10f+0x68>
 8011c4c:	7f7fffff 	.word	0x7f7fffff
 8011c50:	007fffff 	.word	0x007fffff
 8011c54:	355427db 	.word	0x355427db
 8011c58:	3ede5bd9 	.word	0x3ede5bd9
 8011c5c:	3e9a2080 	.word	0x3e9a2080

08011c60 <__ieee754_sqrtf>:
 8011c60:	492b      	ldr	r1, [pc, #172]	; (8011d10 <__ieee754_sqrtf+0xb0>)
 8011c62:	0042      	lsls	r2, r0, #1
 8011c64:	b570      	push	{r4, r5, r6, lr}
 8011c66:	0003      	movs	r3, r0
 8011c68:	1c06      	adds	r6, r0, #0
 8011c6a:	0852      	lsrs	r2, r2, #1
 8011c6c:	428a      	cmp	r2, r1
 8011c6e:	d83b      	bhi.n	8011ce8 <__ieee754_sqrtf+0x88>
 8011c70:	2a00      	cmp	r2, #0
 8011c72:	d038      	beq.n	8011ce6 <__ieee754_sqrtf+0x86>
 8011c74:	2800      	cmp	r0, #0
 8011c76:	db40      	blt.n	8011cfa <__ieee754_sqrtf+0x9a>
 8011c78:	22ff      	movs	r2, #255	; 0xff
 8011c7a:	05d2      	lsls	r2, r2, #23
 8011c7c:	15c0      	asrs	r0, r0, #23
 8011c7e:	4232      	tst	r2, r6
 8011c80:	d10b      	bne.n	8011c9a <__ieee754_sqrtf+0x3a>
 8011c82:	2480      	movs	r4, #128	; 0x80
 8011c84:	0424      	lsls	r4, r4, #16
 8011c86:	4234      	tst	r4, r6
 8011c88:	d13e      	bne.n	8011d08 <__ieee754_sqrtf+0xa8>
 8011c8a:	2200      	movs	r2, #0
 8011c8c:	e000      	b.n	8011c90 <__ieee754_sqrtf+0x30>
 8011c8e:	000a      	movs	r2, r1
 8011c90:	005b      	lsls	r3, r3, #1
 8011c92:	1c51      	adds	r1, r2, #1
 8011c94:	4223      	tst	r3, r4
 8011c96:	d0fa      	beq.n	8011c8e <__ieee754_sqrtf+0x2e>
 8011c98:	1a80      	subs	r0, r0, r2
 8011c9a:	2280      	movs	r2, #128	; 0x80
 8011c9c:	025b      	lsls	r3, r3, #9
 8011c9e:	0a5b      	lsrs	r3, r3, #9
 8011ca0:	0412      	lsls	r2, r2, #16
 8011ca2:	431a      	orrs	r2, r3
 8011ca4:	387f      	subs	r0, #127	; 0x7f
 8011ca6:	0053      	lsls	r3, r2, #1
 8011ca8:	07c1      	lsls	r1, r0, #31
 8011caa:	d424      	bmi.n	8011cf6 <__ieee754_sqrtf+0x96>
 8011cac:	2280      	movs	r2, #128	; 0x80
 8011cae:	2119      	movs	r1, #25
 8011cb0:	2600      	movs	r6, #0
 8011cb2:	2500      	movs	r5, #0
 8011cb4:	1040      	asrs	r0, r0, #1
 8011cb6:	0452      	lsls	r2, r2, #17
 8011cb8:	18ac      	adds	r4, r5, r2
 8011cba:	429c      	cmp	r4, r3
 8011cbc:	dc02      	bgt.n	8011cc4 <__ieee754_sqrtf+0x64>
 8011cbe:	18a5      	adds	r5, r4, r2
 8011cc0:	1b1b      	subs	r3, r3, r4
 8011cc2:	18b6      	adds	r6, r6, r2
 8011cc4:	3901      	subs	r1, #1
 8011cc6:	005b      	lsls	r3, r3, #1
 8011cc8:	0852      	lsrs	r2, r2, #1
 8011cca:	2900      	cmp	r1, #0
 8011ccc:	d1f4      	bne.n	8011cb8 <__ieee754_sqrtf+0x58>
 8011cce:	2b00      	cmp	r3, #0
 8011cd0:	d002      	beq.n	8011cd8 <__ieee754_sqrtf+0x78>
 8011cd2:	2301      	movs	r3, #1
 8011cd4:	3601      	adds	r6, #1
 8011cd6:	439e      	bics	r6, r3
 8011cd8:	23fc      	movs	r3, #252	; 0xfc
 8011cda:	059b      	lsls	r3, r3, #22
 8011cdc:	469c      	mov	ip, r3
 8011cde:	1076      	asrs	r6, r6, #1
 8011ce0:	4466      	add	r6, ip
 8011ce2:	05c0      	lsls	r0, r0, #23
 8011ce4:	1980      	adds	r0, r0, r6
 8011ce6:	bd70      	pop	{r4, r5, r6, pc}
 8011ce8:	1c01      	adds	r1, r0, #0
 8011cea:	f7ef f981 	bl	8000ff0 <__aeabi_fmul>
 8011cee:	1c31      	adds	r1, r6, #0
 8011cf0:	f7ee fe1e 	bl	8000930 <__aeabi_fadd>
 8011cf4:	e7f7      	b.n	8011ce6 <__ieee754_sqrtf+0x86>
 8011cf6:	0093      	lsls	r3, r2, #2
 8011cf8:	e7d8      	b.n	8011cac <__ieee754_sqrtf+0x4c>
 8011cfa:	1c01      	adds	r1, r0, #0
 8011cfc:	f7ef fa90 	bl	8001220 <__aeabi_fsub>
 8011d00:	1c01      	adds	r1, r0, #0
 8011d02:	f7ee ff95 	bl	8000c30 <__aeabi_fdiv>
 8011d06:	e7ee      	b.n	8011ce6 <__ieee754_sqrtf+0x86>
 8011d08:	2201      	movs	r2, #1
 8011d0a:	4252      	negs	r2, r2
 8011d0c:	1a80      	subs	r0, r0, r2
 8011d0e:	e7c4      	b.n	8011c9a <__ieee754_sqrtf+0x3a>
 8011d10:	7f7fffff 	.word	0x7f7fffff
	...

08011d20 <__kernel_cos>:
 8011d20:	b5f0      	push	{r4, r5, r6, r7, lr}
 8011d22:	4647      	mov	r7, r8
 8011d24:	46ce      	mov	lr, r9
 8011d26:	b580      	push	{r7, lr}
 8011d28:	b087      	sub	sp, #28
 8011d2a:	9200      	str	r2, [sp, #0]
 8011d2c:	9301      	str	r3, [sp, #4]
 8011d2e:	4b75      	ldr	r3, [pc, #468]	; (8011f04 <__kernel_cos+0x1e4>)
 8011d30:	004f      	lsls	r7, r1, #1
 8011d32:	4681      	mov	r9, r0
 8011d34:	4688      	mov	r8, r1
 8011d36:	087f      	lsrs	r7, r7, #1
 8011d38:	429f      	cmp	r7, r3
 8011d3a:	dc63      	bgt.n	8011e04 <__kernel_cos+0xe4>
 8011d3c:	f7f1 faa0 	bl	8003280 <__aeabi_d2iz>
 8011d40:	2800      	cmp	r0, #0
 8011d42:	d100      	bne.n	8011d46 <__kernel_cos+0x26>
 8011d44:	e0da      	b.n	8011efc <__kernel_cos+0x1dc>
 8011d46:	464a      	mov	r2, r9
 8011d48:	4643      	mov	r3, r8
 8011d4a:	4648      	mov	r0, r9
 8011d4c:	4641      	mov	r1, r8
 8011d4e:	f7f0 fc57 	bl	8002600 <__aeabi_dmul>
 8011d52:	0004      	movs	r4, r0
 8011d54:	000d      	movs	r5, r1
 8011d56:	4a6c      	ldr	r2, [pc, #432]	; (8011f08 <__kernel_cos+0x1e8>)
 8011d58:	4b6c      	ldr	r3, [pc, #432]	; (8011f0c <__kernel_cos+0x1ec>)
 8011d5a:	f7f0 fc51 	bl	8002600 <__aeabi_dmul>
 8011d5e:	4a6c      	ldr	r2, [pc, #432]	; (8011f10 <__kernel_cos+0x1f0>)
 8011d60:	4b6c      	ldr	r3, [pc, #432]	; (8011f14 <__kernel_cos+0x1f4>)
 8011d62:	f7ef fccd 	bl	8001700 <__aeabi_dadd>
 8011d66:	0022      	movs	r2, r4
 8011d68:	002b      	movs	r3, r5
 8011d6a:	f7f0 fc49 	bl	8002600 <__aeabi_dmul>
 8011d6e:	4a6a      	ldr	r2, [pc, #424]	; (8011f18 <__kernel_cos+0x1f8>)
 8011d70:	4b6a      	ldr	r3, [pc, #424]	; (8011f1c <__kernel_cos+0x1fc>)
 8011d72:	f7f0 fecd 	bl	8002b10 <__aeabi_dsub>
 8011d76:	0022      	movs	r2, r4
 8011d78:	002b      	movs	r3, r5
 8011d7a:	f7f0 fc41 	bl	8002600 <__aeabi_dmul>
 8011d7e:	4a68      	ldr	r2, [pc, #416]	; (8011f20 <__kernel_cos+0x200>)
 8011d80:	4b68      	ldr	r3, [pc, #416]	; (8011f24 <__kernel_cos+0x204>)
 8011d82:	f7ef fcbd 	bl	8001700 <__aeabi_dadd>
 8011d86:	0022      	movs	r2, r4
 8011d88:	002b      	movs	r3, r5
 8011d8a:	f7f0 fc39 	bl	8002600 <__aeabi_dmul>
 8011d8e:	4a66      	ldr	r2, [pc, #408]	; (8011f28 <__kernel_cos+0x208>)
 8011d90:	4b66      	ldr	r3, [pc, #408]	; (8011f2c <__kernel_cos+0x20c>)
 8011d92:	f7f0 febd 	bl	8002b10 <__aeabi_dsub>
 8011d96:	0022      	movs	r2, r4
 8011d98:	002b      	movs	r3, r5
 8011d9a:	f7f0 fc31 	bl	8002600 <__aeabi_dmul>
 8011d9e:	4a64      	ldr	r2, [pc, #400]	; (8011f30 <__kernel_cos+0x210>)
 8011da0:	4b64      	ldr	r3, [pc, #400]	; (8011f34 <__kernel_cos+0x214>)
 8011da2:	f7ef fcad 	bl	8001700 <__aeabi_dadd>
 8011da6:	0022      	movs	r2, r4
 8011da8:	002b      	movs	r3, r5
 8011daa:	f7f0 fc29 	bl	8002600 <__aeabi_dmul>
 8011dae:	9002      	str	r0, [sp, #8]
 8011db0:	9103      	str	r1, [sp, #12]
 8011db2:	2200      	movs	r2, #0
 8011db4:	4b60      	ldr	r3, [pc, #384]	; (8011f38 <__kernel_cos+0x218>)
 8011db6:	0020      	movs	r0, r4
 8011db8:	0029      	movs	r1, r5
 8011dba:	f7f0 fc21 	bl	8002600 <__aeabi_dmul>
 8011dbe:	9a02      	ldr	r2, [sp, #8]
 8011dc0:	9b03      	ldr	r3, [sp, #12]
 8011dc2:	0006      	movs	r6, r0
 8011dc4:	000f      	movs	r7, r1
 8011dc6:	0020      	movs	r0, r4
 8011dc8:	0029      	movs	r1, r5
 8011dca:	f7f0 fc19 	bl	8002600 <__aeabi_dmul>
 8011dce:	9a00      	ldr	r2, [sp, #0]
 8011dd0:	9b01      	ldr	r3, [sp, #4]
 8011dd2:	0004      	movs	r4, r0
 8011dd4:	000d      	movs	r5, r1
 8011dd6:	4648      	mov	r0, r9
 8011dd8:	4641      	mov	r1, r8
 8011dda:	f7f0 fc11 	bl	8002600 <__aeabi_dmul>
 8011dde:	0002      	movs	r2, r0
 8011de0:	000b      	movs	r3, r1
 8011de2:	0020      	movs	r0, r4
 8011de4:	0029      	movs	r1, r5
 8011de6:	f7f0 fe93 	bl	8002b10 <__aeabi_dsub>
 8011dea:	0002      	movs	r2, r0
 8011dec:	000b      	movs	r3, r1
 8011dee:	0030      	movs	r0, r6
 8011df0:	0039      	movs	r1, r7
 8011df2:	f7f0 fe8d 	bl	8002b10 <__aeabi_dsub>
 8011df6:	0002      	movs	r2, r0
 8011df8:	000b      	movs	r3, r1
 8011dfa:	2000      	movs	r0, #0
 8011dfc:	494f      	ldr	r1, [pc, #316]	; (8011f3c <__kernel_cos+0x21c>)
 8011dfe:	f7f0 fe87 	bl	8002b10 <__aeabi_dsub>
 8011e02:	e070      	b.n	8011ee6 <__kernel_cos+0x1c6>
 8011e04:	0002      	movs	r2, r0
 8011e06:	000b      	movs	r3, r1
 8011e08:	f7f0 fbfa 	bl	8002600 <__aeabi_dmul>
 8011e0c:	0004      	movs	r4, r0
 8011e0e:	000d      	movs	r5, r1
 8011e10:	4a3d      	ldr	r2, [pc, #244]	; (8011f08 <__kernel_cos+0x1e8>)
 8011e12:	4b3e      	ldr	r3, [pc, #248]	; (8011f0c <__kernel_cos+0x1ec>)
 8011e14:	f7f0 fbf4 	bl	8002600 <__aeabi_dmul>
 8011e18:	4a3d      	ldr	r2, [pc, #244]	; (8011f10 <__kernel_cos+0x1f0>)
 8011e1a:	4b3e      	ldr	r3, [pc, #248]	; (8011f14 <__kernel_cos+0x1f4>)
 8011e1c:	f7ef fc70 	bl	8001700 <__aeabi_dadd>
 8011e20:	0022      	movs	r2, r4
 8011e22:	002b      	movs	r3, r5
 8011e24:	f7f0 fbec 	bl	8002600 <__aeabi_dmul>
 8011e28:	4a3b      	ldr	r2, [pc, #236]	; (8011f18 <__kernel_cos+0x1f8>)
 8011e2a:	4b3c      	ldr	r3, [pc, #240]	; (8011f1c <__kernel_cos+0x1fc>)
 8011e2c:	f7f0 fe70 	bl	8002b10 <__aeabi_dsub>
 8011e30:	0022      	movs	r2, r4
 8011e32:	002b      	movs	r3, r5
 8011e34:	f7f0 fbe4 	bl	8002600 <__aeabi_dmul>
 8011e38:	4a39      	ldr	r2, [pc, #228]	; (8011f20 <__kernel_cos+0x200>)
 8011e3a:	4b3a      	ldr	r3, [pc, #232]	; (8011f24 <__kernel_cos+0x204>)
 8011e3c:	f7ef fc60 	bl	8001700 <__aeabi_dadd>
 8011e40:	0022      	movs	r2, r4
 8011e42:	002b      	movs	r3, r5
 8011e44:	f7f0 fbdc 	bl	8002600 <__aeabi_dmul>
 8011e48:	4a37      	ldr	r2, [pc, #220]	; (8011f28 <__kernel_cos+0x208>)
 8011e4a:	4b38      	ldr	r3, [pc, #224]	; (8011f2c <__kernel_cos+0x20c>)
 8011e4c:	f7f0 fe60 	bl	8002b10 <__aeabi_dsub>
 8011e50:	0022      	movs	r2, r4
 8011e52:	002b      	movs	r3, r5
 8011e54:	f7f0 fbd4 	bl	8002600 <__aeabi_dmul>
 8011e58:	4a35      	ldr	r2, [pc, #212]	; (8011f30 <__kernel_cos+0x210>)
 8011e5a:	4b36      	ldr	r3, [pc, #216]	; (8011f34 <__kernel_cos+0x214>)
 8011e5c:	f7ef fc50 	bl	8001700 <__aeabi_dadd>
 8011e60:	002b      	movs	r3, r5
 8011e62:	0022      	movs	r2, r4
 8011e64:	f7f0 fbcc 	bl	8002600 <__aeabi_dmul>
 8011e68:	4b35      	ldr	r3, [pc, #212]	; (8011f40 <__kernel_cos+0x220>)
 8011e6a:	9002      	str	r0, [sp, #8]
 8011e6c:	9103      	str	r1, [sp, #12]
 8011e6e:	429f      	cmp	r7, r3
 8011e70:	dd9f      	ble.n	8011db2 <__kernel_cos+0x92>
 8011e72:	4b34      	ldr	r3, [pc, #208]	; (8011f44 <__kernel_cos+0x224>)
 8011e74:	2200      	movs	r2, #0
 8011e76:	429f      	cmp	r7, r3
 8011e78:	dc3a      	bgt.n	8011ef0 <__kernel_cos+0x1d0>
 8011e7a:	4933      	ldr	r1, [pc, #204]	; (8011f48 <__kernel_cos+0x228>)
 8011e7c:	2000      	movs	r0, #0
 8011e7e:	187b      	adds	r3, r7, r1
 8011e80:	492e      	ldr	r1, [pc, #184]	; (8011f3c <__kernel_cos+0x21c>)
 8011e82:	0016      	movs	r6, r2
 8011e84:	001f      	movs	r7, r3
 8011e86:	f7f0 fe43 	bl	8002b10 <__aeabi_dsub>
 8011e8a:	9004      	str	r0, [sp, #16]
 8011e8c:	9105      	str	r1, [sp, #20]
 8011e8e:	2200      	movs	r2, #0
 8011e90:	4b29      	ldr	r3, [pc, #164]	; (8011f38 <__kernel_cos+0x218>)
 8011e92:	0020      	movs	r0, r4
 8011e94:	0029      	movs	r1, r5
 8011e96:	f7f0 fbb3 	bl	8002600 <__aeabi_dmul>
 8011e9a:	0032      	movs	r2, r6
 8011e9c:	003b      	movs	r3, r7
 8011e9e:	f7f0 fe37 	bl	8002b10 <__aeabi_dsub>
 8011ea2:	9a02      	ldr	r2, [sp, #8]
 8011ea4:	9b03      	ldr	r3, [sp, #12]
 8011ea6:	0006      	movs	r6, r0
 8011ea8:	000f      	movs	r7, r1
 8011eaa:	0020      	movs	r0, r4
 8011eac:	0029      	movs	r1, r5
 8011eae:	f7f0 fba7 	bl	8002600 <__aeabi_dmul>
 8011eb2:	9a00      	ldr	r2, [sp, #0]
 8011eb4:	9b01      	ldr	r3, [sp, #4]
 8011eb6:	0004      	movs	r4, r0
 8011eb8:	000d      	movs	r5, r1
 8011eba:	4648      	mov	r0, r9
 8011ebc:	4641      	mov	r1, r8
 8011ebe:	f7f0 fb9f 	bl	8002600 <__aeabi_dmul>
 8011ec2:	0002      	movs	r2, r0
 8011ec4:	000b      	movs	r3, r1
 8011ec6:	0020      	movs	r0, r4
 8011ec8:	0029      	movs	r1, r5
 8011eca:	f7f0 fe21 	bl	8002b10 <__aeabi_dsub>
 8011ece:	0002      	movs	r2, r0
 8011ed0:	000b      	movs	r3, r1
 8011ed2:	0030      	movs	r0, r6
 8011ed4:	0039      	movs	r1, r7
 8011ed6:	f7f0 fe1b 	bl	8002b10 <__aeabi_dsub>
 8011eda:	0002      	movs	r2, r0
 8011edc:	000b      	movs	r3, r1
 8011ede:	9804      	ldr	r0, [sp, #16]
 8011ee0:	9905      	ldr	r1, [sp, #20]
 8011ee2:	f7f0 fe15 	bl	8002b10 <__aeabi_dsub>
 8011ee6:	b007      	add	sp, #28
 8011ee8:	bc0c      	pop	{r2, r3}
 8011eea:	4690      	mov	r8, r2
 8011eec:	4699      	mov	r9, r3
 8011eee:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8011ef0:	4b16      	ldr	r3, [pc, #88]	; (8011f4c <__kernel_cos+0x22c>)
 8011ef2:	2600      	movs	r6, #0
 8011ef4:	9204      	str	r2, [sp, #16]
 8011ef6:	9305      	str	r3, [sp, #20]
 8011ef8:	4f15      	ldr	r7, [pc, #84]	; (8011f50 <__kernel_cos+0x230>)
 8011efa:	e7c8      	b.n	8011e8e <__kernel_cos+0x16e>
 8011efc:	2000      	movs	r0, #0
 8011efe:	490f      	ldr	r1, [pc, #60]	; (8011f3c <__kernel_cos+0x21c>)
 8011f00:	e7f1      	b.n	8011ee6 <__kernel_cos+0x1c6>
 8011f02:	46c0      	nop			; (mov r8, r8)
 8011f04:	3e3fffff 	.word	0x3e3fffff
 8011f08:	be8838d4 	.word	0xbe8838d4
 8011f0c:	bda8fae9 	.word	0xbda8fae9
 8011f10:	bdb4b1c4 	.word	0xbdb4b1c4
 8011f14:	3e21ee9e 	.word	0x3e21ee9e
 8011f18:	809c52ad 	.word	0x809c52ad
 8011f1c:	3e927e4f 	.word	0x3e927e4f
 8011f20:	19cb1590 	.word	0x19cb1590
 8011f24:	3efa01a0 	.word	0x3efa01a0
 8011f28:	16c15177 	.word	0x16c15177
 8011f2c:	3f56c16c 	.word	0x3f56c16c
 8011f30:	5555554c 	.word	0x5555554c
 8011f34:	3fa55555 	.word	0x3fa55555
 8011f38:	3fe00000 	.word	0x3fe00000
 8011f3c:	3ff00000 	.word	0x3ff00000
 8011f40:	3fd33332 	.word	0x3fd33332
 8011f44:	3fe90000 	.word	0x3fe90000
 8011f48:	ffe00000 	.word	0xffe00000
 8011f4c:	3fe70000 	.word	0x3fe70000
 8011f50:	3fd20000 	.word	0x3fd20000
	...

08011f60 <__kernel_rem_pio2>:
 8011f60:	b5f0      	push	{r4, r5, r6, r7, lr}
 8011f62:	46de      	mov	lr, fp
 8011f64:	4657      	mov	r7, sl
 8011f66:	464e      	mov	r6, r9
 8011f68:	4645      	mov	r5, r8
 8011f6a:	b5e0      	push	{r5, r6, r7, lr}
 8011f6c:	4cd9      	ldr	r4, [pc, #868]	; (80122d4 <__kernel_rem_pio2+0x374>)
 8011f6e:	44a5      	add	sp, r4
 8011f70:	910d      	str	r1, [sp, #52]	; 0x34
 8011f72:	0019      	movs	r1, r3
 8011f74:	0014      	movs	r4, r2
 8011f76:	9aa4      	ldr	r2, [sp, #656]	; 0x290
 8011f78:	930a      	str	r3, [sp, #40]	; 0x28
 8011f7a:	4bd7      	ldr	r3, [pc, #860]	; (80122d8 <__kernel_rem_pio2+0x378>)
 8011f7c:	0092      	lsls	r2, r2, #2
 8011f7e:	58d2      	ldr	r2, [r2, r3]
 8011f80:	000b      	movs	r3, r1
 8011f82:	3b01      	subs	r3, #1
 8011f84:	9304      	str	r3, [sp, #16]
 8011f86:	0023      	movs	r3, r4
 8011f88:	9006      	str	r0, [sp, #24]
 8011f8a:	9208      	str	r2, [sp, #32]
 8011f8c:	3314      	adds	r3, #20
 8011f8e:	da00      	bge.n	8011f92 <__kernel_rem_pio2+0x32>
 8011f90:	e3ac      	b.n	80126ec <__kernel_rem_pio2+0x78c>
 8011f92:	1ee0      	subs	r0, r4, #3
 8011f94:	2118      	movs	r1, #24
 8011f96:	f7ee f9ab 	bl	80002f0 <__divsi3>
 8011f9a:	0003      	movs	r3, r0
 8011f9c:	3301      	adds	r3, #1
 8011f9e:	009a      	lsls	r2, r3, #2
 8011fa0:	1a9b      	subs	r3, r3, r2
 8011fa2:	9003      	str	r0, [sp, #12]
 8011fa4:	00db      	lsls	r3, r3, #3
 8011fa6:	18e3      	adds	r3, r4, r3
 8011fa8:	9a03      	ldr	r2, [sp, #12]
 8011faa:	9307      	str	r3, [sp, #28]
 8011fac:	9b04      	ldr	r3, [sp, #16]
 8011fae:	1ad4      	subs	r4, r2, r3
 8011fb0:	9a08      	ldr	r2, [sp, #32]
 8011fb2:	18d6      	adds	r6, r2, r3
 8011fb4:	d414      	bmi.n	8011fe0 <__kernel_rem_pio2+0x80>
 8011fb6:	3601      	adds	r6, #1
 8011fb8:	ad22      	add	r5, sp, #136	; 0x88
 8011fba:	1936      	adds	r6, r6, r4
 8011fbc:	9fa5      	ldr	r7, [sp, #660]	; 0x294
 8011fbe:	e007      	b.n	8011fd0 <__kernel_rem_pio2+0x70>
 8011fc0:	00a3      	lsls	r3, r4, #2
 8011fc2:	58f8      	ldr	r0, [r7, r3]
 8011fc4:	f7f1 f994 	bl	80032f0 <__aeabi_i2d>
 8011fc8:	3401      	adds	r4, #1
 8011fca:	c503      	stmia	r5!, {r0, r1}
 8011fcc:	42b4      	cmp	r4, r6
 8011fce:	d007      	beq.n	8011fe0 <__kernel_rem_pio2+0x80>
 8011fd0:	2c00      	cmp	r4, #0
 8011fd2:	daf5      	bge.n	8011fc0 <__kernel_rem_pio2+0x60>
 8011fd4:	2000      	movs	r0, #0
 8011fd6:	2100      	movs	r1, #0
 8011fd8:	3401      	adds	r4, #1
 8011fda:	c503      	stmia	r5!, {r0, r1}
 8011fdc:	42b4      	cmp	r4, r6
 8011fde:	d1f7      	bne.n	8011fd0 <__kernel_rem_pio2+0x70>
 8011fe0:	9b08      	ldr	r3, [sp, #32]
 8011fe2:	2b00      	cmp	r3, #0
 8011fe4:	da01      	bge.n	8011fea <__kernel_rem_pio2+0x8a>
 8011fe6:	f000 fc02 	bl	80127ee <__kernel_rem_pio2+0x88e>
 8011fea:	a974      	add	r1, sp, #464	; 0x1d0
 8011fec:	468b      	mov	fp, r1
 8011fee:	aa22      	add	r2, sp, #136	; 0x88
 8011ff0:	4691      	mov	r9, r2
 8011ff2:	9a08      	ldr	r2, [sp, #32]
 8011ff4:	ab72      	add	r3, sp, #456	; 0x1c8
 8011ff6:	00d2      	lsls	r2, r2, #3
 8011ff8:	4493      	add	fp, r2
 8011ffa:	9a06      	ldr	r2, [sp, #24]
 8011ffc:	9300      	str	r3, [sp, #0]
 8011ffe:	4690      	mov	r8, r2
 8012000:	469a      	mov	sl, r3
 8012002:	9b04      	ldr	r3, [sp, #16]
 8012004:	00db      	lsls	r3, r3, #3
 8012006:	4499      	add	r9, r3
 8012008:	3308      	adds	r3, #8
 801200a:	4498      	add	r8, r3
 801200c:	9b04      	ldr	r3, [sp, #16]
 801200e:	2600      	movs	r6, #0
 8012010:	2700      	movs	r7, #0
 8012012:	2b00      	cmp	r3, #0
 8012014:	db13      	blt.n	801203e <__kernel_rem_pio2+0xde>
 8012016:	464d      	mov	r5, r9
 8012018:	2600      	movs	r6, #0
 801201a:	2700      	movs	r7, #0
 801201c:	9c06      	ldr	r4, [sp, #24]
 801201e:	682a      	ldr	r2, [r5, #0]
 8012020:	686b      	ldr	r3, [r5, #4]
 8012022:	cc03      	ldmia	r4!, {r0, r1}
 8012024:	f7f0 faec 	bl	8002600 <__aeabi_dmul>
 8012028:	0002      	movs	r2, r0
 801202a:	000b      	movs	r3, r1
 801202c:	0030      	movs	r0, r6
 801202e:	0039      	movs	r1, r7
 8012030:	f7ef fb66 	bl	8001700 <__aeabi_dadd>
 8012034:	3d08      	subs	r5, #8
 8012036:	0006      	movs	r6, r0
 8012038:	000f      	movs	r7, r1
 801203a:	4544      	cmp	r4, r8
 801203c:	d1ef      	bne.n	801201e <__kernel_rem_pio2+0xbe>
 801203e:	4653      	mov	r3, sl
 8012040:	c3c0      	stmia	r3!, {r6, r7}
 8012042:	469a      	mov	sl, r3
 8012044:	2308      	movs	r3, #8
 8012046:	469c      	mov	ip, r3
 8012048:	44e1      	add	r9, ip
 801204a:	45da      	cmp	sl, fp
 801204c:	d1de      	bne.n	801200c <__kernel_rem_pio2+0xac>
 801204e:	a80e      	add	r0, sp, #56	; 0x38
 8012050:	2204      	movs	r2, #4
 8012052:	4684      	mov	ip, r0
 8012054:	4252      	negs	r2, r2
 8012056:	4462      	add	r2, ip
 8012058:	4694      	mov	ip, r2
 801205a:	9908      	ldr	r1, [sp, #32]
 801205c:	008b      	lsls	r3, r1, #2
 801205e:	449c      	add	ip, r3
 8012060:	4662      	mov	r2, ip
 8012062:	4684      	mov	ip, r0
 8012064:	920c      	str	r2, [sp, #48]	; 0x30
 8012066:	9aa5      	ldr	r2, [sp, #660]	; 0x294
 8012068:	3b08      	subs	r3, #8
 801206a:	4463      	add	r3, ip
 801206c:	4694      	mov	ip, r2
 801206e:	930b      	str	r3, [sp, #44]	; 0x2c
 8012070:	9b03      	ldr	r3, [sp, #12]
 8012072:	468a      	mov	sl, r1
 8012074:	009b      	lsls	r3, r3, #2
 8012076:	4463      	add	r3, ip
 8012078:	9305      	str	r3, [sp, #20]
 801207a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801207c:	00da      	lsls	r2, r3, #3
 801207e:	9b06      	ldr	r3, [sp, #24]
 8012080:	3b08      	subs	r3, #8
 8012082:	469b      	mov	fp, r3
 8012084:	4493      	add	fp, r2
 8012086:	4653      	mov	r3, sl
 8012088:	9900      	ldr	r1, [sp, #0]
 801208a:	00da      	lsls	r2, r3, #3
 801208c:	4694      	mov	ip, r2
 801208e:	000b      	movs	r3, r1
 8012090:	4463      	add	r3, ip
 8012092:	681e      	ldr	r6, [r3, #0]
 8012094:	685f      	ldr	r7, [r3, #4]
 8012096:	4653      	mov	r3, sl
 8012098:	9209      	str	r2, [sp, #36]	; 0x24
 801209a:	2b00      	cmp	r3, #0
 801209c:	dd31      	ble.n	8012102 <__kernel_rem_pio2+0x1a2>
 801209e:	4688      	mov	r8, r1
 80120a0:	4b8e      	ldr	r3, [pc, #568]	; (80122dc <__kernel_rem_pio2+0x37c>)
 80120a2:	4453      	add	r3, sl
 80120a4:	00db      	lsls	r3, r3, #3
 80120a6:	4498      	add	r8, r3
 80120a8:	ab0e      	add	r3, sp, #56	; 0x38
 80120aa:	4699      	mov	r9, r3
 80120ac:	e000      	b.n	80120b0 <__kernel_rem_pio2+0x150>
 80120ae:	4698      	mov	r8, r3
 80120b0:	2200      	movs	r2, #0
 80120b2:	4b8b      	ldr	r3, [pc, #556]	; (80122e0 <__kernel_rem_pio2+0x380>)
 80120b4:	0030      	movs	r0, r6
 80120b6:	0039      	movs	r1, r7
 80120b8:	f7f0 faa2 	bl	8002600 <__aeabi_dmul>
 80120bc:	f7f1 f8e0 	bl	8003280 <__aeabi_d2iz>
 80120c0:	f7f1 f916 	bl	80032f0 <__aeabi_i2d>
 80120c4:	2200      	movs	r2, #0
 80120c6:	4b87      	ldr	r3, [pc, #540]	; (80122e4 <__kernel_rem_pio2+0x384>)
 80120c8:	0004      	movs	r4, r0
 80120ca:	000d      	movs	r5, r1
 80120cc:	f7f0 fa98 	bl	8002600 <__aeabi_dmul>
 80120d0:	0002      	movs	r2, r0
 80120d2:	000b      	movs	r3, r1
 80120d4:	0030      	movs	r0, r6
 80120d6:	0039      	movs	r1, r7
 80120d8:	f7f0 fd1a 	bl	8002b10 <__aeabi_dsub>
 80120dc:	f7f1 f8d0 	bl	8003280 <__aeabi_d2iz>
 80120e0:	464b      	mov	r3, r9
 80120e2:	c301      	stmia	r3!, {r0}
 80120e4:	4699      	mov	r9, r3
 80120e6:	4643      	mov	r3, r8
 80120e8:	0020      	movs	r0, r4
 80120ea:	681a      	ldr	r2, [r3, #0]
 80120ec:	685b      	ldr	r3, [r3, #4]
 80120ee:	0029      	movs	r1, r5
 80120f0:	f7ef fb06 	bl	8001700 <__aeabi_dadd>
 80120f4:	4643      	mov	r3, r8
 80120f6:	9a00      	ldr	r2, [sp, #0]
 80120f8:	0006      	movs	r6, r0
 80120fa:	000f      	movs	r7, r1
 80120fc:	3b08      	subs	r3, #8
 80120fe:	4542      	cmp	r2, r8
 8012100:	d1d5      	bne.n	80120ae <__kernel_rem_pio2+0x14e>
 8012102:	9b07      	ldr	r3, [sp, #28]
 8012104:	0030      	movs	r0, r6
 8012106:	001a      	movs	r2, r3
 8012108:	0039      	movs	r1, r7
 801210a:	4698      	mov	r8, r3
 801210c:	f000 fce8 	bl	8012ae0 <scalbn>
 8012110:	23ff      	movs	r3, #255	; 0xff
 8012112:	2200      	movs	r2, #0
 8012114:	059b      	lsls	r3, r3, #22
 8012116:	0004      	movs	r4, r0
 8012118:	000d      	movs	r5, r1
 801211a:	f7f0 fa71 	bl	8002600 <__aeabi_dmul>
 801211e:	f000 fc3f 	bl	80129a0 <floor>
 8012122:	2200      	movs	r2, #0
 8012124:	4b70      	ldr	r3, [pc, #448]	; (80122e8 <__kernel_rem_pio2+0x388>)
 8012126:	f7f0 fa6b 	bl	8002600 <__aeabi_dmul>
 801212a:	0002      	movs	r2, r0
 801212c:	000b      	movs	r3, r1
 801212e:	0020      	movs	r0, r4
 8012130:	0029      	movs	r1, r5
 8012132:	f7f0 fced 	bl	8002b10 <__aeabi_dsub>
 8012136:	000d      	movs	r5, r1
 8012138:	0004      	movs	r4, r0
 801213a:	f7f1 f8a1 	bl	8003280 <__aeabi_d2iz>
 801213e:	4681      	mov	r9, r0
 8012140:	f7f1 f8d6 	bl	80032f0 <__aeabi_i2d>
 8012144:	0002      	movs	r2, r0
 8012146:	000b      	movs	r3, r1
 8012148:	0020      	movs	r0, r4
 801214a:	0029      	movs	r1, r5
 801214c:	f7f0 fce0 	bl	8002b10 <__aeabi_dsub>
 8012150:	0006      	movs	r6, r0
 8012152:	4640      	mov	r0, r8
 8012154:	000f      	movs	r7, r1
 8012156:	2800      	cmp	r0, #0
 8012158:	dc00      	bgt.n	801215c <__kernel_rem_pio2+0x1fc>
 801215a:	e086      	b.n	801226a <__kernel_rem_pio2+0x30a>
 801215c:	4653      	mov	r3, sl
 801215e:	1e5a      	subs	r2, r3, #1
 8012160:	0092      	lsls	r2, r2, #2
 8012162:	ab0e      	add	r3, sp, #56	; 0x38
 8012164:	589b      	ldr	r3, [r3, r2]
 8012166:	2118      	movs	r1, #24
 8012168:	001d      	movs	r5, r3
 801216a:	1a09      	subs	r1, r1, r0
 801216c:	410d      	asrs	r5, r1
 801216e:	44a9      	add	r9, r5
 8012170:	408d      	lsls	r5, r1
 8012172:	1b5d      	subs	r5, r3, r5
 8012174:	ab0e      	add	r3, sp, #56	; 0x38
 8012176:	509d      	str	r5, [r3, r2]
 8012178:	2317      	movs	r3, #23
 801217a:	1a1b      	subs	r3, r3, r0
 801217c:	411d      	asrs	r5, r3
 801217e:	2d00      	cmp	r5, #0
 8012180:	dd00      	ble.n	8012184 <__kernel_rem_pio2+0x224>
 8012182:	e07f      	b.n	8012284 <__kernel_rem_pio2+0x324>
 8012184:	2200      	movs	r2, #0
 8012186:	2300      	movs	r3, #0
 8012188:	0030      	movs	r0, r6
 801218a:	0039      	movs	r1, r7
 801218c:	f7ee f9b8 	bl	8000500 <__aeabi_dcmpeq>
 8012190:	2800      	cmp	r0, #0
 8012192:	d100      	bne.n	8012196 <__kernel_rem_pio2+0x236>
 8012194:	e0ea      	b.n	801236c <__kernel_rem_pio2+0x40c>
 8012196:	4653      	mov	r3, sl
 8012198:	1e59      	subs	r1, r3, #1
 801219a:	9b08      	ldr	r3, [sp, #32]
 801219c:	428b      	cmp	r3, r1
 801219e:	dc0f      	bgt.n	80121c0 <__kernel_rem_pio2+0x260>
 80121a0:	aa0e      	add	r2, sp, #56	; 0x38
 80121a2:	4694      	mov	ip, r2
 80121a4:	2200      	movs	r2, #0
 80121a6:	4b51      	ldr	r3, [pc, #324]	; (80122ec <__kernel_rem_pio2+0x38c>)
 80121a8:	980c      	ldr	r0, [sp, #48]	; 0x30
 80121aa:	4453      	add	r3, sl
 80121ac:	009b      	lsls	r3, r3, #2
 80121ae:	4463      	add	r3, ip
 80121b0:	681c      	ldr	r4, [r3, #0]
 80121b2:	3b04      	subs	r3, #4
 80121b4:	4322      	orrs	r2, r4
 80121b6:	4283      	cmp	r3, r0
 80121b8:	d1fa      	bne.n	80121b0 <__kernel_rem_pio2+0x250>
 80121ba:	2a00      	cmp	r2, #0
 80121bc:	d000      	beq.n	80121c0 <__kernel_rem_pio2+0x260>
 80121be:	e125      	b.n	801240c <__kernel_rem_pio2+0x4ac>
 80121c0:	9b08      	ldr	r3, [sp, #32]
 80121c2:	aa0e      	add	r2, sp, #56	; 0x38
 80121c4:	3b01      	subs	r3, #1
 80121c6:	009b      	lsls	r3, r3, #2
 80121c8:	58d3      	ldr	r3, [r2, r3]
 80121ca:	2b00      	cmp	r3, #0
 80121cc:	d000      	beq.n	80121d0 <__kernel_rem_pio2+0x270>
 80121ce:	e118      	b.n	8012402 <__kernel_rem_pio2+0x4a2>
 80121d0:	2201      	movs	r2, #1
 80121d2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80121d4:	3b04      	subs	r3, #4
 80121d6:	6859      	ldr	r1, [r3, #4]
 80121d8:	3201      	adds	r2, #1
 80121da:	2900      	cmp	r1, #0
 80121dc:	d0fa      	beq.n	80121d4 <__kernel_rem_pio2+0x274>
 80121de:	2301      	movs	r3, #1
 80121e0:	4453      	add	r3, sl
 80121e2:	4699      	mov	r9, r3
 80121e4:	0013      	movs	r3, r2
 80121e6:	4453      	add	r3, sl
 80121e8:	9303      	str	r3, [sp, #12]
 80121ea:	aa22      	add	r2, sp, #136	; 0x88
 80121ec:	4690      	mov	r8, r2
 80121ee:	9a00      	ldr	r2, [sp, #0]
 80121f0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80121f2:	4694      	mov	ip, r2
 80121f4:	4453      	add	r3, sl
 80121f6:	00db      	lsls	r3, r3, #3
 80121f8:	4498      	add	r8, r3
 80121fa:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80121fc:	4463      	add	r3, ip
 80121fe:	469a      	mov	sl, r3
 8012200:	464b      	mov	r3, r9
 8012202:	9a05      	ldr	r2, [sp, #20]
 8012204:	009b      	lsls	r3, r3, #2
 8012206:	58d0      	ldr	r0, [r2, r3]
 8012208:	f7f1 f872 	bl	80032f0 <__aeabi_i2d>
 801220c:	4643      	mov	r3, r8
 801220e:	6018      	str	r0, [r3, #0]
 8012210:	6059      	str	r1, [r3, #4]
 8012212:	9b04      	ldr	r3, [sp, #16]
 8012214:	2b00      	cmp	r3, #0
 8012216:	db25      	blt.n	8012264 <__kernel_rem_pio2+0x304>
 8012218:	4645      	mov	r5, r8
 801221a:	9c06      	ldr	r4, [sp, #24]
 801221c:	2600      	movs	r6, #0
 801221e:	2700      	movs	r7, #0
 8012220:	e002      	b.n	8012228 <__kernel_rem_pio2+0x2c8>
 8012222:	3408      	adds	r4, #8
 8012224:	6828      	ldr	r0, [r5, #0]
 8012226:	6869      	ldr	r1, [r5, #4]
 8012228:	6822      	ldr	r2, [r4, #0]
 801222a:	6863      	ldr	r3, [r4, #4]
 801222c:	f7f0 f9e8 	bl	8002600 <__aeabi_dmul>
 8012230:	0002      	movs	r2, r0
 8012232:	000b      	movs	r3, r1
 8012234:	0030      	movs	r0, r6
 8012236:	0039      	movs	r1, r7
 8012238:	f7ef fa62 	bl	8001700 <__aeabi_dadd>
 801223c:	3d08      	subs	r5, #8
 801223e:	0006      	movs	r6, r0
 8012240:	000f      	movs	r7, r1
 8012242:	455c      	cmp	r4, fp
 8012244:	d1ed      	bne.n	8012222 <__kernel_rem_pio2+0x2c2>
 8012246:	4653      	mov	r3, sl
 8012248:	609e      	str	r6, [r3, #8]
 801224a:	60df      	str	r7, [r3, #12]
 801224c:	2301      	movs	r3, #1
 801224e:	469c      	mov	ip, r3
 8012250:	3307      	adds	r3, #7
 8012252:	44e1      	add	r9, ip
 8012254:	469c      	mov	ip, r3
 8012256:	9b03      	ldr	r3, [sp, #12]
 8012258:	44e0      	add	r8, ip
 801225a:	44e2      	add	sl, ip
 801225c:	454b      	cmp	r3, r9
 801225e:	dacf      	bge.n	8012200 <__kernel_rem_pio2+0x2a0>
 8012260:	469a      	mov	sl, r3
 8012262:	e710      	b.n	8012086 <__kernel_rem_pio2+0x126>
 8012264:	2600      	movs	r6, #0
 8012266:	2700      	movs	r7, #0
 8012268:	e7ed      	b.n	8012246 <__kernel_rem_pio2+0x2e6>
 801226a:	9b07      	ldr	r3, [sp, #28]
 801226c:	2b00      	cmp	r3, #0
 801226e:	d000      	beq.n	8012272 <__kernel_rem_pio2+0x312>
 8012270:	e0bd      	b.n	80123ee <__kernel_rem_pio2+0x48e>
 8012272:	4653      	mov	r3, sl
 8012274:	3b01      	subs	r3, #1
 8012276:	009b      	lsls	r3, r3, #2
 8012278:	aa0e      	add	r2, sp, #56	; 0x38
 801227a:	58d5      	ldr	r5, [r2, r3]
 801227c:	15ed      	asrs	r5, r5, #23
 801227e:	2d00      	cmp	r5, #0
 8012280:	dc00      	bgt.n	8012284 <__kernel_rem_pio2+0x324>
 8012282:	e77f      	b.n	8012184 <__kernel_rem_pio2+0x224>
 8012284:	2301      	movs	r3, #1
 8012286:	469c      	mov	ip, r3
 8012288:	4653      	mov	r3, sl
 801228a:	44e1      	add	r9, ip
 801228c:	2b00      	cmp	r3, #0
 801228e:	dc00      	bgt.n	8012292 <__kernel_rem_pio2+0x332>
 8012290:	e242      	b.n	8012718 <__kernel_rem_pio2+0x7b8>
 8012292:	9c0e      	ldr	r4, [sp, #56]	; 0x38
 8012294:	2c00      	cmp	r4, #0
 8012296:	d000      	beq.n	801229a <__kernel_rem_pio2+0x33a>
 8012298:	e09f      	b.n	80123da <__kernel_rem_pio2+0x47a>
 801229a:	4653      	mov	r3, sl
 801229c:	2b01      	cmp	r3, #1
 801229e:	d02f      	beq.n	8012300 <__kernel_rem_pio2+0x3a0>
 80122a0:	2201      	movs	r2, #1
 80122a2:	4650      	mov	r0, sl
 80122a4:	a90f      	add	r1, sp, #60	; 0x3c
 80122a6:	680c      	ldr	r4, [r1, #0]
 80122a8:	1c53      	adds	r3, r2, #1
 80122aa:	2c00      	cmp	r4, #0
 80122ac:	d100      	bne.n	80122b0 <__kernel_rem_pio2+0x350>
 80122ae:	e097      	b.n	80123e0 <__kernel_rem_pio2+0x480>
 80122b0:	4682      	mov	sl, r0
 80122b2:	2180      	movs	r1, #128	; 0x80
 80122b4:	0449      	lsls	r1, r1, #17
 80122b6:	1b0c      	subs	r4, r1, r4
 80122b8:	0092      	lsls	r2, r2, #2
 80122ba:	a90e      	add	r1, sp, #56	; 0x38
 80122bc:	508c      	str	r4, [r1, r2]
 80122be:	459a      	cmp	sl, r3
 80122c0:	dd1d      	ble.n	80122fe <__kernel_rem_pio2+0x39e>
 80122c2:	009b      	lsls	r3, r3, #2
 80122c4:	468c      	mov	ip, r1
 80122c6:	58ca      	ldr	r2, [r1, r3]
 80122c8:	4651      	mov	r1, sl
 80122ca:	0089      	lsls	r1, r1, #2
 80122cc:	4463      	add	r3, ip
 80122ce:	4461      	add	r1, ip
 80122d0:	4807      	ldr	r0, [pc, #28]	; (80122f0 <__kernel_rem_pio2+0x390>)
 80122d2:	e010      	b.n	80122f6 <__kernel_rem_pio2+0x396>
 80122d4:	fffffd94 	.word	0xfffffd94
 80122d8:	08016c20 	.word	0x08016c20
 80122dc:	1fffffff 	.word	0x1fffffff
 80122e0:	3e700000 	.word	0x3e700000
 80122e4:	41700000 	.word	0x41700000
 80122e8:	40200000 	.word	0x40200000
 80122ec:	3fffffff 	.word	0x3fffffff
 80122f0:	00ffffff 	.word	0x00ffffff
 80122f4:	681a      	ldr	r2, [r3, #0]
 80122f6:	1a82      	subs	r2, r0, r2
 80122f8:	c304      	stmia	r3!, {r2}
 80122fa:	428b      	cmp	r3, r1
 80122fc:	d1fa      	bne.n	80122f4 <__kernel_rem_pio2+0x394>
 80122fe:	2401      	movs	r4, #1
 8012300:	9b07      	ldr	r3, [sp, #28]
 8012302:	2b00      	cmp	r3, #0
 8012304:	dd0e      	ble.n	8012324 <__kernel_rem_pio2+0x3c4>
 8012306:	2b01      	cmp	r3, #1
 8012308:	d100      	bne.n	801230c <__kernel_rem_pio2+0x3ac>
 801230a:	e1e4      	b.n	80126d6 <__kernel_rem_pio2+0x776>
 801230c:	2b02      	cmp	r3, #2
 801230e:	d109      	bne.n	8012324 <__kernel_rem_pio2+0x3c4>
 8012310:	4653      	mov	r3, sl
 8012312:	1e5a      	subs	r2, r3, #1
 8012314:	0092      	lsls	r2, r2, #2
 8012316:	ab0e      	add	r3, sp, #56	; 0x38
 8012318:	589b      	ldr	r3, [r3, r2]
 801231a:	a90e      	add	r1, sp, #56	; 0x38
 801231c:	9303      	str	r3, [sp, #12]
 801231e:	029b      	lsls	r3, r3, #10
 8012320:	0a9b      	lsrs	r3, r3, #10
 8012322:	508b      	str	r3, [r1, r2]
 8012324:	2d02      	cmp	r5, #2
 8012326:	d000      	beq.n	801232a <__kernel_rem_pio2+0x3ca>
 8012328:	e72c      	b.n	8012184 <__kernel_rem_pio2+0x224>
 801232a:	0032      	movs	r2, r6
 801232c:	003b      	movs	r3, r7
 801232e:	2000      	movs	r0, #0
 8012330:	49bb      	ldr	r1, [pc, #748]	; (8012620 <__kernel_rem_pio2+0x6c0>)
 8012332:	f7f0 fbed 	bl	8002b10 <__aeabi_dsub>
 8012336:	0006      	movs	r6, r0
 8012338:	000f      	movs	r7, r1
 801233a:	2c00      	cmp	r4, #0
 801233c:	d100      	bne.n	8012340 <__kernel_rem_pio2+0x3e0>
 801233e:	e721      	b.n	8012184 <__kernel_rem_pio2+0x224>
 8012340:	9a07      	ldr	r2, [sp, #28]
 8012342:	2000      	movs	r0, #0
 8012344:	49b6      	ldr	r1, [pc, #728]	; (8012620 <__kernel_rem_pio2+0x6c0>)
 8012346:	f000 fbcb 	bl	8012ae0 <scalbn>
 801234a:	0002      	movs	r2, r0
 801234c:	000b      	movs	r3, r1
 801234e:	0030      	movs	r0, r6
 8012350:	0039      	movs	r1, r7
 8012352:	f7f0 fbdd 	bl	8002b10 <__aeabi_dsub>
 8012356:	0006      	movs	r6, r0
 8012358:	000f      	movs	r7, r1
 801235a:	2200      	movs	r2, #0
 801235c:	2300      	movs	r3, #0
 801235e:	0030      	movs	r0, r6
 8012360:	0039      	movs	r1, r7
 8012362:	f7ee f8cd 	bl	8000500 <__aeabi_dcmpeq>
 8012366:	2800      	cmp	r0, #0
 8012368:	d000      	beq.n	801236c <__kernel_rem_pio2+0x40c>
 801236a:	e714      	b.n	8012196 <__kernel_rem_pio2+0x236>
 801236c:	464b      	mov	r3, r9
 801236e:	9306      	str	r3, [sp, #24]
 8012370:	9b07      	ldr	r3, [sp, #28]
 8012372:	0030      	movs	r0, r6
 8012374:	425a      	negs	r2, r3
 8012376:	0039      	movs	r1, r7
 8012378:	9505      	str	r5, [sp, #20]
 801237a:	f000 fbb1 	bl	8012ae0 <scalbn>
 801237e:	2200      	movs	r2, #0
 8012380:	4ba8      	ldr	r3, [pc, #672]	; (8012624 <__kernel_rem_pio2+0x6c4>)
 8012382:	0006      	movs	r6, r0
 8012384:	000f      	movs	r7, r1
 8012386:	f7ee f8df 	bl	8000548 <__aeabi_dcmpge>
 801238a:	2800      	cmp	r0, #0
 801238c:	d100      	bne.n	8012390 <__kernel_rem_pio2+0x430>
 801238e:	e201      	b.n	8012794 <__kernel_rem_pio2+0x834>
 8012390:	4ba5      	ldr	r3, [pc, #660]	; (8012628 <__kernel_rem_pio2+0x6c8>)
 8012392:	2200      	movs	r2, #0
 8012394:	0030      	movs	r0, r6
 8012396:	0039      	movs	r1, r7
 8012398:	f7f0 f932 	bl	8002600 <__aeabi_dmul>
 801239c:	f7f0 ff70 	bl	8003280 <__aeabi_d2iz>
 80123a0:	4652      	mov	r2, sl
 80123a2:	0004      	movs	r4, r0
 80123a4:	0095      	lsls	r5, r2, #2
 80123a6:	f7f0 ffa3 	bl	80032f0 <__aeabi_i2d>
 80123aa:	2200      	movs	r2, #0
 80123ac:	4b9d      	ldr	r3, [pc, #628]	; (8012624 <__kernel_rem_pio2+0x6c4>)
 80123ae:	f7f0 f927 	bl	8002600 <__aeabi_dmul>
 80123b2:	0002      	movs	r2, r0
 80123b4:	000b      	movs	r3, r1
 80123b6:	0030      	movs	r0, r6
 80123b8:	0039      	movs	r1, r7
 80123ba:	f7f0 fba9 	bl	8002b10 <__aeabi_dsub>
 80123be:	f7f0 ff5f 	bl	8003280 <__aeabi_d2iz>
 80123c2:	aa0e      	add	r2, sp, #56	; 0x38
 80123c4:	5150      	str	r0, [r2, r5]
 80123c6:	2201      	movs	r2, #1
 80123c8:	9b07      	ldr	r3, [sp, #28]
 80123ca:	4452      	add	r2, sl
 80123cc:	3318      	adds	r3, #24
 80123ce:	4690      	mov	r8, r2
 80123d0:	9307      	str	r3, [sp, #28]
 80123d2:	0093      	lsls	r3, r2, #2
 80123d4:	aa0e      	add	r2, sp, #56	; 0x38
 80123d6:	50d4      	str	r4, [r2, r3]
 80123d8:	e032      	b.n	8012440 <__kernel_rem_pio2+0x4e0>
 80123da:	2301      	movs	r3, #1
 80123dc:	2200      	movs	r2, #0
 80123de:	e768      	b.n	80122b2 <__kernel_rem_pio2+0x352>
 80123e0:	3104      	adds	r1, #4
 80123e2:	001a      	movs	r2, r3
 80123e4:	4298      	cmp	r0, r3
 80123e6:	d000      	beq.n	80123ea <__kernel_rem_pio2+0x48a>
 80123e8:	e75d      	b.n	80122a6 <__kernel_rem_pio2+0x346>
 80123ea:	4682      	mov	sl, r0
 80123ec:	e788      	b.n	8012300 <__kernel_rem_pio2+0x3a0>
 80123ee:	2200      	movs	r2, #0
 80123f0:	4b8e      	ldr	r3, [pc, #568]	; (801262c <__kernel_rem_pio2+0x6cc>)
 80123f2:	0030      	movs	r0, r6
 80123f4:	f7ee f8a8 	bl	8000548 <__aeabi_dcmpge>
 80123f8:	2800      	cmp	r0, #0
 80123fa:	d000      	beq.n	80123fe <__kernel_rem_pio2+0x49e>
 80123fc:	e17b      	b.n	80126f6 <__kernel_rem_pio2+0x796>
 80123fe:	2500      	movs	r5, #0
 8012400:	e6c0      	b.n	8012184 <__kernel_rem_pio2+0x224>
 8012402:	2301      	movs	r3, #1
 8012404:	4453      	add	r3, sl
 8012406:	4699      	mov	r9, r3
 8012408:	9303      	str	r3, [sp, #12]
 801240a:	e6ee      	b.n	80121ea <__kernel_rem_pio2+0x28a>
 801240c:	464b      	mov	r3, r9
 801240e:	9a07      	ldr	r2, [sp, #28]
 8012410:	9306      	str	r3, [sp, #24]
 8012412:	4688      	mov	r8, r1
 8012414:	008b      	lsls	r3, r1, #2
 8012416:	a90e      	add	r1, sp, #56	; 0x38
 8012418:	58cb      	ldr	r3, [r1, r3]
 801241a:	3a18      	subs	r2, #24
 801241c:	9505      	str	r5, [sp, #20]
 801241e:	9207      	str	r2, [sp, #28]
 8012420:	2b00      	cmp	r3, #0
 8012422:	d10d      	bne.n	8012440 <__kernel_rem_pio2+0x4e0>
 8012424:	468c      	mov	ip, r1
 8012426:	4641      	mov	r1, r8
 8012428:	4b81      	ldr	r3, [pc, #516]	; (8012630 <__kernel_rem_pio2+0x6d0>)
 801242a:	4453      	add	r3, sl
 801242c:	009b      	lsls	r3, r3, #2
 801242e:	4463      	add	r3, ip
 8012430:	3b04      	subs	r3, #4
 8012432:	6858      	ldr	r0, [r3, #4]
 8012434:	3901      	subs	r1, #1
 8012436:	3a18      	subs	r2, #24
 8012438:	2800      	cmp	r0, #0
 801243a:	d0f9      	beq.n	8012430 <__kernel_rem_pio2+0x4d0>
 801243c:	4688      	mov	r8, r1
 801243e:	9207      	str	r2, [sp, #28]
 8012440:	9a07      	ldr	r2, [sp, #28]
 8012442:	2000      	movs	r0, #0
 8012444:	4976      	ldr	r1, [pc, #472]	; (8012620 <__kernel_rem_pio2+0x6c0>)
 8012446:	f000 fb4b 	bl	8012ae0 <scalbn>
 801244a:	4643      	mov	r3, r8
 801244c:	0004      	movs	r4, r0
 801244e:	000d      	movs	r5, r1
 8012450:	2b00      	cmp	r3, #0
 8012452:	da00      	bge.n	8012456 <__kernel_rem_pio2+0x4f6>
 8012454:	e1c1      	b.n	80127da <__kernel_rem_pio2+0x87a>
 8012456:	009e      	lsls	r6, r3, #2
 8012458:	ab0e      	add	r3, sp, #56	; 0x38
 801245a:	469c      	mov	ip, r3
 801245c:	4643      	mov	r3, r8
 801245e:	9a00      	ldr	r2, [sp, #0]
 8012460:	00db      	lsls	r3, r3, #3
 8012462:	4466      	add	r6, ip
 8012464:	0011      	movs	r1, r2
 8012466:	469c      	mov	ip, r3
 8012468:	4461      	add	r1, ip
 801246a:	9307      	str	r3, [sp, #28]
 801246c:	000f      	movs	r7, r1
 801246e:	9100      	str	r1, [sp, #0]
 8012470:	4691      	mov	r9, r2
 8012472:	e000      	b.n	8012476 <__kernel_rem_pio2+0x516>
 8012474:	001f      	movs	r7, r3
 8012476:	6830      	ldr	r0, [r6, #0]
 8012478:	f7f0 ff3a 	bl	80032f0 <__aeabi_i2d>
 801247c:	0022      	movs	r2, r4
 801247e:	002b      	movs	r3, r5
 8012480:	f7f0 f8be 	bl	8002600 <__aeabi_dmul>
 8012484:	4b68      	ldr	r3, [pc, #416]	; (8012628 <__kernel_rem_pio2+0x6c8>)
 8012486:	6038      	str	r0, [r7, #0]
 8012488:	6079      	str	r1, [r7, #4]
 801248a:	2200      	movs	r2, #0
 801248c:	0020      	movs	r0, r4
 801248e:	0029      	movs	r1, r5
 8012490:	f7f0 f8b6 	bl	8002600 <__aeabi_dmul>
 8012494:	003b      	movs	r3, r7
 8012496:	0004      	movs	r4, r0
 8012498:	000d      	movs	r5, r1
 801249a:	3e04      	subs	r6, #4
 801249c:	3b08      	subs	r3, #8
 801249e:	45b9      	cmp	r9, r7
 80124a0:	d1e8      	bne.n	8012474 <__kernel_rem_pio2+0x514>
 80124a2:	ab4a      	add	r3, sp, #296	; 0x128
 80124a4:	9303      	str	r3, [sp, #12]
 80124a6:	469b      	mov	fp, r3
 80124a8:	2300      	movs	r3, #0
 80124aa:	469a      	mov	sl, r3
 80124ac:	9b08      	ldr	r3, [sp, #32]
 80124ae:	4699      	mov	r9, r3
 80124b0:	4643      	mov	r3, r8
 80124b2:	9304      	str	r3, [sp, #16]
 80124b4:	464b      	mov	r3, r9
 80124b6:	2b00      	cmp	r3, #0
 80124b8:	db30      	blt.n	801251c <__kernel_rem_pio2+0x5bc>
 80124ba:	2080      	movs	r0, #128	; 0x80
 80124bc:	4b5d      	ldr	r3, [pc, #372]	; (8012634 <__kernel_rem_pio2+0x6d4>)
 80124be:	9d00      	ldr	r5, [sp, #0]
 80124c0:	4698      	mov	r8, r3
 80124c2:	05c0      	lsls	r0, r0, #23
 80124c4:	495c      	ldr	r1, [pc, #368]	; (8012638 <__kernel_rem_pio2+0x6d8>)
 80124c6:	2600      	movs	r6, #0
 80124c8:	2700      	movs	r7, #0
 80124ca:	2400      	movs	r4, #0
 80124cc:	e008      	b.n	80124e0 <__kernel_rem_pio2+0x580>
 80124ce:	2308      	movs	r3, #8
 80124d0:	469c      	mov	ip, r3
 80124d2:	3508      	adds	r5, #8
 80124d4:	44e0      	add	r8, ip
 80124d6:	45a2      	cmp	sl, r4
 80124d8:	db11      	blt.n	80124fe <__kernel_rem_pio2+0x59e>
 80124da:	4643      	mov	r3, r8
 80124dc:	6818      	ldr	r0, [r3, #0]
 80124de:	6859      	ldr	r1, [r3, #4]
 80124e0:	682a      	ldr	r2, [r5, #0]
 80124e2:	686b      	ldr	r3, [r5, #4]
 80124e4:	f7f0 f88c 	bl	8002600 <__aeabi_dmul>
 80124e8:	0002      	movs	r2, r0
 80124ea:	000b      	movs	r3, r1
 80124ec:	0030      	movs	r0, r6
 80124ee:	0039      	movs	r1, r7
 80124f0:	f7ef f906 	bl	8001700 <__aeabi_dadd>
 80124f4:	3401      	adds	r4, #1
 80124f6:	0006      	movs	r6, r0
 80124f8:	000f      	movs	r7, r1
 80124fa:	45a1      	cmp	r9, r4
 80124fc:	dae7      	bge.n	80124ce <__kernel_rem_pio2+0x56e>
 80124fe:	465b      	mov	r3, fp
 8012500:	c3c0      	stmia	r3!, {r6, r7}
 8012502:	469b      	mov	fp, r3
 8012504:	4653      	mov	r3, sl
 8012506:	9a00      	ldr	r2, [sp, #0]
 8012508:	3301      	adds	r3, #1
 801250a:	3a08      	subs	r2, #8
 801250c:	9200      	str	r2, [sp, #0]
 801250e:	9a04      	ldr	r2, [sp, #16]
 8012510:	4592      	cmp	sl, r2
 8012512:	d006      	beq.n	8012522 <__kernel_rem_pio2+0x5c2>
 8012514:	469a      	mov	sl, r3
 8012516:	464b      	mov	r3, r9
 8012518:	2b00      	cmp	r3, #0
 801251a:	dace      	bge.n	80124ba <__kernel_rem_pio2+0x55a>
 801251c:	2600      	movs	r6, #0
 801251e:	2700      	movs	r7, #0
 8012520:	e7ed      	b.n	80124fe <__kernel_rem_pio2+0x59e>
 8012522:	9b04      	ldr	r3, [sp, #16]
 8012524:	4698      	mov	r8, r3
 8012526:	9ba4      	ldr	r3, [sp, #656]	; 0x290
 8012528:	2b02      	cmp	r3, #2
 801252a:	dc31      	bgt.n	8012590 <__kernel_rem_pio2+0x630>
 801252c:	2b00      	cmp	r3, #0
 801252e:	dd00      	ble.n	8012532 <__kernel_rem_pio2+0x5d2>
 8012530:	e0f4      	b.n	801271c <__kernel_rem_pio2+0x7bc>
 8012532:	d121      	bne.n	8012578 <__kernel_rem_pio2+0x618>
 8012534:	9a03      	ldr	r2, [sp, #12]
 8012536:	9b07      	ldr	r3, [sp, #28]
 8012538:	4694      	mov	ip, r2
 801253a:	4463      	add	r3, ip
 801253c:	001d      	movs	r5, r3
 801253e:	2600      	movs	r6, #0
 8012540:	2400      	movs	r4, #0
 8012542:	e000      	b.n	8012546 <__kernel_rem_pio2+0x5e6>
 8012544:	001d      	movs	r5, r3
 8012546:	682a      	ldr	r2, [r5, #0]
 8012548:	686b      	ldr	r3, [r5, #4]
 801254a:	0030      	movs	r0, r6
 801254c:	0021      	movs	r1, r4
 801254e:	f7ef f8d7 	bl	8001700 <__aeabi_dadd>
 8012552:	002b      	movs	r3, r5
 8012554:	9a03      	ldr	r2, [sp, #12]
 8012556:	0006      	movs	r6, r0
 8012558:	000c      	movs	r4, r1
 801255a:	3b08      	subs	r3, #8
 801255c:	42aa      	cmp	r2, r5
 801255e:	d1f1      	bne.n	8012544 <__kernel_rem_pio2+0x5e4>
 8012560:	9b05      	ldr	r3, [sp, #20]
 8012562:	2b00      	cmp	r3, #0
 8012564:	d003      	beq.n	801256e <__kernel_rem_pio2+0x60e>
 8012566:	2380      	movs	r3, #128	; 0x80
 8012568:	061b      	lsls	r3, r3, #24
 801256a:	469c      	mov	ip, r3
 801256c:	4464      	add	r4, ip
 801256e:	0032      	movs	r2, r6
 8012570:	0023      	movs	r3, r4
 8012572:	990d      	ldr	r1, [sp, #52]	; 0x34
 8012574:	600a      	str	r2, [r1, #0]
 8012576:	604b      	str	r3, [r1, #4]
 8012578:	2007      	movs	r0, #7
 801257a:	9b06      	ldr	r3, [sp, #24]
 801257c:	4018      	ands	r0, r3
 801257e:	239b      	movs	r3, #155	; 0x9b
 8012580:	009b      	lsls	r3, r3, #2
 8012582:	449d      	add	sp, r3
 8012584:	bc3c      	pop	{r2, r3, r4, r5}
 8012586:	4690      	mov	r8, r2
 8012588:	4699      	mov	r9, r3
 801258a:	46a2      	mov	sl, r4
 801258c:	46ab      	mov	fp, r5
 801258e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8012590:	9ba4      	ldr	r3, [sp, #656]	; 0x290
 8012592:	2b03      	cmp	r3, #3
 8012594:	d1f0      	bne.n	8012578 <__kernel_rem_pio2+0x618>
 8012596:	4643      	mov	r3, r8
 8012598:	2b00      	cmp	r3, #0
 801259a:	dc00      	bgt.n	801259e <__kernel_rem_pio2+0x63e>
 801259c:	e134      	b.n	8012808 <__kernel_rem_pio2+0x8a8>
 801259e:	9a03      	ldr	r2, [sp, #12]
 80125a0:	00db      	lsls	r3, r3, #3
 80125a2:	469a      	mov	sl, r3
 80125a4:	0013      	movs	r3, r2
 80125a6:	4691      	mov	r9, r2
 80125a8:	4453      	add	r3, sl
 80125aa:	681e      	ldr	r6, [r3, #0]
 80125ac:	685f      	ldr	r7, [r3, #4]
 80125ae:	4b23      	ldr	r3, [pc, #140]	; (801263c <__kernel_rem_pio2+0x6dc>)
 80125b0:	4443      	add	r3, r8
 80125b2:	469b      	mov	fp, r3
 80125b4:	00db      	lsls	r3, r3, #3
 80125b6:	4499      	add	r9, r3
 80125b8:	e000      	b.n	80125bc <__kernel_rem_pio2+0x65c>
 80125ba:	4699      	mov	r9, r3
 80125bc:	464b      	mov	r3, r9
 80125be:	685c      	ldr	r4, [r3, #4]
 80125c0:	681b      	ldr	r3, [r3, #0]
 80125c2:	0018      	movs	r0, r3
 80125c4:	0021      	movs	r1, r4
 80125c6:	0032      	movs	r2, r6
 80125c8:	003b      	movs	r3, r7
 80125ca:	9000      	str	r0, [sp, #0]
 80125cc:	9101      	str	r1, [sp, #4]
 80125ce:	f7ef f897 	bl	8001700 <__aeabi_dadd>
 80125d2:	0004      	movs	r4, r0
 80125d4:	000d      	movs	r5, r1
 80125d6:	0002      	movs	r2, r0
 80125d8:	000b      	movs	r3, r1
 80125da:	9800      	ldr	r0, [sp, #0]
 80125dc:	9901      	ldr	r1, [sp, #4]
 80125de:	f7f0 fa97 	bl	8002b10 <__aeabi_dsub>
 80125e2:	0032      	movs	r2, r6
 80125e4:	003b      	movs	r3, r7
 80125e6:	f7ef f88b 	bl	8001700 <__aeabi_dadd>
 80125ea:	464b      	mov	r3, r9
 80125ec:	9a03      	ldr	r2, [sp, #12]
 80125ee:	6098      	str	r0, [r3, #8]
 80125f0:	60d9      	str	r1, [r3, #12]
 80125f2:	601c      	str	r4, [r3, #0]
 80125f4:	605d      	str	r5, [r3, #4]
 80125f6:	0026      	movs	r6, r4
 80125f8:	3b08      	subs	r3, #8
 80125fa:	002f      	movs	r7, r5
 80125fc:	454a      	cmp	r2, r9
 80125fe:	d1dc      	bne.n	80125ba <__kernel_rem_pio2+0x65a>
 8012600:	4643      	mov	r3, r8
 8012602:	2b01      	cmp	r3, #1
 8012604:	dc00      	bgt.n	8012608 <__kernel_rem_pio2+0x6a8>
 8012606:	e0ff      	b.n	8012808 <__kernel_rem_pio2+0x8a8>
 8012608:	9a03      	ldr	r2, [sp, #12]
 801260a:	0013      	movs	r3, r2
 801260c:	4453      	add	r3, sl
 801260e:	681e      	ldr	r6, [r3, #0]
 8012610:	685f      	ldr	r7, [r3, #4]
 8012612:	465b      	mov	r3, fp
 8012614:	00db      	lsls	r3, r3, #3
 8012616:	469b      	mov	fp, r3
 8012618:	445a      	add	r2, fp
 801261a:	4690      	mov	r8, r2
 801261c:	e011      	b.n	8012642 <__kernel_rem_pio2+0x6e2>
 801261e:	46c0      	nop			; (mov r8, r8)
 8012620:	3ff00000 	.word	0x3ff00000
 8012624:	41700000 	.word	0x41700000
 8012628:	3e700000 	.word	0x3e700000
 801262c:	3fe00000 	.word	0x3fe00000
 8012630:	3ffffffe 	.word	0x3ffffffe
 8012634:	08016be0 	.word	0x08016be0
 8012638:	3ff921fb 	.word	0x3ff921fb
 801263c:	1fffffff 	.word	0x1fffffff
 8012640:	4698      	mov	r8, r3
 8012642:	4643      	mov	r3, r8
 8012644:	685c      	ldr	r4, [r3, #4]
 8012646:	681b      	ldr	r3, [r3, #0]
 8012648:	0018      	movs	r0, r3
 801264a:	0021      	movs	r1, r4
 801264c:	0032      	movs	r2, r6
 801264e:	003b      	movs	r3, r7
 8012650:	9000      	str	r0, [sp, #0]
 8012652:	9101      	str	r1, [sp, #4]
 8012654:	f7ef f854 	bl	8001700 <__aeabi_dadd>
 8012658:	0004      	movs	r4, r0
 801265a:	000d      	movs	r5, r1
 801265c:	0002      	movs	r2, r0
 801265e:	000b      	movs	r3, r1
 8012660:	9800      	ldr	r0, [sp, #0]
 8012662:	9901      	ldr	r1, [sp, #4]
 8012664:	f7f0 fa54 	bl	8002b10 <__aeabi_dsub>
 8012668:	0032      	movs	r2, r6
 801266a:	003b      	movs	r3, r7
 801266c:	f7ef f848 	bl	8001700 <__aeabi_dadd>
 8012670:	4643      	mov	r3, r8
 8012672:	9a03      	ldr	r2, [sp, #12]
 8012674:	6098      	str	r0, [r3, #8]
 8012676:	60d9      	str	r1, [r3, #12]
 8012678:	601c      	str	r4, [r3, #0]
 801267a:	605d      	str	r5, [r3, #4]
 801267c:	3b08      	subs	r3, #8
 801267e:	0026      	movs	r6, r4
 8012680:	002f      	movs	r7, r5
 8012682:	429a      	cmp	r2, r3
 8012684:	d1dc      	bne.n	8012640 <__kernel_rem_pio2+0x6e0>
 8012686:	465d      	mov	r5, fp
 8012688:	4694      	mov	ip, r2
 801268a:	2600      	movs	r6, #0
 801268c:	2400      	movs	r4, #0
 801268e:	4647      	mov	r7, r8
 8012690:	3508      	adds	r5, #8
 8012692:	4465      	add	r5, ip
 8012694:	682a      	ldr	r2, [r5, #0]
 8012696:	686b      	ldr	r3, [r5, #4]
 8012698:	0030      	movs	r0, r6
 801269a:	0021      	movs	r1, r4
 801269c:	f7ef f830 	bl	8001700 <__aeabi_dadd>
 80126a0:	3d08      	subs	r5, #8
 80126a2:	0006      	movs	r6, r0
 80126a4:	000c      	movs	r4, r1
 80126a6:	42af      	cmp	r7, r5
 80126a8:	d1f4      	bne.n	8012694 <__kernel_rem_pio2+0x734>
 80126aa:	9b03      	ldr	r3, [sp, #12]
 80126ac:	9f4a      	ldr	r7, [sp, #296]	; 0x128
 80126ae:	685d      	ldr	r5, [r3, #4]
 80126b0:	6899      	ldr	r1, [r3, #8]
 80126b2:	68d8      	ldr	r0, [r3, #12]
 80126b4:	9b05      	ldr	r3, [sp, #20]
 80126b6:	2b00      	cmp	r3, #0
 80126b8:	d176      	bne.n	80127a8 <__kernel_rem_pio2+0x848>
 80126ba:	002b      	movs	r3, r5
 80126bc:	003a      	movs	r2, r7
 80126be:	9d0d      	ldr	r5, [sp, #52]	; 0x34
 80126c0:	602a      	str	r2, [r5, #0]
 80126c2:	606b      	str	r3, [r5, #4]
 80126c4:	000a      	movs	r2, r1
 80126c6:	0003      	movs	r3, r0
 80126c8:	60aa      	str	r2, [r5, #8]
 80126ca:	60eb      	str	r3, [r5, #12]
 80126cc:	0032      	movs	r2, r6
 80126ce:	0023      	movs	r3, r4
 80126d0:	612a      	str	r2, [r5, #16]
 80126d2:	616b      	str	r3, [r5, #20]
 80126d4:	e750      	b.n	8012578 <__kernel_rem_pio2+0x618>
 80126d6:	4653      	mov	r3, sl
 80126d8:	1e5a      	subs	r2, r3, #1
 80126da:	0092      	lsls	r2, r2, #2
 80126dc:	ab0e      	add	r3, sp, #56	; 0x38
 80126de:	589b      	ldr	r3, [r3, r2]
 80126e0:	a90e      	add	r1, sp, #56	; 0x38
 80126e2:	9303      	str	r3, [sp, #12]
 80126e4:	025b      	lsls	r3, r3, #9
 80126e6:	0a5b      	lsrs	r3, r3, #9
 80126e8:	508b      	str	r3, [r1, r2]
 80126ea:	e61b      	b.n	8012324 <__kernel_rem_pio2+0x3c4>
 80126ec:	2318      	movs	r3, #24
 80126ee:	2200      	movs	r2, #0
 80126f0:	425b      	negs	r3, r3
 80126f2:	9203      	str	r2, [sp, #12]
 80126f4:	e457      	b.n	8011fa6 <__kernel_rem_pio2+0x46>
 80126f6:	2301      	movs	r3, #1
 80126f8:	469c      	mov	ip, r3
 80126fa:	4653      	mov	r3, sl
 80126fc:	44e1      	add	r9, ip
 80126fe:	2502      	movs	r5, #2
 8012700:	2b00      	cmp	r3, #0
 8012702:	dd00      	ble.n	8012706 <__kernel_rem_pio2+0x7a6>
 8012704:	e5c5      	b.n	8012292 <__kernel_rem_pio2+0x332>
 8012706:	0032      	movs	r2, r6
 8012708:	003b      	movs	r3, r7
 801270a:	2000      	movs	r0, #0
 801270c:	4940      	ldr	r1, [pc, #256]	; (8012810 <__kernel_rem_pio2+0x8b0>)
 801270e:	f7f0 f9ff 	bl	8002b10 <__aeabi_dsub>
 8012712:	0006      	movs	r6, r0
 8012714:	000f      	movs	r7, r1
 8012716:	e535      	b.n	8012184 <__kernel_rem_pio2+0x224>
 8012718:	2400      	movs	r4, #0
 801271a:	e5f1      	b.n	8012300 <__kernel_rem_pio2+0x3a0>
 801271c:	9a03      	ldr	r2, [sp, #12]
 801271e:	9b07      	ldr	r3, [sp, #28]
 8012720:	4694      	mov	ip, r2
 8012722:	4463      	add	r3, ip
 8012724:	001e      	movs	r6, r3
 8012726:	2500      	movs	r5, #0
 8012728:	2400      	movs	r4, #0
 801272a:	e000      	b.n	801272e <__kernel_rem_pio2+0x7ce>
 801272c:	001e      	movs	r6, r3
 801272e:	6832      	ldr	r2, [r6, #0]
 8012730:	6873      	ldr	r3, [r6, #4]
 8012732:	0028      	movs	r0, r5
 8012734:	0021      	movs	r1, r4
 8012736:	f7ee ffe3 	bl	8001700 <__aeabi_dadd>
 801273a:	0033      	movs	r3, r6
 801273c:	9a03      	ldr	r2, [sp, #12]
 801273e:	0005      	movs	r5, r0
 8012740:	000c      	movs	r4, r1
 8012742:	3b08      	subs	r3, #8
 8012744:	42b2      	cmp	r2, r6
 8012746:	d1f1      	bne.n	801272c <__kernel_rem_pio2+0x7cc>
 8012748:	984a      	ldr	r0, [sp, #296]	; 0x128
 801274a:	994b      	ldr	r1, [sp, #300]	; 0x12c
 801274c:	0023      	movs	r3, r4
 801274e:	002a      	movs	r2, r5
 8012750:	f7f0 f9de 	bl	8002b10 <__aeabi_dsub>
 8012754:	9b05      	ldr	r3, [sp, #20]
 8012756:	2b00      	cmp	r3, #0
 8012758:	d134      	bne.n	80127c4 <__kernel_rem_pio2+0x864>
 801275a:	0023      	movs	r3, r4
 801275c:	002a      	movs	r2, r5
 801275e:	9c0d      	ldr	r4, [sp, #52]	; 0x34
 8012760:	6022      	str	r2, [r4, #0]
 8012762:	6063      	str	r3, [r4, #4]
 8012764:	4643      	mov	r3, r8
 8012766:	2b00      	cmp	r3, #0
 8012768:	dd0e      	ble.n	8012788 <__kernel_rem_pio2+0x828>
 801276a:	2601      	movs	r6, #1
 801276c:	af4c      	add	r7, sp, #304	; 0x130
 801276e:	cf0c      	ldmia	r7!, {r2, r3}
 8012770:	3601      	adds	r6, #1
 8012772:	f7ee ffc5 	bl	8001700 <__aeabi_dadd>
 8012776:	45b0      	cmp	r8, r6
 8012778:	daf9      	bge.n	801276e <__kernel_rem_pio2+0x80e>
 801277a:	9b05      	ldr	r3, [sp, #20]
 801277c:	2b00      	cmp	r3, #0
 801277e:	d003      	beq.n	8012788 <__kernel_rem_pio2+0x828>
 8012780:	2380      	movs	r3, #128	; 0x80
 8012782:	061b      	lsls	r3, r3, #24
 8012784:	469c      	mov	ip, r3
 8012786:	4461      	add	r1, ip
 8012788:	000b      	movs	r3, r1
 801278a:	0002      	movs	r2, r0
 801278c:	990d      	ldr	r1, [sp, #52]	; 0x34
 801278e:	608a      	str	r2, [r1, #8]
 8012790:	60cb      	str	r3, [r1, #12]
 8012792:	e6f1      	b.n	8012578 <__kernel_rem_pio2+0x618>
 8012794:	4653      	mov	r3, sl
 8012796:	0030      	movs	r0, r6
 8012798:	0039      	movs	r1, r7
 801279a:	009c      	lsls	r4, r3, #2
 801279c:	f7f0 fd70 	bl	8003280 <__aeabi_d2iz>
 80127a0:	ab0e      	add	r3, sp, #56	; 0x38
 80127a2:	5118      	str	r0, [r3, r4]
 80127a4:	46d0      	mov	r8, sl
 80127a6:	e64b      	b.n	8012440 <__kernel_rem_pio2+0x4e0>
 80127a8:	2280      	movs	r2, #128	; 0x80
 80127aa:	0612      	lsls	r2, r2, #24
 80127ac:	4694      	mov	ip, r2
 80127ae:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80127b0:	4465      	add	r5, ip
 80127b2:	4460      	add	r0, ip
 80127b4:	4464      	add	r4, ip
 80127b6:	601f      	str	r7, [r3, #0]
 80127b8:	605d      	str	r5, [r3, #4]
 80127ba:	6099      	str	r1, [r3, #8]
 80127bc:	60d8      	str	r0, [r3, #12]
 80127be:	611e      	str	r6, [r3, #16]
 80127c0:	615c      	str	r4, [r3, #20]
 80127c2:	e6d9      	b.n	8012578 <__kernel_rem_pio2+0x618>
 80127c4:	2280      	movs	r2, #128	; 0x80
 80127c6:	0612      	lsls	r2, r2, #24
 80127c8:	4694      	mov	ip, r2
 80127ca:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80127cc:	4464      	add	r4, ip
 80127ce:	601d      	str	r5, [r3, #0]
 80127d0:	605c      	str	r4, [r3, #4]
 80127d2:	4643      	mov	r3, r8
 80127d4:	2b00      	cmp	r3, #0
 80127d6:	dcc8      	bgt.n	801276a <__kernel_rem_pio2+0x80a>
 80127d8:	e7d2      	b.n	8012780 <__kernel_rem_pio2+0x820>
 80127da:	9ba4      	ldr	r3, [sp, #656]	; 0x290
 80127dc:	2b02      	cmp	r3, #2
 80127de:	dc09      	bgt.n	80127f4 <__kernel_rem_pio2+0x894>
 80127e0:	2b00      	cmp	r3, #0
 80127e2:	dc0e      	bgt.n	8012802 <__kernel_rem_pio2+0x8a2>
 80127e4:	d000      	beq.n	80127e8 <__kernel_rem_pio2+0x888>
 80127e6:	e6c7      	b.n	8012578 <__kernel_rem_pio2+0x618>
 80127e8:	2600      	movs	r6, #0
 80127ea:	2400      	movs	r4, #0
 80127ec:	e6b8      	b.n	8012560 <__kernel_rem_pio2+0x600>
 80127ee:	ab72      	add	r3, sp, #456	; 0x1c8
 80127f0:	9300      	str	r3, [sp, #0]
 80127f2:	e42c      	b.n	801204e <__kernel_rem_pio2+0xee>
 80127f4:	ab4a      	add	r3, sp, #296	; 0x128
 80127f6:	9303      	str	r3, [sp, #12]
 80127f8:	9ba4      	ldr	r3, [sp, #656]	; 0x290
 80127fa:	2b03      	cmp	r3, #3
 80127fc:	d100      	bne.n	8012800 <__kernel_rem_pio2+0x8a0>
 80127fe:	e6ca      	b.n	8012596 <__kernel_rem_pio2+0x636>
 8012800:	e6ba      	b.n	8012578 <__kernel_rem_pio2+0x618>
 8012802:	2500      	movs	r5, #0
 8012804:	2400      	movs	r4, #0
 8012806:	e79f      	b.n	8012748 <__kernel_rem_pio2+0x7e8>
 8012808:	2600      	movs	r6, #0
 801280a:	2400      	movs	r4, #0
 801280c:	e74d      	b.n	80126aa <__kernel_rem_pio2+0x74a>
 801280e:	46c0      	nop			; (mov r8, r8)
 8012810:	3ff00000 	.word	0x3ff00000
	...

08012820 <__kernel_sin>:
 8012820:	b5f0      	push	{r4, r5, r6, r7, lr}
 8012822:	46ce      	mov	lr, r9
 8012824:	4647      	mov	r7, r8
 8012826:	b580      	push	{r7, lr}
 8012828:	b087      	sub	sp, #28
 801282a:	9200      	str	r2, [sp, #0]
 801282c:	9301      	str	r3, [sp, #4]
 801282e:	4a48      	ldr	r2, [pc, #288]	; (8012950 <__kernel_sin+0x130>)
 8012830:	004b      	lsls	r3, r1, #1
 8012832:	4681      	mov	r9, r0
 8012834:	4688      	mov	r8, r1
 8012836:	085b      	lsrs	r3, r3, #1
 8012838:	4293      	cmp	r3, r2
 801283a:	dc06      	bgt.n	801284a <__kernel_sin+0x2a>
 801283c:	4648      	mov	r0, r9
 801283e:	4641      	mov	r1, r8
 8012840:	f7f0 fd1e 	bl	8003280 <__aeabi_d2iz>
 8012844:	2800      	cmp	r0, #0
 8012846:	d100      	bne.n	801284a <__kernel_sin+0x2a>
 8012848:	e07e      	b.n	8012948 <__kernel_sin+0x128>
 801284a:	464a      	mov	r2, r9
 801284c:	4643      	mov	r3, r8
 801284e:	4648      	mov	r0, r9
 8012850:	4641      	mov	r1, r8
 8012852:	f7ef fed5 	bl	8002600 <__aeabi_dmul>
 8012856:	0004      	movs	r4, r0
 8012858:	000d      	movs	r5, r1
 801285a:	0002      	movs	r2, r0
 801285c:	000b      	movs	r3, r1
 801285e:	4648      	mov	r0, r9
 8012860:	4641      	mov	r1, r8
 8012862:	f7ef fecd 	bl	8002600 <__aeabi_dmul>
 8012866:	4a3b      	ldr	r2, [pc, #236]	; (8012954 <__kernel_sin+0x134>)
 8012868:	4b3b      	ldr	r3, [pc, #236]	; (8012958 <__kernel_sin+0x138>)
 801286a:	0006      	movs	r6, r0
 801286c:	000f      	movs	r7, r1
 801286e:	0020      	movs	r0, r4
 8012870:	0029      	movs	r1, r5
 8012872:	f7ef fec5 	bl	8002600 <__aeabi_dmul>
 8012876:	4a39      	ldr	r2, [pc, #228]	; (801295c <__kernel_sin+0x13c>)
 8012878:	4b39      	ldr	r3, [pc, #228]	; (8012960 <__kernel_sin+0x140>)
 801287a:	f7f0 f949 	bl	8002b10 <__aeabi_dsub>
 801287e:	0022      	movs	r2, r4
 8012880:	002b      	movs	r3, r5
 8012882:	f7ef febd 	bl	8002600 <__aeabi_dmul>
 8012886:	4a37      	ldr	r2, [pc, #220]	; (8012964 <__kernel_sin+0x144>)
 8012888:	4b37      	ldr	r3, [pc, #220]	; (8012968 <__kernel_sin+0x148>)
 801288a:	f7ee ff39 	bl	8001700 <__aeabi_dadd>
 801288e:	0022      	movs	r2, r4
 8012890:	002b      	movs	r3, r5
 8012892:	f7ef feb5 	bl	8002600 <__aeabi_dmul>
 8012896:	4a35      	ldr	r2, [pc, #212]	; (801296c <__kernel_sin+0x14c>)
 8012898:	4b35      	ldr	r3, [pc, #212]	; (8012970 <__kernel_sin+0x150>)
 801289a:	f7f0 f939 	bl	8002b10 <__aeabi_dsub>
 801289e:	0022      	movs	r2, r4
 80128a0:	002b      	movs	r3, r5
 80128a2:	f7ef fead 	bl	8002600 <__aeabi_dmul>
 80128a6:	4b33      	ldr	r3, [pc, #204]	; (8012974 <__kernel_sin+0x154>)
 80128a8:	4a33      	ldr	r2, [pc, #204]	; (8012978 <__kernel_sin+0x158>)
 80128aa:	f7ee ff29 	bl	8001700 <__aeabi_dadd>
 80128ae:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80128b0:	9002      	str	r0, [sp, #8]
 80128b2:	9103      	str	r1, [sp, #12]
 80128b4:	2b00      	cmp	r3, #0
 80128b6:	d034      	beq.n	8012922 <__kernel_sin+0x102>
 80128b8:	9800      	ldr	r0, [sp, #0]
 80128ba:	9901      	ldr	r1, [sp, #4]
 80128bc:	2200      	movs	r2, #0
 80128be:	4b2f      	ldr	r3, [pc, #188]	; (801297c <__kernel_sin+0x15c>)
 80128c0:	f7ef fe9e 	bl	8002600 <__aeabi_dmul>
 80128c4:	9a02      	ldr	r2, [sp, #8]
 80128c6:	9b03      	ldr	r3, [sp, #12]
 80128c8:	9004      	str	r0, [sp, #16]
 80128ca:	9105      	str	r1, [sp, #20]
 80128cc:	0030      	movs	r0, r6
 80128ce:	0039      	movs	r1, r7
 80128d0:	f7ef fe96 	bl	8002600 <__aeabi_dmul>
 80128d4:	0002      	movs	r2, r0
 80128d6:	000b      	movs	r3, r1
 80128d8:	9804      	ldr	r0, [sp, #16]
 80128da:	9905      	ldr	r1, [sp, #20]
 80128dc:	f7f0 f918 	bl	8002b10 <__aeabi_dsub>
 80128e0:	0022      	movs	r2, r4
 80128e2:	002b      	movs	r3, r5
 80128e4:	f7ef fe8c 	bl	8002600 <__aeabi_dmul>
 80128e8:	9a00      	ldr	r2, [sp, #0]
 80128ea:	9b01      	ldr	r3, [sp, #4]
 80128ec:	f7f0 f910 	bl	8002b10 <__aeabi_dsub>
 80128f0:	4a23      	ldr	r2, [pc, #140]	; (8012980 <__kernel_sin+0x160>)
 80128f2:	0004      	movs	r4, r0
 80128f4:	000d      	movs	r5, r1
 80128f6:	4b23      	ldr	r3, [pc, #140]	; (8012984 <__kernel_sin+0x164>)
 80128f8:	0030      	movs	r0, r6
 80128fa:	0039      	movs	r1, r7
 80128fc:	f7ef fe80 	bl	8002600 <__aeabi_dmul>
 8012900:	0002      	movs	r2, r0
 8012902:	000b      	movs	r3, r1
 8012904:	0020      	movs	r0, r4
 8012906:	0029      	movs	r1, r5
 8012908:	f7ee fefa 	bl	8001700 <__aeabi_dadd>
 801290c:	0002      	movs	r2, r0
 801290e:	000b      	movs	r3, r1
 8012910:	4648      	mov	r0, r9
 8012912:	4641      	mov	r1, r8
 8012914:	f7f0 f8fc 	bl	8002b10 <__aeabi_dsub>
 8012918:	b007      	add	sp, #28
 801291a:	bc0c      	pop	{r2, r3}
 801291c:	4690      	mov	r8, r2
 801291e:	4699      	mov	r9, r3
 8012920:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8012922:	0002      	movs	r2, r0
 8012924:	000b      	movs	r3, r1
 8012926:	0020      	movs	r0, r4
 8012928:	0029      	movs	r1, r5
 801292a:	f7ef fe69 	bl	8002600 <__aeabi_dmul>
 801292e:	4a14      	ldr	r2, [pc, #80]	; (8012980 <__kernel_sin+0x160>)
 8012930:	4b14      	ldr	r3, [pc, #80]	; (8012984 <__kernel_sin+0x164>)
 8012932:	f7f0 f8ed 	bl	8002b10 <__aeabi_dsub>
 8012936:	0032      	movs	r2, r6
 8012938:	003b      	movs	r3, r7
 801293a:	f7ef fe61 	bl	8002600 <__aeabi_dmul>
 801293e:	464a      	mov	r2, r9
 8012940:	4643      	mov	r3, r8
 8012942:	f7ee fedd 	bl	8001700 <__aeabi_dadd>
 8012946:	e7e7      	b.n	8012918 <__kernel_sin+0xf8>
 8012948:	4648      	mov	r0, r9
 801294a:	4641      	mov	r1, r8
 801294c:	e7e4      	b.n	8012918 <__kernel_sin+0xf8>
 801294e:	46c0      	nop			; (mov r8, r8)
 8012950:	3e3fffff 	.word	0x3e3fffff
 8012954:	5acfd57c 	.word	0x5acfd57c
 8012958:	3de5d93a 	.word	0x3de5d93a
 801295c:	8a2b9ceb 	.word	0x8a2b9ceb
 8012960:	3e5ae5e6 	.word	0x3e5ae5e6
 8012964:	57b1fe7d 	.word	0x57b1fe7d
 8012968:	3ec71de3 	.word	0x3ec71de3
 801296c:	19c161d5 	.word	0x19c161d5
 8012970:	3f2a01a0 	.word	0x3f2a01a0
 8012974:	3f811111 	.word	0x3f811111
 8012978:	1110f8a6 	.word	0x1110f8a6
 801297c:	3fe00000 	.word	0x3fe00000
 8012980:	55555549 	.word	0x55555549
 8012984:	3fc55555 	.word	0x3fc55555
	...

08012990 <fabs>:
 8012990:	0049      	lsls	r1, r1, #1
 8012992:	084b      	lsrs	r3, r1, #1
 8012994:	0019      	movs	r1, r3
 8012996:	4770      	bx	lr
	...

080129a0 <floor>:
 80129a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80129a2:	4647      	mov	r7, r8
 80129a4:	46ce      	mov	lr, r9
 80129a6:	004b      	lsls	r3, r1, #1
 80129a8:	4a3d      	ldr	r2, [pc, #244]	; (8012aa0 <floor+0x100>)
 80129aa:	0d5b      	lsrs	r3, r3, #21
 80129ac:	189e      	adds	r6, r3, r2
 80129ae:	b580      	push	{r7, lr}
 80129b0:	0005      	movs	r5, r0
 80129b2:	000c      	movs	r4, r1
 80129b4:	000f      	movs	r7, r1
 80129b6:	4680      	mov	r8, r0
 80129b8:	2e13      	cmp	r6, #19
 80129ba:	dc31      	bgt.n	8012a20 <floor+0x80>
 80129bc:	2e00      	cmp	r6, #0
 80129be:	db1f      	blt.n	8012a00 <floor+0x60>
 80129c0:	4b38      	ldr	r3, [pc, #224]	; (8012aa4 <floor+0x104>)
 80129c2:	4133      	asrs	r3, r6
 80129c4:	4699      	mov	r9, r3
 80129c6:	400b      	ands	r3, r1
 80129c8:	4303      	orrs	r3, r0
 80129ca:	d04e      	beq.n	8012a6a <floor+0xca>
 80129cc:	4a36      	ldr	r2, [pc, #216]	; (8012aa8 <floor+0x108>)
 80129ce:	4b37      	ldr	r3, [pc, #220]	; (8012aac <floor+0x10c>)
 80129d0:	f7ee fe96 	bl	8001700 <__aeabi_dadd>
 80129d4:	2200      	movs	r2, #0
 80129d6:	2300      	movs	r3, #0
 80129d8:	f7ed fdac 	bl	8000534 <__aeabi_dcmpgt>
 80129dc:	2800      	cmp	r0, #0
 80129de:	d009      	beq.n	80129f4 <floor+0x54>
 80129e0:	2c00      	cmp	r4, #0
 80129e2:	da03      	bge.n	80129ec <floor+0x4c>
 80129e4:	2780      	movs	r7, #128	; 0x80
 80129e6:	037f      	lsls	r7, r7, #13
 80129e8:	4137      	asrs	r7, r6
 80129ea:	193f      	adds	r7, r7, r4
 80129ec:	464b      	mov	r3, r9
 80129ee:	439f      	bics	r7, r3
 80129f0:	2300      	movs	r3, #0
 80129f2:	4698      	mov	r8, r3
 80129f4:	4640      	mov	r0, r8
 80129f6:	0039      	movs	r1, r7
 80129f8:	bc0c      	pop	{r2, r3}
 80129fa:	4690      	mov	r8, r2
 80129fc:	4699      	mov	r9, r3
 80129fe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8012a00:	4a29      	ldr	r2, [pc, #164]	; (8012aa8 <floor+0x108>)
 8012a02:	4b2a      	ldr	r3, [pc, #168]	; (8012aac <floor+0x10c>)
 8012a04:	f7ee fe7c 	bl	8001700 <__aeabi_dadd>
 8012a08:	2200      	movs	r2, #0
 8012a0a:	2300      	movs	r3, #0
 8012a0c:	f7ed fd92 	bl	8000534 <__aeabi_dcmpgt>
 8012a10:	2800      	cmp	r0, #0
 8012a12:	d0ef      	beq.n	80129f4 <floor+0x54>
 8012a14:	2c00      	cmp	r4, #0
 8012a16:	db2b      	blt.n	8012a70 <floor+0xd0>
 8012a18:	2300      	movs	r3, #0
 8012a1a:	2700      	movs	r7, #0
 8012a1c:	4698      	mov	r8, r3
 8012a1e:	e7e9      	b.n	80129f4 <floor+0x54>
 8012a20:	2e33      	cmp	r6, #51	; 0x33
 8012a22:	dd08      	ble.n	8012a36 <floor+0x96>
 8012a24:	2380      	movs	r3, #128	; 0x80
 8012a26:	00db      	lsls	r3, r3, #3
 8012a28:	429e      	cmp	r6, r3
 8012a2a:	d1e5      	bne.n	80129f8 <floor+0x58>
 8012a2c:	0002      	movs	r2, r0
 8012a2e:	000b      	movs	r3, r1
 8012a30:	f7ee fe66 	bl	8001700 <__aeabi_dadd>
 8012a34:	e7e0      	b.n	80129f8 <floor+0x58>
 8012a36:	4a1e      	ldr	r2, [pc, #120]	; (8012ab0 <floor+0x110>)
 8012a38:	4694      	mov	ip, r2
 8012a3a:	2201      	movs	r2, #1
 8012a3c:	4463      	add	r3, ip
 8012a3e:	4252      	negs	r2, r2
 8012a40:	40da      	lsrs	r2, r3
 8012a42:	4691      	mov	r9, r2
 8012a44:	4202      	tst	r2, r0
 8012a46:	d010      	beq.n	8012a6a <floor+0xca>
 8012a48:	4a17      	ldr	r2, [pc, #92]	; (8012aa8 <floor+0x108>)
 8012a4a:	4b18      	ldr	r3, [pc, #96]	; (8012aac <floor+0x10c>)
 8012a4c:	f7ee fe58 	bl	8001700 <__aeabi_dadd>
 8012a50:	2200      	movs	r2, #0
 8012a52:	2300      	movs	r3, #0
 8012a54:	f7ed fd6e 	bl	8000534 <__aeabi_dcmpgt>
 8012a58:	2800      	cmp	r0, #0
 8012a5a:	d0cb      	beq.n	80129f4 <floor+0x54>
 8012a5c:	2c00      	cmp	r4, #0
 8012a5e:	db0f      	blt.n	8012a80 <floor+0xe0>
 8012a60:	4643      	mov	r3, r8
 8012a62:	464a      	mov	r2, r9
 8012a64:	4393      	bics	r3, r2
 8012a66:	4698      	mov	r8, r3
 8012a68:	e7c4      	b.n	80129f4 <floor+0x54>
 8012a6a:	0028      	movs	r0, r5
 8012a6c:	0021      	movs	r1, r4
 8012a6e:	e7c3      	b.n	80129f8 <floor+0x58>
 8012a70:	2300      	movs	r3, #0
 8012a72:	0064      	lsls	r4, r4, #1
 8012a74:	0864      	lsrs	r4, r4, #1
 8012a76:	4325      	orrs	r5, r4
 8012a78:	4698      	mov	r8, r3
 8012a7a:	d0bb      	beq.n	80129f4 <floor+0x54>
 8012a7c:	4f0d      	ldr	r7, [pc, #52]	; (8012ab4 <floor+0x114>)
 8012a7e:	e7b9      	b.n	80129f4 <floor+0x54>
 8012a80:	2e14      	cmp	r6, #20
 8012a82:	d009      	beq.n	8012a98 <floor+0xf8>
 8012a84:	2334      	movs	r3, #52	; 0x34
 8012a86:	2001      	movs	r0, #1
 8012a88:	1b9e      	subs	r6, r3, r6
 8012a8a:	40b0      	lsls	r0, r6
 8012a8c:	1945      	adds	r5, r0, r5
 8012a8e:	45a8      	cmp	r8, r5
 8012a90:	d904      	bls.n	8012a9c <floor+0xfc>
 8012a92:	1c67      	adds	r7, r4, #1
 8012a94:	46a8      	mov	r8, r5
 8012a96:	e7e3      	b.n	8012a60 <floor+0xc0>
 8012a98:	1c67      	adds	r7, r4, #1
 8012a9a:	e7e1      	b.n	8012a60 <floor+0xc0>
 8012a9c:	46a8      	mov	r8, r5
 8012a9e:	e7df      	b.n	8012a60 <floor+0xc0>
 8012aa0:	fffffc01 	.word	0xfffffc01
 8012aa4:	000fffff 	.word	0x000fffff
 8012aa8:	8800759c 	.word	0x8800759c
 8012aac:	7e37e43c 	.word	0x7e37e43c
 8012ab0:	fffffbed 	.word	0xfffffbed
 8012ab4:	bff00000 	.word	0xbff00000
	...

08012ac0 <matherr>:
 8012ac0:	2000      	movs	r0, #0
 8012ac2:	4770      	bx	lr
	...

08012ad0 <nan>:
 8012ad0:	2000      	movs	r0, #0
 8012ad2:	4901      	ldr	r1, [pc, #4]	; (8012ad8 <nan+0x8>)
 8012ad4:	4770      	bx	lr
 8012ad6:	46c0      	nop			; (mov r8, r8)
 8012ad8:	7ff80000 	.word	0x7ff80000
 8012adc:	00000000 	.word	0x00000000

08012ae0 <scalbn>:
 8012ae0:	004b      	lsls	r3, r1, #1
 8012ae2:	b570      	push	{r4, r5, r6, lr}
 8012ae4:	0d5b      	lsrs	r3, r3, #21
 8012ae6:	0014      	movs	r4, r2
 8012ae8:	000a      	movs	r2, r1
 8012aea:	2b00      	cmp	r3, #0
 8012aec:	d125      	bne.n	8012b3a <scalbn+0x5a>
 8012aee:	004b      	lsls	r3, r1, #1
 8012af0:	085b      	lsrs	r3, r3, #1
 8012af2:	4303      	orrs	r3, r0
 8012af4:	d020      	beq.n	8012b38 <scalbn+0x58>
 8012af6:	4b2b      	ldr	r3, [pc, #172]	; (8012ba4 <scalbn+0xc4>)
 8012af8:	2200      	movs	r2, #0
 8012afa:	f7ef fd81 	bl	8002600 <__aeabi_dmul>
 8012afe:	4b2a      	ldr	r3, [pc, #168]	; (8012ba8 <scalbn+0xc8>)
 8012b00:	429c      	cmp	r4, r3
 8012b02:	db47      	blt.n	8012b94 <scalbn+0xb4>
 8012b04:	000a      	movs	r2, r1
 8012b06:	004b      	lsls	r3, r1, #1
 8012b08:	0d5b      	lsrs	r3, r3, #21
 8012b0a:	3b36      	subs	r3, #54	; 0x36
 8012b0c:	4d27      	ldr	r5, [pc, #156]	; (8012bac <scalbn+0xcc>)
 8012b0e:	18e3      	adds	r3, r4, r3
 8012b10:	42ab      	cmp	r3, r5
 8012b12:	dc1a      	bgt.n	8012b4a <scalbn+0x6a>
 8012b14:	2b00      	cmp	r3, #0
 8012b16:	dc37      	bgt.n	8012b88 <scalbn+0xa8>
 8012b18:	001d      	movs	r5, r3
 8012b1a:	3535      	adds	r5, #53	; 0x35
 8012b1c:	da29      	bge.n	8012b72 <scalbn+0x92>
 8012b1e:	4b24      	ldr	r3, [pc, #144]	; (8012bb0 <scalbn+0xd0>)
 8012b20:	429c      	cmp	r4, r3
 8012b22:	dc12      	bgt.n	8012b4a <scalbn+0x6a>
 8012b24:	4c23      	ldr	r4, [pc, #140]	; (8012bb4 <scalbn+0xd4>)
 8012b26:	4d24      	ldr	r5, [pc, #144]	; (8012bb8 <scalbn+0xd8>)
 8012b28:	2900      	cmp	r1, #0
 8012b2a:	db38      	blt.n	8012b9e <scalbn+0xbe>
 8012b2c:	4a21      	ldr	r2, [pc, #132]	; (8012bb4 <scalbn+0xd4>)
 8012b2e:	4b22      	ldr	r3, [pc, #136]	; (8012bb8 <scalbn+0xd8>)
 8012b30:	0020      	movs	r0, r4
 8012b32:	0029      	movs	r1, r5
 8012b34:	f7ef fd64 	bl	8002600 <__aeabi_dmul>
 8012b38:	bd70      	pop	{r4, r5, r6, pc}
 8012b3a:	4d20      	ldr	r5, [pc, #128]	; (8012bbc <scalbn+0xdc>)
 8012b3c:	42ab      	cmp	r3, r5
 8012b3e:	d1e5      	bne.n	8012b0c <scalbn+0x2c>
 8012b40:	0002      	movs	r2, r0
 8012b42:	000b      	movs	r3, r1
 8012b44:	f7ee fddc 	bl	8001700 <__aeabi_dadd>
 8012b48:	e7f6      	b.n	8012b38 <scalbn+0x58>
 8012b4a:	4c1d      	ldr	r4, [pc, #116]	; (8012bc0 <scalbn+0xe0>)
 8012b4c:	4d1d      	ldr	r5, [pc, #116]	; (8012bc4 <scalbn+0xe4>)
 8012b4e:	2900      	cmp	r1, #0
 8012b50:	db06      	blt.n	8012b60 <scalbn+0x80>
 8012b52:	4a1b      	ldr	r2, [pc, #108]	; (8012bc0 <scalbn+0xe0>)
 8012b54:	4b1b      	ldr	r3, [pc, #108]	; (8012bc4 <scalbn+0xe4>)
 8012b56:	0020      	movs	r0, r4
 8012b58:	0029      	movs	r1, r5
 8012b5a:	f7ef fd51 	bl	8002600 <__aeabi_dmul>
 8012b5e:	e7eb      	b.n	8012b38 <scalbn+0x58>
 8012b60:	4c17      	ldr	r4, [pc, #92]	; (8012bc0 <scalbn+0xe0>)
 8012b62:	4d19      	ldr	r5, [pc, #100]	; (8012bc8 <scalbn+0xe8>)
 8012b64:	4a16      	ldr	r2, [pc, #88]	; (8012bc0 <scalbn+0xe0>)
 8012b66:	4b17      	ldr	r3, [pc, #92]	; (8012bc4 <scalbn+0xe4>)
 8012b68:	0020      	movs	r0, r4
 8012b6a:	0029      	movs	r1, r5
 8012b6c:	f7ef fd48 	bl	8002600 <__aeabi_dmul>
 8012b70:	e7e2      	b.n	8012b38 <scalbn+0x58>
 8012b72:	4c16      	ldr	r4, [pc, #88]	; (8012bcc <scalbn+0xec>)
 8012b74:	3336      	adds	r3, #54	; 0x36
 8012b76:	4022      	ands	r2, r4
 8012b78:	051b      	lsls	r3, r3, #20
 8012b7a:	4313      	orrs	r3, r2
 8012b7c:	0019      	movs	r1, r3
 8012b7e:	2200      	movs	r2, #0
 8012b80:	4b13      	ldr	r3, [pc, #76]	; (8012bd0 <scalbn+0xf0>)
 8012b82:	f7ef fd3d 	bl	8002600 <__aeabi_dmul>
 8012b86:	e7d7      	b.n	8012b38 <scalbn+0x58>
 8012b88:	4c10      	ldr	r4, [pc, #64]	; (8012bcc <scalbn+0xec>)
 8012b8a:	051b      	lsls	r3, r3, #20
 8012b8c:	4022      	ands	r2, r4
 8012b8e:	431a      	orrs	r2, r3
 8012b90:	0011      	movs	r1, r2
 8012b92:	e7d1      	b.n	8012b38 <scalbn+0x58>
 8012b94:	4a07      	ldr	r2, [pc, #28]	; (8012bb4 <scalbn+0xd4>)
 8012b96:	4b08      	ldr	r3, [pc, #32]	; (8012bb8 <scalbn+0xd8>)
 8012b98:	f7ef fd32 	bl	8002600 <__aeabi_dmul>
 8012b9c:	e7cc      	b.n	8012b38 <scalbn+0x58>
 8012b9e:	4c05      	ldr	r4, [pc, #20]	; (8012bb4 <scalbn+0xd4>)
 8012ba0:	4d0c      	ldr	r5, [pc, #48]	; (8012bd4 <scalbn+0xf4>)
 8012ba2:	e7c3      	b.n	8012b2c <scalbn+0x4c>
 8012ba4:	43500000 	.word	0x43500000
 8012ba8:	ffff3cb0 	.word	0xffff3cb0
 8012bac:	000007fe 	.word	0x000007fe
 8012bb0:	0000c350 	.word	0x0000c350
 8012bb4:	c2f8f359 	.word	0xc2f8f359
 8012bb8:	01a56e1f 	.word	0x01a56e1f
 8012bbc:	000007ff 	.word	0x000007ff
 8012bc0:	8800759c 	.word	0x8800759c
 8012bc4:	7e37e43c 	.word	0x7e37e43c
 8012bc8:	fe37e43c 	.word	0xfe37e43c
 8012bcc:	800fffff 	.word	0x800fffff
 8012bd0:	3c900000 	.word	0x3c900000
 8012bd4:	81a56e1f 	.word	0x81a56e1f
	...

08012be0 <atanf>:
 8012be0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8012be2:	46c6      	mov	lr, r8
 8012be4:	4b71      	ldr	r3, [pc, #452]	; (8012dac <atanf+0x1cc>)
 8012be6:	0045      	lsls	r5, r0, #1
 8012be8:	b500      	push	{lr}
 8012bea:	1c04      	adds	r4, r0, #0
 8012bec:	0007      	movs	r7, r0
 8012bee:	086d      	lsrs	r5, r5, #1
 8012bf0:	429d      	cmp	r5, r3
 8012bf2:	dd0b      	ble.n	8012c0c <atanf+0x2c>
 8012bf4:	23ff      	movs	r3, #255	; 0xff
 8012bf6:	05db      	lsls	r3, r3, #23
 8012bf8:	429d      	cmp	r5, r3
 8012bfa:	dd00      	ble.n	8012bfe <atanf+0x1e>
 8012bfc:	e072      	b.n	8012ce4 <atanf+0x104>
 8012bfe:	2800      	cmp	r0, #0
 8012c00:	dc00      	bgt.n	8012c04 <atanf+0x24>
 8012c02:	e07f      	b.n	8012d04 <atanf+0x124>
 8012c04:	486a      	ldr	r0, [pc, #424]	; (8012db0 <atanf+0x1d0>)
 8012c06:	bc04      	pop	{r2}
 8012c08:	4690      	mov	r8, r2
 8012c0a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8012c0c:	4b69      	ldr	r3, [pc, #420]	; (8012db4 <atanf+0x1d4>)
 8012c0e:	429d      	cmp	r5, r3
 8012c10:	dc7f      	bgt.n	8012d12 <atanf+0x132>
 8012c12:	4b69      	ldr	r3, [pc, #420]	; (8012db8 <atanf+0x1d8>)
 8012c14:	429d      	cmp	r5, r3
 8012c16:	dd69      	ble.n	8012cec <atanf+0x10c>
 8012c18:	2601      	movs	r6, #1
 8012c1a:	4276      	negs	r6, r6
 8012c1c:	1c21      	adds	r1, r4, #0
 8012c1e:	1c20      	adds	r0, r4, #0
 8012c20:	f7ee f9e6 	bl	8000ff0 <__aeabi_fmul>
 8012c24:	1c01      	adds	r1, r0, #0
 8012c26:	4680      	mov	r8, r0
 8012c28:	f7ee f9e2 	bl	8000ff0 <__aeabi_fmul>
 8012c2c:	4963      	ldr	r1, [pc, #396]	; (8012dbc <atanf+0x1dc>)
 8012c2e:	1c05      	adds	r5, r0, #0
 8012c30:	f7ee f9de 	bl	8000ff0 <__aeabi_fmul>
 8012c34:	4962      	ldr	r1, [pc, #392]	; (8012dc0 <atanf+0x1e0>)
 8012c36:	f7ed fe7b 	bl	8000930 <__aeabi_fadd>
 8012c3a:	1c29      	adds	r1, r5, #0
 8012c3c:	f7ee f9d8 	bl	8000ff0 <__aeabi_fmul>
 8012c40:	4960      	ldr	r1, [pc, #384]	; (8012dc4 <atanf+0x1e4>)
 8012c42:	f7ed fe75 	bl	8000930 <__aeabi_fadd>
 8012c46:	1c29      	adds	r1, r5, #0
 8012c48:	f7ee f9d2 	bl	8000ff0 <__aeabi_fmul>
 8012c4c:	495e      	ldr	r1, [pc, #376]	; (8012dc8 <atanf+0x1e8>)
 8012c4e:	f7ed fe6f 	bl	8000930 <__aeabi_fadd>
 8012c52:	1c29      	adds	r1, r5, #0
 8012c54:	f7ee f9cc 	bl	8000ff0 <__aeabi_fmul>
 8012c58:	495c      	ldr	r1, [pc, #368]	; (8012dcc <atanf+0x1ec>)
 8012c5a:	f7ed fe69 	bl	8000930 <__aeabi_fadd>
 8012c5e:	1c29      	adds	r1, r5, #0
 8012c60:	f7ee f9c6 	bl	8000ff0 <__aeabi_fmul>
 8012c64:	495a      	ldr	r1, [pc, #360]	; (8012dd0 <atanf+0x1f0>)
 8012c66:	f7ed fe63 	bl	8000930 <__aeabi_fadd>
 8012c6a:	4641      	mov	r1, r8
 8012c6c:	f7ee f9c0 	bl	8000ff0 <__aeabi_fmul>
 8012c70:	4958      	ldr	r1, [pc, #352]	; (8012dd4 <atanf+0x1f4>)
 8012c72:	4680      	mov	r8, r0
 8012c74:	1c28      	adds	r0, r5, #0
 8012c76:	f7ee f9bb 	bl	8000ff0 <__aeabi_fmul>
 8012c7a:	4957      	ldr	r1, [pc, #348]	; (8012dd8 <atanf+0x1f8>)
 8012c7c:	f7ee fad0 	bl	8001220 <__aeabi_fsub>
 8012c80:	1c29      	adds	r1, r5, #0
 8012c82:	f7ee f9b5 	bl	8000ff0 <__aeabi_fmul>
 8012c86:	4955      	ldr	r1, [pc, #340]	; (8012ddc <atanf+0x1fc>)
 8012c88:	f7ee faca 	bl	8001220 <__aeabi_fsub>
 8012c8c:	1c29      	adds	r1, r5, #0
 8012c8e:	f7ee f9af 	bl	8000ff0 <__aeabi_fmul>
 8012c92:	4953      	ldr	r1, [pc, #332]	; (8012de0 <atanf+0x200>)
 8012c94:	f7ee fac4 	bl	8001220 <__aeabi_fsub>
 8012c98:	1c29      	adds	r1, r5, #0
 8012c9a:	f7ee f9a9 	bl	8000ff0 <__aeabi_fmul>
 8012c9e:	4951      	ldr	r1, [pc, #324]	; (8012de4 <atanf+0x204>)
 8012ca0:	f7ee fabe 	bl	8001220 <__aeabi_fsub>
 8012ca4:	1c29      	adds	r1, r5, #0
 8012ca6:	f7ee f9a3 	bl	8000ff0 <__aeabi_fmul>
 8012caa:	1c01      	adds	r1, r0, #0
 8012cac:	4640      	mov	r0, r8
 8012cae:	f7ed fe3f 	bl	8000930 <__aeabi_fadd>
 8012cb2:	1c21      	adds	r1, r4, #0
 8012cb4:	f7ee f99c 	bl	8000ff0 <__aeabi_fmul>
 8012cb8:	1c73      	adds	r3, r6, #1
 8012cba:	d025      	beq.n	8012d08 <atanf+0x128>
 8012cbc:	4b4a      	ldr	r3, [pc, #296]	; (8012de8 <atanf+0x208>)
 8012cbe:	00b6      	lsls	r6, r6, #2
 8012cc0:	58f1      	ldr	r1, [r6, r3]
 8012cc2:	f7ee faad 	bl	8001220 <__aeabi_fsub>
 8012cc6:	1c21      	adds	r1, r4, #0
 8012cc8:	f7ee faaa 	bl	8001220 <__aeabi_fsub>
 8012ccc:	4b47      	ldr	r3, [pc, #284]	; (8012dec <atanf+0x20c>)
 8012cce:	1c01      	adds	r1, r0, #0
 8012cd0:	58f0      	ldr	r0, [r6, r3]
 8012cd2:	f7ee faa5 	bl	8001220 <__aeabi_fsub>
 8012cd6:	2f00      	cmp	r7, #0
 8012cd8:	da95      	bge.n	8012c06 <atanf+0x26>
 8012cda:	2380      	movs	r3, #128	; 0x80
 8012cdc:	061b      	lsls	r3, r3, #24
 8012cde:	469c      	mov	ip, r3
 8012ce0:	4460      	add	r0, ip
 8012ce2:	e790      	b.n	8012c06 <atanf+0x26>
 8012ce4:	1c01      	adds	r1, r0, #0
 8012ce6:	f7ed fe23 	bl	8000930 <__aeabi_fadd>
 8012cea:	e78c      	b.n	8012c06 <atanf+0x26>
 8012cec:	4940      	ldr	r1, [pc, #256]	; (8012df0 <atanf+0x210>)
 8012cee:	f7ed fe1f 	bl	8000930 <__aeabi_fadd>
 8012cf2:	21fe      	movs	r1, #254	; 0xfe
 8012cf4:	0589      	lsls	r1, r1, #22
 8012cf6:	f7ed fc59 	bl	80005ac <__aeabi_fcmpgt>
 8012cfa:	0003      	movs	r3, r0
 8012cfc:	1c20      	adds	r0, r4, #0
 8012cfe:	2b00      	cmp	r3, #0
 8012d00:	d08a      	beq.n	8012c18 <atanf+0x38>
 8012d02:	e780      	b.n	8012c06 <atanf+0x26>
 8012d04:	483b      	ldr	r0, [pc, #236]	; (8012df4 <atanf+0x214>)
 8012d06:	e77e      	b.n	8012c06 <atanf+0x26>
 8012d08:	1c01      	adds	r1, r0, #0
 8012d0a:	1c20      	adds	r0, r4, #0
 8012d0c:	f7ee fa88 	bl	8001220 <__aeabi_fsub>
 8012d10:	e779      	b.n	8012c06 <atanf+0x26>
 8012d12:	f000 f87d 	bl	8012e10 <fabsf>
 8012d16:	4b38      	ldr	r3, [pc, #224]	; (8012df8 <atanf+0x218>)
 8012d18:	1c04      	adds	r4, r0, #0
 8012d1a:	429d      	cmp	r5, r3
 8012d1c:	dc16      	bgt.n	8012d4c <atanf+0x16c>
 8012d1e:	4b37      	ldr	r3, [pc, #220]	; (8012dfc <atanf+0x21c>)
 8012d20:	429d      	cmp	r5, r3
 8012d22:	dc32      	bgt.n	8012d8a <atanf+0x1aa>
 8012d24:	1c01      	adds	r1, r0, #0
 8012d26:	f7ed fe03 	bl	8000930 <__aeabi_fadd>
 8012d2a:	21fe      	movs	r1, #254	; 0xfe
 8012d2c:	0589      	lsls	r1, r1, #22
 8012d2e:	f7ee fa77 	bl	8001220 <__aeabi_fsub>
 8012d32:	2180      	movs	r1, #128	; 0x80
 8012d34:	1c05      	adds	r5, r0, #0
 8012d36:	05c9      	lsls	r1, r1, #23
 8012d38:	1c20      	adds	r0, r4, #0
 8012d3a:	f7ed fdf9 	bl	8000930 <__aeabi_fadd>
 8012d3e:	1c01      	adds	r1, r0, #0
 8012d40:	1c28      	adds	r0, r5, #0
 8012d42:	f7ed ff75 	bl	8000c30 <__aeabi_fdiv>
 8012d46:	2600      	movs	r6, #0
 8012d48:	1c04      	adds	r4, r0, #0
 8012d4a:	e767      	b.n	8012c1c <atanf+0x3c>
 8012d4c:	4b2c      	ldr	r3, [pc, #176]	; (8012e00 <atanf+0x220>)
 8012d4e:	429d      	cmp	r5, r3
 8012d50:	dc14      	bgt.n	8012d7c <atanf+0x19c>
 8012d52:	21ff      	movs	r1, #255	; 0xff
 8012d54:	0589      	lsls	r1, r1, #22
 8012d56:	f7ee fa63 	bl	8001220 <__aeabi_fsub>
 8012d5a:	21ff      	movs	r1, #255	; 0xff
 8012d5c:	1c05      	adds	r5, r0, #0
 8012d5e:	0589      	lsls	r1, r1, #22
 8012d60:	1c20      	adds	r0, r4, #0
 8012d62:	f7ee f945 	bl	8000ff0 <__aeabi_fmul>
 8012d66:	21fe      	movs	r1, #254	; 0xfe
 8012d68:	0589      	lsls	r1, r1, #22
 8012d6a:	f7ed fde1 	bl	8000930 <__aeabi_fadd>
 8012d6e:	1c01      	adds	r1, r0, #0
 8012d70:	1c28      	adds	r0, r5, #0
 8012d72:	f7ed ff5d 	bl	8000c30 <__aeabi_fdiv>
 8012d76:	2602      	movs	r6, #2
 8012d78:	1c04      	adds	r4, r0, #0
 8012d7a:	e74f      	b.n	8012c1c <atanf+0x3c>
 8012d7c:	1c01      	adds	r1, r0, #0
 8012d7e:	4821      	ldr	r0, [pc, #132]	; (8012e04 <atanf+0x224>)
 8012d80:	f7ed ff56 	bl	8000c30 <__aeabi_fdiv>
 8012d84:	2603      	movs	r6, #3
 8012d86:	1c04      	adds	r4, r0, #0
 8012d88:	e748      	b.n	8012c1c <atanf+0x3c>
 8012d8a:	21fe      	movs	r1, #254	; 0xfe
 8012d8c:	0589      	lsls	r1, r1, #22
 8012d8e:	f7ee fa47 	bl	8001220 <__aeabi_fsub>
 8012d92:	21fe      	movs	r1, #254	; 0xfe
 8012d94:	1c05      	adds	r5, r0, #0
 8012d96:	0589      	lsls	r1, r1, #22
 8012d98:	1c20      	adds	r0, r4, #0
 8012d9a:	f7ed fdc9 	bl	8000930 <__aeabi_fadd>
 8012d9e:	1c01      	adds	r1, r0, #0
 8012da0:	1c28      	adds	r0, r5, #0
 8012da2:	f7ed ff45 	bl	8000c30 <__aeabi_fdiv>
 8012da6:	2601      	movs	r6, #1
 8012da8:	1c04      	adds	r4, r0, #0
 8012daa:	e737      	b.n	8012c1c <atanf+0x3c>
 8012dac:	507fffff 	.word	0x507fffff
 8012db0:	3fc90fdb 	.word	0x3fc90fdb
 8012db4:	3edfffff 	.word	0x3edfffff
 8012db8:	30ffffff 	.word	0x30ffffff
 8012dbc:	3c8569d7 	.word	0x3c8569d7
 8012dc0:	3d4bda59 	.word	0x3d4bda59
 8012dc4:	3d886b35 	.word	0x3d886b35
 8012dc8:	3dba2e6e 	.word	0x3dba2e6e
 8012dcc:	3e124925 	.word	0x3e124925
 8012dd0:	3eaaaaab 	.word	0x3eaaaaab
 8012dd4:	bd15a221 	.word	0xbd15a221
 8012dd8:	3d6ef16b 	.word	0x3d6ef16b
 8012ddc:	3d9d8795 	.word	0x3d9d8795
 8012de0:	3de38e38 	.word	0x3de38e38
 8012de4:	3e4ccccd 	.word	0x3e4ccccd
 8012de8:	08016c40 	.word	0x08016c40
 8012dec:	08016c30 	.word	0x08016c30
 8012df0:	7149f2ca 	.word	0x7149f2ca
 8012df4:	bfc90fdb 	.word	0xbfc90fdb
 8012df8:	3f97ffff 	.word	0x3f97ffff
 8012dfc:	3f2fffff 	.word	0x3f2fffff
 8012e00:	401bffff 	.word	0x401bffff
 8012e04:	bf800000 	.word	0xbf800000
	...

08012e10 <fabsf>:
 8012e10:	0040      	lsls	r0, r0, #1
 8012e12:	0840      	lsrs	r0, r0, #1
 8012e14:	4770      	bx	lr
 8012e16:	46c0      	nop			; (mov r8, r8)
	...

08012e20 <__ieee754_logf>:
 8012e20:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8012e22:	46de      	mov	lr, fp
 8012e24:	4657      	mov	r7, sl
 8012e26:	464e      	mov	r6, r9
 8012e28:	4645      	mov	r5, r8
 8012e2a:	0003      	movs	r3, r0
 8012e2c:	b5e0      	push	{r5, r6, r7, lr}
 8012e2e:	0042      	lsls	r2, r0, #1
 8012e30:	d044      	beq.n	8012ebc <__ieee754_logf+0x9c>
 8012e32:	2800      	cmp	r0, #0
 8012e34:	db4d      	blt.n	8012ed2 <__ieee754_logf+0xb2>
 8012e36:	4a8e      	ldr	r2, [pc, #568]	; (8013070 <__ieee754_logf+0x250>)
 8012e38:	4290      	cmp	r0, r2
 8012e3a:	dd00      	ble.n	8012e3e <__ieee754_logf+0x1e>
 8012e3c:	e0c5      	b.n	8012fca <__ieee754_logf+0x1aa>
 8012e3e:	4a8d      	ldr	r2, [pc, #564]	; (8013074 <__ieee754_logf+0x254>)
 8012e40:	2100      	movs	r1, #0
 8012e42:	4290      	cmp	r0, r2
 8012e44:	dc06      	bgt.n	8012e54 <__ieee754_logf+0x34>
 8012e46:	2198      	movs	r1, #152	; 0x98
 8012e48:	05c9      	lsls	r1, r1, #23
 8012e4a:	f7ee f8d1 	bl	8000ff0 <__aeabi_fmul>
 8012e4e:	2119      	movs	r1, #25
 8012e50:	0003      	movs	r3, r0
 8012e52:	4249      	negs	r1, r1
 8012e54:	15da      	asrs	r2, r3, #23
 8012e56:	025b      	lsls	r3, r3, #9
 8012e58:	0a5c      	lsrs	r4, r3, #9
 8012e5a:	4b87      	ldr	r3, [pc, #540]	; (8013078 <__ieee754_logf+0x258>)
 8012e5c:	3a7f      	subs	r2, #127	; 0x7f
 8012e5e:	18e0      	adds	r0, r4, r3
 8012e60:	2380      	movs	r3, #128	; 0x80
 8012e62:	041b      	lsls	r3, r3, #16
 8012e64:	4003      	ands	r3, r0
 8012e66:	20fe      	movs	r0, #254	; 0xfe
 8012e68:	1852      	adds	r2, r2, r1
 8012e6a:	21fe      	movs	r1, #254	; 0xfe
 8012e6c:	0580      	lsls	r0, r0, #22
 8012e6e:	4058      	eors	r0, r3
 8012e70:	15de      	asrs	r6, r3, #23
 8012e72:	4320      	orrs	r0, r4
 8012e74:	0589      	lsls	r1, r1, #22
 8012e76:	18b6      	adds	r6, r6, r2
 8012e78:	f7ee f9d2 	bl	8001220 <__aeabi_fsub>
 8012e7c:	0022      	movs	r2, r4
 8012e7e:	4b7f      	ldr	r3, [pc, #508]	; (801307c <__ieee754_logf+0x25c>)
 8012e80:	320f      	adds	r2, #15
 8012e82:	1c05      	adds	r5, r0, #0
 8012e84:	421a      	tst	r2, r3
 8012e86:	d12b      	bne.n	8012ee0 <__ieee754_logf+0xc0>
 8012e88:	2100      	movs	r1, #0
 8012e8a:	f7ed fb75 	bl	8000578 <__aeabi_fcmpeq>
 8012e8e:	2800      	cmp	r0, #0
 8012e90:	d100      	bne.n	8012e94 <__ieee754_logf+0x74>
 8012e92:	e09e      	b.n	8012fd2 <__ieee754_logf+0x1b2>
 8012e94:	2000      	movs	r0, #0
 8012e96:	2e00      	cmp	r6, #0
 8012e98:	d015      	beq.n	8012ec6 <__ieee754_logf+0xa6>
 8012e9a:	0030      	movs	r0, r6
 8012e9c:	f7ee fba0 	bl	80015e0 <__aeabi_i2f>
 8012ea0:	4977      	ldr	r1, [pc, #476]	; (8013080 <__ieee754_logf+0x260>)
 8012ea2:	1c04      	adds	r4, r0, #0
 8012ea4:	f7ee f8a4 	bl	8000ff0 <__aeabi_fmul>
 8012ea8:	4976      	ldr	r1, [pc, #472]	; (8013084 <__ieee754_logf+0x264>)
 8012eaa:	1c05      	adds	r5, r0, #0
 8012eac:	1c20      	adds	r0, r4, #0
 8012eae:	f7ee f89f 	bl	8000ff0 <__aeabi_fmul>
 8012eb2:	1c01      	adds	r1, r0, #0
 8012eb4:	1c28      	adds	r0, r5, #0
 8012eb6:	f7ed fd3b 	bl	8000930 <__aeabi_fadd>
 8012eba:	e004      	b.n	8012ec6 <__ieee754_logf+0xa6>
 8012ebc:	20cc      	movs	r0, #204	; 0xcc
 8012ebe:	2100      	movs	r1, #0
 8012ec0:	0600      	lsls	r0, r0, #24
 8012ec2:	f7ed feb5 	bl	8000c30 <__aeabi_fdiv>
 8012ec6:	bc3c      	pop	{r2, r3, r4, r5}
 8012ec8:	4690      	mov	r8, r2
 8012eca:	4699      	mov	r9, r3
 8012ecc:	46a2      	mov	sl, r4
 8012ece:	46ab      	mov	fp, r5
 8012ed0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8012ed2:	1c01      	adds	r1, r0, #0
 8012ed4:	f7ee f9a4 	bl	8001220 <__aeabi_fsub>
 8012ed8:	2100      	movs	r1, #0
 8012eda:	f7ed fea9 	bl	8000c30 <__aeabi_fdiv>
 8012ede:	e7f2      	b.n	8012ec6 <__ieee754_logf+0xa6>
 8012ee0:	2180      	movs	r1, #128	; 0x80
 8012ee2:	05c9      	lsls	r1, r1, #23
 8012ee4:	f7ed fd24 	bl	8000930 <__aeabi_fadd>
 8012ee8:	1c01      	adds	r1, r0, #0
 8012eea:	1c28      	adds	r0, r5, #0
 8012eec:	f7ed fea0 	bl	8000c30 <__aeabi_fdiv>
 8012ef0:	4680      	mov	r8, r0
 8012ef2:	0030      	movs	r0, r6
 8012ef4:	f7ee fb74 	bl	80015e0 <__aeabi_i2f>
 8012ef8:	4641      	mov	r1, r8
 8012efa:	4682      	mov	sl, r0
 8012efc:	4640      	mov	r0, r8
 8012efe:	f7ee f877 	bl	8000ff0 <__aeabi_fmul>
 8012f02:	4b61      	ldr	r3, [pc, #388]	; (8013088 <__ieee754_logf+0x268>)
 8012f04:	1c01      	adds	r1, r0, #0
 8012f06:	4699      	mov	r9, r3
 8012f08:	4683      	mov	fp, r0
 8012f0a:	f7ee f871 	bl	8000ff0 <__aeabi_fmul>
 8012f0e:	495f      	ldr	r1, [pc, #380]	; (801308c <__ieee754_logf+0x26c>)
 8012f10:	1c07      	adds	r7, r0, #0
 8012f12:	f7ee f86d 	bl	8000ff0 <__aeabi_fmul>
 8012f16:	495e      	ldr	r1, [pc, #376]	; (8013090 <__ieee754_logf+0x270>)
 8012f18:	f7ed fd0a 	bl	8000930 <__aeabi_fadd>
 8012f1c:	1c39      	adds	r1, r7, #0
 8012f1e:	f7ee f867 	bl	8000ff0 <__aeabi_fmul>
 8012f22:	495c      	ldr	r1, [pc, #368]	; (8013094 <__ieee754_logf+0x274>)
 8012f24:	f7ed fd04 	bl	8000930 <__aeabi_fadd>
 8012f28:	1c39      	adds	r1, r7, #0
 8012f2a:	f7ee f861 	bl	8000ff0 <__aeabi_fmul>
 8012f2e:	495a      	ldr	r1, [pc, #360]	; (8013098 <__ieee754_logf+0x278>)
 8012f30:	f7ed fcfe 	bl	8000930 <__aeabi_fadd>
 8012f34:	4659      	mov	r1, fp
 8012f36:	f7ee f85b 	bl	8000ff0 <__aeabi_fmul>
 8012f3a:	4958      	ldr	r1, [pc, #352]	; (801309c <__ieee754_logf+0x27c>)
 8012f3c:	4683      	mov	fp, r0
 8012f3e:	1c38      	adds	r0, r7, #0
 8012f40:	f7ee f856 	bl	8000ff0 <__aeabi_fmul>
 8012f44:	4956      	ldr	r1, [pc, #344]	; (80130a0 <__ieee754_logf+0x280>)
 8012f46:	f7ed fcf3 	bl	8000930 <__aeabi_fadd>
 8012f4a:	1c39      	adds	r1, r7, #0
 8012f4c:	f7ee f850 	bl	8000ff0 <__aeabi_fmul>
 8012f50:	4954      	ldr	r1, [pc, #336]	; (80130a4 <__ieee754_logf+0x284>)
 8012f52:	f7ed fced 	bl	8000930 <__aeabi_fadd>
 8012f56:	1c39      	adds	r1, r7, #0
 8012f58:	f7ee f84a 	bl	8000ff0 <__aeabi_fmul>
 8012f5c:	1c01      	adds	r1, r0, #0
 8012f5e:	4658      	mov	r0, fp
 8012f60:	f7ed fce6 	bl	8000930 <__aeabi_fadd>
 8012f64:	4b50      	ldr	r3, [pc, #320]	; (80130a8 <__ieee754_logf+0x288>)
 8012f66:	44a1      	add	r9, r4
 8012f68:	1b1c      	subs	r4, r3, r4
 8012f6a:	464b      	mov	r3, r9
 8012f6c:	1c07      	adds	r7, r0, #0
 8012f6e:	431c      	orrs	r4, r3
 8012f70:	2c00      	cmp	r4, #0
 8012f72:	dd48      	ble.n	8013006 <__ieee754_logf+0x1e6>
 8012f74:	21fc      	movs	r1, #252	; 0xfc
 8012f76:	1c28      	adds	r0, r5, #0
 8012f78:	0589      	lsls	r1, r1, #22
 8012f7a:	f7ee f839 	bl	8000ff0 <__aeabi_fmul>
 8012f7e:	1c29      	adds	r1, r5, #0
 8012f80:	f7ee f836 	bl	8000ff0 <__aeabi_fmul>
 8012f84:	1c01      	adds	r1, r0, #0
 8012f86:	1c04      	adds	r4, r0, #0
 8012f88:	1c38      	adds	r0, r7, #0
 8012f8a:	f7ed fcd1 	bl	8000930 <__aeabi_fadd>
 8012f8e:	4641      	mov	r1, r8
 8012f90:	f7ee f82e 	bl	8000ff0 <__aeabi_fmul>
 8012f94:	1c07      	adds	r7, r0, #0
 8012f96:	2e00      	cmp	r6, #0
 8012f98:	d049      	beq.n	801302e <__ieee754_logf+0x20e>
 8012f9a:	4939      	ldr	r1, [pc, #228]	; (8013080 <__ieee754_logf+0x260>)
 8012f9c:	4650      	mov	r0, sl
 8012f9e:	f7ee f827 	bl	8000ff0 <__aeabi_fmul>
 8012fa2:	4938      	ldr	r1, [pc, #224]	; (8013084 <__ieee754_logf+0x264>)
 8012fa4:	1c06      	adds	r6, r0, #0
 8012fa6:	4650      	mov	r0, sl
 8012fa8:	f7ee f822 	bl	8000ff0 <__aeabi_fmul>
 8012fac:	1c39      	adds	r1, r7, #0
 8012fae:	f7ed fcbf 	bl	8000930 <__aeabi_fadd>
 8012fb2:	1c01      	adds	r1, r0, #0
 8012fb4:	1c20      	adds	r0, r4, #0
 8012fb6:	f7ee f933 	bl	8001220 <__aeabi_fsub>
 8012fba:	1c29      	adds	r1, r5, #0
 8012fbc:	f7ee f930 	bl	8001220 <__aeabi_fsub>
 8012fc0:	1c01      	adds	r1, r0, #0
 8012fc2:	1c30      	adds	r0, r6, #0
 8012fc4:	f7ee f92c 	bl	8001220 <__aeabi_fsub>
 8012fc8:	e77d      	b.n	8012ec6 <__ieee754_logf+0xa6>
 8012fca:	1c01      	adds	r1, r0, #0
 8012fcc:	f7ed fcb0 	bl	8000930 <__aeabi_fadd>
 8012fd0:	e779      	b.n	8012ec6 <__ieee754_logf+0xa6>
 8012fd2:	4936      	ldr	r1, [pc, #216]	; (80130ac <__ieee754_logf+0x28c>)
 8012fd4:	1c28      	adds	r0, r5, #0
 8012fd6:	f7ee f80b 	bl	8000ff0 <__aeabi_fmul>
 8012fda:	1c01      	adds	r1, r0, #0
 8012fdc:	20fc      	movs	r0, #252	; 0xfc
 8012fde:	0580      	lsls	r0, r0, #22
 8012fe0:	f7ee f91e 	bl	8001220 <__aeabi_fsub>
 8012fe4:	1c29      	adds	r1, r5, #0
 8012fe6:	1c04      	adds	r4, r0, #0
 8012fe8:	1c28      	adds	r0, r5, #0
 8012fea:	f7ee f801 	bl	8000ff0 <__aeabi_fmul>
 8012fee:	1c01      	adds	r1, r0, #0
 8012ff0:	1c20      	adds	r0, r4, #0
 8012ff2:	f7ed fffd 	bl	8000ff0 <__aeabi_fmul>
 8012ff6:	1c04      	adds	r4, r0, #0
 8012ff8:	2e00      	cmp	r6, #0
 8012ffa:	d121      	bne.n	8013040 <__ieee754_logf+0x220>
 8012ffc:	1c21      	adds	r1, r4, #0
 8012ffe:	1c28      	adds	r0, r5, #0
 8013000:	f7ee f90e 	bl	8001220 <__aeabi_fsub>
 8013004:	e75f      	b.n	8012ec6 <__ieee754_logf+0xa6>
 8013006:	1c01      	adds	r1, r0, #0
 8013008:	1c28      	adds	r0, r5, #0
 801300a:	f7ee f909 	bl	8001220 <__aeabi_fsub>
 801300e:	4641      	mov	r1, r8
 8013010:	f7ed ffee 	bl	8000ff0 <__aeabi_fmul>
 8013014:	1c04      	adds	r4, r0, #0
 8013016:	2e00      	cmp	r6, #0
 8013018:	d0f0      	beq.n	8012ffc <__ieee754_logf+0x1dc>
 801301a:	4919      	ldr	r1, [pc, #100]	; (8013080 <__ieee754_logf+0x260>)
 801301c:	4650      	mov	r0, sl
 801301e:	f7ed ffe7 	bl	8000ff0 <__aeabi_fmul>
 8013022:	4918      	ldr	r1, [pc, #96]	; (8013084 <__ieee754_logf+0x264>)
 8013024:	1c06      	adds	r6, r0, #0
 8013026:	4650      	mov	r0, sl
 8013028:	f7ed ffe2 	bl	8000ff0 <__aeabi_fmul>
 801302c:	e7c1      	b.n	8012fb2 <__ieee754_logf+0x192>
 801302e:	1c01      	adds	r1, r0, #0
 8013030:	1c20      	adds	r0, r4, #0
 8013032:	f7ee f8f5 	bl	8001220 <__aeabi_fsub>
 8013036:	1c01      	adds	r1, r0, #0
 8013038:	1c28      	adds	r0, r5, #0
 801303a:	f7ee f8f1 	bl	8001220 <__aeabi_fsub>
 801303e:	e742      	b.n	8012ec6 <__ieee754_logf+0xa6>
 8013040:	0030      	movs	r0, r6
 8013042:	f7ee facd 	bl	80015e0 <__aeabi_i2f>
 8013046:	490e      	ldr	r1, [pc, #56]	; (8013080 <__ieee754_logf+0x260>)
 8013048:	1c06      	adds	r6, r0, #0
 801304a:	f7ed ffd1 	bl	8000ff0 <__aeabi_fmul>
 801304e:	490d      	ldr	r1, [pc, #52]	; (8013084 <__ieee754_logf+0x264>)
 8013050:	1c07      	adds	r7, r0, #0
 8013052:	1c30      	adds	r0, r6, #0
 8013054:	f7ed ffcc 	bl	8000ff0 <__aeabi_fmul>
 8013058:	1c01      	adds	r1, r0, #0
 801305a:	1c20      	adds	r0, r4, #0
 801305c:	f7ee f8e0 	bl	8001220 <__aeabi_fsub>
 8013060:	1c29      	adds	r1, r5, #0
 8013062:	f7ee f8dd 	bl	8001220 <__aeabi_fsub>
 8013066:	1c01      	adds	r1, r0, #0
 8013068:	1c38      	adds	r0, r7, #0
 801306a:	f7ee f8d9 	bl	8001220 <__aeabi_fsub>
 801306e:	e72a      	b.n	8012ec6 <__ieee754_logf+0xa6>
 8013070:	7f7fffff 	.word	0x7f7fffff
 8013074:	007fffff 	.word	0x007fffff
 8013078:	004afb20 	.word	0x004afb20
 801307c:	007ffff0 	.word	0x007ffff0
 8013080:	3f317180 	.word	0x3f317180
 8013084:	3717f7d1 	.word	0x3717f7d1
 8013088:	ffcf5c30 	.word	0xffcf5c30
 801308c:	3e178897 	.word	0x3e178897
 8013090:	3e3a3325 	.word	0x3e3a3325
 8013094:	3e924925 	.word	0x3e924925
 8013098:	3f2aaaab 	.word	0x3f2aaaab
 801309c:	3e1cd04f 	.word	0x3e1cd04f
 80130a0:	3e638e29 	.word	0x3e638e29
 80130a4:	3ecccccd 	.word	0x3ecccccd
 80130a8:	0035c288 	.word	0x0035c288
 80130ac:	3eaaaaab 	.word	0x3eaaaaab

080130b0 <atoi>:
 80130b0:	b510      	push	{r4, lr}
 80130b2:	220a      	movs	r2, #10
 80130b4:	2100      	movs	r1, #0
 80130b6:	f000 f8eb 	bl	8013290 <strtol>
 80130ba:	bd10      	pop	{r4, pc}
 80130bc:	0000      	movs	r0, r0
	...

080130c0 <__errno>:
 80130c0:	4b01      	ldr	r3, [pc, #4]	; (80130c8 <__errno+0x8>)
 80130c2:	6818      	ldr	r0, [r3, #0]
 80130c4:	4770      	bx	lr
 80130c6:	46c0      	nop			; (mov r8, r8)
 80130c8:	20001664 	.word	0x20001664
 80130cc:	00000000 	.word	0x00000000

080130d0 <memcpy>:
 80130d0:	2300      	movs	r3, #0
 80130d2:	b510      	push	{r4, lr}
 80130d4:	429a      	cmp	r2, r3
 80130d6:	d100      	bne.n	80130da <memcpy+0xa>
 80130d8:	bd10      	pop	{r4, pc}
 80130da:	5ccc      	ldrb	r4, [r1, r3]
 80130dc:	54c4      	strb	r4, [r0, r3]
 80130de:	3301      	adds	r3, #1
 80130e0:	e7f8      	b.n	80130d4 <memcpy+0x4>
	...

080130f0 <memset>:
 80130f0:	0003      	movs	r3, r0
 80130f2:	1812      	adds	r2, r2, r0
 80130f4:	4293      	cmp	r3, r2
 80130f6:	d100      	bne.n	80130fa <memset+0xa>
 80130f8:	4770      	bx	lr
 80130fa:	7019      	strb	r1, [r3, #0]
 80130fc:	3301      	adds	r3, #1
 80130fe:	e7f9      	b.n	80130f4 <memset+0x4>

08013100 <strchr>:
 8013100:	b2c9      	uxtb	r1, r1
 8013102:	7803      	ldrb	r3, [r0, #0]
 8013104:	2b00      	cmp	r3, #0
 8013106:	d004      	beq.n	8013112 <strchr+0x12>
 8013108:	428b      	cmp	r3, r1
 801310a:	d100      	bne.n	801310e <strchr+0xe>
 801310c:	4770      	bx	lr
 801310e:	3001      	adds	r0, #1
 8013110:	e7f7      	b.n	8013102 <strchr+0x2>
 8013112:	424b      	negs	r3, r1
 8013114:	4159      	adcs	r1, r3
 8013116:	4249      	negs	r1, r1
 8013118:	4008      	ands	r0, r1
 801311a:	e7f7      	b.n	801310c <strchr+0xc>
 801311c:	0000      	movs	r0, r0
	...

08013120 <strpbrk>:
 8013120:	b510      	push	{r4, lr}
 8013122:	7803      	ldrb	r3, [r0, #0]
 8013124:	2b00      	cmp	r3, #0
 8013126:	d013      	beq.n	8013150 <strpbrk+0x30>
 8013128:	000b      	movs	r3, r1
 801312a:	7802      	ldrb	r2, [r0, #0]
 801312c:	2a00      	cmp	r2, #0
 801312e:	d10d      	bne.n	801314c <strpbrk+0x2c>
 8013130:	781b      	ldrb	r3, [r3, #0]
 8013132:	1e5a      	subs	r2, r3, #1
 8013134:	4193      	sbcs	r3, r2
 8013136:	425b      	negs	r3, r3
 8013138:	4018      	ands	r0, r3
 801313a:	bd10      	pop	{r4, pc}
 801313c:	4294      	cmp	r4, r2
 801313e:	d0fc      	beq.n	801313a <strpbrk+0x1a>
 8013140:	3301      	adds	r3, #1
 8013142:	781c      	ldrb	r4, [r3, #0]
 8013144:	2c00      	cmp	r4, #0
 8013146:	d1f9      	bne.n	801313c <strpbrk+0x1c>
 8013148:	3001      	adds	r0, #1
 801314a:	e7ee      	b.n	801312a <strpbrk+0xa>
 801314c:	000b      	movs	r3, r1
 801314e:	e7f8      	b.n	8013142 <strpbrk+0x22>
 8013150:	0018      	movs	r0, r3
 8013152:	e7f2      	b.n	801313a <strpbrk+0x1a>
	...

08013160 <strspn>:
 8013160:	0003      	movs	r3, r0
 8013162:	b530      	push	{r4, r5, lr}
 8013164:	781c      	ldrb	r4, [r3, #0]
 8013166:	2c00      	cmp	r4, #0
 8013168:	d007      	beq.n	801317a <strspn+0x1a>
 801316a:	000a      	movs	r2, r1
 801316c:	e002      	b.n	8013174 <strspn+0x14>
 801316e:	42a5      	cmp	r5, r4
 8013170:	d005      	beq.n	801317e <strspn+0x1e>
 8013172:	3201      	adds	r2, #1
 8013174:	7815      	ldrb	r5, [r2, #0]
 8013176:	2d00      	cmp	r5, #0
 8013178:	d1f9      	bne.n	801316e <strspn+0xe>
 801317a:	1a18      	subs	r0, r3, r0
 801317c:	bd30      	pop	{r4, r5, pc}
 801317e:	3301      	adds	r3, #1
 8013180:	e7f0      	b.n	8013164 <strspn+0x4>
	...

08013190 <_strtol_l.isra.0>:
 8013190:	b5f0      	push	{r4, r5, r6, r7, lr}
 8013192:	b087      	sub	sp, #28
 8013194:	9101      	str	r1, [sp, #4]
 8013196:	9202      	str	r2, [sp, #8]
 8013198:	001f      	movs	r7, r3
 801319a:	000a      	movs	r2, r1
 801319c:	2108      	movs	r1, #8
 801319e:	9005      	str	r0, [sp, #20]
 80131a0:	4838      	ldr	r0, [pc, #224]	; (8013284 <_strtol_l.isra.0+0xf4>)
 80131a2:	0013      	movs	r3, r2
 80131a4:	781c      	ldrb	r4, [r3, #0]
 80131a6:	1c55      	adds	r5, r2, #1
 80131a8:	5d06      	ldrb	r6, [r0, r4]
 80131aa:	002a      	movs	r2, r5
 80131ac:	400e      	ands	r6, r1
 80131ae:	d1f8      	bne.n	80131a2 <_strtol_l.isra.0+0x12>
 80131b0:	2c2d      	cmp	r4, #45	; 0x2d
 80131b2:	d134      	bne.n	801321e <_strtol_l.isra.0+0x8e>
 80131b4:	782c      	ldrb	r4, [r5, #0]
 80131b6:	3601      	adds	r6, #1
 80131b8:	1c9d      	adds	r5, r3, #2
 80131ba:	2f00      	cmp	r7, #0
 80131bc:	d05e      	beq.n	801327c <_strtol_l.isra.0+0xec>
 80131be:	2f10      	cmp	r7, #16
 80131c0:	d109      	bne.n	80131d6 <_strtol_l.isra.0+0x46>
 80131c2:	2c30      	cmp	r4, #48	; 0x30
 80131c4:	d107      	bne.n	80131d6 <_strtol_l.isra.0+0x46>
 80131c6:	2220      	movs	r2, #32
 80131c8:	782b      	ldrb	r3, [r5, #0]
 80131ca:	4393      	bics	r3, r2
 80131cc:	2b58      	cmp	r3, #88	; 0x58
 80131ce:	d150      	bne.n	8013272 <_strtol_l.isra.0+0xe2>
 80131d0:	2710      	movs	r7, #16
 80131d2:	786c      	ldrb	r4, [r5, #1]
 80131d4:	3502      	adds	r5, #2
 80131d6:	4b2c      	ldr	r3, [pc, #176]	; (8013288 <_strtol_l.isra.0+0xf8>)
 80131d8:	0039      	movs	r1, r7
 80131da:	18f3      	adds	r3, r6, r3
 80131dc:	0018      	movs	r0, r3
 80131de:	9303      	str	r3, [sp, #12]
 80131e0:	f7ed f87c 	bl	80002dc <__aeabi_uidivmod>
 80131e4:	9104      	str	r1, [sp, #16]
 80131e6:	2101      	movs	r1, #1
 80131e8:	2300      	movs	r3, #0
 80131ea:	4249      	negs	r1, r1
 80131ec:	0002      	movs	r2, r0
 80131ee:	468c      	mov	ip, r1
 80131f0:	0018      	movs	r0, r3
 80131f2:	0021      	movs	r1, r4
 80131f4:	3930      	subs	r1, #48	; 0x30
 80131f6:	2909      	cmp	r1, #9
 80131f8:	d816      	bhi.n	8013228 <_strtol_l.isra.0+0x98>
 80131fa:	000c      	movs	r4, r1
 80131fc:	42a7      	cmp	r7, r4
 80131fe:	dd1f      	ble.n	8013240 <_strtol_l.isra.0+0xb0>
 8013200:	1c59      	adds	r1, r3, #1
 8013202:	d009      	beq.n	8013218 <_strtol_l.isra.0+0x88>
 8013204:	4663      	mov	r3, ip
 8013206:	4282      	cmp	r2, r0
 8013208:	d306      	bcc.n	8013218 <_strtol_l.isra.0+0x88>
 801320a:	d102      	bne.n	8013212 <_strtol_l.isra.0+0x82>
 801320c:	9904      	ldr	r1, [sp, #16]
 801320e:	42a1      	cmp	r1, r4
 8013210:	db02      	blt.n	8013218 <_strtol_l.isra.0+0x88>
 8013212:	2301      	movs	r3, #1
 8013214:	4378      	muls	r0, r7
 8013216:	1820      	adds	r0, r4, r0
 8013218:	782c      	ldrb	r4, [r5, #0]
 801321a:	3501      	adds	r5, #1
 801321c:	e7e9      	b.n	80131f2 <_strtol_l.isra.0+0x62>
 801321e:	2c2b      	cmp	r4, #43	; 0x2b
 8013220:	d1cb      	bne.n	80131ba <_strtol_l.isra.0+0x2a>
 8013222:	782c      	ldrb	r4, [r5, #0]
 8013224:	1c9d      	adds	r5, r3, #2
 8013226:	e7c8      	b.n	80131ba <_strtol_l.isra.0+0x2a>
 8013228:	0021      	movs	r1, r4
 801322a:	3941      	subs	r1, #65	; 0x41
 801322c:	2919      	cmp	r1, #25
 801322e:	d801      	bhi.n	8013234 <_strtol_l.isra.0+0xa4>
 8013230:	3c37      	subs	r4, #55	; 0x37
 8013232:	e7e3      	b.n	80131fc <_strtol_l.isra.0+0x6c>
 8013234:	0021      	movs	r1, r4
 8013236:	3961      	subs	r1, #97	; 0x61
 8013238:	2919      	cmp	r1, #25
 801323a:	d801      	bhi.n	8013240 <_strtol_l.isra.0+0xb0>
 801323c:	3c57      	subs	r4, #87	; 0x57
 801323e:	e7dd      	b.n	80131fc <_strtol_l.isra.0+0x6c>
 8013240:	1c5a      	adds	r2, r3, #1
 8013242:	d108      	bne.n	8013256 <_strtol_l.isra.0+0xc6>
 8013244:	9a05      	ldr	r2, [sp, #20]
 8013246:	3323      	adds	r3, #35	; 0x23
 8013248:	6013      	str	r3, [r2, #0]
 801324a:	9b02      	ldr	r3, [sp, #8]
 801324c:	9803      	ldr	r0, [sp, #12]
 801324e:	2b00      	cmp	r3, #0
 8013250:	d109      	bne.n	8013266 <_strtol_l.isra.0+0xd6>
 8013252:	b007      	add	sp, #28
 8013254:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8013256:	2e00      	cmp	r6, #0
 8013258:	d000      	beq.n	801325c <_strtol_l.isra.0+0xcc>
 801325a:	4240      	negs	r0, r0
 801325c:	9a02      	ldr	r2, [sp, #8]
 801325e:	2a00      	cmp	r2, #0
 8013260:	d0f7      	beq.n	8013252 <_strtol_l.isra.0+0xc2>
 8013262:	2b00      	cmp	r3, #0
 8013264:	d001      	beq.n	801326a <_strtol_l.isra.0+0xda>
 8013266:	1e6b      	subs	r3, r5, #1
 8013268:	9301      	str	r3, [sp, #4]
 801326a:	9b02      	ldr	r3, [sp, #8]
 801326c:	9a01      	ldr	r2, [sp, #4]
 801326e:	601a      	str	r2, [r3, #0]
 8013270:	e7ef      	b.n	8013252 <_strtol_l.isra.0+0xc2>
 8013272:	2430      	movs	r4, #48	; 0x30
 8013274:	2f00      	cmp	r7, #0
 8013276:	d1ae      	bne.n	80131d6 <_strtol_l.isra.0+0x46>
 8013278:	2708      	movs	r7, #8
 801327a:	e7ac      	b.n	80131d6 <_strtol_l.isra.0+0x46>
 801327c:	2c30      	cmp	r4, #48	; 0x30
 801327e:	d0a2      	beq.n	80131c6 <_strtol_l.isra.0+0x36>
 8013280:	270a      	movs	r7, #10
 8013282:	e7a8      	b.n	80131d6 <_strtol_l.isra.0+0x46>
 8013284:	08016c51 	.word	0x08016c51
 8013288:	7fffffff 	.word	0x7fffffff
 801328c:	00000000 	.word	0x00000000

08013290 <strtol>:
 8013290:	b510      	push	{r4, lr}
 8013292:	0013      	movs	r3, r2
 8013294:	000a      	movs	r2, r1
 8013296:	0001      	movs	r1, r0
 8013298:	4802      	ldr	r0, [pc, #8]	; (80132a4 <strtol+0x14>)
 801329a:	6800      	ldr	r0, [r0, #0]
 801329c:	f7ff ff78 	bl	8013190 <_strtol_l.isra.0>
 80132a0:	bd10      	pop	{r4, pc}
 80132a2:	46c0      	nop			; (mov r8, r8)
 80132a4:	20001664 	.word	0x20001664
